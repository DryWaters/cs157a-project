Distributed Mining of Association Rules Based on Privacy-Preserved Method   Hua-jin Wang and Chun-an Hu School of Information Engineering Jiangxi University of Science and Technology Ganzhou, China wanghj128@163.com Jian-sheng Liu School of Science Jiangxi University of Science and Technology Ganzhou, China jxgzjscn@126.com   Abstract With the rapid development of social information the application of distributed database system is increasing Distributed data mining will play an important role in data 
mining. As one of the well-known distributed association rules mining algorithm, the FDM algorith m is very fast and efficient however, the cost of this algorithm is very great because it is designed under the condition of non-shared resource Moreover, the important information at every site is exposed to other sites, which is not accord to the nowadays trend of attaching importance to privacy preserving increasingly. In this paper, we prop ose an improved algorithm based on the FDM algorithm. In the process, it computes the total support count with the privacy-preserved method, meanwhile ensures 
the source of every local large item-set and local support count is covered, so it reduces the time spent on communication and preserves the privacy of the data distributed at each site. The experimental evaluations show th at the proposed algorithm is efficient and rather suitable for the practical application fields FDM; privacy preserving; asso ciation rules; data mining I   I NTRODUCTION  Association rules mining is an important research area in data mining, which indicates relations among item sets in database, With the accumulation of the data, association rule mining in large data set attracts more and more attention 
distributed mining algorithms are effective methods to solve this problem. At present, researchers have proposed some distributed algorithms to mining association rules such as PDM, CD, FDM, DMA, FPM, DDDM, Grid based method and parallel FP-Growth et al. Among these algorithms FDM 1 is classical which is proposed by Cheung D.W. based on the CD 2 algorithm. The time cost of each iteration can be reduced by decreasing the communicating cost and the number of candidates in each site In each site, the FDM algorith m finds the local support counts and prunes all infrequent local candidate sets. After completing local pruning, each site broadcasts messages 
containing all the remaining candidate sets to all other sites to request for their support counts. It then decides whether large item sets are globally frequent and generates the candidate item sets from those globally frequent item sets This process continues until no globally frequent item sets is generated or no candidate set is produced To reduce message communication, it uses polling site method. In this method every itemset is assign to one local site and this site must calculate support count of it. So if a site need support count of any itemset, ask from its polling site. This idea reduces communi cations between processes FDM’s main advantage over CD is that it reduces the 
communication overhead However, the FDM algorithm was designed under the condition of non-shared-resource. In the paper  t h e network condition of topology is formed between all sites and local large candidate item sets are broadcasted to all sites that results into the exposure of important information of every site in the distributed system and unable to privacy preserving Therefore, based on the FDM algorithm, an improved algorithm which named PPFDM is proposed. In the process it computes the total support count with the privacypreserved method, meanwhile ensures the source of every 
local large item-set and local support count is covered. The experimental result shows that it reduces the time spent on communication and preserves the privacy of data distributed on each site II  P ROBLEM D ESCRIPTION  With the increasing development of information technology, people appeal to privacy preserving urgently. In the paper s i ngul arl y hi gh  pri v acy preser vi ng i s  req u i r ed  in some fields of data mining, especially in the field of finance, medical treatment etc For example, to analyze the incidence of one disease, it n eeds for several hospitals to integrate and analyze the inform 
ation held by their own, but in practice, the hospitals are unwilling to share the information for the reason of protecting privacy of patients or for other reasons. Thus, in some fields, privacy preserving becomes the important factor to evaluate the performance of distributed data mining. In the paper As far as t h e defe ct of FDM algorithm concerned, since it was designed under the condition of non-shared resource, the topology of network causes one site to expose its own information to other sites. Consequently, we improve the classical FDM 
Third International Symposium on Information Science and Engineering 978-0-7695-4360-4/10 $26.00 © 2010 IEEE DOI 10.1109/ISISE.2010.125 498 
Third International Symposium on Information Science and Engineering 978-0-7695-4360-4/10 $26.00 © 2010 IEEE DOI 10.1109/ISISE.2010.125 498 
Third International Symposium on Information Science and Engineering 978-0-7695-4360-4/10 $26.00 © 2010 IEEE DOI 10.1109/ISISE.2010.125 494 


algorithm in order to prevent revealing important data and improve the performance of the algorithm Distributed mining of associa tion rules can be classified into two kinds: horizontally partitioned and vertically partitioned. In [6-8 Acco rd in g l y FDM algo rith m is o n the base of horizontally partitioned data and correspondingly the theory of privacy preserving in horizontally partitioned data mining is to ensure local candidate item-sets are accessible to local sites but inaccessible to other sites. Hereby the motive of introducing privacy preserving in this paper, namely the problems need to be solved is as follows 1\ Ensuring that the local la rge itemset and local support count is covered to other sites 2\omputing the global support count Firstly, secure set union is proposed to adopt by means of encrypting, re-encrypting and permuting encrypted items at every site, so that the local large item-set and local support count could be transferred between sites and the tracing of source of original data could be prevented well Secondly, secure sum could be adopted to solve the second problem. In detail, we set up a site called home site then it is proposed to compute a certain function from the home site to other sites with the privacy input into this function, return the ultimate function value to the home site decrypt the returned functi on value at the home site according to the original privac y input, and obtain the secure sum finally, that is global support count III   P RIVACY P RESERVED M ETHOD  As is known that in classi cal FDM algorithm, the local large item sets need to be broadcasted to other sites after the local pruning so that the global support count of these local large item-sets could be computed. In order to ensure the information of local site such as local large item-sets and local support count could not be aware to other sites, we introduce the secure set union here Secure set union is a method of privacy preserving in data mining, through which the information of local site such as rules, local large item-sets etc. can be broadcasted in the distribution system, but owners of broadcasted information can’t be exposed. Theoretically secure set union executes its function basing on the thought of permuting encrypt item Figure 1 shows the principle to set up secure set union      3 2 C E E     3 2 D E E    1 C E    C     3 C E  D    3 D E       1 3 2 C E E E     1 3 C E E     Figure 1  Determining the union of itemsets If given key 1  n K KK for any permutation  ij the following two equations hold 11       iin j jn KK K K EEM EEM   12 1 2  M MMMM given arbitrary  1  2 k k s.t 11 12        iin j jn rK K K K PE E M E E M 2  By introducing the secure se t union, each site encrypts the local data and transfers it to other sites, then each site reencrypt data received from ot her sites. Accordingly to equation 1 and equation 2, duplicates in the original items will be duplicated in the encryp ted items, and can be deleted In addition, the decryption can occur in any order. Thus, by permuting the encrypted items, it is prevented that each site tracks the source item-sets Obviously, through this method of secure set union each site could transfer the information of local large itemsets and local support count etc  without revealing that information from which site. However during the process of transferring data, the number of local large item-sets is revealed which exist in two s ites. For example, if K site have a local large item-set, it will be duplicated k times Although the item-set itself is not revealed, the true secure computation could not reveal this information. In practice allowing innocuous information leakage in an algorithm means lower cost than the al gorithm with fully secure computation On the other hand, we would like to compute the global support counts and ensure the local supports of each site could not revealed to other sites as well. This can be easily fulfilled by the method of secure sum If given sites 1 2   s first a home site\(site No.1\ust to be determined; and site No.1 randomly produces a random R which ranges in 1 n and will be added the local support count of site No.1, then transfers 1 mod Rv n to site No.2; as R is a random ranging in 1 n site No.2 could not obtain the real value of 1 v after receiving the information of 1 mod Rv n similar mode to compute the function will be set up in remainder sites No l  2 1 ls and now the received function value in site No l is 1 1 mod l j j VR v n  which will be added R that is 1 mod   mod l jj j Rv nvV n  d transferred to site No 1 l similarly the last site \(site No s putes the function and returns the function value to site No.1 where decryption will be implemente d according to the value of cryptically R global support count will be acquired and local support counts of other sites can’t be revealed. Figure 2 shows the principle to compute secure sum Obviously, the method of secure sum will be confronted with problem if sites collude. For instance, site No 1 l and site No 1 l could collude, then could confirm the real 2 D 3 C 1 C 
499 
499 
495 


  7 12    19     2 19 R   17 R   5 17   0 R  Figure 2. The principle to compute secure sum value of l v by comparing the function values that they sent out and received. However one s ite could be threatened on privacy secure, unless all the other sites colluded. This makes it possible for secure sum to be used in our proposed method IV  E XPERIMENTAL  EVALUATION  The proposed improved algorithm \(PPFDM\ is evaluated on some UCI datasets 9 and the distributed system in the experiment is made of four co mputers which are deployed with the following hardware and software: CPU Pentium\(R\ D CPU 2.60GHZ; Memory: 1024MB; Operation System: Windows XP. Java was adopted as the programming language in the experiment The front 1400 records of dataset named Contraceptive Method Choice in UCI datasets are used in the experiment We first discretize an attribute named Wife's age, the original values of which are integers and range in [2 the value of other attributes is discreti zed originally and need not be scattered\suppose the data distributes symmetrically in each computer, namely the numbers of the data distributed in each site are approximately equa l. Our scheme is described as: symmetrically distributing 1400 discrete records to each site, just 350 records per site Table I describes some samples with records Among the above attributes, fi rstly, attribute A denotes wife’s age: 2 for 20~29 years old, 3 for 30~39 years old, 4 for 40~49 years old; secondly, attribute B denotes wife’s education level which ranges from low to high as: 1, 2, 3, 4 thirdly, attribute C denotes husband’s education level which ranges from low to high as: 1, 2, 3, 4; and attribute D is the statistic of number of children ev er born; attribute E shows wife’s religion: 0 for non-Islam and 1 for Islam; attribute F figures whether wife is now wo rking: 0 for working and 1 for not working; attribute G de notes husband’s occupation level which ranges from low to high as: 1, 2, 3, 4; in addition, attribute H denotes standard of living index which ranges from low to high as: 1, 2, 3, 4; and attribute I shows media exposure: 0 for good and 1 for not good. Finally attribute J shows way to contracept: 1 for never use, 2 for long-time use and 3 for short-time use Given min_sup=20%, min_conf 70%. In the testing on effectiveness, we got the aver age time of 10 times tested on experimented dataset respectiv ely by classic FDM algorithm and improved algorithm, and the experimental results are showed in Table II TABLE I  S OME S AMPLES  Code of attribute  No. of record Name of  attribute      A Wife’s age 2 4 4 4 3 B Wife’s education 2 1 2 3 3 C Husband’s education 3 3 3 2 3 D Number of children ever born 3 10 7 9 8 E Wife’s religion 1 1 1 1 1 F Wife’s now working 1 1 1 1 1 G Husband’s occupation 2 3 3 3 3 H Standard of living index 3 4 4 3 2 I Media exposure 0 0 0 0 0 J Contraceptive method used 1 1 1 1 1 TABLE II  EXPERIMENTAL RESULTS ON EFFECTIVENESS TESTING   FDM Algorithm PPFDM Algorithm the Result of Large Association Rules 3 0 1  1 1 1 J I E J F E  3 0 1  1 1 1 J I E J F E  Time Spent 2246ms 2019ms  As is shown that in Table II the proposed improved PPFDM algorithm is more effectiv e than the FDM algorithm At the same time, we have got the same large association rules by the improved algorithm. Furthermore, we have compared the efficiency of the improved algorithm with the classical one. The proposed algorithm reduces the computation time because secure sum has been used in the improved strategy and the ne w communication mode has decreased the time which spen t on communication with the set up of home site. Besides, privacy of each site has been also preserved well V  C ONCLUSIONS  In this study, we propose an improved algorithm PPFDM\ based on the FDM algorithm and the computation method of privacy preserving. In the process, this algorithm computes the total support count with the privacy-preserved method, meanwhile ensures the source of every local large item-set and local support count is covered, so it reduces the time which spent on communication and preserves the privacy of the data distributed at each site. The experimental evaluation proves that the im proved algorithm is efficient and rather suitable for the pr actical application fields Site No.3 7 Site No.2 5 Site No.1 0 
500 
500 
496 


particularly those fields whic h require preserving privacy in the mining process A CKNOWLEDGMENT  The authors acknowledge the support from Jiangxi University of Science and Technology and the research grants provided by the Youth Science Fund of Education Office of Jiangxi Province \(No.GJJ09522  R EFERENCES  1  D.W. Cheung,  et al., 1996. A Fast Distributed Algorithm for Mining Association Rules. In Proc. Para llel and Distributed Information Systems, IEEE CS Press, pp: 31-42 2  R. Agrawal and J. Shafer, 1996. Parallel mining of association rules IEEE Transaction on Knowledge a nd Data Engineering, 8\(6\: 962969 3  Huang Xianying, Wang Keke, Fan Wei. Distributed Ming of Association Rules Based on Network of Start Model  Science of Computer, 2004\(12\: 180-188 4  Huang Yiqun, Lu Zhengding, Hu he ping, Li Ruixuan. Algorithm of Privacy-preserved Association Rule s Mining in Distributed System   Co m puter E ngineer ing 2006 13  1214  5  R.Agrawal and R.Srikant. Privacy-preserving Data Mining. In Proceedings of 2000 ACM SIGMOD Conference on Management of Data, Dallas, TX, 2000: 439-450 6  S.C.Pohlig and M.E.Hellman. An improved algorithm for computing logarithms over GF\(p\ and its cryptographic significance. IT-24 1978.106-110 7  Zhang Guorong. Problem of privacy preserving in Distributed Data Mi  Knowledge and T echnology  of Computer, 2006\(08\:30-212 8  B.Schneier. Applied Cryptogr aphy. John Wiley & Sons. 1995 9  UCI Repository of Machine Learning Databases http://archive.ics.uci.edu/ml  
501 
501 
497 


   


  0   5   10   15   20   25   30   0   5   10   15   20   25   30   35 Speed of threads alignmena \(untied fft \(untied   floorplan \(manual-untied   health \(manual-tied   nqueens \(manual-untied  sort \(untied   sparselu \(for-tied  strassen \(nocutoff-tied   Figure 3 Benchmark suite results as base code version These results give an idea of the performance behavior for each application We have applications  NQueens or SparseLU  which have an almost linear speed-up and other applications  Strassen  Health or FFT  which quickly reach a saturation phase B Cut-off mechanism comparison Due to the recursive nature of some benchmarks see Section III-B we can group cut-off mechanisms into two groups 002rst we include cut-off mechanisms which are based on the task depth i.e the recursion level Such kind of cut-off is usually implemented in the application itself Our benchmark suite implements when possible these cutoff mechanisms In the second group we can 002nd cut-off mechanisms based on the total number of tasks already created the number of tasks ready to be executed etc Such pruning mechanisms can be easily implemented in the OpenMP runtime itself   0   5   10   15   20   25   30   1   2   4   8   16   24   32 Speed-up of threads with if clause cut-off with manual cut-off  with no cut-off   Figure 4 Queens benchmark using different cut-off mechanisms Figure 4 shows the speed-up s obtained using these different cut-offs for the NQueens benchmark 017 manual cut-off  prunes the generation of tasks in the application code itself Compiler and runtime are not aware of the possibility of creating a task or not 017 pragma if cut-off  uses the OpenMP clause if  as a part of the task creation directive task  When the condition evaluates to false the task will not be created But the runtime still has to do some management in order to keep consistency e.g task hierarchy and dependence in order to execute properly a taskwait  017 no-cutoff  the application does not provide a cut-off and only the one implemented by the runtime if any is in use The Intel Compiler uses a cut-off based on the number of tasks We can see in the results that with the Intel Compiler programming a manual cut-off is more effective than using an if clause or relying on their runtime cut-off Being a very new compiler these results were expected Hopefully as the task implementations mature these differences will disappear thus reducing the burden on the programmer C Tied vs untied tasks The OpenMP programming model speci\002es that tasks can be labeled with the untied clause establishing two different kinds of tasks tied and untied A tied task is a task that when it is suspended can be resumed only by the same thread that suspended it whereas untied tasks can be resumed by any thread Tiedness of a task does not only imply which thread can resume a task but it also implies some task scheduling constraints which can also impact on the application performance   0   5   10   15   20   25   30   1   2   4   8   16   24   32 Speed-up of threads alignment tied alignment untied  nqueens tied  nqueens untied   Figure 5 Benchmark suite results using tied and untied tasks The suite comes with versions for all applications with tied and untied tasks to compare their behavior Figure 5 shows the results obtained using tied and untied tasks 
129 
129 


with the Alignment and NQueens benchmarks Results are similar with both versions Although a deeper analysis will be needed the results suggest two main hypothesis 017 The Intel Compiler does not implement thread switching and thus untied tasks cannot bene\002t from this feature which should avoid imbalances This is particularly evident in the Alignment benchmark which has been reported to scale 017 Task scheduling constraints do not seem to impact signi\002cantly the performance results at most there is a 4 difference between the versions The other applications show a similar behavior D Other opportunities for analysis The Intel Compiler does not implement mechanisms that allow the user choose among different task scheduling policies but other OpenMP compilers e 16 that have such capabilities One interesting study is to 002nd how task scheduling policies and how they can mantain locality across tasks can affect the performance results of the benchmarks of the suite In previous sections we have discussed how implementing a cut-off mechanism can affect application performance but we have not discussed due to space limitations how the different cut-off values i.e at which point in the recursion we cut relate with the creation of parallelism and the overall performance Choosing a low cut-off value can restrict parallelism opportunities but choosing a high cut-off value can saturate the system with a large amount of tasks which have no thread available to execute them The right choice depends many times of the input data set Comparing the application behaviour using different cut-off values or testing runtime features which allow to modify dynamically the cut-off can also be interesting analyses The quality of implementations for different task generation schemes e.g in the SparseLU benchmark which can use a single or multiple generator scheme taskwait constructs or other task related implementation details could also be analyzed with our benchmark suite proposal V C ONCLUSIONS AND F UTURE WORK We have presented BOTS  Barcelona OpenMP Task Suite  built with the double motivation of coping with the great characteristics of the multicore processors and offer a set of benchmarks to evaluate OpenMP tasking We think that BOTS will help implementors and programmers to have a better understanding of the OpenMP tasking model and its performance implications Each of these benchmarks comes also with different versions to test different aspects of the tasking model For example they can be used to evaluate task scheduling alternatives tiedness   Also a number of input sets are provided so that benchmarks can be used as tests or really stress the processors and memory system in your machine It is interesting to note that we have tried to select benchmarks with diverse characteristics In this paper we have highlighted the differences and we have shown their evaluation on an SGI Altix machine with up to 32 processors and we report some of their characteristics per task e.g operations memory writes    Their evaluation also shows that there is plenty of work to do at all levels  architecture compiler runtime system programming model to improve certain benchmarks given that their current scalability is very limited This suite can be used to obtain useful data of the strenghts and weaknesses of an OpenMP implementation that can help developers to improve it Currently we are working to add new benchmarks to the suite to cover more problem domains and scenarios We are as well planning to do a full cross-vendor evaluation to 002nd which is the current state of the OpenMP tasking implementations A CKNOWLEDGMENTS This research was supported by the Spanish Ministry of Science and Innovation contracts no TIN2007-60625 and CSD2007-00050 the European Commission in the context of the SARC project contract no 27648 the HiPEAC Network of Excellence contract no IST-004408 the IBM CAS Program and the Mare Incognito project under the BSC-IBM collaboration agreement R EFERENCES  O ARB OpenMP Applicati on Program Interf ace v  3.0  May 2008  J M Bull Measuring Synchronizati on and Scheduling Ov er heads in OpenMP in First European Workshop on OpenMP  September 1999  LLNL OpenMP Performance Suite Description 2001 A v ailable https://computation.llnl.gov/casc/RTS Report/openmp perf.html  A Dorta C Rodriguez F  de Sande and A Gonzalez The OpenMP Source Code Repository Euromicro Conference on Parallel Distributed and Network-Based Processing  vol 0 pp 244–250 2005  C Bienia S K umar  J P  Singh and K Li The P ARSEC Benchmark Suite Characterization and Architectural Implications in Proceedings of the 17th International Conference on Parallel Architectures and Compilation Techniques  2008 pp 72–81  H Jin M Frumkin and J Y an The OpenMP Implementation of NAS Parallel Benchmarks and Its Performance NASA Ames Research Center Technical Report NAS-99-011 1999 A v ailable citeseer.ist.psu.edu/408248.html 
130 
130 


 D H Baile y  E  Barszcz J T  Barton D S Bro wning R L Carter D Dagum R A Fatoohi P O Frederickson T A Lasinski R S Schreiber H D Simon V Venkatakrishnan and S K Weeratunga The NAS Parallel Benchmarks The International Journal of Supercomputer Applications  vol 5 no 3 pp 63–73 Fall 1991 A v ailable citeseer.nj.nec.com/bailey95nas.html  H Jin and R F  V  der W ijng aart Performance Characteristics of the Multi-zone NAS Parallel Benchmarks J Parallel Distrib Comput  vol 66 no 5 pp 674–685 2006  V  Aslot M Domeika R Eigenmann G Gaertner  W  B Jones and B Parady SPEComp A New Benchmark Suite for Measuring Parallel Computer Performance Lecture Notes in Computer Science  vol 2104 pp 1  10 2001  A v ailable citeseer nj.nec.com/aslot01specomp.html  C Bienia S K umar  and K Li  P ARSEC vs SPLASH-2 A Quantitative Comparison of Two Multithreaded Benchmark Suites on Chip-Multiprocessors IEEE International Symposium on Workload Characterization 2008  pp 47–56 2008  K K usano S  Satoh and M Sato Performance Ev aluation of the Omni OpenMP Compiler in Prooceedings of the Third International Symposium on High Performance Computing  2000 pp 403–414  S Shah G Haab P  Petersen and J Throop Fle xible Control Structures for Parallellism in OpenMP in 1st European Workshop on OpenMP  September 1999  P  C Fischer and R L Probert Ef 002cient Procedures for Using Matrix Algorithms in Proceedings of the 2nd Colloquium on Automata Languages and Programming  SpringerVerlag 1974 pp 413–427  M Frigo C E Leiserson and K H Randall The Implementation of the Cilk-5 Multithreaded Language in Proceedings of the ACM SIGPLAN 1998 conference on Programming Language Design and Implementation  1998 pp 212–223  E A yguad  e N Copty A Duran J Hoe\003inger Y Lin F Massaioli E Su P Unnikrishnan and G Zhang A Proposal for Task Parallelism in OpenMP in Proceedings of the 3rd International Workshop on OpenMP  Beijing China June 2007  X T eruel X Martorell A Duran R Ferrer  and E A yguad  e Support for OpenMP Tasks in Nanos v4 in CAS Conference 2007  October 2007  E A yguad  e A Duran J Hoe\003inger F Massaioli and X Teruel An Experimental Evaluation of the New OpenMP Tasking Model in Proceedings of the 20th International Workshop on Languages and Compilers for Parallel Computing  October 2007  A Duran J Corbal  an and E Ayguad  e Evaluation of OpenMP Task Scheduling Strategies in Proceedings of the 4th International Workshop on OpenMP  2008  H L v an der Spek E M Bakk er  and H A W ijshof f Char acterizing the performance penalties induced by irregular code using pointer structures and indirection arrays on the intel core 2 architecture in Computing Frontiers 2009  May 2009  M Burtscher  P  Carribault M K ulkarni K Ping ali C Cascaval and C von Praun Lonestar benchmark suite http://iss.ices.utexas.edu/lonestar 2009  B Chamberlain J Feo J Le wis and D Mizell An Application Kernel Matrix for Studying the Productivity of Parallel Programming Languages in W3S Workshop 26th International Conference on Software Engineering  May 2004 pp 37–41  M C and A Rogers Softw are Caching and Computation Migration in Olden 1995  G Myers and S Selznick and Z Zhang and W  Miller Progressive Multiple Alignment with Constraints in RECOMB 97 Proceedings of the 002rst annual international conference on Computational molecular biology  New York NY USA 1997 pp 220–225  J Coole y and J T uk e y  An Algorithm for the Machine Calculation of Complex Fourier Series Mathematics of Computation  vol 19 pp 297–301 1965  S R Das and R M Fujimoto A Performance Study of the Cancelback Protocol for Time Warp SIGSIM Simul Dig  vol 23 no 1 pp 135–142 1993  S G Akl and N Santoro Optimal P arallel Mer ging and Sorting Without Memory Con\003icts IEEE Transactions on Computers  vol 36 no 11 pp 1367–1369 1987  A Duran J Corbal  an and E Ayguad  e An Adaptive Cut-off for Task Parallelism in Proceedings of the 2008 ACM/IEEE conference on Supercomputing  IEEE Press 2008  J Bal art A Duran M Gonz 036 alez X Martorell E Ayguad  e and J Labarta Nanos Mercurium a Research Compiler for OpenMP in Proceedings of the European Workshop on OpenMP 2004  October 2004 
131 
131 


