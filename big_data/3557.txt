Set-Oriented Mining for Association Rules in Relational Databases Maurice Houtsma University of Twente the Netherlands hou t sma t rc nl Abstract We describe set-oriented algorithms for mining as sociation rules Such algorithms imply performing multiple joins and may appear to be inherently less escient than special-purpose algorithms We develop new algorithms that can be expressed as SQL queries and discuss optimization of these algorithms Af ter analytical evaluation an algorithm named 
SETM emerges as the algorithm of choice Algorithm SETM uses only simple database primitives viz sorting and merge-scan join Algorithm SETM is simple fast and stable over the mnge of pammeter values The major contribution of this paper is that it shows that at least some aspects of data mining can be cam\222ed out by using general query languages such as SQL mther than by developing specialized black box algo rithms The set-oriented nature of Algorithm SETM facilitates the development 
of extensions 1 Introduction The competitiveness of companies is becoming in creasingly dependent on the quality of their decision making Hence it is no wonder that companies often try to learn from past transactions and decisions in order to improve the quality of decisions taken in the present or future In order to support this process large amounts of data are collected and stored during business operations Later these data are analyzed for relevant information This process is called data min ing 3 12 18 51 or knowledge 
discovery in databases 8 15,9 111 Data mining is relevant to many different types of businesses As examples, retail stores obtain profiles from customers and their buying patterns and 221M Houtsma\222s research was made possible by a fellowship of the Royal Netherlands Academy of Arts and Sciences; he i8 currently at Telematics Research Centre P.O Box 217 7500 AE Enschede the Netherlands tA Swami is currently at Silicon Graphics Computer Sys tems 2011 N Shoreline Blvd Mountain View CA 94043-1389 Arun Swamit IBM Almaden Research Center San Jose CA 95120 aruns@sgi com supermarkets analyze their 
sales and the effect of ad vertising on sales Such 223targeted marketing\224 6 is becoming increasingly important Different aspects of data mining have been explored in the literature In classification data units tuples are grouped together based on some common char acteristics and rules are generated to describe this grouping This has been done both in the context of AI 16 and in the context of databases 2 8 51 Work has been done to search for similar sequences or time series l New indexing schemes for 
facilitating data mining in large archival databases are proposed in 17 In finding association rules one tries to discover fre quently occurring patterns within data units 14 41 Our interest is in the problem of finding association rules There has been a lot of work in rule discovery that is related but not directly applicable for example 7 10 13 161 Business applications deal with an uncontrolled real world where many rules will overlap in their com ponents and uncertainty is common 14 Examples of rules could be 223Most sales transactions in which bread 
and butter are purchased also include milk,\224 or 223Customers with kids are more likely to buy a particu lar brand of cereal if it includes baseball cards.\224 Work on finding these kinds of rules has been done in AI for some specific applications see 15 for an overview Although the work done in AI is usually very general the computational complexity of the proposed algo rithms is high and the algorithms are feasible only for small data sets 111 Performance is a problem with these algorithms for the kind of applications we consider which involve mining 
large databases In 12 a small example is described of generating rules from data but the emphasis is more on architectural issues than on performance and large data sets In 4 the problem of rule discovery is addressed in a database context The paper describes an algorithm for rule discovery on a large data set However the algorithm in 4 still has a tuple-oriented flavor tuples are repre sented as strings and the algorithm consists of string 25 1063-6382195 4.00 0 1995 IEEE 


manipulation operations and is rather complex We develop efficient algorithms for mining associa tion rules from large datasets in relational databases This differentiates our work from much of the work in AI Problems of optimization of discovered rules subsumption etc are beyond the scope of this paper Retailing transactions are used in the examples in this paper However the work is applicable to mining of association rules from any domain We address rule discovery in database systems from a set-oriented perspective The motivations for a new approach to this problem are several A set-oriented approach allows a clearer expression of what needs to be done as opposed to specifying exactly how the op erations are carried out The declarative nature of this approach allows consideration of different ways to op timize the required operations The experience that has been gained in optimizing relational queries can directly be applied here Eventually it should be pos sible to integrate rule discovery completely with the database system This would facilitate the use of the large amounts of data that are currently stored on rela tional databases The relational query optimizer can then determine the most efficient way to obtain the desired results Finally our set-oriented approach has a small number of well-defined simple concepts and operations This allows easy extensibility to handling additional kinds of mining e.g relating association rules to customer classes The structure of this paper is as follows In Sec tion 2 we define the problem of set-oriented data min ing and give an initial sketch of our approach In Section 3 we present an initial set-oriented algorithm expressed in SQL and analyze its performance In Section 4 we present a second set-oriented algorithm expressed in SQL and analyze its performance In Section 4.4 we describe the latter algorithm called Algorithm SETM in terms of simple database oper ations: sorting and merge-scan join We also illustrate the algorithm by means of a small example Section 5 explains how rules are generated In Section 6 we de scribe several experiments we did with an implemen tation of our algorithm on a large data set Section 7 presents our conclusions 2 Set-oriented mining Consider the problem of finding association rules in sales data Typically a retail store records informa tion for each customer transaction where a customer transaction involves the purchase of a variable num ber of items We can store this information in a rela tional database system using a table with the following schema SALES\(tmns-id item For each customer transaction that takes place tuples corresponding to the items sold are inserted in SALES In order to find association rules we need to scan transactions for reoccurring patterns that occur often enough to be of interest this is made more precise later We use the term pattern to capture the concept of itemset introduced in 4 This is more in line with existing terminology 15 A pattern can be defined as follows If items A B and C frequently occur together in a single customer transaction, this means that the pattern ABC occurs often This observation might allow us to conclude among other rules the association rule AA B  C  Here AB is called the antecedent of the rule and C is called the consequent of the rule Usually some constraints need to be met before we conclude that an association rule holds As in 4 we define support for a pattern to be the ratio of customer transactions supporting that pattern to the total number of customer transactions Also the confidence factor for a rule obtained from a pattern is defined as the ratio of the support for the pattern to the support for the antecedent of the rule For the rule A A B C this would be IABCl/IABI where lABCl denotes the support for pattern ABC We are interested only in association rules where the support for the pattern\(s involved in the rule is greater than some minimum value called minimum support We also require that qualifying rules have a confidence factor greater than some value Pat terns can be generated in a straightforward fashion by repeated joins with SALES For instance, generating all patterns of exactly two items is expressed by the following SQL query SELECT rl.trans-id rl.item r2.item FROM SALES r1 SALES r2 WHERE rl.trans-id  rz.trans-id AND rl.item  r2.item For each pair of items z,y we count the num ber of transaction-ids in order to find the number of transactions supporting this pattern All patterns of exactly three items can now be obtained by joining the result of the previous step again with SALES and so on The order in which items appear is not rele vant right now 2 y is equivalent to y z since both pairs have the same support Order only becomes im portant when generating the rules because confidence factors can be different for different orders Causality is not necessarily implied Also the ordering of A and B in the antecedent of the rule is arbitrary 26 


This strategy is elaborated in Sections 3 and 4 and expressed in terms of a set-oriented query language viz., SQL The first expression that is generated natu rally leads to nested-loop based joins A rough analy sis of its expected performance indicates that such an implementation would perform very poorly Conse quently we generate an equivalent expression in SQL that naturally leads to sort-merge based joins A first analysis shows it to be very promising and we pursue this implementation in the remainder of the paper We include the discussion of both SQL expressions of our strategy because we wish to emphasize the methodology that we used in this research Taking a set-oriented approach does not immediately lead to great results but it clearly helps in getting a good un derstanding of the problem In our case by first hav ing studied the nested-loop strategy we were able to develop the strategy based on sort-merge joins fairly easily by taking into consideration the ways a rela tional query optimizer deals with these types of com plex queries 3 Using nested-loop joins We discuss a formulation of our set-oriented data mining strategy that naturally leads to nested-loop based joins We express the algorithm in SQL and then analyze its expected performance 3.1 Formulation The customer transactions are available in the re lation SALES\(tmns-id item Using this relation we first generate the counts for each item x i.e the num ber of transactions that support item x We check that the minimumsupport requirement is met and store the result in relation Cl item count INSERT INTO C1 SELECT r1 item COUNT  FROMSALES r1 GROUP BY r1.item HAVING COUNT  minaupport The next step is to generate all patterns 2 y and check if they meet the minimumsupport criterion For a specific item A this is easy to express For example all patterns A,y can be generated using a self-join of SALES as shown below SELECT r1 item rz.item COUNT FROM SALES r1 SALES r2 WHERE rl.trans-id  rz.trans-id AND r1 item 221A\222 AND rz.item  221A\222 GROUP BY rl.item r2.item HAVING COUNT  minaupport This kind of expression only generates patterns with a specific item in the first position The expres sion has to be generalized in order to generate arbi trary patterns As stated earlier the order of the items in a pattern is not relevant at the time of generation The order is important only in the final rule generation process We take advantage of this fact by generating patterns with the items in lexicographical order For instance we generate AB but we do not generate BA We generalize over all values of item having minimum support by using the following SQL expression to gen erate all lexicographically ordered patterns of length k having minimum support INSERT INTO Ck SELECT rl item    Pk item COUNT  WHERE rl.trans-id      rk.trans-id AND FROM ck-1 C SALES rl   SALES rk r1.item  c.item1 AND rk-l.item  c.itemk-1 AND rk.item  rk-l.item GROUP BY rl.item   rk.item HAVING COUNT   minaupport Relation ck has schema iteml itemz   itemk count All feasible rules are found by consecutively generating all qualifying patterns from length 1 to k until ck+l   Since the items in the patterns are lexicographically ordered a single inequality test in the SQL query is sufficient 3.2 Analysis We perform a simple analysis of the expected per formance of the strategy based on nested-loop joins Let us consider how a relational query optimizer could optimize the final SQL expression in Section 3.1 For efficient evaluation of the nested-loop joins we need two indexes on the table SALES an index on item tmns-id and another index on tmns-id Given these indexes the query can be evaluated as follows 1 Take a tuple c from Ck-1 and use the index on item, tmns-id for rl to get qualifying tuples with r1 item  c.item1 27 


2 For each of these tuples use the index on item trans-id for 7-2 to get tuples that satisfy rz.item  c.item2 and ra.trans-id  rl.trans-id 3 Similarly for relations r3   Pk-1 4 Finally, use the index on trans-id for rk to com pute rk.tranS-id  rk-l.trans-id and check the remaining condition rk.item  rk-l.item 5 The qualifying tuples are sorted on the item val ues and the count is used to check the minimum support constraint Let us consider a hypothetical retailing database to characterize the performance of this strategy There are 1000 different items that can be sold The data consists of 200,000 customer transactions The aver age number of items sold in a transaction is 10 Thus the relation SALES contains about 2 million tuples To make the analysis tractable we assume that the items have approximately equal probability of being sold in the actual data set the items are not sold with equal probability Hence the chance of an item appearing in a particular transaction is 1 We will assume the following characteristics for the database system Page size is 4 Kbytes and each item and transaction id is represented using 4 bytes \(item val ues are represented by integers Hence each initial tuple consists of 8 bytes Consider the B+-tree index on item trans-id Since all the data is contained in the index we do not need a pointer in the leaf page entries Assuming little overhead we can store upto 500 entries in each leaf page The number of leaf pages in the B+-tree index on item trans-id is 2,000,000/500 w 4,000 Assuming 4 bytes for a pointer an index entry in the non-leaf pages has a size of 12 bytes Assum ing very little overhead we can store about 333 key value/pointer pairs on a non-leaf index page The fol lowing inequality holds for the number of levels L of the index tree 333L 2 1,000,000  333L hence L  3 The number of non-leaf pages in this index is 1  4,000/333  14 Similar calculations for the index on trans-id show that the number of leaf pages is 2,000 and the number of non-leaf pages is 5 Since the number of non-leaf pages is small we can assume that they reside in memory and are not fetched from disk Let the minimum support desired be 1000 transac tions i.e 0.5 of the total number of transactions On the average each item appears in about 1 of the transactions Assuming uniform probabilities all items qualify as having minimum support Therefore the cardinality of C1 will be 1000 To obtain C2 we take each tuple c from C1 and access the index on item tmns-id This requires 1 x 4,000 leaf page fetches i.e w 40 page fetches The result consists of about 2,000 transaction-ids 1 For each transaction-id we now have to access the index on tmns-id resulting in 1 page fetch From this we may conclude that the first step alone will require about 1000 x 40  2000 x 1 a 2,000,000 page fetches Most of these page fetches are random A random page fetch costs about 20 ms Hence the time for the first step alone is a 40,000 seconds which is more than 11 hours Clearly the implementation based on nested-loop joins is very inefficient However one could consider a different implementation for the same basic pattern finding strategy viz sort-merge joins We will con sider this strategy in the next section 4 Using sort-merge joins We now discuss the second formulation of our set oriented data mining strategy based on using sort merge joins We again express the algorithm in SQL and then analyze its expected performance 4.1 Formulation In the previous implementation we would generate intermediate relations R tmns-id item1     item  extract support information from these relations and then discard them But what if after each step we saved the last  that was generated Furthermore let us save R sorted on trans-id iteml   item We could then generate all lexicographically ordered patterns of length k using the following expression INSERT INTO RL SELECT p.trans-id,p.iteml  p.itemk-l,q.item WHERE q.trans-id  p.trans-id AND q.item  p.itemk-1 FROM Rk-1 p SALES q After generating all lexicographically ordered pat terns of length k in RL we now have to generate counts for those patterns in RL that meet the minimum sup port constraint This can be done as follows INSERT INTO Ck SELECT p.item1    p.itemk COUNT FROM RL p GROUP BY p.item1    p.itemk HAVING COUNT   minsupport 


Before we go on to generate patterns of length k 1 we first have to select the tuples from RI that should be extended viz those tuples that meet the minimum support constraint We also wish the resulting relation to be sorted on trans-id iteml   itemk This is done as follows INSERT INTO Rk SELECT p.trans-id p.iteml  p.itemk FROM RI p Ck q WHERE pitem1  q.item1 AND p.itemk  q.itemk ORDER BY p.trans-id,p.iteml  p.itemk We can now repeat this process until at some point Rk  0 Note that the sorting we did in the last step is not really required It does however enable an efficient execution plan if the sort order of the relations is tracked across iterations 4.2 Example We illustrate this strategy by means of an exam ple The example database consists of 10 transactions where each transaction has 3 items We require a min imum support of 3O i.e 3 transactions The desired confidence factor is 70 The customer transactions are shown in Figure 1 For brevity we have presented the transactions as non-normalized tuples The algo rithm however uses the tuple format described be fore a subset of the corresponding relation is shown too The contents of the count relation C1 are also shown in Figure 1 RI and Rk denote the R relations before and after elimination of patterns that do not meet the minimum support count In the first iteration R2 is generated and sorted on items and C2 is generated from R2 We show Ri Rz and C2 in Figure 2 In the next iteration R3 is generated and sorted on items and C3 is generated from R3 The contents of Rh R2 and C2 are as shown in Figure 3 The next iteration will not generate any new tuples and the algorithm terminates 4.3 Analysis In the section the performance of the sort-merge strategy is analyzed using the same data set as for the nested-loop strategy The 1/0 complexity of the sort-merge strategy can easily be expressed by a formula derived as follows Let llRkll denote the number of pages used to store the relation in iteration k In the worst case apply ing the minimum support constraints does not elim inate any tuples from Rk Assume that no patterns of length n have the minimum support i.e the rela tion R is empty We thus make n  1 passes i.e n 1 merge-scans requiring n  1 ll~lll cy ll 11 page accesses The number of page accesses to store the result of these merge-scans is R After each merge-scan the output is read again, sorted, and writ ten out to disk requiring 2cyz 11R,l1 page accesses We assume R1 to be sorted, and the sort operations to take place in pipelining mode No page accesses are required for storing or retrieving Ci since it is usually small enough to be kept in memory being the result of an aggregation query Therefore the total number of page accesses is bounded by n-I Let us calculate the time to generate Cz as we did for the nested-loops strategy Let R3 be empty Using the same numbers as in Section 3.2 the cardinality of R is given by io x 200,000 The size of a tuple from R is i  1 x 4 bytes This gives us the following llRlll  4,000 and llRzll  27,000 The number of page accesses is thus 3 x 4,000  4 x 27,000  120,000 Reading and writing all the R relations can be done in a sequential fashion We estimate the time for each page access as 10 ms Hence the total time spent on 1/0 operations is 1200 seconds or 10 minutes In comparison the nested-loop strategy required more than 11 hours This rough analysis shows that the implementation based on sort-merge joins will be much more efficient than the algorithm based on using nested-loop join with indexes We will therefore proceed with fur ther experimental evaluation of the algorithm based on sort-merge joins 4.4 Algorithm SETM The sort-merge strategy is described in pseudocode in Figure 4 We refer to it as Algorithm SETM The algorithm consists of a single loop in which two sort operations and one merge-scan join are performed The first sort is needed to implement the merge-scan join that follows it The second sort is used in order to generate the support counts efficiently Generat ing the counts involves a simple sequential scan over 29 


txid 1 item I item 1 item txid 10 10 10 20 20 20 30 30 30  item A B c A B D A B C    C D C D G G H F F F 10 20 30 40 50 60 70 80 90 99 A B A B A B B C A C A D A E D E D E D E F txid 10 10 10 20 20 20 30 30 30  Figure 1 Customer transactions corresponding relation and relation C1 item1 A A B A A B A A B  item1 A A B A A A B B A  item2 B C C B D D B C C  item2 B C C B B C C C C  80 D 90 D item1 item2 D E item1 1 item2 I cnt 1 D F E F item3 cnt F3 txid 10 10 10 20 30 30 30 40 50  E F E F E F Figure 2 Relations Ri C2 and R2 Figure 3 Relation R C3 and R3 30 


Rk Deleting the tuples from Rk that do not meet the minimum support involves simple table look-ups on relation ck The ck relations are of interest to us for rule generation We have not included in this algorithm the optimizations mentioned in Section 4.3 k  1 sort R1 on item C1  generate counts from RI repeat k  k  1 sort Rk-1 on trans-id iteml     itemk-1 RB  merge-scan Rk-1 RI sort RL on iteml  itemk ck  generate counts from RL Rk  filter RB to retain supported patterns until Rk   Figure 4 Outline of Algorithm SETM 5 Rule generation We have omitted so far any discussion of how the rules are generated from the count relations The rule generation algorithm is straightforward For any pat tern of length k we consider all possible combinations of k  1 items in the antecedent The remaining item not used in the combinations is in the consequent For each combination of antecedent and consequent we check if the confidence factor meets or exceeds the minimum confidence factor desired If the confidence factor is high enough the rule is written to output In order to check the confidence factor we need the count for the current pattern available in the current count relation C and the count for the pattern compris ing the antecedent available by lookup in a previous count relation Ci-1 Let us consider the example from Section 4.4 The minimumsupport is 30 3 transactions and the min imum confidence factor is 70 After relation Cz is obtained, the rules obtained are shown below Rules have been written in the form X j I c,s where X is the list of items in the antecedent of the rule I is the item in the consequent of the rule s is the support expressed as a percentage and c is the con fidence factor Let us see how we obtain the rule B A The pattern AB is supported since its support is 3 and the minimum support desired is 3 The ratio IABI/IBI  3/4  75 which is greater than the minimum confidence factor of 70 The ra tio IABI/IAI  3/6  50 which is less than the min imum confidence factor of 70 Hence we do not obtain the rule A B B  A 75.0%, 30.011 C  A 175.0 30.011 B  C 75.0 30.011 C  B 75.0 30.011 E  D 75.0 30.0%1 F  D lOO.O 30.011 E  F 75.0 30.011 F  E lOO.O 30.011 After the second iteration relation C3 is available The rules generated from C are D E  F C30.01 lOO.OO%l D F  E C30.01 lOO.OO%l E F I D 30.0 100.00%1 6 Experiments In previous sections we have described the new algo rithm and given some analysis to show that we expect it to be efficient We implemented the algorithm to run in main memory and read a file of transactions The execution times given are for running the algo rithm on the IBM Risc/System 6000 350 with a clock speed of 41.1 MHz In 4 a data set was used that consists of sales data obtained from a large retailing company with a total of 46,873 customer transactions The experiments were conducted using this data set 6.1 Variation of relation shes We first study how the size of the R trans-id and items relation varies with each iteration of algorithm SETM In Figure 5 we show the variation in the size in Kbytes of R with iteration i for the retailing data set Curves are shown for different values of minimum support where minimum support is varied from 0.1 to 5 The maximum size of the rules is 3 hence in all cases lR41  0 with 141 denoting the cardinality of R Also the starting relations are the same and hence I R1 I  115,568 in all cases If the minimum support is small enough 5 0.1  the size of relation R can first increase and then de crease But the general trend is that the size relation R decreases For large values of minimum support IR,I decreases quite rapidly from the first iteration to the second This sharp decrease is delayed somewhat for the smaller values of minimum support Hence using small values of minimum support allows us to obtain more rules In general it also allows us to 31 


obtain rules with more items in the antecedent For example if the minimum support is reduced to 0.05 we obtain rules with 3 items in the antecedent We expect the Ci count relations to be small enough to fit in memory We now study how the car dinality ICil of these relations varies with iteration number Figure 6 shows curves for different values 200 of minimum support The values of lCil measure k the number of item combinations that could garner e enough support We observe that for small values of c  150 minimum support the value of lCil increases initially Q before decreasing with later iterations Since lCil is a 5 measure of how many rules can possibly be generated c we again see the importance of handling small values  100 3 of minimum support in a timely fashion The maxi 5 c mum size of the rules is 3 hence in all cases IC41  0 Also the starting relations are the same and hence IC1 I  59 for all minimum support values 6.2 Execution times 250 N 50 l8 Minimum Support I 0.1 We measured the execution times of our set 1 2 3 4 oriented algorithm SETM for various values of the Iteration Number minimum support We varied the minimum support from 0.1 to 5 The execution times are shown in the following table Figure 5 Size of relation R Execution Time seconds 6.90 0.5 1 2 5.30 4.64 I 4.22 400 I 5 I 3.97 I I 1   I 2 300 3 We see that algorithm SETM is very stable The  c execution time varies from 7 secs for 0.1 minimum  0 support to sz 4 secs for 5 minimum support 2 7 Conclusions y 200 c 3 8 In this paper we have investigated a set-oriented 100 approach to mining association rules We have shown that by following a set-oriented methodology we 60 arrived at a simple algorithm The algorithm is 30 0 straightforward-basic steps are sorting and merge scan join-and could be implemented easily in a re lational database system The major contribution of this paper is that it shows that at least some aspects of data mining can be carried out by using general query languages such as SQL rather than by develop ing specialized black box algorithms 1 2 3 4 Iteration Number Figure 6 Cardinality of Ci 32 


The algorithm exhibits good performance and sta ble behavior, with execution time almost insensitive to the chosen minimum support For a real-life data set execution times are on the order of 4-7 seconds The simple and clean form of our algorithm makes it easily extensible and facilitates integration into a in teractive data mining system We are investigating extending the algorithm in order to handle additional kinds of mining, e.g., relating association rules to cus tomer classes Acknowledgements We thank Rakesh Agrawal Bobbie Cochrane Bill Cody and Hamid Pirahesh References l R Agrawal C Faloutsos and A Swami Ef ficient Similarity Search In Sequence Databases In Proceedings of the Fourth International Con ference on Foundations of Data Organization and Algorithms pages 69-84 Springer-Verlag, Berlin October 1993 Lecture Notes in Computer Sci ence V303 2 R Agrawal S Ghosh T Imielinski B Iyer and A Swami An Interval Classifier for Database Mining Applications In Proceedings of the Eigh teenth International Conference on Very Large Data Bases pages 560-573 Vancouver August 1992 3 R Agrawal T Imielinski and A Swami Database Mining A Performance Perspective IEEE Tmnsactions on Knowledge and Data En gineering 5\(6 December 1993 Special issue on Learning and Discovery in Knowledge Based Databases 4 R Agrawal T Imielinski and A Swami Mining Association Rules Between Sets of Items in Large Databases In Proceedings of ACM-SIGMOD In ternational Conference on Management of Data pages 207-216 Washington DC, June 1993 5 T M Anwar H W Beck and S B Navathe Knowledge Mining by Imprecise Querying A Classification-Based Approach In IEEE 8th International Conference on Data Engineering Phoenix, Arizona 1992 6 David Shepard Associates editor The New Di rect Marketing Business One Irwin Homewood Illinois 1990 7 P Cheeseman Autoclass A Bayesian Classifica tion System In 5th International Conference on Machine Learning Morgan Kaufman June 1988 8 J Han Y Cai and N Cercone Knowledge Dis covery in Databases An Attribute-Oriented Ap proach In Proceedings of the Eighteenth Inter national Conference on Very Large Data Bases pages 547-559 Vancouver August 1992 9 R Krishnamurthy and T Imielinski Practitioner Problems in Need of Database Research Re search Directions in Knowledge Discovery A CM SIGMOD Record 20\(3 September 1991 lo P Langley H Simon G Bradshaw and J Zytkow editors Scientific Discovery Com putational Explorations of the Creative Process MIT Press 1987 ll D J Lubinsky Discovery from Databases A Review of AI and Statistical Techniques In IJCA 1-89 Workshop on Knowledge Discovery in Databases pages 204-218 1989 12 R.S Michalski L Kerschberg K.A Kaufman and J.S Ribeiro Mining for Knowledge in Databases The INLEN Architecture Initial Im plementation and First Results Journal of In telligent Information Systems 1:85-113 1992 13 J Pearl, editor Probabilistic Reasoning in Intel ligent Systems Networks of Plausible Inference Morgan Kaufman 1992 14 G Piatetsky-Shapiro Discovery Analysis and Presentation of Strong Rules In Knowledge Dis covery in Databases pages 229-248 AAAI/MIT Press 1991 15 G Piatetsky-Shapiro editor Knowledge Discov ery in Databases AAAI/MIT Press 1991 16 J R Quinlan Induction of Decision Trees Ma chine Learning 1:81-106 1986 17 P Seshadri and A Swami Generalized Partial Indexes In Proceedings of IEEE Data Engineer ing Conference IEEE Computer Society March 1995 18 S Tsur Data Dredging IEEE Database Engi neering Bulletin 13\(4 December 1990 33 


related issues b ecome prime candidates for immediate atten tion F or example traditionally database systems supp orted declarativ e querying without the necessit y to care ab out the pro ceduralit y of the queries In this pap er w eha v e actually demonstrated that asso ciation rule mining can b e view ed as a Datalog query  It is immediate that a direct mapping from the Datalog expressions presen ted in this pap er to SQL can be dev elop ed with no problem at all W e can then rely on ecien t database pro cessing of the query in an optimized fashion Hence w ecomeclose to the essence of the visions expressed b y the leading database researc hers and practioners 12  References 1 Rak esh Agra w al and Ramakrishnan Srik an t F ast algorithms for mining asso ciation rules in large databases In VLDB  pages 487{499 1994 2 Anon ymous A declarativ e metho d for mining c hisquare rules from deductiv e databases T ec hnical rep ort Departmen t of Computer Science Anon ymous Univ ersit y USA F ebruary 2001 3 C Beeri and R Ramakrishnan On the po w er of magic In Pr o c e e dings of the 6th A CM Symp osium on Principles of Datab ase Systems  pages 269{283 1987 4 Sergey Brin Ra jeev Mot w ani and Craig Silv erstein Bey ond mark et bask ets Generalizing asso ciation rules to correlations In Pr o c A CM SIGMOD  pages 265 276 1997 5 D Chimen ti et al The LD L system protot yp e IEEE Journal on Data and Know le dge Engine ering  2\(1 90 1990 6 Jia w ei Han Jian P ei and Yiw en Yin Mining frequen t patterns without candidate generation In Pr o c A CM SIGMOD  pages 1{12 2000 7 Marcel Holsheimer Martin L Kersten Heikki Mannila and Hann uT oiv onen A p ersp ectiv e on databases and data mining In Pr o c of the sixth A CM SIGKDD Intl Conf  pages 150{155 Mon treal Queb ec 1995 8 Flip Korn Alexandros Labrinidis Y annis Kotidis and Christos F aloutsos Ratio rules A new paradigm for fast quan tiable data mining In Pr o c of 24th VLDB  pages 582{593 1998 9 Brian Len t Arun N Sw ami and Jennifer Widom Clustering asso ciation rules In Pr o c of the 3th ICDE  pages 220{231 1997 10 Mengc hi Liu Relationlog At yp ed extension to datalog with sets and tuples In John Llo yd editor Pr oc e e dings of the 12th International L o gic Pr o gr amming Symp osium  pages 83{97 P ortland Oregon Decem ber 1995 MIT Press 11 Rosa Meo Giusepp e Psaila and Stefano Ceri An extension to SQL for mining asso ciation rules Data Mining and Know le dge Disc overy  2\(2 1998 12 Amir Netz Sura jit Chaudh uri Je Bernhardt and Usama M F a yy ad In tegration of data mining with database tec hnology  In Pr o c e e dings of 26th VLDB  pages 719{722 2000 13 Amir Netz Sura jit Chaudh uri Usama M F a yy ad and Je Bernhardt In tegrating data mining with SQL databases In IEEE ICDE  2001 14 Ra ymond T Ng Laks V S Lakshmanan Jia w ei Han and Alex P ang Exploratory mining and pruning optimizations of constrained asso ciation rules In Pr o c A CM SIGMOD  pages 13{24 1998 15 Jong So o P ark Ming-Sy an Chen and Philip S Y u An eectiv e hash based algorithm for mining asso ciation rules In Pr o c A CM SIGMOD  pages 175{186 1995 16 Karthic k Ra jamani Alan Co x Bala Iy er and A tul Chadha Ecien t mining for asso ciation rules with relational database systems In Pr o c e e dings of the International Datab ase Engine ering and Applic ations Symp osium  pages 148{155 1999 17 R Ramakrishnan D Sriv asta v a and S Sudarshan CORAL  Con trol Relations and Logic In Pr o c of 18th VLDB Confer enc e  pages 238{250 1992 18 Konstan tinos F Sagonas T errance Swift and Da vid Scott W arren XSB as an ecien t deductiv e database engine In Pr o c of the A CM SIGMOD Intl Conf  pages 442{453 1994 19 Sunita Sara w agi Shib y Thomas and Rak esh Agra w al In tegrating mining with relational database systems Alternativ es and implications In Pr o c A CM SIGMOD  pages 343{354 1998 20 Ashok a Sa v asere Edw ard Omiecinski and Shamk an tB Nav athe An ecien t algorithm for mining asso ciation rules in large databases In Pr o c of 21th VLDB  pages 432{444 1995 21 Pradeep Sheno y  Ja y an t R Haritsa S Sudarshan Gaura v Bhalotia Ma y ank Ba w a and Dev a vrat Shah T urb o-c harging v ertical mining of large databases In A CM SIGMOD  pages 22{33 2000 22 Abraham Silb ersc hatz Henry F Korth and S Sudarshan Datab ase System Conc epts  McGra w-Hill third edition 1996 23 Shib y Thomas and Sunita Sara w agi Mining generalized asso ciation rules and sequen tial patterns using SQL queries In KDD  pages 344{348 1998 24 J D Ullman Principles of Datab ase and Know le dgeb ase Systems Part I II  Computer Science Press 1988 25 Mohammed J Zaki Generating non-redundan t association rules In Pr o c of the 6th A CM SIGKDD Intl Conf  Boston MA August 2000 1 0 


OM OM 006 OD8 01 012 014 016 018 02 022 False alarm demity Figure 9 Percentage of tracks lost within 200 seconds using three-scan assignment with PD  0.9 TI  O.ls Figure 11 T2  1.9s and T  Is ij  20 and 0  0.1 24 1 22  20  E fls 0  8l 16 0 n 14  12  0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 T1/12 PD Average track life of three-scan assignment with PD varying TI  0-ls T2  1.9s T  Is X  0.02 ij LO and   0.1 mareuvenng index Figure 12 Percentage of lost tracks of 4-D assipment in 200 seconds with maneuvering index varying X  0.01 Ti  0.1 T2  1.9s and T  IS PD  0.98 Figure 10 Percentage of lost tracks of 4-D assignment in 200 SeoDllCls with TI and T2 varying PD  0.98 X  0.02 q 20 and 0  0.1 4-1607 


Figure 13 Average gate size for Kalman filter Figure is relative as compared to nq and curves are parametrized by ij/r with unit-time between each pair of samples 1.2 Iy I 1.1 0.5 I A CRLB for he unifm samiina I  0.4 0.35 d 3 03 i7 3 0.25 0 0.M 0.04 0.06 008 0.1 0.12 0.14 0.16 0.18 0.2 False A!am DemW V I    Figure 14 CramerRao Lower Boundfor Mean Square Error of uniform and nonuniform sampling schemes with Ti  O.ls T2  1.9s T  IS PD  0.9 ij  5 and U  0.25 1 unifon sampling r-ls ked i non-uniform sampling loge inlewi I ti non-uniform sampling shod interva I 0.9 0.8 I Figure 15 MSE comparison of three-scan assignment with Ti and T2 varying I'D  1 X  0.01 ij  20 and U  0.1 4-1608 


Plenary Panel Session 30 XML Databases   Moderator: Michael Carey, IBM Almaden Research Center USA Panelists Adam Bosworth, Microsoft Corporation USA David De Witt University of Wisconsin-Madison, USA Alon Levy University of Washington USA Bruce Lindsay IBM Almaden Research Center USA Jennifer Widom Stanford University USA Demo Session 1 Web Query Optimizer  661 V Zadorozhny L Bright L Raschid T Urhan and M Vidal ReQueSS: Relational Querying of Semi-structured Data  664 R Sunderraman The IDEAL Approach to Internet-Based Negotiation for E-Business  666 J Hammer C Huang Y Huang C Pluempitiwiriyawej M Lee H Li L Wang Y Liu and S Su READY A High Performance Event Notification Service  668 R Gruber B Krishnamurthy, and E Panagos A Multimedia Information Server with Mixed Workload Scheduling  670 G Nerjes DISIMA An Object-Oriented Approach to Developing an Image Database System  672 V Oria T Ozsu P Iglinski B Xu and L Cheng Demo Session 2 The Collaboration Management Infrastructure  677 H Schuster D Baker A Cichocki D Georgakopoulos and M Rusinkiewicz Assisting the Integration of Taxonomic Data The LITCHI Toolkit  679 I Sutherland J Robinson S Brandt A Jones S Embury W Gray R White and F Bisby TheaterLoc: Using Information Integration Technology to Rapidly Build Virtual Applications  681 G. Barish Y.4 Chen D Dipasquo, C Knoblock S Minton I Muslea and C Shahabi Lineage Tracing in a Data Warehousing System  683 Y Cui and J Widom xiii 


The Mentor-Lite Prototype A Light-Weight Workflow Management System  685 J Weissenfels M Gillmann 0 Roth, G Shegalov and W Wonner Location Prediction and Queries for Tracking Moving Objects  687 0 Wolfson B Xu and S Chamberlain Semiorder Database for Complex Activity Recognition in Multi-Sensory Environments  689 S Bhonsle A Gupta S Santini and R Jain Tutorial 1 Web Information Retrieval  693 M Henzinger Tutorial 2 Mobile and Wireless Database Access for Pervasive Computing  694 P Chrysanthis and E Pitoura Tutorial 3 Data Mining with Decision Trees  696 J Gehrke Tutorial 4 Directories Managing Data for Networked Applications  697 D Srivastava Tutorial 5 Indexing High-Dimensional Spaces Database Support for Next Decade\222s Applications  698 S Berchtold and D Keim xiv 


 T5.I2.D100K T10.I4.D100K T15.I4.D100K T10.I6.D400K T10.I6.D800K T10.I6.D1600K Optimizations across Databases 5 0 5 10 15 20 25 30 35 40 45 Improvement COMP TREE COMP-TREE 1 2 4 8 1 2 4 8 1 2 4 8 2 4 8 2 4 8 1 2 4 8 Processors Databases Figure 5 Effect of Computation and Hash Tree Balancing good as the COMP optimization The reason that the hash tree balancing is not suf\336cient to offset inherent load imbalance in the candidate generation in this case The most effective approach is to apply both optimizations at the same time COMP-TREE The combined effect is suf\336cient to push the improvements in the 40 range in the multiple-processor case On 1 processor only hash tree balancing is bene\336cial since computation balancing only adds extra cost 5.4 Short-circuited Subset Checking Figure 6 shows the improvement due to the short-circuited subset checking optimization with respect to the unoptimized version The unoptimized version is the Apriori algorithm due to Agrawal et al 5 The results are presented for dif ferent number of processors across dif ferent databases The results indicate that while there is some improvement for databases with small transaction sizes the optimization is most effective when the transaction size is large In this case we get improvements of around 25 r the unoptimized version To gain further insight into this optimization consider 336gure 7 It shows the percentage improvement obtained per iteration on applying this optimization on the T20.I6.D100K database It shows results only for the uni-processor case r similar results were obtained on more processors We observe that as the iteration k increases there is more opportunity for shortcircuiting the subset checking and we get increasing bene\336ts of up to 60 The improvements start to fall off t the high end where the number of candidates becomes small resulting in a small hash tree and less opportunity for short-circuiting It becomes clear that is an extremely effective 15 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 T5.I2.D100K T10.I6.D800K T15.I4.D100K T20.I6.D100K procs across Databases 0 5 10 15 20 25 Improvement 1 2 4 8 Figure 6 Effect of Short-circuited Subset Checking 23456789101112 Iterations 0 10 20 30 40 50 60 improvement T20.I6.D100K Figure 7  Improvement per Iteration  proc   16 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


optimization for larger transaction sizes and in cases where there are large number of candidate k itemsets 6 Conclusions In this paper e presented a parallel implementation of the Apriori algorithm on the SGI Power Challenge shared memory multi-processor We also discussed a set of optimizations which include optimized join and pruning computation balancing for candidate generation hash tree balancing and short-circuited subset checking We then presented experimental results on each of these Improvements of more than 40 were obtained for the computation and hash tree balancing The short-circuiting optimization was found to be extremely effective for databases with large transaction sizes Finally we reported the parallel performance of the algorithm While we d good speed-up we observed a need for parallel I/O techniques for further performance gains References  R Agra wal T  Imielinski and A Swami Database mining A performance perspecti v e  I n IEEE Trans on Knowledge and Data Engg  pages 5\(6 1993  R Agra wal T  Imielinski and A Swami Mining association rules between sets of items in lar ge databases In Proc M SIGMOD Intl Conf Management of Data  May 1993  R Agra wal H Mannila R Srikant H T o i v onen and A I V erkamo F ast disco v ery of association rules In U F et al editor Advances in Knowledge Discovery and Data Mining  MIT Press 1996  R Agra wal and J Shafer  P arallel mining of association rules design implementation and e xperience Technical Report RJ10004 IBM Almaden Research Center San Jose CA 95120 Jan 1996  R Agra wal and R Srikant F ast algorithms for mining association rules In Proc 20th VLDB Conf  Sept 1994  M Cierniak W  Li and M J Zaki Loop scheduling for heterogeneity  I n 4th IEEE Intl Symposium on High-Performance Distributed Computing also as URCS-TR 540 CS Dept Univ f Rochester  Aug 1995  M Holsheimer  M  K ersten H Mannila and H T o i v onen A perspecti v e on databases and data mining In 1st Intl Conf Knowledge Discovery and Data Mining  Aug 1995  M Houtsma and A Swami Set-oriented mining of association rules In RJ 9567  IBM Almaden Oct 1993  H Mannila H T o i v onen and I V erkamo Ef 336cient algorithms for disco v ering association rules In AAAI Wkshp Knowledge Discovery in Databases  July 1994  J S P ark M Chen and P  S Y u  A n e f fecti v e hash based algorithm for mining association rules In Proc M SIGMOD Intl Conf Management of Data  May 1995 17 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 J S P ark M Chen and P  S Y u  E f 336cient parallel data mining for association rules T echnical Report RC20156 IBM T J Watson Research Center Aug 1995  G Piatetsk y-Shapiro Disco v ery  presentation and analysis of strong rules In G P S et al editor  KDD  AAAI Press 1991  A Sa v asere E Omiecinski and S Na v athe An ef 336cient algorithm for mining association rules in large databases In Proc 21st VLDB Conf  1995  M J Zaki M Ogihara S P arthasarathy  and W  Li P arallel data mining for association rules on shared-memory multi-processors Technical Report 618 Department of Computer Science University of Rochester 618 1996 18 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


