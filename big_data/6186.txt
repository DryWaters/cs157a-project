An Efficient Data Mining Technique for Discovering Interesting Association Rules Show-Jane Yen and Arbee L.P Chen Department of Computer Science National Tsing Hua University Hsinchu, Taiwan 300 R.O.C Email alpchen@cs.nthu.edu.tw Abstract Mining association rules is an important task Past transaction data can be analyzed to discover customer purchasing behaviors such that the quality of busi ness decision can be improved The association rules describe the associations among items in the large database of customer transactions However the size of the database can be very large It is very 
time con suming to find all the association rules from a large database and users may be only interested in the as sociations among some items Moreover the criteria of the discovered rules for the user requirements may not be the same Many uninteresting association rules for the user requirements can be generated when tra ditional mining methods are applied Hence a data mining language needs to be provided such that users can query only interesting knowledge to them from a large database of customer transactions In this pa per a data mining language is presented From the 
data mining language users ca.n specify the interested items and the criteria of the rules to be discovered Also an efficient data mining technique is proposed to extract the association rules according to the users\221 requests 1 Introduction Data mining has high applicability in retail indus try The effective management of business is signifi cantly dependent on the quality of its decision making It is therefore important to analyze past transaction data to discover customer purchasing behaviors and improve the quality of business decision Because the amount of these transaction data is very large an ef ficient 
algorithm needs to be devised for discovering useful information embedded in the transaction data An association rule describes the association among items in which when some items are purchased in a transaction others are purchased too The follow ing definitions are adopted from l A transaction supports an itemset Z if Z is contained in the trans action The support for an ztemset is defined as the This work was partially supported by the Republic of China National Science Council under Contract No NSC 86-2213-E 007-009 0-8186-8147-0197 
10.00 0 1997 IEEE ratio of the total number of transactions which sup port this itemset to the total number of transactions in the database To make the discussion easier occa sionally we also let the total number of transactions which support the itemset denote the support for the itemset The major work of mining association rules is to find all itemsets that satisfy a certain user-specified minimum support Each such itcmsct is rcferred to as large itemset In order to find association rules all large itemsets need to be generated from 
the database However the size of the database can be very large It is very time consuming to find all association rules from the large database and users may be only interested in the associations among cert,ain items Moreover the criteria such as minimum support to discover rules for the users may not be the same Many uninter esting association rules to the users can be generated when traditional methods of mining association rules are applied l 2 4 51 Hence a data mining language is needed such that users can query knowledge from a large database 
of customer transactions Meo Psaila and Ceri 3 proposed a SQL-like op erator for extracting association rules The SQL-like operator is capable of expressing the problem of min ing association rules However the expressive power of the SQL-like operator is still limitary For exam ple users may want to query the associations between certain items and all the other items The SQL-like operator cannot express this kind of query Further more the SQL-like query language is inconvenient for naive users which is suita.ble to SQL programmers and experts and the SQL-like operator performs set oriented 
operations i.e join operations which are very inefficient operations For designing a data mining language two impor tant issues need to be considered the easy-to-use user interface and the efficient data mining language pro cessing This paper is concerned with the two issues We present a data mining language from which users only need to specify the criteria for discovering the rules and the items in the antecedent and the conse quent in the rules We also propose an efficient data mining technique to process user\222s request Accord ing to the user\222s request the discovered large item 664 


sets are called the anterestang large atemsets and the discovered association rules the anterestang assocaataon rules For the efficient data mining technique the inter esting large itemsets are discovered firstly After dis covering all interesting large itemsets the interesting association rules can be extracted according to the antecedent and the consequent specified in the user\222s request For an interesting large itemset Z if itemsets X and Y match the user-specified antecedent and the consequent respectively and X U Y  2 then the rule X Y can be generated The confidence of X Y in database D is the probability that when itemset X occurs in a transaction in D itemset Y also occurs in the same transaction That is the ratio of the support for itemset Z to the support for itemset X This rule is an interesting association rule if its confidence achieves the manLmum conjidence specified in the user\222s request An example of such an associ ation rule is 22495 of the transactions in which coffee and sugar are purchased milk is purchased too.\224 The form of this rule is 224coffee sugar  milk 95%.\224 The antecedent of this rule consists of coffee and sugar and the consequent consists of milk alone The percentage 95% is the confidence of the rule The rest of the paper is organized as follows Sec tion 2 presents the data mining language Section 3 proposes the efficient data mining algorithm for the presented data mining language The performance analysis for the data mining algorithm is presented in Section 4 Finally we conclude this paper and present directions for future research in Section 5 Mining Association Rules From  Database  With Antecedent  Items   r Consequent  Items   Support s Confidence c  Items   item itemIk Where 0 6 s,c 5 1 and k  0 The parameter  Database  is used to specify the database name to which users query the association rules In the With clause users can specify items in the antecedent and the consequent of the rules to be dis covered after the keywords Antecedent and Con sequent respectively If the items are specified in  Items  after the keyword Antecedent Conse quent then the antecedent consequent of each dis covered rule will contain these items Besides users need to specify the two criteria minimum support and minimum confidence by the keywords Support and Confidence respectively Notice that the phrase within the parentheses is optional If the user does not specify the keyword Antecedent Consequent then any item can ap pear in the antecedent consequent of the discovered rules If the user does not specify the two keywords Antecedent and Consequent all association rules which achieve the user-specified criteria will be dis covered The notation 224*\224 represents all items except the items specified in  Items  If the notation 224*\224 is specified after the keyword Antecedent Con sequent then in addition to the items specified in  Items  other items can also be contained in the antecedent consequent of each discovered rule 3 Efficient Data Mining Algorithm In this section we describe how to process a user\222s request We develop an efficient data mining EDM algorithm to generate the interesting association rules according to the user\222s request For a user\222s request if both the two keywords An tecedent and Consequent are specified in the With clause and there is no notation 224*\224 specified then the antecedent and the consequent of the discovered rule will contain only the items specified in  Items 222s after the keywords Antecedent and Consequent respectively We call this type of users\222 requests the Type I request If the user likes to extract associa tion rules whose antecedent or consequent can contain other items except the items specified in  Items  then the noataion 224*\224 has to be specified in the With clause We call this type of users\222 requests the Type II request The request in which only one of the two key words Antecedent and Consequent is specified also belongs to the Type I1 request If both keywords An is the large atem generataon phase In this phase EDM algorithm scans the database to record related infor mation for each anterested atem and find large items The interested items for the Type I request are the items specified in the With clause The interested items for the Type I1 and Type I11 requests are all items in the database The second phase is the assocaataon graph construc tion phase which constructs an association graph to in dicate the associations between every two large items generated in the first phase The third phase is the znterestang large atemset generataon phase which gen erates all interesting large itemsets by traversing the constructed association graph according to the user\222s request The final phase is the anterestang assocaa ihon rule generataon phase which generates all inter esting association rules according to the discovered in teresting large itemsets the items specified after the two keywords Antecedent and Consequent and the user-specified minimum confidence in the user\222s request 3.1 Large item generation In the first phase algorithm EDM scans the database and builds a bit vector for each interested 665 


item The length of each bit vector is the number of transactions in the database If an item appears in the ith transaction the ith bit of the bit vector associated with this item is set to 1 Otherwise the ith bit of the bit vector is set to 0 The bit vector associated with item z is denoted as BV The number of 1\222s in SV is equal to the number of transactions which support the item 2 that is the support for the item z Property 1 The support for the itemset il,i2  ik is SKI 0 BV 0  0 BKk where 224d\222 is the inner product of two vectors Lemma 1 If an item ij 1 5 j 5 k is not a large item then the itemset i~,...,i~,...,i cannot be alarge itemset Rationale Because item ij is not a large item, the number of 1\222s in the bit vector BV is less than the minimum support Hence SKI  BV 0  e SV must be less than the minimum support The sup port for the itemset i~,...,ij,...,i is also less than the minimum support according to the Property 1 So the itemset i~,...,ij,...,i is not a large itemset For the Type I request if there is an interested item which is not a large item then there is no answer to the request because any itemset which contains the interested item cannot be a large itemset according to Lemma 1 Otherwise i.e all the interested items are large items the inner products are performed on the bit vectors associated with all the interested items If the result is no less than the user-specified minimum support then the set of the interested items is an in teresting large itemset Hence, for the Type I request the interesting large itemset can be generated after the first phase 10 11 12 13 14 Itemset 1 CEAGB BDAECG ABCEG ECGA GEACD BDFCH DFB CE Table 1 Database TDB Consider the example transaction database TDB shown in Table 1 Each record is a TID Itemset pair where TID is the identifier of the corresponding transaction and Itemset records the items purchased in the transaction For example if a user wants to know if the rule whose antecedent contains only items A and C and consequent contains only item E is an association rule whose support and confidence achieve 20 and SO respectively then the request is described as follows Request 1 Mining Association Rules From TDB With Antecedent A C Consequent E Support 20 Confidence 80 This request belongs to the Type I request and the interested items are A C and E Because the minimum support is 20 i.e 3 transactions the interested items A C and E are all large items and the associated bit vectors BVA BVc and BVE are 111111110000000\\(11111000111 1001 and 111111100000000 respectively After performing in ner products on BVA BVc and BVE the support for the itemset A C E is 5 2 3 Hence the itemset A C E is an interesting large itemset 3.2 Association Graph Construction After building the bit vector for each interested item the database need not be scanned again for the algorithm EDM For the Type I1 and Type I11 re quests EDM needs to construct an association graph for the interesting large itemset generation Before constructing the association graph each large item is assigned a unique integer number Sup pose item i represents the item whose item number is i and the bit vector associated with item i is denoted as SV In the association graph construction phase for every two large items i and j i  j  if SV BV is no less than the user-specified minimum support a directed edge from item i to item j is created Also itemset i,j is a large 2-itemset Note that an ordered list notation is used to indicate the order of the items in an itemset for the following discussion Since the two itemsets i,j and j,i are the same we consider only one direction to avoid computing the supports for the same itemsets For example if we like to extract the association rules whose antecedent and consequent contain item C and item E respectively and support and confidence achieve 20 and SO respectively then the request can be written as Request 2 Request 2 Mining Association Rules From TDB With Antecedent C  Consequent E  Support 20 Confidence 80 For Request 2 the interested items are all items in the database After the first phase the large items i.e items A B C D, E F and G are found and the bit vectors associated with the large items are built The item numbers for the items A B C D, E F and G are 1 2 3 4 5 6 and 7 respectively The association graph for Request 2 is shown in Figure 1 666 


Figure 1 The association graph for Request 2 and Request 3 3.3 Interesting large itemset generation In the third phase the algorithm EDM generates all interesting large itemsets according to the user\222s request In this phase we develop two algorithms LGTE Large itemset Generation by Tree Expansion and LGDE large itemset Generation by Direct Ex tension to process the Type I1 and Type I11 requests respectively 3.3.1 interesting large itemset generation for Type I1 requests For Type I1 requests in addition to the items specified in  Items Is other items can also be contained in the antecedent and the consequent of each rule to be discovered The Algorithm LGTE is applied to gen erate interesting large itemsets for Type I1 requests LGTE constructs an expunszon tree based on the as sociation graph Each node in the expansion tree con tains an large itemset During the expansion tree con struction LGTE expands each node which contains a large k-itemset k _ 1 to generate its child nodes which contain large k  1-itemsets First LGTE checks if the set of the items specified in  Items Is is a large itemset If this itemset is a large itemset then the itemset is designated the root node of the expansion tree, and the item numbers of the items in the root node is in the increasing order Subsequently LGTE marks 224*\224 between every two items before the first item and after the last item in the root node For example consider Request 2 which is a Type I1 request The itemset specified in Request 2 is 3 5 which is a large itemset since BGoB is5 2 3 After marking\224*\224 in the itemset the root node of the expansion tree becomes 3*5 After creating the root node of the expansion tree the itemset in the root node will be extended to gener ate extended itemsets We have the following Lemmas to check if an itemset in a node can be extended Lemma 2 If an itemset is not a large itemset, then any itemset which contains the items in this itemset cannot be a large itemset Rationale Because the itemset is not a large itemset the support for the itemset is less than the minimum support Hence the support for an itemset which con tains the items in this itemset must be also less than the minimum support Lemma 3 For a large itemset il i2  io if there is no directed edge from any item ih ik-1  ih when k  1 to item ik 1 5 k 5 n then item set ill  ik-1 ih ik    in or ih  il i2    in when k  1 cannot be a large itemset Rationale Because there is no directed edge from any item ih ik-1  ih when k  1 to item ik the itemset ih,ik or ih il when k  1 is not a large 2-itemset  Hence by Lemma 2 item set ill  ik-1 I lk  in or ih ill i2  in when k  1 is not a large itemset Lemma 4 For a large itemset ill ia  in if there is no directed edge from item ik 1 5 k 5 n to any item ip ip  ik+l when k  n then item set ill  zk zp 2k+1  in or ill i2  io ip when k  n cannot be a large itemset Rationale Because there is no directed edge from item ik to any item i ip  ik+l when k  n itemset ik ip is not a large 2-itemset Hence item set il  ik ip ik+1  in or ill i2  in ip when k  n is not a large itemset according to Lemma 2 If there is an n-itemset in a node with a 224*I\222 marked then this n-itemset can be extended into n  1-itemset from the position of the mark 224*\224 except one of the cases stated in Lemma 3 and Lemma 4 holds Hence for each 224*\224 marked in a node LGTE checks if the itemset I=\(il i2  in in the node can be extended Suppose node N which contains itemset I is a root node and is marked as il*i2*...*in In the following we describe how to construct an expansion tree If the position of the mark 224*\224 is before the first item il of the itemset I in node NI then LGTE checks if there are directed edges from some items to the item il in the association graph If there is no directed edge from any item ih to the item ill then the itemset cannot be extended for this mark 224*\224  because for any item ih itemset ih ill i2  in is not a large itemset according to Lemma3 The mark 224*\224 is then removed from node N Hence node N becomes il*i2  in If there is a directed edge from an item i to the item il then the itemset I is extended into the itemset i il i2  in because this extended itemset can be a large itemset If the extended itemset is a large itemset the node ieil*i2*...*in is created, and this node becomes a child node of node N If the position of the mark 224*\224 is between items ik and ik+1 of the itemset I in node NI then LGTE checks if there are directed edges from the item ik to the other items whose item nu ik+l If there is no directed edge from the item ik to the other item i ip  ik+l then the itemset can not be extended for this mark 224*\224 because for any item i itemset il  ik i ik+1  in is not a large itemset according to Lemma 4 The mark 224*\224 be tween items ik and ik+l is then removed from node N and its child nodes created so far and node N be comes il*...*ikik+l*...*in However if there is a di rected edge from item ik to an item i i  ik+l and item i to item ik+l then the itemset I is ex tended into the itemset ill  ik i ik+l  in be cause this extended itemset can be a large itemset If the extended itemset is a large itemset, then the node il*...*i~i,*ik+l*...*in is created, and this node also becomes a child node of node N  667 


If the position of the mark 224*\224 is after the last item in of the itemset 1 in node N then LGTE checks if there are directed edges from item in to the other items in the association graph If there is no directed edge from item in to the other item i then the itemset cannot be extended for this mark 224*\224 because for any item i itemset il  in i is not a large itemset according to Lemma4 The mark 224*\224 is then removed from node N and its child nodes created so far and node N becomes il*i2*...*in However if there is a directed edge from item in to an item it then the itemset I is extended into the itemset il  in it because this extended itemset can be a large itemset If the extended itemset is a large itemset, the node il*i2*...*init is created and this node becomes a child node of node N For each created node if there exist 224*\224\222s in the node LGTE expands all children of this node for each mark 224*\224 and removes the mark 224*\224 from the node af ter the expansion For a node if all extended itemsets for a mark 224*\224 are not large itemsets, then the mark 224*\224 is removed from the node and its child node cre ated so far After constructing the expansion tree the itemset in each node is an interesting large itemset Finally LGTE generates all interesting large itemsets from each node of the expansion tree The algorithm LGTE is described as follows For example consider Request 2 First LGTE creates the root node 3*5 For the first mark 224*\224 in the node because there exist directed edges from items 1 and 2 to item 3 in the association graph shown in Figure 1 the extended itemsets are 1 3 5 and 2 3 5 Because the itemsets 1 3 5 and 2 3 5 both are large itemsets 13*5 and 23*5 are created as child nodes of the original node 3*5 After expand ing all child nodes for this mark 224*\224 the original node 3*5 becomes 3*5 For the mark 224*\224 between item 3 and item 5 in the root node there is only one directed edge from item 3 to item 4 whose item number is less than item 5 However there is no directed edge from item 4 to item 5 Hence the itemset 3 5 in the root node cannot item 3 and item 5 is removed from the root node and its child nodes created so far Hence the root node becomes 35 and the two child nodes become 223135\224 and 235*, respectively For the mark 224*\224 after the item 5 in th root node there is only one directed edge from item 5 to item 7 in Figure 1 and the extended itemset 3 5 7 is a large itemset Hence the node 357 is created as a child node of the root node After the expansion this mark 224*\224 is removed from the root node and the root node becomes 35 Similarly LGTE continues to expand all created child nodes The expansion tree for Request 2 is shown in Figure 2 Finally LGTE generates all interesting large item sets from each node of the expansion tree in Figure 2 Because there are eight nodes in the expansion tree there are eight interesting large itemsets generated be extended for this mark 224 2 224  The mark 224*\224 between I357 1235 z357 12357 Figure 2 The expansion tree for Request 2 3.3.2 interesting large itemset generation for Type I11 requests For Type I11 requests there are no keywords An tecedent and Consequent specified in the users\222 re quests Hence all association rules achieve the user specified criteria will be discovered For example if we like to extract all association rules whose support and confidence achieve 20 and SO respectively then the request is written as Request 3 Request 3 Mining Association Rules From TDB With Support 20 Confidence 80 The LGDE algorithm is proposed to generate all interesting large itemsets for Type I11 requests Sup pose the set of large k-itemsets is Lk k  1 The 2-itemsets Lz is found in the association graph con struction phase In the interesting large itemset gen eration phase the LGDE algorithm generates large k-itemsets LI k  2 For each large k-itemset in Lk k 2 2 the last item of the k-itemset is used to extend the itemset into k  1-itemsets Suppose il i  ik is a large k-itemset If there is a directed edge from item ik to item U in the association graph then the itemset il iz  ik is extended into k+l-itemset il,i2  ik because this extended itemset can be a large itemset The extended itemset il,i2  ik is a large k  1-itemset if BE 0 L?x2 0  0 SE 0 SV is no less than the user-specified minimum support If no large k-itemsets can be generated the LGDE algorithm terminates For example consider Request 3 In the associa tion graph construction phase 15 large 2-itemsets are generated and the association graph is shown in Fig ure 1 For large 2-itemset 1 a there are five directed edges from item 2 of the itemset 1 2 to items 3 4 5 6 and 7 respectively Hence the 2-itemset 1 2 can be extended into 3-itemsets 1 2 3 1 2 4 1 2 5 1 2 6 and 1 2 7 Because SV 0 BVz BVq and BV1 0 BV2 0 BVc are 1 and 0 which are less than the user-specified minimum support i.e 3 the 3 itemsets 1 2 4 and 1 2 6 are not large itemsets The other 3-itemsets 1 2 3 1 2 5 and 1 2 7 are large 3-itemsets The LGDE algorithm terminates when no large 6-itemsets can be further generated 668 


3.4 Association rule generation After discovering all interesting large itemsets EDM generates interesting association rules according to the interesting large itemsets the items specified after the keywords Antecedent and Consequent and the minimum confidence specified by the keyword Confidence in the user's request If the keywords Antecedent and Consequent are not specified in the user's request i.e it is a Type I11 request then for any interesting large itemset AP all rules that reference items in the interesting large itemset can be generated The antecedent of each of these rules is a proper subset SAP of AP and the consequent is AP SAP For each SAP AP  SAP EDM checks if the confidence achieves the user-specified minimum confidence If the confidence achieves the minimum confidence then the rule SAP I AP  SAP is an interesting association rule If both keywords Antecedent and Consequent are specified in the user's request and there are no notation s specified in the user's request i.e it is a Type I request then EDM checks if the rule whose antecedent and consequent contain only the items specified after the keywords Antecedent and Consequent  respectively is an interesting associa tion rule If there is only one of the keywords An tecedent and Consequent specified or there is a no tation s specified in the user's request i.e it is a Type I1 request then EDM generates rules whose an tecedents consequents need to match the items spec ified after the keywords Antecedent Consequent For example consider Request 2 For the interest ing large itemset A C E two combinations of the antecedent and consequent match the items specified in Request 2 AC E and C AE The confi less than the minimum confidence 80 Hence C  AE is not an interesting association rule However the confidence for AC j E is s~~~~:~~f":~f~~$l  1 which is greater than 80 Hence AC E is gen erated which is an interesting association rule dence for C 3 AE is supportfor{A,C~E  S which is supportfor C 10 4 Performance Analysis In this section we analyze the performance for the efficient data mining algorithm EDM The effi cient data mining technique is implemented in Sun SPARC 10 workst at ion In the large item generation phase, EDM scans the database to find large items from the interested items and build the bit vector for each generated large item The cost for the first phase is one database scan For the Type I request suppose there are k items speci fied in the With clause After the first phase EDM performs k  1 inner products on the bit vectors For the Type I1 and Type I11 requests EDM gen erates interesting large itemsets through the following two phases For the graph construction phase, suppose there are 1 large items generated in the first phase EDM performs inner products on bit vectors to construct association graph For the interesting large itemset generation phase EDM develops two algorithms LGTE and LGDE to process the Type I1 request and the Type I11 request respectively In the kth k  2 iteration LGDE extends each large k  l-itemset into k-itemsets ac cording to the association graph Suppose the average out-degree of each node is q in the association graph LGDE performs k  1 x ILk-11 x q inner products to find all large k-itemsets which has been demon strated to have a better performance 5 than the other approaches For LGTE algorithm suppose there are n nodes in the constructed expansion tree and on the average there are m extended itemsets on each node and the length of each extended itemset is k LGTE algorithm performs n x m x k  1 inner products to construct expansion tree Hence EDM is an efficient algorithm for generating association rules according to the user's request 5 Conclusion and Future Work We introduce a data mining language From the data mining language users can specify the items in the antecedent and the consequent and the two cri teria minimum support and minimum confidence of the association rules to be discovered We propose an efficient data mining algorithm EDM to process a user's request The algorithm EDM needs only one database scan and some inner products to generate all interesting association rules according to the user's request which is very efficient In the future we shall extend the data mining lan guage to allow more flexible query specifications and develop an interactive data mining technique to dis cover other kinds of association rules according to the user's request such as generalized association rules and multiple-level association rules References R Agrawal and et al Mining Association Rules Between Sets o\200 Items in Large Databases In Proceedzngs of the ACM SIGMOD pages 207 216 1993 R Agrawal and R Srikant Fast Algorithm for Mining Association Rules In Proceedzngs of the Internataonal Conference on Very Large Data Bases pages 487-499 1994 R Meo G Psaila, and S Ceri A New SQL-like Operator for Mining Association Rules In Pro ceedzngs of the Internatzonal Conference on Very Large Data Bases pages 122-133 1996 J.S Park M.S Chen and P.S Yu An Ef fective Hash-Based Algorithm for Mining Asso ciation Rules Proceedangs of ACM SIGMOD 24\(2 1995 S.J Yen and A.L.P. Chen An Efficient Approach to Discovery Knowledge from Large Databases In Proceedzngs of the Internatzonal Conference on Parallel and Dzstrzbuted Inforniatzon Systems pages 8-18 1996 669 


The disco v ery of rules of arbitrary cardinalit y proceeds as follo ws giv en the set of rules m 002 n  where m is the cardinalit y of the b o dy and n is the cardinalit y of the head the algorithm computes the set of rules  m 1 002 n and the set of rules m 002  n  1 from whic h rules with insu\016cien t supp ort are pruned This pro cess determines a lattice at the top w e 014nd the set of elemen tary rules giv en a rule set m 002 n  the left c hild con tains rules  m 1 002 n  while the righ tc hild con tains rules m 002  n  1 The pro cess of rule disco v ery starts b y considering all the rules in the set at the top of the lattice then it generates rules for the rule sets in the subsequen t la y er and so on un til a la y er with empt y rule sets is pro duced Observ e that rule sets m 002 n  with m and n b oth greater than 1 can b e obtained in t w o alternativ ew a ys b oth from the rule set  m 000 1 002 n  and from the rule set m 002  n 000 1 The e\016ciency of the algorithm is maximi zed if at eac h step w e start from the set with lo w er cardinalit y  A detailed description of the algorithm is outside the scop e of this pap er and can b e found in 5 Observ e that the generation of elemen tary rules is p erformed b y the prepro cessor in SQL in presence of mining condition b ecause it in v olv es the ev aluation of a SQL predicate In this case elemen tary rules are retriev ed b y the core op erator from table InputRules  In the other cases the core op erator itself p erforms the precomputation of elemen tary rules whic h conceptually requires the building of the cartesian pro duct of the source tuples b elonging to the same group The resulting elemen tary rules are asso ciated with the iden ti\014er of the groups and p ossibly the clusters from whic h they are extracted the cluster condition selects o v er this cartesian pro duct only certain cluster pairs rep orted in table ClusterCouples  The cartesian pro duct is not materialized it is describ ed b y p oin ters b et w een source tuples F or this reason this computation is part of the core op erator instead of b eing done in SQL 4.4 The P ostpro cessor The last comp onen t of the arc hitecture pro duces the output rules Conceptually  the core op erator produces rules as asso ciations b et w een t w o itemsets the 014rst one for the b o dy  the second one for the head where eac h itemset is a set of item iden ti\014ers Th us the output of the MINE RULE op erator should include attributes built b y the set t yp e constructor ho w ev er this feature is not standardized and not y et a v ailable on most relational systems In order to a v oid an y p ortabilit y problem and to ac hiev e algorithm indep endence also from the viewp oin t of the pro duced outputs the core operator generates a normalized form based on the use of three tables In the 014rst one eac h tuple corresp onds to a rule and has sc hema BodyId HeadId SUPPORT CONFIDENCE  attributes BodyId and HeadId are iden ti\014ers of enco ded b o dies and heads returned b y the core op erator in t w o auxiliary tables OutputBodies with sc hema BodyId Bid  and OutputHeads with sc hema HeadId Hid  resp ectiv ely  Eac h item in these tables is referred to b y means of its iden ti\014er Th us while table output table name is already in the user format tables OutputBodies and OutputHeads m ust b e translated b y the p ostpro cessor in to the corresp onding user readable output table name Bodies and output table name Heads b y means of the temp orary tables Bset and Hset to o when H is true 5 Conclusions The in tegration of mining of asso ciation rules with relational pro cessing is a step to w ards the dev elopmen t of tigh tly in tegrated en vironmen ts for on-line analytical pro cessing W e b eliev e that the curren t div ersit yof data mining pro ducts represen ts just the initial step in the natural ev olution of this mark et sector and that so oner or later standardization will b ecome a m ust also for data mining pro ducts Then in tegration with the SQL language and pro cessing will b e t w ok ey success factors The main con tribution of this pap er is to iden tify an arc hitecture for the seamless in tegration of the data mining pro cess with a SQL serv er W e sho w that the in tegration is feasible pro vided that the core pro cessing of data mining is p erformed e\016cien tly b y sp ecialized algorithms W e prop ose a b orderline b et w een relational and data mining pro cessing and w e demonstrate that with this c hoice of b orderline the translation pro cess for an arbitrary data mining op eration can b e done in a rather easy and e\016cien tw a y  References  R Agra w al T Imielinski and A Sw ami Mining asso ciation rules b et w een sets of items in large databases In Pr o c.A CM SIGMOD Confer enc e on Management of Data  pages 207{216 W ashington D.C Ma y 1993 British Colum bia  R Agra w al and K Shim Dev eloping tigh tlycoupled data mining applications on a relational database system KDD-96  pages 287{290 1996  R Agra w al and R Srik an t F ast algorithms for mining asso ciation rules in large databases In Pr o c e e dings of the 20th VLDB Confer enc e  Santiago Chile Septem b er 1994  E Baralis S Ceri R Meo G Psaila M Ric heldi and P  Risimini Amore An in tegrated en vironmen t for database mining In Pr oc e e dings of SEBD 97 Sistemi Evoluti p er Basi di Dati V erona Italy  June 1997  E Baralis R Meo G Psaila and M Ric heldi Researc h rep ort n um ber 5 Pr oje ct 101196 CSEL T Polite cnic odiT orino  June 1997  J Han et al Dbminer A system for mining kno wledge in large relational databases KDD96  pages 250{255 1996  H.T oiv onen Sampling large databases for association rules In Pr o c e e dings of the 22nd VLDB Confer enc e  Bom ba y Mum bai India 1996 


 T Imielinski A Virmani and A Ab doulghani Datamine Application programmi ng in terface and query language for database mining KDD96  pages 256{260 1996  Silicon Graphics Incorp orated Mineset http:www.sgi.c om/Pr o ducts/softwar e/MineSet   R Meo Un Linguaggio e Nuove Soluzioni p er il Data Mining  Ph.D Thesis in Italian 1997  R Meo G Psaila and S Ceri A new sql-lik e op erator for mining asso ciation rules In Pr o c e e dings of the 22st VLDB Confer enc e  Bom ba y  India Septem b er 1996  J S P ark M Shen and P S.Y u An e\013ectiv e hash based algorithm for mining asso ciation rules In Pr o c e e dings of the A CM-SIGMOD International Confer enc e on the Management of Data  San Jose California Ma y 1995  A Sa v asere E Omiecinski and S Na v athe An e\016cien t algorithm for mining asso ciation rules in large databases In Pr o c e e dings of the 21st VLDB Confer enc e  Zuric h Swizerland 1995 App endix A SQL Queries As in tro duced in Section 4.1 w e rep ort the SQL programs p erforming the prepro cessing for the case of simple asso ciation rules W e refer to Figure 4 In the follo wing giv en a b o olean condition C  the notation  expr ession  C indicates an expression that is actually presen t in the 014nal query if condition C is true w e use as conditions the same b o olean v ariables whic h describ e the presence of sev en syn tactic comp onen ts in a MINE RULE op eration as de\014ned in Section 4.1 AR stands for Asso ciation Rules Query Q 0  Basic tables listed in the from list are join t p ossibly using the source cond ifspeci\014ed denoted b y the b o olean condition W  it produces table Source  i.e the table on whic hAR extraction is p erformed needed attr list indicates the set of attributes that are actually useful in AR extraction obtained as the union of the attribute lists body schema  head schema  group attr list  cluster attr list and mine attr list attributes refered to b y the mining cond  plus the attributes p ossibly referred b y aggregate functions in group cond and cluster cond  INSERT INTO Source SELECT needed attr list FROM from list  WHERE source cond  W  Query Q 1  It calculates the n um b er of groups in the Source  The result is stored in to v ariable totg  SELECT COUNT INTO totg FROM SELECT DISTINCT group attr list FROM Source Query Q 2  First The Source is partitioned in to groups on attributes in group attr list  applying the group cond if presen t b o olean condition G  the view ValidGroupsView is pro duced CREATE VIEW ValidGroups Vi ew AS SELECT group attr list FROM Source GROUP BY group attr list  HAVING group cond  G  Second the table ValidGroups is generated An identi\014er called Gid  is asso ciated for eac hv alid group and is the n umerical iden ti\014er for groups In Oracle n umerical iden ti\014ers are obtained b y sequences that are de\014ned b y the follo wing instruction CREATE SEQUENCE sequence-name Av alue of the sequence is generated b y a call to the function sequence-name>.NE XTVAL  The iden ti\014er Gid will b e generated in the follo wing instruction b y means of a sequence called Gidsequence  Eac hv alid group tak en from the view ValidGroupsView is inserted with a unique v alue of the sequence in to table ValidGroups  INSERT INTO ValidGroup s SELECT Gidsequen ce NE XTV AL AS Gid V FROM ValidGrou psV ie wAS V This kind of generation of iden ti\014ers applies also to queries Q 3  Q 4 and Q 5 F or brevit yw e simply indicate this op eration with sequence-name>.NEX TVAL  omitting the rest of details Query Q 3  The enco ding of items is p erformed b y query Q 3  A t 014rst the temp orary table DistinctGroupsInB ody is generated b y the follo wing query  This table represen ts for eac h b o dy elemen t the distinct v alid groups con taining it INSERT INTO DistinctGr oup sI nBo dy SELECT DISTINCT body schema gro up attr list FROM Source Then the follo wing query generates the Bset table con taining for eac h elemen t an attribute for the identi\014er  Bid  the attributes in the body schema and the n um ber of v alid groups that con tain the elemen t this n um b er is later used to compute con\014dence of elemen tary rules if the general core pro cessing algorithm is adopted in particular only elemen ts whic h app ear in a su\016cien tn um b er of groups are selected b y the HAVING clause INSERT INTO Bset SELECT Bidsequen ce NE XTV AL AS Bid,<body schema FROM DistinctGr ou psI nBo dy GROUP BY body schema HAVING COUNT  mingroups  Query Q 4  Finally  the CodedSource table is produced b y means of a join b et w een tables Source  ValidGroups and the Bset  INSERT INTO CodedSourc e SELECT DISTINCT V.Gid B.Bid FROM Source S ValidGrou ps AS V Bset B WHERE S.<group attr list  V.<group attr list AND S.<body schema  B.<body schema T o conclude the p ostpro cessing query for b o dies are rep orted for simple asso ciation rules INSERT INTO output table name>_Bod ies SELECT BodyId body schema FROM OutputBodie s Bset WHERE OutputBodi es Bi d  Bset.Bid 





BAT841 CAR881 I COD701 COD721 COL891 871 LAM89 J LEC88 MAC851 W861 Alashqur A.M Su S.Y.W and Lam H A Rule-based Language for Deductive Object Oriented Databases Proceedings of the 6th Inter national Conference on Data Engineering Los Angeles CA Feb 5-9 1990 Bancilhon F et al FAD a Powerful and Si ple Database Language Proceedings of the 13th VLDB Conference Brighton 1987 Banerjee J et al Queries in 8ject-oriented Databases Proceedings of the 4th Intl Confer ence on Data Encrineerine Los Angeles CA  97-105 I I  1988 pp 31-38 Batory D.S and Buchmann A.P Molecular Obiects Abstract Abstract Data Tvws and Data M6deIsi A Framework Proceedings Intl Confer ence on VLDB 1984, pp 172-184 Carey M J et al A Data Model and Query Language for EXODUS ACM-SIGMOD Confer ence 1988, pp. 413-423 Chuang H S Operational Role Processing in a Prototype OSAM KBMS Master's thesis University of Florida 1990 Codd E A Relational Model of Data for Large Shared Data Bank CACM Vol 13 No 6 1970 pp 377-387 Codd E R:lational Completeness of Database Sublanguages in Data Base Systems Rustin R ed Prentice-Hall Inc Englewook Cliffs NJ Colby L S A Recursive Algebra and Query Optimization for Nested Relations ACM SIGMOD Conference 1989 pp 273-283 Fishman D H et al Iris An Object-Oriented Database Management System ACM Transaction on Office Infomation Systems 51 1987 pp49 69 Goldberg A Introducing the Smalltalk-80 Sys tem Byte Aug 1981. pp.14-26 Hammer M and Mcleod D Database Descrip tion with SDM A Semantic Association Model Kim W et al Composite Object Support in an Object-oriented Database System Proceedings of King R Sembase A Semantic DBMS the Proceedings of the First Intemational Workshop on Expert Database Systems Oct 1984, pp.151 171 Lam H et al Prototype Implementation of an Object-oriented Knowledge Base Management System Proceedings of PROCIEM 89 Orlando Lecluse C Richard P and Velez F 02 an Object-Oriented Data Model ACM-SIGMOD Conference 1988, pp 425-433 MacGregor R ARTEL--A Semantic Front-End to Relational DBMSs Proceedings of VLDB 85 Atlanta GA April 1988 Maier D et al Development of an Object oriented DBMS Proc of OOPSLA 86 Confer ence Sept 29  Oct 2 Portland Oregon pp 472-482 1971 pp.65-98 ACM TODS Vol 6 NO 3 1981 pp 351-368 OOPSLA, Oct 4-8 1987 FL pp 118-125 FL NOV 13-15, 1989 SU86 SUSS SU89 ZD087 Manola F and Dayal U PDM An Object Oriented Model Int'l Workshop On Object Oriented Database Systems 1986, pp 18-25 Pant S An Intelligent Schema Design Tool for OsAM Master's thesis University of Florida 1990 Rowe L A and Stonebraker M R The POSTGRES Data Model Proceedings of the 13th VLDB Conference Brighton 1987 pp 83-96 Shaw G M and ZdoNc S B A Query Alge bra for Object-Oriented Databases IEEE Trans on Data Engineering 12\(3 pp 154-162 Feb 1990 Shipan D The Functional Data Model and the Data Language DAPLAX ACM Trans Database System ql March 1918 Singh M Transaction Oriented Rule Processing in an Object-Oriented Knowledge Base Manage ment System Master's thesis University of Florida 1990 Su S.Y.W Modeling Integrated Manufacturing Data With SAM IEEE Computer January Su S.Y.W et al An Object-oriented Comput ing Environment for Productivity Jmprovement in Automated Design and Manufacturing Project Summary PROCIEM 88,Orlandq E Nov 14-15 1988 Su S.Y.W Kxishnamurthy V and Lam H An Object-oriented Semantic Association Model OsAM AI in Industrial Engineering and Manufacturing Theoretical Issues and Applica tions Kumara S Soyster A.L and Kashyap R.L eds American Institute of Industrial Engineering 1989 Su S.Y.W Guo M and Lam H Association Algebra A Mathematical Foundation for Object Oriented Databases to be submitted to Trans on Knowledge and Data Engineering Tsurt S and Zaniolo C An Implementation of GEM  Supporting a Semantic Data Model on a Relational Back End Proceedings of the ACM SIGMOD Jntl Conference on the Management of Data 1984 pp 286-295 Frederick Ty The Design and Implementation of a Graphics Interface for an Object-oriented Language Master's thesis University of Florida 1988 Zaniolo C The Database language GEM Proceedings of the ACM SIGMOD Intl Confer ence on the Management of Data 1983 Zdonik S B Skarra A H and Reiss S P An Object Server for an Object-oriented Database System Intemational Workshop on Object oriented Database Systems Pacific Grove CA Sept 1986 Zdonik S.B The implementation of a Shared Clustered Memory System for an 0-0 Database System ACM Trans on Office Information Sys tems Apr 1987 1986 pp.34-49 32 I 


It can also be added to cell CrossSales.3\(PC, printer one_year,\205 5  Distributed and Incremental Rule Mining There exist two ways to deal with association rules 267  Static that is, to extract a group of rules from a snapshot, or a history, of data and use "as is 267  Dynamic that is, to evolve rules from time to time using newly available data We mine association rules from an e-commerce data warehouse holding transaction data. The data flows in continuously and is processed daily Mining association rules dynamically has the following benefits 267  223Real-time\224 data mining, that is, the rules are drawn from the latest transactions for reflecting the current commercial trends 267  Multilevel knowledge abstraction, which requires summarizing multiple partial results. For example association rules on the month or year basis cannot be concluded from daily mining results. In fact multilevel mining is incremental in nature 267  For scalability, incremental and distributed mining has become a practical choice Figure 3: Distributed rule mining Incremental association rule mining requires combining partial results. It is easy to see that the confidence and support of multiple rules may not be combined directly. This is why we treat them as \223views\224 and only maintain the association cube, the population cube and the base cube that can be updated from each new copy of volume cube. Below, we discuss several cases to show how a GDOS can mine association rules by incorporating the partial results computed at LDOSs 267  The first case is to sum up volume-cubes generated at multiple LDOSs. Let C v,i be the volume-cube generated at LDOS i The volume-cube generated at the GDOS by combining the volume-cubes fed from these LDOSs is 345   n i i v v C C 1  The association rules are then generated at the GDOS from the centralized C v  214  The second case is to mine local rules with distinct bases at participating LDOSs, resulting in a local association cube C a,I a local population cube C p,I  and a local base cube C b,i at each LDOS. At the GDOS, multiple association cubes, population cubes and base cubes sent from the LDOSs are simply combined, resulting in a summarized association cube and a summarized population cube, as 345   n i i a a C C 1   345   n i i p p C C 1  and 345   n i i b b C C 1  The corresponding confidence cube and support cube can then be derived as described earlier. Cross-sale association rules generated from distinct customers belong to this case In general, it is inappropriate to directly combine association cubes that cover areas a 1 205, a k to cover a larger area a In the given example, this is because association cubes record counts of customers that satisfy   customer product merchant time area Doe TV Dept Store 98Q1 California Doe VCR Dept Store 98Q1 California customer product merchant time area Doe VCR Sears 5-Feb-98 San Francisco Joe PC OfficeMax 7-Feb-98 San Francisco customer product merchant time area Doe TV Fry's 3-Jan-98 San Jose Smith Radio Kmart 14-Jan-98 San Jose Association   population      base          confidence      support cube               cube                cube         cube                cube LDOS LDOS GDOS 


the association condition, and the sets of customers contained in a 1 205, a k are not mutually disjoint. This can be seen in the following examples 214  A customer who bought A and B in both San Jose and San Francisco which are covered by different LDOSs , contributes a count to the rule covering each city, but has only one count, not two, for the rule A  336  B covering California 214  A customer \(e.g. Doe in Figure 3\who bought a TV in San Jose, but a VCR in San Francisco, is not countable for the cross-sale association rule TV  336 VCR covering any of these cities, but countable for the rule covering California. This is illustrated in Figure 3 6  Conclusions In order to scale-up association rule mining in ecommerce, we have developed a distributed and cooperative data-warehouse/OLAP infrastructure. This infrastructure allows us to generate association rules with enhanced expressive power, by combining information of discrete commercial activities from different geographic areas, different merchants and over different time periods. In this paper we have introduced scoped association rules  association rules with conjoint items and functional association rules as useful extensions to association rules The proposed infrastructure has been designed and prototyped at HP Labs to support business intelligence applications in e-commerce. Our preliminary results validate the scalability and maintainability of this infrastructure, and the power of the enhanced multilevel and multidimensional association rules. In this paper we did not discuss privacy control in customer profiling However, we did address this issue in our design by incorporating support for the P3P protocol [1 i n  ou r data warehouse. We plan to integrate this framework with a commercial e-commerce system References 1  Sameet Agarwal, Rakesh Agrawal, Prasad Deshpande Ashish Gupta, Jeffrey F. Naughton, Raghu Ramakrishnan, Sunita Sarawagi, "On the Computation of Multidimensional Aggregates", 506-521, Proc. VLDB'96 1996 2  Surajit Chaudhuri and Umesh Dayal, \223An Overview of Data Warehousing and OLAP Technology\224, SIGMOD Record Vol \(26\ No \(1\ 1996 3  Qiming Chen, Umesh Dayal, Meichun Hsu 223 OLAPbased Scalable Profiling of Customer Behavior\224, Proc. Of 1 st International Conference on Data Warehousing and Knowledge Discovery \(DAWAK99\, 1999, Italy 4  Hector Garcia-Molina, Wilburt Labio, Jun Yang Expiring Data in a Warehouse", Proc. VLDB'98, 1998 5  J. Han, S. Chee, and J. Y. Chiang, "Issues for On-Line Analytical Mining of Data Warehouses", SIGMOD'98 Workshop on Research Issues on Data Mining and Knowledge Discovery \(DMKD'98\ , USA, 1998 6  J. Han, "OLAP Mining: An Integration of OLAP with Data Mining", Proc. IFIP Conference on Data Semantics DS-7\, Switzerland, 1997 7  Raymond T. Ng, Laks V.S. Lakshmanan, Jiawei Han Alex Pang, "Exploratory Mining and Pruning Optimizations of Constrained Associations Rules", Proc ACM-SIGMOD'98, 1998 8  Torben Bach Pedersen, Christian S. Jensen Multidimensional Data Modeling for Complex Data Proc. ICDE'99, 1999 9  Sunita Sarawagi, Shiby Thomas, Rakesh Agrawal Integrating Association Rule Mining with Relational Database Systems: Alternatives and Implications", Proc ACM-SIGMOD'98, 1998   Hannu Toivonen, "Sampling Large Databases for Association Rules", 134-145, Proc. VLDB'96, 1996   Dick Tsur, Jeffrey D. Ullman, Serge Abiteboul, Chris Clifton, Rajeev Motwani, Svetlozar Nestorov, Arnon Rosenthal, "Query Flocks: A Generalization of Association-Rule Mining" Proc. ACM-SIGMOD'98 1998   P3P Architecture Working Group, \223General Overview of the P3P Architecture\224, P3P-arch-971022 http://www.w3.org/TR/WD-P3P.arch.html 1997 


Plenary Panel Session 30 XML Databases   Moderator: Michael Carey, IBM Almaden Research Center USA Panelists Adam Bosworth, Microsoft Corporation USA David De Witt University of Wisconsin-Madison, USA Alon Levy University of Washington USA Bruce Lindsay IBM Almaden Research Center USA Jennifer Widom Stanford University USA Demo Session 1 Web Query Optimizer  661 V Zadorozhny L Bright L Raschid T Urhan and M Vidal ReQueSS: Relational Querying of Semi-structured Data  664 R Sunderraman The IDEAL Approach to Internet-Based Negotiation for E-Business  666 J Hammer C Huang Y Huang C Pluempitiwiriyawej M Lee H Li L Wang Y Liu and S Su READY A High Performance Event Notification Service  668 R Gruber B Krishnamurthy, and E Panagos A Multimedia Information Server with Mixed Workload Scheduling  670 G Nerjes DISIMA An Object-Oriented Approach to Developing an Image Database System  672 V Oria T Ozsu P Iglinski B Xu and L Cheng Demo Session 2 The Collaboration Management Infrastructure  677 H Schuster D Baker A Cichocki D Georgakopoulos and M Rusinkiewicz Assisting the Integration of Taxonomic Data The LITCHI Toolkit  679 I Sutherland J Robinson S Brandt A Jones S Embury W Gray R White and F Bisby TheaterLoc: Using Information Integration Technology to Rapidly Build Virtual Applications  681 G. Barish Y.4 Chen D Dipasquo, C Knoblock S Minton I Muslea and C Shahabi Lineage Tracing in a Data Warehousing System  683 Y Cui and J Widom xiii 


The Mentor-Lite Prototype A Light-Weight Workflow Management System  685 J Weissenfels M Gillmann 0 Roth, G Shegalov and W Wonner Location Prediction and Queries for Tracking Moving Objects  687 0 Wolfson B Xu and S Chamberlain Semiorder Database for Complex Activity Recognition in Multi-Sensory Environments  689 S Bhonsle A Gupta S Santini and R Jain Tutorial 1 Web Information Retrieval  693 M Henzinger Tutorial 2 Mobile and Wireless Database Access for Pervasive Computing  694 P Chrysanthis and E Pitoura Tutorial 3 Data Mining with Decision Trees  696 J Gehrke Tutorial 4 Directories Managing Data for Networked Applications  697 D Srivastava Tutorial 5 Indexing High-Dimensional Spaces Database Support for Next Decade\222s Applications  698 S Berchtold and D Keim xiv 


 T5.I2.D100K T10.I4.D100K T15.I4.D100K T10.I6.D400K T10.I6.D800K T10.I6.D1600K Optimizations across Databases 5 0 5 10 15 20 25 30 35 40 45 Improvement COMP TREE COMP-TREE 1 2 4 8 1 2 4 8 1 2 4 8 2 4 8 2 4 8 1 2 4 8 Processors Databases Figure 5 Effect of Computation and Hash Tree Balancing good as the COMP optimization The reason that the hash tree balancing is not suf\336cient to offset inherent load imbalance in the candidate generation in this case The most effective approach is to apply both optimizations at the same time COMP-TREE The combined effect is suf\336cient to push the improvements in the 40 range in the multiple-processor case On 1 processor only hash tree balancing is bene\336cial since computation balancing only adds extra cost 5.4 Short-circuited Subset Checking Figure 6 shows the improvement due to the short-circuited subset checking optimization with respect to the unoptimized version The unoptimized version is the Apriori algorithm due to Agrawal et al 5 The results are presented for dif ferent number of processors across dif ferent databases The results indicate that while there is some improvement for databases with small transaction sizes the optimization is most effective when the transaction size is large In this case we get improvements of around 25 r the unoptimized version To gain further insight into this optimization consider 336gure 7 It shows the percentage improvement obtained per iteration on applying this optimization on the T20.I6.D100K database It shows results only for the uni-processor case r similar results were obtained on more processors We observe that as the iteration k increases there is more opportunity for shortcircuiting the subset checking and we get increasing bene\336ts of up to 60 The improvements start to fall off t the high end where the number of candidates becomes small resulting in a small hash tree and less opportunity for short-circuiting It becomes clear that is an extremely effective 15 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 T5.I2.D100K T10.I6.D800K T15.I4.D100K T20.I6.D100K procs across Databases 0 5 10 15 20 25 Improvement 1 2 4 8 Figure 6 Effect of Short-circuited Subset Checking 23456789101112 Iterations 0 10 20 30 40 50 60 improvement T20.I6.D100K Figure 7  Improvement per Iteration  proc   16 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


optimization for larger transaction sizes and in cases where there are large number of candidate k itemsets 6 Conclusions In this paper e presented a parallel implementation of the Apriori algorithm on the SGI Power Challenge shared memory multi-processor We also discussed a set of optimizations which include optimized join and pruning computation balancing for candidate generation hash tree balancing and short-circuited subset checking We then presented experimental results on each of these Improvements of more than 40 were obtained for the computation and hash tree balancing The short-circuiting optimization was found to be extremely effective for databases with large transaction sizes Finally we reported the parallel performance of the algorithm While we d good speed-up we observed a need for parallel I/O techniques for further performance gains References  R Agra wal T  Imielinski and A Swami Database mining A performance perspecti v e  I n IEEE Trans on Knowledge and Data Engg  pages 5\(6 1993  R Agra wal T  Imielinski and A Swami Mining association rules between sets of items in lar ge databases In Proc M SIGMOD Intl Conf Management of Data  May 1993  R Agra wal H Mannila R Srikant H T o i v onen and A I V erkamo F ast disco v ery of association rules In U F et al editor Advances in Knowledge Discovery and Data Mining  MIT Press 1996  R Agra wal and J Shafer  P arallel mining of association rules design implementation and e xperience Technical Report RJ10004 IBM Almaden Research Center San Jose CA 95120 Jan 1996  R Agra wal and R Srikant F ast algorithms for mining association rules In Proc 20th VLDB Conf  Sept 1994  M Cierniak W  Li and M J Zaki Loop scheduling for heterogeneity  I n 4th IEEE Intl Symposium on High-Performance Distributed Computing also as URCS-TR 540 CS Dept Univ f Rochester  Aug 1995  M Holsheimer  M  K ersten H Mannila and H T o i v onen A perspecti v e on databases and data mining In 1st Intl Conf Knowledge Discovery and Data Mining  Aug 1995  M Houtsma and A Swami Set-oriented mining of association rules In RJ 9567  IBM Almaden Oct 1993  H Mannila H T o i v onen and I V erkamo Ef 336cient algorithms for disco v ering association rules In AAAI Wkshp Knowledge Discovery in Databases  July 1994  J S P ark M Chen and P  S Y u  A n e f fecti v e hash based algorithm for mining association rules In Proc M SIGMOD Intl Conf Management of Data  May 1995 17 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 J S P ark M Chen and P  S Y u  E f 336cient parallel data mining for association rules T echnical Report RC20156 IBM T J Watson Research Center Aug 1995  G Piatetsk y-Shapiro Disco v ery  presentation and analysis of strong rules In G P S et al editor  KDD  AAAI Press 1991  A Sa v asere E Omiecinski and S Na v athe An ef 336cient algorithm for mining association rules in large databases In Proc 21st VLDB Conf  1995  M J Zaki M Ogihara S P arthasarathy  and W  Li P arallel data mining for association rules on shared-memory multi-processors Technical Report 618 Department of Computer Science University of Rochester 618 1996 18 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


