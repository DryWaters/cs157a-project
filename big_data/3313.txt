Stream-Close Fast mining of Closed Frequent Itemsets in high speed data streams Ranganath B.N Indian Institute of Science Stochastic systems lab Bangalore India ranga.nitk@gmail.com M Narasimha Murty Indian Institute of Science Stochastic systems lab Bangalore India mnm@csa.iisc.ernet.in Abstract With the emergence of large-volume and high-speed streaming data the recent techniques for stream mining of CFIís Closed frequent itemsets will become inef\036cient When concept drift occurs at a slow rate in high speed data streams the rate of change of information across different sliding windows will be negligible So the user wonít be devoid of change in information if we slide window by multiple transactions at a time Therefore we propose a novel approach for mining CFIís cumulatively by making sliding width  002 1 over high speed data streams However it is nontrivial to mine CFIís cumulatively over stream because such growth may lead to the generation of exponential number of candidates for closure checking In this study we develop an ef\036cient algorithm Stream-Close for mining CFIís over stream by exploring some interesting properties Our performance study reveals that Stream-Close achieves good scalability and has promising results Keywords Data stream CFIís Association rules 1 Introduction Mining CFIís has the same power as mining the complete set of frequent itemsets but it will drastically reduce the number of redundant frequent itemsets to be generated and increase the ef\036ciency and effectivity of mining Recently much research has been done on closed itemsets mining b u t i t i s m ainly f or traditional databases where multiple scans are needed and whenever new transactions arrive mining should be performed from scratch on whole of the updated database instead of mining on new transactions with the help of already mined old CFIís therefore they are not suitable for data stream mining A data stream is an ordered sequence of transactions that arrives in a timely order Unlike traditional static databases data streams pose the following challenges First they are continuous unbounded and comes with high speed Second the volume of data streams is very large Third the data distribution in streams usually changes with time i.e concept drift occurs As data stream model is motivated by emerging application involving huge data sets e.g customer click streams telephone records large sets of web pages and sets of retail chain transactions much research on how to get frequent patterns in a data stream model has been conducted In 5 t he authors p ropose a lgorithms to 036nd frequent itemsets throughout the entire history of data streams In a n algorithm for incremental mining of closed itemsets based on formal concept analysis and Galois lattice is proposed In d if ferent sliding w indo w m odels a re used to 036nd recent frequent itemsets in data streams These algorithms mine frequent itemsets instead of CFIís with one scan over entire data streams In C hi et al propose t he Moment algorithm to mine CFIís over a data stream sliding window In Nan Jiang et al propose C FI-Stream algorithm to mine CFIís over a sliding window by maintaining lexicographical ordered direct update tree The algorithm checks for each and every itemset in newly arrived transaction to check for the closedness property But this generates an explosive number of itemsets to be checked which will be very costly Moreover when volume and incoming rate of data streams are very high the above proposed methods consume signi\036cant time when window width is larger and support threshold is low The number of arrived transactions overshoots the main memory and are to be stored in secondary storage devices making access very expensive and 036nally leading to large increase in user response time when concept drift is not too dramatic the information change across different sliding windows will be negligible Therefore In order to overcome the above problems we can slide the window by multiple transactions at a time In this paper an ef\036cient algorithm called Stream-Close 
2008 IEEE International Conference on Data Mining Workshops 978-0-7695-3503-6/08 $25.00 © 2008 IEEE DOI 10.1109/ICDM.Workshops.2008.53 516 
2008 IEEE International Conference on Data Mining Workshops 978-0-7695-3503-6/08 $25.00 © 2008 IEEE DOI 10.1109/ICDMW.2008.51 516 


is developed to cumulatively mine the CFIís by using the sliding width 002 1  based on pattern-growth approach Several novel ideas are introduced in the algorithm development Speciﬁcally we make the following contributions  Closure checking of itemsets is done directly in the mining process through Look-ahead approach to obtain the closure of itemsets in newly added part of the window  We perform mining process only once on the newly arrived block of transactions  Two optimization techniques maximum itemset matching and Common preﬁx pruning are designed to improve the performance  Dynamic reordering of items is done to assist maximum itemset matching in pruning nonclosed itemsets Maximum itemset matching is used for obtaining new CFI which helps in direct pruning of non closed itemsets Common pre\036x pruning is designed to reduce the number of candidates for closed itemset checking for some itemsets which share a common pre\036x thereby reducing the search space Our performance study shows that Stream-Close is ef\036cient and scalable The rest of this paper is organized as follows Section 2 formally de\036nes the concept of CFIís Lexicographical ordered direct update tree LDIU tree and describes the notations to be used throughout the paper Section 3.1 gives an overview of algorithm Stream-Close Section 3.2 explains the strategies for 036nding new CFIís arising from newly arrived block of transactions Section 3.3 discusses the optimization techniques and ideas used in algorithm development Section 3.4 presents our proposed Stream-Close algorithm The performance evaluation is depicted in Section 4 Finally Section 5 concludes the paper 2 PRELIMINARIES We use following notations in the rest of the paper   denotes equals   denotes an assignment Let I  i 1 i 2   i n  be a set of n elements called items A subset X 003 I is called an itemset A m-subset is called a m-itemset Each transaction t is a set of items in I Given a set of transactions T the support of an itemset X is the percentage of transactions that contain X An itemset X is a closed frequent itemset in T if X is frequent in T and 1 2 3 4 5 6 C, D A, B, C A, C, D A, B A, B, C B, C window #1 window #2 tid items timeline Figure 1 A streaming example there exists no proper super-itemset Y of X such that Y has the same support as X in T The following notations are used throughout the paper and explained w.r.t 036gure 1  W Window consisting of block of transactions W represents transactions with tidís 1-4\(i.e window#1  d Sliding width 002 1 d is equal to 2  d 002 block Newly arrived block of transactions\(of width d when we slide window W by width d d 002 block represents transactions with tidís 5-6 of width d:=2 when we slide window W by width dí:=2  d-block Block of transactions of width d which left W after sliding W by width d d-block represents transactions with tidís 1-2\(of width d:=2 which left W after sliding W by width dí:=2  W/d-block Set of transactions which are in W but not in d-block W/d-block represents transactions with tidís 3-4  W 002  Union of W/d-block and d 002 block W 002 represents transactions with tidís 3-6\(i.e window#2  S Minimum support threshold Next we will discuss lexicographical ordered Direct Update LDIU t used to store f requent closed itemsets in curent sliding window We assume that there is a lexicographical order among the items in I and we use A 004 B to denote that item A is lexicographically smaller than item B Furthermore an itemset can be represented by a sequence wherein items are lexicographically ordered For instance  W X Y  is represented by WXY given W 004 X 004 Y We also use notation 004 to denote lexicographical order between two itemsets For example AB 004 ABC 004 CD We use the above lexicographical order to store closed itemsets in LDIU tree We use a lexicographical ordered DIU t to maintain the current closed itemsets Each node in the LDIU tree represents a closed itemset There are k levels in the LDIU tree each level i stores the closed itemsets of length i where k is the maximum length of the current closed itemsets Each node in the LDIU tree stores a closed itemset its current support and count information 
517 
517 


AB C ABC CD 2 3 1 3 1 2 0 1 Figure 2 LDIU tree for transactions 1-4 in gure 1 and the links to its immediate parent and children nodes The count of an itemset indicates how many transactions in W are same as itemset Figure 2 illustrates the LDIU tree after the 036rst four transactions arrive in 036gure 1 The support of each node is labeled in the upper right corner of the node itself and count of node is labeled in lower right corner of node itself The 036gure shows that currently there are 4 closed itemsets C AB CD and ABC in the LDIU tree and their associated supports are 3 3 1 2 and counts are 0,1,1,2 respectively We will explain how to fetch closure of an itemset from LDIU tree For fetching closure of an itemset we perform depth-\036rst scan from rightmost point of the LDIU tree We declare the 036rst superset of an itemset obtained during scan as the closure of the itemset Suppose there exists a closure of itemset other than 036rst superset then 036rst superset will not be a closed itemset in LDIU tree which is not possible Therefore 036rst superset is the closure of the given itemset Let us consider obtaining the closure for itemset c from LDIU tree as shown in 036gure 2 We do depth\036rst scan from rightmost point of the LDIU tree We obtain c with support equal to 3 as improper superset to be the closure of itemset c Now if there exists a second superset of c with support greater than 3 then c is not a closed itemset in LDIU tree which is impossible Problem Statement-Given a sliding window W a sliding width d 002 1 a minimum support threshold S the set of CFI’s in W when we slide window W by a width d problem is to mine the set of CFI 002 cumulatively in W 002 based on CFI’s in W/d-block and on d 002 block instead of mining on W 002 from scratch 3 Efﬁcient Cumulative Mining of CFI’s In this section we present our proposed Stream-Close algorithm and optimization techniques to prune the number of candidate itemsets for closure checking with the help of an in-memory data structure called lexicographical ordered Direct Update LDIU tree to perform the closure checking online over a data stream sliding window We 036rst give an overview of Stream-Close Then we discuss the conditions that we need to check for closed itemsets and how we check for them when performing addition and deletion operations Based on this we develop an online algorithm to discover and incrementally update closed itemsets 3.1 Algorithm overview When a block of consecutive transactions arrives to or leaves the current data stream sliding window the algorithm checks each itemset in the block of transactions on the 037y and updates the associated closed itemsetís supports Current closed itemsets are maintained and updated in real time in the LDIU tree The CFIís can be output at any time at userís speci\036ed thresholds by browsing the LDIU tree Our algorithm is an incremental algorithm where we check for closed itemsets and update their associated supports based on the previous mining results This is more ef\036cient as compared with mining approaches that rescan and regenerate all closed itemsets when a new block of transactions arrives Also in t he y perform closure checking for each and every itemset in new transaction whereas we have several optimization techniques to prune the number of candidates for which closure checking has to be performed We discuss the update of the DIU tree and the closure checking procedure for addition and deletion operations in section 3.3 3.2 Strategies to nd new CFI’s arising from d 002 block We will be having a set of CFIís in W When we slide window by width d some of CFIís in W become infrequent closed or nonclosed some will remain frequent closed or nonclosed in W/d-block and upon addition of d 002 block some new CFIís will arise in W 002 which are not in CFIís for W/dblock Those new CFIís have to be present in d 002 block Therefore To 036nd new CFIís in W 002  we need to check whether each and every itemset X with support 002 1in d 002 block is a new CFI in W 002  For that we need to get the closure of X in W/d-block say Y and in d 002 block say Z Case 1:If Y 005 Z=X and X  006 CFI in W/d-block and support of X in W 002 002 S then by closure de\036nition X is a new CFI in W 002  To illustrate case 1 consider an example from table 1 and table 2 Let us take itemset X:=\(a,b Itís closure in W/dblock is Y:=\(a,b,c:3 and in d 002 block is Z:=\(a,b,d,e:1 Here Y 005 Z=X and X:=\(a,b is not closed in W/d-block Considering S:=4 X:=\(a,b becomes a new CFI in W 002  
518 
518 


Transaction ID Items in transactions 1 abc 2 abcd 3 abcde 4 bcd 5 bcde 6 bcdefg Table 1 Transactions 1-6 represent W/dblock Transaction ID Items in transactions 7 abde 8 ace 9 bdef 10 acg Table 2 Transactions 7-10 represent d 002 block Case 2:If Y 005 Z 002 and support of Z in W 002 002 S then Z is anewCFIin W 002  To illustrate case 2 consider an example from table 1 and table 2 Let us take the itemset X:=\(a,c,g Itís closure in W/d-block is Y 002 and in d 002 block is Z:=\(a,c,g:1 Here Y 005 Z 002 and X:=\(a,c,g is closed in W 002  Considering S:=1 X:=\(a,c,g becomes a new CFI in W 002  First case is a general case where Y and Z exist for a given itemset X Second case arises when Y 002 Sointhis case X cannot be a CFI in W 002 since there exists a closure for X in W 002 in the form of Z But the above mentioned approach is similar to brute force approach since it needs checking of each and every itemset in d 002 block for closure So we discuss in the next section optimization techniques and various ideas to prune the search space to reduce the number of candidates for closure checking 3.3 Optimization techniques The following notations are used in this section   to denote an item   to denote an itemset   to denote todo-set or done-set or conditional set Most frequent pattern mining algorithms conduct depth\036rst enumerations in the pattern I t s tarts f rom an empty pattern set recursively calls the pattern-growth routine to expand the pattern set Since the individual items are sorted at any stage of the algorithm all the single items can be partitioned into three disjoint sets the conditional set the items appearing in the current pattern the todo-set the items to be expanded based on the current pattern and a a,b a,b,c a,b,c,d a,b,c,e a,b,c,d,e a a,b,d a,b,d,e a,b,e a,c a,c,d a,c,d,e a,c,e a,d a,d,e a,e Figure 3 Depth-ﬁrst search in pattern space the done-set all the other items For example consider a search space with 036ve single items a,b,c,d,e as shown in Figure 3 in the s ame o rder  At the time when the depth-\036rst search reaches pattern a,c the conditional set is  a,c   the todo-set is  d,e  and the done-set is  b   Optimization 1:Dynamic reordering We now discuss the item reordering routine  of the algorithm This pruning method is based on the following lemma Further we will see how dynamic reordering technique can be used to assist other optimization techniques in pruning non closed itemsets Lemma 1 Let P 3 be a closed itemset if closure of itemset P 1 is P 3  then for any itemset P 2 such that P 1 003 P 2 003 P 3  P 3 is a closure of P 2  Proof Refer  For example if itemset a\s closure is itemset a b c d so are patterns a a a d a b c a b d and a c d thus all these itemsets can be safely pruned without further checking for closedness However the pruning technique is nontrivial because the prunable space is embedded in the whole search space removing this space would leave the whole search space unconnected Take 036gure 4 as an e xample Assume itemset a b  c d is closure of a and a b c d has been selected as a closure According to Lemma 1 the search space containing a b d a c a d and a c d can be pruned However if we remove them those itemsets which contain item e i.e a b d e a c d e a c e a,b,e and a d e etc will be unreachable To overcome this problem we dynamically reorder the search space as a,e,b,c,d shown in 036gure 5 where we enumerate patterns containing item e 036rst and items b c d later The search space within the dashed lines in 036gure 5 is pruned W e refer items bí,ící,íd as the set of prunable-items 
519 
519 


a a,b a,c a,d a,e a,b,c a,b,d a,b,e a,b,c,d a,b,c,e a,b,c,d,e a,b,d,e a,c,d a,c,d,e a,c,e a,d,e a Figure 4 Search space without dynamic reordering a a,d a,c,d b a,e a,e,b a,e,b,c a,e,b,c,d a,e,b,d a,e,c a,e,c,d a,e,d a,b a,b,c a,b,c,d a,b,d a,c Figure 5 Search space with dynamic reordering Transaction ID Items in transactions 1 abce 2 abcd 3 cfgh 4 cgh 5 def 6 dgh Table 3 Transactions 1-6 represent W/dblock Transaction ID Items in transactions 7 abf 8 abfp 9 cdef 10 cdg Table 4 Transactions 7-10 represent d 002 block Optimization 2:Look ahead approach As we saw in section 3.2 we need to have the closure of itemset X in d 002 block one way is to run the non incremental algorithm on d 002 block for 036nding CFIís in d 002 block and store the CFIís obtained in LDIU tree Then again run our incremental algorithm on d 002 block to 036nd new CFIís in W 002 by obtaining closure of X in d 002 block already stored in LDIU tree Clearly above method is not ef\036cient since it needs two executions on d 002 block Therefore in order to circumvent the above problem we use Look ahead approach Here we obtain the closure of X in d 002 block directly in single execution We will explain our approach w.r.t table 4 So let us consider d 002 block for pattern-growth by constructing FP-tree on it During pattern-growth if frequency of two items are equal we give priority according to alphabetical order So If frequency of items b and d are equal then b comes above d in fptree header When we get itemset g in pattern-growth since LDIU tree is empty we look in to itís conditional FP-tree and 036nd items c and d with support same as g Therefore closure of g is c,d,g let us consider itemset a and when we look in to itís LDIU tree we get itís closure as a,b,f which was found when we had itemset b by looking in to bís conditional FP-tree Lemma 2 The closure of itemset X can be found by looking in to LDIU tree If it doesnít exist then items with the same frequency as itemset are directly merged into the conditional set from todo  set Proof Refer  Optimization 3:Maximum itemset Matching 
520 
520 


Maximum itemset matching is used for obtaining new CFI which helps in direct pruning of non closed itemsets Let us consider an example from table 3 and table 4 During pattern-growth on d 002 block consider an itemset b whose closure is a,b,c in W/d-block and a,b,f in d 002 block Consider their intersection a,b which is a new CFI in W 002  Here we directly got a new CFI a,b without looking at itemset b,a Lemma 3 If the intersection of closures for itemset X in W/d-block and d 002 block has common items in todo-set but not in done-set for X in d 002 block then the intersection Y is a newly discovered closed itemset Proof Let Z be a CFI containing Y Then there exists atleast one frequent item in Z which is not in Y Consider CFIís of Z in W/d-block and d 002 block,which are CFIís of Y also Perform the intersection of CFIís  By lemma 3 statement it is Y Therefore Z doesnít exist Hence the proof We will see in optimization 5 the reason for mentioning the condition that intersection can have common items in todo-set but not in done-set for X in d 002 block in lemma 3 Optimization 4:Prune candidate itemsets for closure checking by Maximum itemset Matching and dynamic reordering Considering similar example used in Maximum itemset Matching we can prune itemset b,a without checking for it For itemset b the todo-set items are  a,f   Since intersection of closures of b is a,b and common todo-set item is a present in both intersection a,b and todo-set items  a,f   we can skip b,a for closure checking by dynamic reordering  f,a  instead of  a,f   This approach is very ef\036cient when itemset size is small and intersection size is large The following lemma states the above property The above property takes care of common suf\036x pruning since candidate itemsets containing common todo-set items are getting pruned Lemma 4 The todo-set items of an itemset X present in itís maximum itemset matching along with itemset X do not form candidates for closure checking Proof Refer  Optimization 5:Common preﬁx pruning Common pre\036x pruning is designed to reduce the number of candidates for closed itemset checking for some itemsets which share a common pre\036x thereby reducing the search space We shall explain our approach by considering an example from table 3 and table 4 During pattern-growth on d 002 block Consider the itemset a The done-set of a is  p,b  and todo-set is  f   Consider intersection of closures of a in W/d-block and in d 002 block i.e a,b Since a,b contains done-set item of a i.e b therefore itemset a,b is already found when we considered itemset b So there wonít be any CFI Z containing a and todo-set items of a Since itemset b would be present along with Z For example itemset a,f cannot be CFI since a,b,f is the closure of a,f Lemma 5 If the intersection of closures for itemset X in W/d-block and d 002 block have common items in done-set for X in d 002 block then there exists no CFI containing X as a base and todo-set items of X in pattern-growth strategy Proof Suppose intersection of closures for X in W/d-block and d 002 block have common items in done-set for X in d 002 block and Let Z be a CFI containing X as a base and todo-set items of X in pattern-growth strategy Then there exists a CFI Y which is a union of Z and items in intersection of closures for X which are in done-set for X in d 002 block Therefore Z is not a CFI Hence the proof Optimization 6:Prune non closed itemsets by dynamic reordering From table 3 and table 4 Consider itemset p during pattern-growth on d 002 block p doesnít have closure in W/d-block Considering minimum support S:=1 in W 002 the closure of p in d 002 block is a,b,f,p So a,b,f,p is a new CFI in W 002  Since todoset-items of p which are present in a,b,f,p are  a,b,f   all possible subsets of a,b,f along with p wonít be having closure in W/d-block So their closure will be a,b,f,p itself in W 002 which is already found when we consider itemset p Therefore all possible subsets of a,b,f along with p can be pruned by dynamic reordering This case may arise when itemset contains newly added items in d 002 block or when itemset is not present in W/d-block The following lemma states the above property Lemma 6 All combinations of todo-set items of an itemset X in itís closure in d 002 block with itemset X as a base including itemset X can be pruned when itemset X doesnít have a closure in W/d-block and itemset X is frequent in W 002  Proof Refer  Optimization 7 update the CFI’s in W after sliding Wbywidth’d It is easy to observe that deletion of d-block from W doesnít result in new CFIís in W/d-block When we delete d-block from W and update\(decrease the support of CFIís in W w.r.t to d-block some CFIís in W will become infrequent S=0 rest of CFIís will become frequent closed or nonclosed in W/d-block We discuss the strategies to handle the above two cases when CFI X becomes infrequent and frequent in W/d-block Case 1:When CFI X become infrequent\(S=0 in W/dblock we delete it from LDIU tree for W 
521 
521 


Case 2:When CFI X become frequent in W/d-block we check for itís closure If it is closed in W/d-block we retain it otherwise we delete it from LDIU tree for W we perform deletion operation step by step i.e updating LDIU tree for each transaction in d-block similar to  But for closure checking of a closed itemset we adopt a different method In the following part of this section we use the notations as follows  t An outgoing transaction in Window W and belonging to d-block  W/t Transactions in Window W excluding t After we perform deletion operation w.r.t t W:=W/t We perform the above operation until W=W/d-block  the y state t hat to determine if a c losed itemset in t is closed or not in W/t they 036nd all the proper supersets of that itemset in W/t that are closed in W/t They perform intersection of all those supersets If intersection is equal to itemset itself then they declare itemset to be closed in W/t They perform closure checking for itemsets based on precedence order of length in an outgoing transaction i.e closure checking for itemset of length i will be performed 036rst than for itemset of length j if i  j The reason for this precedence will be known in Lemma 7 But the above method requires searching for all proper supersets of that itemset in W/t that are closed in W/t So we propose the following lemma which advocates the determination of closedness of an itemset by searching only one proper superset of itemset in W/t that is closed in W/t Lemma 7 If Y is a closed itemset in W and Y is present in t then scan the LDIU tree for the 036rst proper superset of Y by traversing depth-\036rst from rightmost point of the tree If the 036rst proper superset obtained from LDIU tree has support same as that of Y in W/t then Y is not closed If the 036rst proper superset has support less than that of Y in W/t or if there is no proper superset present then Y is closed Proof If the 036rst proper superset obtained from LDIU tree has support same as that of Y in W/t then by closure de\036nition Y is not closed If there is no proper superset present then by closure de\036nition Y is closed Suppose the 036rst proper superset has support less than that of Y in W/t and there exist another proper superset of Y say Z in LDIU tree whose support is same as Y Then the 036rst proper superset is not closed since there will be presence of Z-Y items wherever 036rst proper superset is present in W/t But 036rst proper superset is closed in W/t by de\036nition of lemma 7 Therefore Z does not exist Hence the proof Transaction ID Items in transactions 1 abcf Table 5 Transaction 1 represent d-block Transaction ID Items in transactions 2 abcg 3 bcf 4 abcdg 5 bc Table 6 Transactions 2-5 represent W/dblock Since closure checking of itemset needs to obtain itís proper superset the support or closedness of proper superset should be known prior to the closure checking of the given itemset This is the reason for precedence order of length for closure checking of itemsets To illustrate the above lemma consider d-block as shown in table 5 W/d-block in table 6 and the LDIU tree shown in 036gure 6 Taking S:=1 let us consider itemset a,b,c present in table 5 which is a CFI in W Now to check whether it is closed in W/d-block we 036nd 036rst proper superset of a,b,c i.e a,b,c,g by scanning from rightmost point of LDIU tree Since support of a,b,c is same as that of a,b,c,g i.e equal to 2 in W/d-block we conclude a,b,c is not closed in W/dblock and delete a,b,c in LDIU tree let us consider itemset b,c,f present in table 5 which is a CFI in W Now to check whether it is closed in W/d-block we 036nd 036rst proper superset of b,c,f by scanning from rightmost point of LDIU tree Since there is no proper superset of b,c,f in LDIU tree we conclude it is closed and just decrease itís support by 1 let us consider itemset b,c present in table 5 which is a CFI in W Now to check whether it is closed in W/d-block we 036nd 036rst proper superset of b,c i.e b,c,f by scanning bc bcf abc abcdg abcf abcg 5 2 1 3 2 1 Figure 6 LDIU tree for d-block 007 W/d-block of table 5 and table 6 
522 
522 


from rightmost point of LDIU tree Since support of b,c,f is 1 which is less than support of b,c i.e 4 in W/d-block we conclude b,c is closed in W/d-block There cannot exist any proper superset of b,c in LDIU tree with support equal to 4 because if it exists then b,c,f will not be a closed itemset in LDIU tree We do not need to update\(increase the support of CFIís in W/d-block w.r.t d 002 block because during pattern-growth on d 002 block  while intersecting the closures of an itemset X we check whether the intersection is same as closure of X in W/d-block If it is same we increase the support of CFI of X in W/d-block by the support of X in d 002 block So If CFIís in W/d-block are present in d 002 block then they are updated during pattern-growth on d 002 block otherwise we do not need to update them We integrate all the optimization techniques mentioned above in to Stream-Close Algorithm development which will be discussed in next subsection 3.4 Stream-Close DESIGN AND IMPLEMENTATION In this section we formulate the Stream-Close algorithm which mines new CFI by FP-tree method Input W d LDIUW\(LDIU tree for W LDIUdelta\(LDIU tree for d 002 block d 002 block S:=1 IS//global parameters Output Set of CFI 002 in W 002 global parameters BEGIN 1 CFI 002  002  LDIU-delta 002  2 For every CFI in LDIUW update the support w.r.t d-block;//Applying optimization 7 so that resulting CFIís support will be in accordance with W/d-block and CFIís in W which become nonclosed in W/d-block are removed 3 Scan the items in d 002 block according to their support in W 002 w.r.t minsup S and create FP tree F on scanned d 002 block with support  1in d 002 block;//Since infrequent items in W 002 present in d 002 block donít contribute to Set of CFI 002 in W 002  4:IS  002 global stack to keep itemsets 5 Stream-Close:Addition F Optimizations 1-6 6 CFI 002 CFI 002 007 setofallCFIísinLDIUW END procedure Stream-Close:Addition F 1 For each item i in F.headtable push item into IS 2 Fetch the closure X of IS from LDIU-delta If X is NULL extract X by look ahead approach from ISís conditional FP-tree\(w.r.t minimum support:=support of IS and insert X in to LDIU-delta.//Applying optimization 2 3 Fetch the closure Y of IS from LDIUW 3.1:if Y is NULL check for support of X 3.1.1:If support of X is 002 S then CFI 002 CFI 002 007 X and dynamically reorder the todo-set itemís of IS present in X and prune them later and Go to step 6 Applying optimization 6 and 1 3.1.2:If support of X is  S then pop item from IS and continue 4 If sum of support of X and Y  S then pop item from IS and continue 5 If sum of support of X and Y 002 S then perform Z:=Y 005 X 5.1:If Z contains done-set items of IS,then pop item from IS and continue.//Applying optimization 5 5.2:If Z 010 Y then CFI 002 CFI 002 007 Z and dynamically reorder the todo-set itemís of IS present in Z and prune them later and Go to step 6 Applying optimization 3 and 4 5.3:If Z 005 Y=Y and if Yís support  S then CFI 002 CFI 002 007 Y update the support of Y by support of IS and dynamically reorder the todo-set itemís of IS present in Z and prune them later and Go to step 6 5.4:If Z 005 Y=Y and if Yís support 002 S then update the support of Y by support of IS and dynamically reorder the todo-set itemís of IS present in Z and prune them later 6:construct ISís conditional FP-tree F new w.r.t minimum support:=1 Stream-Close F new  pop item from IS Stream-Close algorithm illustrates how to 036nd CFI 002 in W 002 when we slide W by width d First we perform deletion operation w.r.t d-block and 036nd the set of CFI 002 in W/dblock as illustrated in line 2 of BEGIN block As shown in lines 3-5 of BEGIN block we perform insertion operation w.r.t d 002 block and scan the items in d 002 block according to their support in W 002 w.r.t minsup S and create FP tree F on scanned d 002 block to perform FP-growth routine IS is a global stack to keep track of itemsets generated during FPgrowth routine In procedure Stream-Close:Addition we perform FPgrowth routine to check for new CFIís generated due to addition of d 002 block For each itemset generated during FPgrowth routine we extract the closure of IS in d 002 block say X from LDIU-delta If it is not present in LDIU-delta we extract from ISís conditional fp-tree by merging items of same support as that of IS to form ISís closure\(line 2 Next we fetch the closure of IS in W/d-block say Y from LDIUW tree maintained for W/d-block\(line 3 If Y is NULL we check for support of X and if support of X is 002 Sweadd X as a new CFI to the set CFI 002 and dynamically reorder the todo-set itemís of IS present in X and prune them later by 
523 
523 


applying optimization 2\(line 3.1 and 3.1.1 If Y is NULL and support of X is  S then any itemset which is a superset of IS has support  Sin W 002  therefore pop item from IS and continue to examine next itemset\(line 3.1.2 Similar is the case for line 4 If sum of support of X and Y\(i.e support of IS in W 002  is 002 S then we need to examine if their intersection say Z is a new CFI\(line 5 If Z contains done-set items then it should have been already examined earlier according to optimization 5 so all intersections of closures of supersets of IS contains done-set items Therefore pop item from IS and continue\(line 5.1 If Z is a subset of Y then Z is nonclosed in W/d-block but is closed in W 002 due to addition of d 002 block therefore add it as a new CFI to set CFI 002 and prune common todo-set items by dynamic reordering\(line 5.2 Suppose if Z  Y and support of Y is  S in W/d-block then Y\(already closed becomes frequent in W 002 due to addition of d 002 block therefore add it as a new CFI to set CFI 002 and prune common todo-set items by dynamic reordering\(line 5.3 If support of Y is 002 S in W/d-block then it is already present in LDIUW tree therefore just update itís support by support of IS in d 002 block and prune common todo-set items by dynamic reordering\(line 5.4 Line 6 constructs ISís conditional FP-tree F new w.r.t minimum support:=1 to explore further itemsets based on dynamic reordering and recursively calls the procedure Stream-Close on F new  Finally in line 6 of BEGIN block it merges CFIís of CFI 002 and LDIUW tree to output the set of CFI 002 in W 002  Lemma 8 An itemset is a CFI in W 002 iff Stream-Close says Proof An itemset D is found as a CFI by Stream-Close when 1 D is frequent 2 there is no item which appears in every transaction in D-conditional database and 3 D is not a proper subset of any CFI already found To assert correctness of the lemma we show that there is no frequent closed itemset E which can be found later such that D is a subset of E Suppose we can 036nd such an itemset E then ED 011  0 must happen in every transaction of the D-conditional database This leads to a con\037ict with the fact that there is no item appearing in every transaction in the D-conditional database Thus we have the lemma The correctness of the algorithm has been reasoned stepby-step It generates the complete set of CFIís in W 002 as shown in above lemmas 4 Empirical results We compare our algorithm with Moment w hich is the state-of-the-art algorithm to mine frequent closed item0 0.01 0.02 0.03 0.04 0.05 0.5 3 5.5 8 10.5 13 15.5 18 20.5  The Minimum Support Running time in Seconds   Moment Stream\025Close  Figure 7 Performance comparisons of Moment and Stream-close 0 0.01 0.02 0.03 0.04 0.05 0.4 0.9 1.4 1.9 2.4 2.9  The Minimum Support Memory usage in number of itemsets   Moment Stream\025Close  Figure 8 Memory usage results of Moment and Stream-close The order of number of itemsets is 10 7  sets in data streams For performance evaluation the synthetic dataset T10.I6.D100K is used The dataset is generated by the same procedure as described in where t he three numbers o f each dataset denote the average transaction size T the average maximal potential frequent itemset size I and the total number of transactions D respectively In our experiments the transactions of T10.I6.D100K dataset are looked up incrementally in blocks in sequence to simulate the environment of an online data stream In our experiments we keep sliding width parameter d  10 for Stream-Close window width:=1,00,000 for both Stream-Close and Moment and perform experiments over 100 sliding windows for Moment and 10 sliding windows for Stream-Close\(since dí:=10 and take the average processing time for every 10 transactions processed under different minimum supports for T10.I6.D100K data set as shown in 036gure 7 We can see from 036gure 7 that Stream-Close runs much faster than Moment when the support threshold is relatively low because the number of boundary nodes stored in the data structure of Moment increases when the support threshold decreases as the number of nodes to be processed 
524 
524 


and checked for node property increase execution time is increased When the support threshold is relatively high these two algorithms have comparable running time Moment runs a little bit faster than Stream-Close as the threshold increases This is because as the threshold is increased the number of the boundary nodes in Moment decreases while Stream-Close processes the same number of closed itemsets independent of support information This is advantageous when users have different speci\036ed support thresholds in their online queries Regarding memory usage Stream-Close maintains only CFIís in LDIU-tree but whereas for Moment when the user de\036ned support threshold is small the number of nodes it maintains in the memory increases dramatically which consists of all the infrequent gateway nodes unpromising gateway nodes intermediate nodes and closed nodes as shown in 036gure 8 We performed all our experiments on 2 GB RAM 1.8 GHz AMD machine Our performance study shows that Stream-Close is very ef\036cient and the optimization techniques proposed in this paper are effective in improving the algorithm ef\036ciency 5 Conclusions In this paper we investigated the issues for cumulative mining of CFIís in high speed data streams and addressed the inef\036ciency problem of mining the new window from scratch,sliding window by one transaction and also the problem associated with closedness checking of candidate itemsets in newly arrived block We proposed an algorithm Stream-Close by exploring several novel techniques to increase ef\036ciency and scalability It is a promising algorithm to mine CFIís over high speed data streams In the future we plan to explore how to mine compressed top-k itemsets in datastreams and also how to adaptively vary sliding width according to speed of the data streams Also we plan to perform experiments on different datasets 6 Acknowledgements We thank Dr Yun Chi at the University of California for providing us the Moment algorithm source code References  J  Pei J  Han and R Mao Closet An e f 036cient algorithm for mining frequent closed itemsets ACM SIGMOD International Workshop on Data Mining and Knowledge Discovery May 2000  J  Pei J  Han and J W ang Closet Searching for the best strategies for mining frequent closed itemsets ACM SIGKDD Intíl Conf on Knowledge Discovery and Data Mining August 2003  M  J  Z aki and C J Hsiao Charm An ef 036cient algorithm for closed itemsets mining SIAM Intíl Conf on Data Mining April 2002  C  L ucchese S Orlando and R Pere go F a st and memory ef\036cient mining of frequent closed itemsets Knowledge and Data Engineering IEEE Transactions January 2006  J  H  Chang W  S Lee A Zhou Finding recent frequent itemsets adaptively over online data streams ACM SIGKDD Intíl Conf on Knowledge Discovery and Data Mining August 2003  S H L i S Lee and M Shan An ef 036cient algorithm for mining frequent itemsets over the entire history of data streams Intíl Workshop on Knowledge Discovery in Data Streams Sept 2004  G S  M anku R Motw ani Approximate frequenc y counts over data streams Intíl Conf on Very Large Databases 2002  J  H  Chang W  S Lee A s liding w indo w m ethod for 036nding recently frequent itemsets over online data streams Journal of Information Science and Engineering July 2004  C  Giannella J  Han J Pei X Y an P  S Y u  Mining frequent patterns in data streams at multiple time granularities Data Mining Next Generation Challenges and Future Directions AAAI/MIT 2003  C Lin D Chiu Y  W u A L P  Chen Mining frequent itemsets from data streams with a time-sensitive sliding window SIAM Intíl Conf on Data Mining April 2005  Y  Chi H W ang  P  S  Y u  R R Muntz Moment Maintaining closed frequent itemsets over a stream sliding window Intíl Conf on Data Mining November 2004  Nan J iang Le Gruenw ald CFI-Stream M ining Closed Frequent Itemsets in Data Streams KDD August 2006  Dong Xin Jia wei Han Xifeng Y a n and Hong Cheng On Compressing Frequent Patterns Knowledge and Data Engineering Special issue on Intelligent Data Mining 60\(1 5-29 2007  R Agra w a l R Srikant F ast a lgorithms for m ining association rules Intíl Conf on Very Large Databases September 1994  P  V a ltchef R  M issaoui and R Godin A F ramework for Incremental Generation of Frequent Closed ItemSets Proceedings of the 2nd SIAM Workshop on Data Mining Arlington VA April 2002  A v ailable a t h ttp://cl w eb csa.iisc.ernet.in/srirang a 
525 
525 


