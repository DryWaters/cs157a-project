T-Trees Vertical Partitioning and Distributed Association Rule Mining Frans Coenen Paul Leng and Shakil Ahmed Department of Computer Science The University of Liverpool Liverpool L69 3BX UK 000 frans,phl,shakil 001 csc.liv.ac.uk Abstract In this paper we consider a technique DATA-VP for distributed and parallel Association Rule Mining that makes use of a vertical partitioning technique to distribute the input data amongst processors The proposed vertical partitioning is facilitated by a ovel compressed set enumeration tree data structure the T-tree and an associated mining algorithm Apriori-T that allows for computation 
ally effective distributed/parallel ARM when compared with existing approaches 1 Introduction An approach to distributed/parallel Association Rule Mining ARM DATA-VP that makes use of a vertical partitioning approach to distributing the input data is described Using this approach each partition can be mined in isolation while at the same time taking into account the possibility of the existence of large itemsets dispersed across two or more partitions To facilitate the partitioning a compressed set enumeration tree data structure the T-tree developed by the authors s d together with an associated ARM 
algorithm 204 Apriori-T The approach described offers signi\223cant advantages with respect to computational ef\223ciency when compared to alternative mechanisms for a dividing the input data between processors and/or b achieving distributed/parallel ARM 2 The T-tree and the Apriori-T algorithm A signi\223cant consideration with respect to ARM is the nature of the data structures used to store itemsets as the algorithm progresses The authors have developed a number of compressed set enumeration tree structures to support ARM including the T-tree Total Support Tree 7 6 and a 
number of serial ARM algorithms to be used in association with these structures Of particular relevance with respect to this paper is the Apriori-T algorithm The T-tree differs from more standard set enumeration trees in that the nodes at the same level in any sub-branch are organised into 1-D arrays so that array indexes represent column numbers For this purpose it is ore convenient to build a 215reverse\216 version of the tree see Figure 1\(a which permits direct indexing with attribute/column numbers The T-tree offers two initial advantages over standard set enu 
meration trees 1 fast traversal of the tree using indexing mechanisms and 2 reduced storage in that itemset labels are not required to be explicitly stored and thus no sibling references pointers are required The implementation of this structure is illustrated in Figure 1\(b where nodes in the T-tree are objects comprising a support value and a reference to an array of child T-tree nodes The T algorithm combines e ssic Apriori ARM algorithm 2 with th e T t r e e d ata str u ctu r e 1  As each level is processed candidates are added as a new level of 
the T-tree their support is counted and those that do not reach the required support threshold pruned When the algorithm terminates the T-tree contains only large itemsets At each level new candidate itemsets of size K are generated from identi\223ed large K-1 itemsets using the downward closure roperty of itemsets  which in turn may necessitate the inspection of neighbouring branches in the T-tree to determine if a particular K-1 subset is supported We refer to this process as X-checking  Note that X-checking adds a 
computational overhead offset agai nst the additional effort required to establish whether a candidate K itemset all of whose K-1 itemsets may not necessarily be supported is or is not a large itemset The number of candidate nodes generated during the construction of a T-tree and consequently the computational effort required is very much dependent on the distribution of columns within the input data Best results are produced by reordering the dataset according to the support counts for the 1-itemsets so that the most frequent 1 
itemsets occur 223rst 5 1 Elsewhere  the authors h a v e d es cribed an algorithm  A priori-T F P  which uses both the T-tree structure and another set-enumeration tree the P-tree In this paper we examine methods using only the T-tree structure Proceedings of the Third IEEE Internati onal Conference on Data Mining \(ICDM\22203 0-7695-1978-4/03 $ 17.00 \251 2003 IEEE 


 1 3 1 1 5 11 2 31 1 4 2 1 2 2 6 3 1 1 1 2 1 4 1 2 1 2 1 4 1 2 1 1 1 null null null 1 null 03 2 1 1 null null 1 null 03 24 1 null null null 1 null 03 2 2 1 null null null 1 null 03 24 null 5 null 1 null 1 null 02 1 2 null 1 03 2 null null 1 null 1 null null 1 02 null 1 1 31 1 2 1 023546 null null null a reverse order b representation of support tree using index tables \(arrays Figure 1 The T-tree for the data set 000\000 000 000 001 000 002 001 000 000 003 000 002 000 004 001 000 000 003 000 002 000 005 001\001  Note t for ease of processing items/attributes are enumerated commencing with 000 3 The distributed Apriori-T Algorithm with Vertical Partitioning DATA-VP The DATA-VP algorithm commences by distributing the input dataset over the available number of processes using a vertical partitioning strategy Initially the set of single attributes columns is split equally between the available processes so that an 001\002 002 003\004\001\005\006\003\007\b 005\t\n\013 t\005 a sequence of single attributes is de\223ned for each process in terms of a f\005\001\r 005\016 003\002 017 n and t\007\021\016 003\002 017 020\n  001\002 002 003\004\001\005\006\003\007\b 005\t\n\013 t\005 006 000 007 002 f\005\001\r 005\016 003\002 017 n 022 007 003 t\007\021\016 003\002 017 020\n 001 Each process will have its own 001\002 002 003\004\001\005\006\003\007\b 005\t\n\013 t\005 which is then used to determine the subset of the input dataset to be considered by the process Using its 001\002 002 004\001\005\006\003\007\b t\n\013 005 each process will proceed as follows 1 Remove all records in the input dataset that do not intersect with the 001\002 002 003\004\001\005\006\003\007\b 005\t\n\013 t\005  2 From the remaining records remove those attributes whose column number is greater than t\007\021\016 003\002 017 020\n  We cannot remove those attributes whose identi\223ers are less than f\005\001\r 005\016 003\002 017 020\n because these may represent the 215leading sub-string\216 of large itemset to be included in e sub tree counted by the process The input dataset distribution procedure given an 001\002 002 004\001\005\006\003\007\b t\n\013 005  can be summarised as follows Figure 2 Distributed T-tree representing the vertical partitioning presented in the example 004 r t\004\003\r 021\f 005 006\007\023\020\005 021\001\005\001 006\024 007 r t\004\003\r 021 006 001\002 002 003\004\001\005\006\003\007\b 005\t\n\013 t\005 007 005\r 020\t b r t\004\003\r 021 006 000 007 002 007 005 r\t\004\003\r\021 007 003 t\007\021\016 003\002 017 020\n 001 t\002 f\t 021\t\002 t\005\t r t\004\003\r 021 For example 204 given the data set 000\000 001\000 004\000 024 001 000 000 025 001 000 000 001\000 004\000 t 001 000 000 025\000 021 001 000 000 001\000 t 001 000 000 001\000 025\000 004 001 000 000 021 001 000 000 001\000 025 001 000 000 004 001 000 000 001\000 025 000\021 001\001 andassuming three processes the above partitioning process will result in three dataset partitions Process 1 a to b 000\000 001 001 000 000 025 001 000 000 001 001 000 000 025 001 000 000 001 001 000 000 001\000 025 001 000 000\001 000 000 001\000 025 001 000 000\001 000 000 001\000 025 001\001 Process 2 c to d 000\000 001\000 004 001 000 000\001 000 000 001\000 004 001 000 000 025\000 021 001 000 000\001 000 000 001\000 025\000 004 001 000 000 021 001 000 000\001 000 000 004 001 000 000 001\000 025\000 021 001\001 Process 3 e to f 000\000 001\000 004\000 024 001 000 000\001 000 000 001\000 004\000 t 001 000 000\001 000 000 001\000 t 001 000 000\001 000 000\001 000 000\001 000 000\001 000 000\001\001 Figure 2 shows the resulting sub T-trees assuming all combinations represented by each partition are supported Note that because the input dataset is ordered according to the frequency of 1-itemsets the size of the individual partitioned sets does not necessarily increase as the t\007\021\016 003\002 017 020\n approaches 017 the number of columns in the input dataset in the later partitions the lower frequency leads to more records being eliminated Thus the overall result of the vertical partitioning is that the overall size of the dataset applicable to the process in question is reduced Once partitioning is complete each partition can be mined using the Apriori-T algorithm in isolation The DATA-VP algorithm can thus be summarised as follows 1 Start all processes Master plus a number of Workers 2 Master determines the division of 001\002 002 003\004\001\005\006\003\007\b 005\t\n\013 t\005 according to the total number of available processes and transmits this information to the Workers 3 Each process then generates a T-tree for its allocated partition a sub tree of the 223nal T-tree 4 On completion each process transmits its partition of the T-tree to all other processes which are then merged Proceedings of the Third IEEE Internati onal Conference on Data Mining \(ICDM\22203 0-7695-1978-4/03 $ 17.00 \251 2003 IEEE 


into a single T-tree so that each process has a copy of the 223nal T-tree ready for the next stage in the ARM process 204 rule generation The process begins with a top-level 215tree\216 comprising only those 1-itemsets included in its 000\001 001 003\000\004\005\002\006\007 b\t\n b\004  The process will then generate the candidate 2-itemsets that belong in its sub T-tree These will comprise all the possible pairings between each element in the 000\001 001 002\003\000\004\005\002\006\007 004\b\t\n b\004 and the lexicographically preceding attribute of those elements see Figure 2 The support values for the candidate 2-itemsets are then determined and the sets pruned to leave only large 2-itemsets Candidate sets for the third level are then generated Again no attributes from succeeding 000\001 001 002\003\000\004\005\002\006\007 004\b\t\n b\004 are considered t the possible candidates will in general have subsets which are contained in preceding 000\001 001 003\000\004\005\002\006\007 b\t\n 004 and which therefore are being counted by some other process To avoid the overhead involved in X-checking which in this case would require message-passing between the processes concerned X-checking does not take place Instead the process will generate its candidates assuming where necessary that any subsets outside its local T-tree are large 4 Related Work Generally speaking two types of parallel/distributed ARM algorithms can be identi\223ed 4 Data Distribution e.g Agrawal and Schafer\220s 215count distribution algorithm\216 1 The dat a i s apport i oned amongst the processes typically by 215horizontally\216 segmenting the dataset into sets of records Each process then mines its allocated segment exchanging information on-route as necessary Task Distribution e.g Agrawal is Schafer\220s 215data distribution algorithm\216 1 Each proces s h as acces s t o t he entire dataset but is responsible for some subset of the t of candidate itemsets generated at each l To evaluate the DATA-VP algorithm see below we will compare its performance with a data parallel Apriori-T algorithm DATA-DD and an Apriori-T version of the task parallel approach DATA-TD 5 Evaluation The implmentation of the algorithms was carried oput using Java Spaces The e v aluation pres ented here us es 223ve processes and the data set T20.I10.D500K.N500 generated using the IBM Quest generator used in Agrawal and Srikant 2 although th e research team have obtained similar results using other data sets In all case the dataset has been preprocessed so that it is ordered Support  2.0 1.5 1.0 0.5 DATA-DD 3472 4621 8855 36119 DATA-TD 695 924 1771 7225 DATA-VP 11 21 60 228 e 1 Average Total size Kbytes of mess sent nd read/taken r process 5.1 Number of T-tree Messages The most signi\223cant overhead of any distributed/parallel ARM algorithm is the number of messages sent and received between processes For DATA-DD and DATA-TD processes are required to exchange information as each level of the T-tree is constructed the number of levels will equal the size of the largest supported set For DATA-VP the number of messages sent is independent of the number of levels in the T-tree communication takes place only at the end of the tree construction DATA-VP therefore has a clear advantage in terms of the number of messages sent 5.2 Amount of Data Sent and Received Table 1 shows the average amount of data sent and received by each process for each of the Apriori-T algorithms under consideration assuming 223ve processes Note that 000 With respect to DATA-DD for each generated T-tree level un-pruned levels of the T-tree are passed from one process to another and then pruned 000 In the case of DATA-TD pruned sections of levels in the T-tree are passed from one process to another 000 DATA-VP passes entire pruned sub T-trees pruned T-tree branches not entire levels Consequently the amount of data passed between processes when using DATA-VP is signi\223cantly less than that associated with the other approaches 000 In the case of DATA-DD adding more processes increases the amount of communication because all processes send data to all others In the case of DATA-TD and DATA-VP however each process sends only the set of candidates it is counting or has counted which becomes proportionately smaller as the number of processes is increased i.e for these methods the messaging overhead remains approximately constant 5.3 Number of Updates The number of support value updates/incrementations per process is a good indication of the amount of work done by each process Table 2 gives e number of updates for Proceedings of the Third IEEE Internati onal Conference on Data Mining \(ICDM\22203 0-7695-1978-4/03 $ 17.00 \251 2003 IEEE 


Support  2.0 1.5 1.0 0.5 DATA-VP 20 22 30 57 DD TD Apriori-T 99 111 148 285 with X-check Apriori-T 99 111 148 286 No X-check Table 2 Average number of updates  000 000\001 000 o generate a 223nal T-tree per process Support  2.0 1.5 1.0 0.5 DATA-DD 13 16 25 99 Apriori-T No X-check 15 19 31 95 DATA-TD 9 9 16 66 DATA-VP 3 4 10 31 Table 3 Average execution time seconds per process each of the algorithms under consideration for a range of support thresholds and using 223ve processes Note that 001 Table 2 includes for comparison values for the serial form of the Apriori-T algorithm with and without Xchecking 001 DATA-DD DATA-TD and DATA-VP all have the same average number of updates as would be expected 5.4 Execution Time The overall execution time for each algorithm is arguably the most signi\223cant performance parameter A set of times seconds is presented in Table 3 The table includes execution times using the Apriori-T serial algorithm without X-checking as this provides a slightly better esult or this data set In terms of execution time the Task Distribution algorithms DATA-TD and especially the vertical partitioning algorithm DATA-VP perform much better than the data distribution algorithm DATA-DD because f the messaging overhead Note also that for DATA-DD as further processes are added the increasing overhead of messaging more than outweighs any gain from using additional processes so that distribution/parallelisation becomes counter productive DATA-TD shows some gain from the addition of further processes however DATA-VP gives the best results and e best scaling 6 Summary and Conclusions We have described the DATA-VP approach to disibuted/parallel ARM founded on the T-tree data structure and the associated Apriori-T algorithm We have evaluated DATA-VP against established data and task distribution approaches The principal advantages offered by DATA-VP are 1 minimal amount of message passing compared to DATA-DD and DATA-TD 2 minimal message size especially with respect to DATA-DD but also when compared to DATA-TD and 3 enhanced ef\223ciency as the number of processes increases unlike DATA-DD Our experimental evaluation of DATA-VP clearly demonstrates that the approach performs much better than those methods that use data and task distributed approaches This is largely due to the T-tree data structure which a facilitates vertical distribution of the input dataset and b readily lends itself to distribution/parallelisation More generally we have demonstrated that both the Ttree data structure and the T algorithm are good generic mechanisms that can be used effectively to implement many approaches to distributed/parallel ARM References  Agra w a l R  and S hafer  J C   1996 P arallel M ining o f Association Rules IEEE Transactions on Knowledge and Data Engineering Vol 8 No 6 pp962-969  Agra w a l  R  and S ri kant  R  1994 Fast algorithms for mining association rules  Proc 20th VLDB Conference Morgan Kaufman pp487-499  Arnol d K F reeman E and H upfer  S   1999 JavaSpaces Principles Patterns and Practice n Wesley  C hat t r at i c hat  J  Darl i ngt on J   G hanem M Guo Y   Hning H Khler M Sutiwaraphun J To H W Yang D 1997 Large Scale Data Mining Challenges and Responses oc 3rd Int.Conf on Knowledge Discovery and Data mining KDD\22097 pp143-146  C oenen F  and Leng P  2001 Optimising Association Rule Algorithms Using Itemset Ordering Research and Development in Intelligent Systems XVIII Proc ES2001 Conference eds M Bramer F Coenen and A Preece Springer pp53-66  C oenen F   G oul bourne G and Leng P    2003 Tree Structures for Mining association Rules To appear in the journal of Data Mining and Knowledge Discovery  Goul bourne G C oenen F  and Leng P  2000 Algorithms for Computing Association Rules Using a Partial-Support Tree Journal of Knowledge-Based Systems Vol 13 pp141-149 Proceedings of the Third IEEE Internati onal Conference on Data Mining \(ICDM\22203 0-7695-1978-4/03 $ 17.00 \251 2003 IEEE 


32 From the algebra point of view a temporal OODB TOODB\can be viewed as a collection of temporal objects grouped together in classes relations\and interrelated through three associations aggregation generalisation and time-reference Each temporal relation can be viewed as a 3 dimensional structure i.e a cube Basically, the standard relational algebra provides a unary operator for each of its two dimensions select for the value dimension and project for the attribute dimension. The temporal algebra supports an operation on the third dimension i.e the time dimension time-slice An object algebra allows the predicate of the select operation on a contiguous sequence of attributes along a branch of class-aggregation hierarchy This sort of query is usually represented by a path l and is often referred as an implicit join We have defined the enhanced path that extends the path with time-reference so that the select provides an access of data along associations of both aggregation hierarchy and time-reference A complete set of algebraic operators has been defined for our temporal object data model The detailed definitions are given 17 Table 2 simply lists some basic algebra operators 4 An extensible approach to processing temporal object-oriented queries The temporal object data model and an algebra for this model presented in the previous sections provide a basis for query processing Due to the hierarchical feature of our data model, as shown in Fig 3 our algebra possesses the property of reducibility. That is when time dimension is not taken into account the temporal object algebra will be reduced to the object algebra and when the object-oriented features of aggregation and inheritance are not taken into consideration the algebra will be reduced to the relational algebra We therefore could explore an extensible approach to processing temporal queries within the existing object query processing framework that in turn is extended from relational query processing framework 4.1 Optimizer hierarchy Our optimizer is of a hierarchical structure as shown in Fig 4 where the temporal optimizer is built on the top of the object optimizer that in turn is on the top of the relational optimizer The temporal object queries can be processed and optimized within the existing query processing framework through smoothly extending the existing query processing techniques Fig 3 Data model hierarchy 4.2 Query transformations I lh emporal optimizer I Fig 4 Optimizer hierarchy One important aspect of query optimization is the transformation of one query into an equivalent query that might be more efficient to evaluate The size of the search space of equivalent query plans for a snapshot query is determined in part by the algebraic equivalence available in the snapshot algebra As we represent a temporal object as a time series that can 


33 be thought of as the equivalence of a 221blob\222 object the transformation rules in object algebra can directly apply As our object algebra is also consistently extended from relational algebra the relational algebraic transformation rules can directly apply. Now we identify the following transformation rules Relational rules techniques in RDBs They are called relational rules The following set of equivalencies is derived from well-known algebraic optimization C,UC c2 uc commutative law C,n C2  C2 n C commutative law CiD6 Ci=cj CI U c1 c idempotent law C,n CI=cI idempotent law c,-c,=0 c1 u0 c C1nO=O Ci D 60G0 c 0 e 0-c,=0 C c2 e2  CI CI  c2  C3 CI  C2 c3 OPI CIW2  C2UOPl c OPI OP2 Cl  OPl cl CP1.4 P2 Cl ClDC c2 cc2 DC c1 CiDG c2 D6 C3 C2 c3 nAi\(clW2 c1 commutative law commutative law associative law associative law It is a good heuristic to push select, project and time-slice or offset as far down the query graph as possible esp to perform the time-slice as early as possible It has been identified some transformations are incorrect in general 14 A selection can not be pushed through an aggregate operator or offset operator An aggregation operator can not be pushed through an offset operator and vice versa Path transformation rules In OODBs select operation allows its predicate on a contiguous sequence of attributes along a branch of the class-aggregation hierarchy We use the path to express this sort of predicate and the 


34 enhanced path expression to represent the path that includes the time references For simplicity we suppose the time-reference occurs at the end of the path even if it is not, it will only involve the looking up storage and will not provide any difficulty to the query optimization Generally speaking the attribute/domain link between a class C and domain D of one of the attributes A of C creates the join between the class C and 0 in which the attribute A of the class C and identifier OID which is defined by the system and which can be considered as an attribute of class D are join attributes l Therefore, an object query with a path expression involving N classes is equivalent to a relational query which requires the join in N relations corresponding to N classes  11 This is why select operator is usually called an implicit join According to the definition of our algebra when the predicate of select involving a path expression is as path op value=CI.AI.A 2....AnrM op v the equivalence between an implicit join and an explicit join is as CI  7C ci DQP 7Z c2  DUP Cn 1 Ai 0 CI AI A2 AnrM Op U A\(CI We use Dd to represent the join that is slightly different from the join defined in our algebra in that the join attributes are the attribute Ai of the class Ci and identifier OID of C if we join Ci.1 and Ci The project specifies the query target If there is a complex predicate involving a single path such as P  CI AI op VI and CI Ai.Az op v2  and CI.AI Az A vn  Pi and Pz  and P then we have a general form 0 c  n cP,c1 DQ nAZaP2\(cz DQ  DQ apn\(Cn 2 P\(C8 AI Ai AIC where Pi is optional that can be omitted if it does not exist P involves both time and value dimensions and the first project specifies the query target The way to visit the path introduces a path traversal operator. The Linear path traversal operator is a navigational operator N-op[Cl.A 2....A T to execute the implicit join along a path It is equivalent to a set of joins as in equation 2 N-op[Ci AI A2 A  OP,Ci DUP 0 C DQP...D4P OPn\(C 3 A P According to the associative law in previous subsection, the above linear path traversal operator can be further rewritten into the following form N-op[Cl AI A1 A N-op[C AI A  I bap c C N_op[Cl.Al A2 bU c 4 0 C  z A\(C,i\(N-~p[CI.Al _.__ A DQ C 5 Cm A=OlD\(C Thus Cn-i A=olD\(c",nP P\(CI AI A1 i Fig 5 A sample path temporal queries      Fig 6 A operator graph Fig 5 is a single path with n classes Fig 6 gives an operator graph \(OG for equation 5 that involves such a single path An OG is a labelled n-ary tree where the leaf nodes represent collection of objects, the non-leaf nodes represent operators e.g join navigational operator etc and the edges represent temporary collections that can be represented by support tables 


35 4 A support table can be regarded as a collection of tuples of qualified object identifiers and attributes Two support tables can be joined together if there exists a common supported collection between them The execution of an OG follows bottom-up order In order to processing temporal queries we have assumed a temporal class is at the end of a path. Therefore the evaluation of the enhanced path can be initially decomposed by dividing the path into two parts a sub-path with time-referenced class and an ordinary sub-path without time-stamped classes\that can be further divided into sub-paths The decomposition strategy for processing temporal queries can be further illustrated in Fig 7 A complex user query with path expressions that involves time-references is first translated into a set of single path expressions A single path is then divided into two sub-paths a sub-path containing a time-stamped class that can be optimized by making use of the ordering information of temporal data and an ordinary sub-path that can be further decomposed and traversed using different algorithms The intermediate results of traversed two sub-paths are joined together to create the output query Fig 7 A decomposition strategy 5 Processing temporal query components The block B in Fig 6 consists of temporal predicate evaluation as well as time-series processing and a join which can be further expressed in Fig 8 As temporal data provide more opportunities for optimization 7 141 temporal optimization comes into play at this stage When optimizing such a query the object optimizer takes charge of the outer query block and the temporal optimizer operates on the nested query block Each optimizer is responsible for its own query blocks 5.1 Time-related operations and optimization Predicate evaluation in Fig 8 involves the time-related operation and value evaluation Temporal operations such as time-slice offset aggregation can be treated as methods and its output can then participate in the value evaluation. Temporal optimizer must be sure to 221plan\222 the evocation of function and make use of the ordering information for optimization. Stream processing approach is a strategy for optimization utilising the ordering information of data 7 141 5.2 Join Let C and D represent the supporting tables or the intermediate results of block A in Fig 6 and B\222 in Fig 8 as shown in Fig 9 There are various join algorithms to join C and D together The advantage in representing it as an explicit join is that we can use well-known join algorithms to perform optimization Here a temporal object stands as a 221blob\222 object that can be treated as an ordinary object in a snapshot OODB Two basic types ofjoins are: forward join and reverse join Forward-Join FJ The idea of FJ can be informally presented as follows l Given a pair of classes C and 13 such that D is the domain of an attribute A of C the values of that attribute A are identifiers of 


36 the instances of class D If classes C and D are in this order in a given permutation the join between these classes is obtained by the following operations ForcinCdo begin retrieve c.A a  B  OID\(d A is single-valued C    i g g rzg all0 n upport lable f block A retrieve d in D such that tc  OID\(d A is multi-valued evaluate the predicate on d end sub-path Fig 8 Further decomposition of temporal Implementation of forward join can integrate pointer-chasing with well-known join algorithms for optimization, such as pointer-based nested loops pointer-based sort-merge and pointer-based hybrid-hash etc 151 If however the permutation involves retrieving the instances in class D before the retrieval of the instances in C then the following reverse join schema will apply Reverse-Join RJ The idea of RJ can be informally presented as follows  13 ford in D do retrieve u=OID\(d evaluate the predicate on d retrieve c in C such that c.A=u ifA is single-valued u~c.A ifA is multi-valued end begin  Z Fig 9 Join between block A and block B As there is no direct link from D collection to C a value-based join must be used to check the OID membership condition. This algorithm is efficient when the predicate in the last collection is selective It performs value-based comparisons of OIDs which is generally inefficient on a CPU 4 Again, the implementation can employ relational algorithms of nest loop join sort-merge join etc 6 Conclusions In this paper we present a uniform framework for processing temporal object-oriented queries The temporal data model presented is of a hierarchical structure it forms the relational-like cubes but with aggregation and inheritance associations as it is evolved from the unified model of RDB and OODB that is in tum extended from the relational model A query algebra that is thereby defined to provide an access of objects through these associations of aggregation inheritance and time-reference possesses the property of reducibility i.e when the time-reference is not taken into account it will be reduced to the object algebra that in tum will be reduced the relational algebra when the hierarchies of aggregation and inheritance do not exist. The hierarchical structure of data model and the reducibility of query algebra provide a basis to extend existing query processing and evaluation techniques for temporal object query processing Query transformation can then be carried out based on a set of algebraic transformation rules identified A strategy of decomposition is then proposed for processing temporal queries that involve paths That is evaluation of an enhanced path which is defined to refer to the path with the time-reference is decomposed by 


37 initially dividing the path into two sub-paths one containing the time-stamped class that can be optimized by making use of the ordering information of temporal data and another an ordinary sub path with no time-stamped class which can be further decomposed and evaluated using different algorithms. The intermediate results of traversed two sub-paths are then joined together to create the query output It has been shown that techniques developed for relational join pointer-based join and sequential processing can be adapted to process the decomposed temporal query components 4 temporal object is defined as a time series which can be treated as a function of time, that avoids thie complexity of a general temporal relational join Temporal optimizer is built on the top of object optimizer that requires less modification of object optimizer since the techniques of object-oriented query processing and evaluation as well as sequence processing can directly apply Future work will involve a detailed study of execution algorithms and cost analysis References 1 Bertino E and Martino L 1993 Object-Oriented Database Systems Concepis and Architecrures Addison-Wesley Publishers Ltd 2 DAndrea A and Janus P 1996 UNISQL's next-generation object-relational database management system SIGMOD RECORD 25\(3 3 Dayal U and Wuu G.T.J 1992. A uniform approach to processing temporal queries Proc ofthe 18th lnt Con on VLDB p407-417 Canada 4 Gardarin G er al 1996. Cost-based selection of path expression processing algorithms in object-oriented databases Proc offhe 22th Int Con on VWB p 390-401, Mumbai, India 5 Ginsburg S 1993 A temporal data model based on time sequences Temporal Databases Theory, Design and Implementation edited by A U Tansel er al p248-270 Benjamin Cummings Publishing 6 Kim W 1993. Object-oriented databases systems: promises, reality, and future Proc ofthe 19th Int Con on VLD6 p676-687, Dublin, Ireland 7 hung T.Y.C., and Muntz R.R 1993 Stream Processing: Temporal Query Processing and Optimization Temporal Databases: Theory, Design and Implementarion edited by A.U Tansel et al p329-355 Benjamid Cummings 8 Ozsoyoglu G and Snodgrass R T 1995. Temporal and real-time databases a survey IEEE Trans on Knowledge and Data Engineering 7\(4 9 Ozsu M T and Blakeley J A 1995 Query processing in object-oriented database system Modem Database Sysrems the Object Model Interoperabiliry and Beyond edited by W Kim p146-174 ACM Press 10 Pissinou N et al 1993 On temporal modelling in the context of object databases SIGMOD RECORD 22\(3\8-15 11 Pissinou N et al 1994. Towards an infrasmcture for temporal databases report of an invitational ARPmSF 12. Segev A 1993 Join processing and optimization in temporal relational databases Temporal Databases Theoiy 13. Segev A et al 1995. Report on the 1995 international workshop on temporal databases SIGMOD RECORD 24\(4 14. Seshadri P et al 1996. The design and implementation of a sequence database system Proc of the 22th Int Con on 15 Shekita E J and Carey M.J 1990 A performance evaluation of pointer-based joins Proc ofACM SIGMOD Conf 16 Snodgrass R 1995. Temporal object-oriented databases a critical comparison Modem Database Systems the Object 17 Wang L Wing M Davis C and Revell N 1996 An algebra for a temporal object data model LNCS 1134 18 Wang, L Wing M Davis, C and Revell N 1996 Query processing in object-oriented databases Proc of 13th workshop SIGMOD RECORD 23\(1 35-51 Design and Implementation edited by A.U Tansel er al p356-387. Benjamin/ Cummings 46-52 VWB p 99-1 IO India 300-311 Atlantic NJ Model, Interoperabilify and Beyond edited by W Kim\p 386-408. ACM Press Database and en Systems Applications p667-677, Proceedings Zurich Switzerland European Meeting on Cybemetics and System Research p803-808 Vienna Austria 


CMP A Fast Decision Tree Classifier Using Multivariate Predictions  449 H Wang and C Zaniolo Mining Recurrent Items in Multimedia with Progressive Resolution Refinement  461 0 Zai'ane J Hun and H Zhu Panel Session 22 Is E-Commerce a New Wave for Database Research Moderator Anant Jhingran IBM T.J Watson Research Center USA Panelists Sesh Murthy IBM T.J Watson Research Center USA Sham Navathe, Georgia Institute of Technology USA Hamid Pirahesh IBM Almaden Research Center USA Krithi Ramamrithan University of Massachusetts-Amherst USA Industrial Session 23 Java and Databases Pure Java Databases for Deployed Applications  477 N Wyatt Database Technology for Internet Applications  700 A Nori Session 24 Association Rules and Correlations Finding Interesting Associations without Support Pruning  489 E Cohen M Datar S Fujiwara A Gionis P Indyk R Motwani J Ullman and C. Yang Dynamic Miss-Counting Algorithms Finding Implication and Similarity Rules with Confidence Pruning  501 S Fujiwara J Ullman and R Motwani Efficient Mining of Constrained Correlated Sets  512 G Grahne L Lakshmanan and X Wang Session 25 Spatial and Temporal Data Analyzing Range Queries on Spatial Data  525 J Jin N An and A Sivasubramaniam Data Redundancy and Duplicate Detection in Spatial Join Processing  535 J.-P Dittrich and B Seeger Query Plans for Conventional and Temporal Queries Involving Duplicates and Ordering  547 G Slivinskas C Jensen, and R Snodgrass xi 


Industrial Session 26 XML and Databases Oracle  The XML Enabled Data Management System  561 S Banerjee V Krishnamurthy M Krishnaprasad, and R Murthy XML and DB2  569 J Cheng and J Xu Session 27 High-Dimensional Data Independent Quantization An Index Compression Technique for High-Dimensional Data Spaces  577 S Berchtold, C Bohm H Jagadish H.-P. Kriegel and J Sander Deflating the Dimensionality Curse Using Multiple Fractal Dimensions  589 B.-U Pagel F Korn and C. Faloutsos Similarity Search for Multidimensional Data Sequences  599 S.-L Lee S.-J Chun D.-H Kim, J.-H Lee and C.-W Chung Session 28 Web-Based Systems WRAP An XML-Enabled Wrapper Construction System for Web Information Sources  611 L Liu C Pu and W. Hun Self-Adaptive User Profiles for Large-scale Data Delivery  622 U Cetintemel M Franklin and C. Giles Industrial Session 29 Main Memory and Small Footprint Databases In-Memory Data Management in the Application Tier  637 The TimesTen Team SQLServer for Windows CE -A Database Engine for Mobile and Embedded Platforms  642 P Seshadri and P. Garrett Join Enumeration in a Memory-Constrained Environment  645 I Bowman and G Paulley xii 


Plenary Panel Session 30 XML Databases   Moderator: Michael Carey, IBM Almaden Research Center USA Panelists Adam Bosworth, Microsoft Corporation USA David De Witt University of Wisconsin-Madison, USA Alon Levy University of Washington USA Bruce Lindsay IBM Almaden Research Center USA Jennifer Widom Stanford University USA Demo Session 1 Web Query Optimizer  661 V Zadorozhny L Bright L Raschid T Urhan and M Vidal ReQueSS: Relational Querying of Semi-structured Data  664 R Sunderraman The IDEAL Approach to Internet-Based Negotiation for E-Business  666 J Hammer C Huang Y Huang C Pluempitiwiriyawej M Lee H Li L Wang Y Liu and S Su READY A High Performance Event Notification Service  668 R Gruber B Krishnamurthy, and E Panagos A Multimedia Information Server with Mixed Workload Scheduling  670 G Nerjes DISIMA An Object-Oriented Approach to Developing an Image Database System  672 V Oria T Ozsu P Iglinski B Xu and L Cheng Demo Session 2 The Collaboration Management Infrastructure  677 H Schuster D Baker A Cichocki D Georgakopoulos and M Rusinkiewicz Assisting the Integration of Taxonomic Data The LITCHI Toolkit  679 I Sutherland J Robinson S Brandt A Jones S Embury W Gray R White and F Bisby TheaterLoc: Using Information Integration Technology to Rapidly Build Virtual Applications  681 G. Barish Y.4 Chen D Dipasquo, C Knoblock S Minton I Muslea and C Shahabi Lineage Tracing in a Data Warehousing System  683 Y Cui and J Widom xiii 


The Mentor-Lite Prototype A Light-Weight Workflow Management System  685 J Weissenfels M Gillmann 0 Roth, G Shegalov and W Wonner Location Prediction and Queries for Tracking Moving Objects  687 0 Wolfson B Xu and S Chamberlain Semiorder Database for Complex Activity Recognition in Multi-Sensory Environments  689 S Bhonsle A Gupta S Santini and R Jain Tutorial 1 Web Information Retrieval  693 M Henzinger Tutorial 2 Mobile and Wireless Database Access for Pervasive Computing  694 P Chrysanthis and E Pitoura Tutorial 3 Data Mining with Decision Trees  696 J Gehrke Tutorial 4 Directories Managing Data for Networked Applications  697 D Srivastava Tutorial 5 Indexing High-Dimensional Spaces Database Support for Next Decade\222s Applications  698 S Berchtold and D Keim xiv 


 T5.I2.D100K T10.I4.D100K T15.I4.D100K T10.I6.D400K T10.I6.D800K T10.I6.D1600K Optimizations across Databases 5 0 5 10 15 20 25 30 35 40 45 Improvement COMP TREE COMP-TREE 1 2 4 8 1 2 4 8 1 2 4 8 2 4 8 2 4 8 1 2 4 8 Processors Databases Figure 5 Effect of Computation and Hash Tree Balancing good as the COMP optimization The reason that the hash tree balancing is not suf\336cient to offset inherent load imbalance in the candidate generation in this case The most effective approach is to apply both optimizations at the same time COMP-TREE The combined effect is suf\336cient to push the improvements in the 40 range in the multiple-processor case On 1 processor only hash tree balancing is bene\336cial since computation balancing only adds extra cost 5.4 Short-circuited Subset Checking Figure 6 shows the improvement due to the short-circuited subset checking optimization with respect to the unoptimized version The unoptimized version is the Apriori algorithm due to Agrawal et al 5 The results are presented for dif ferent number of processors across dif ferent databases The results indicate that while there is some improvement for databases with small transaction sizes the optimization is most effective when the transaction size is large In this case we get improvements of around 25 r the unoptimized version To gain further insight into this optimization consider 336gure 7 It shows the percentage improvement obtained per iteration on applying this optimization on the T20.I6.D100K database It shows results only for the uni-processor case r similar results were obtained on more processors We observe that as the iteration k increases there is more opportunity for shortcircuiting the subset checking and we get increasing bene\336ts of up to 60 The improvements start to fall off t the high end where the number of candidates becomes small resulting in a small hash tree and less opportunity for short-circuiting It becomes clear that is an extremely effective 15 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 T5.I2.D100K T10.I6.D800K T15.I4.D100K T20.I6.D100K procs across Databases 0 5 10 15 20 25 Improvement 1 2 4 8 Figure 6 Effect of Short-circuited Subset Checking 23456789101112 Iterations 0 10 20 30 40 50 60 improvement T20.I6.D100K Figure 7  Improvement per Iteration  proc   16 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


optimization for larger transaction sizes and in cases where there are large number of candidate k itemsets 6 Conclusions In this paper e presented a parallel implementation of the Apriori algorithm on the SGI Power Challenge shared memory multi-processor We also discussed a set of optimizations which include optimized join and pruning computation balancing for candidate generation hash tree balancing and short-circuited subset checking We then presented experimental results on each of these Improvements of more than 40 were obtained for the computation and hash tree balancing The short-circuiting optimization was found to be extremely effective for databases with large transaction sizes Finally we reported the parallel performance of the algorithm While we d good speed-up we observed a need for parallel I/O techniques for further performance gains References  R Agra wal T  Imielinski and A Swami Database mining A performance perspecti v e  I n IEEE Trans on Knowledge and Data Engg  pages 5\(6 1993  R Agra wal T  Imielinski and A Swami Mining association rules between sets of items in lar ge databases In Proc M SIGMOD Intl Conf Management of Data  May 1993  R Agra wal H Mannila R Srikant H T o i v onen and A I V erkamo F ast disco v ery of association rules In U F et al editor Advances in Knowledge Discovery and Data Mining  MIT Press 1996  R Agra wal and J Shafer  P arallel mining of association rules design implementation and e xperience Technical Report RJ10004 IBM Almaden Research Center San Jose CA 95120 Jan 1996  R Agra wal and R Srikant F ast algorithms for mining association rules In Proc 20th VLDB Conf  Sept 1994  M Cierniak W  Li and M J Zaki Loop scheduling for heterogeneity  I n 4th IEEE Intl Symposium on High-Performance Distributed Computing also as URCS-TR 540 CS Dept Univ f Rochester  Aug 1995  M Holsheimer  M  K ersten H Mannila and H T o i v onen A perspecti v e on databases and data mining In 1st Intl Conf Knowledge Discovery and Data Mining  Aug 1995  M Houtsma and A Swami Set-oriented mining of association rules In RJ 9567  IBM Almaden Oct 1993  H Mannila H T o i v onen and I V erkamo Ef 336cient algorithms for disco v ering association rules In AAAI Wkshp Knowledge Discovery in Databases  July 1994  J S P ark M Chen and P  S Y u  A n e f fecti v e hash based algorithm for mining association rules In Proc M SIGMOD Intl Conf Management of Data  May 1995 17 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 J S P ark M Chen and P  S Y u  E f 336cient parallel data mining for association rules T echnical Report RC20156 IBM T J Watson Research Center Aug 1995  G Piatetsk y-Shapiro Disco v ery  presentation and analysis of strong rules In G P S et al editor  KDD  AAAI Press 1991  A Sa v asere E Omiecinski and S Na v athe An ef 336cient algorithm for mining association rules in large databases In Proc 21st VLDB Conf  1995  M J Zaki M Ogihara S P arthasarathy  and W  Li P arallel data mining for association rules on shared-memory multi-processors Technical Report 618 Department of Computer Science University of Rochester 618 1996 18 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


