Data Mining Library Reuse Patterns in User-Selected Applications Amir Michail Dept of Computer Science and Engineering University of Washington Box 352350 Seattle WA 98195-2350 USA amir@cs.washington.edu Abstract In this paper we show how data mining can be used to discover library reuse patterns in user-selected applications This can be helpful in building and debugging applications that use a particular library by observing how other devel 
opers have used that library in their applications Speci\002cally we consider the problem of discovering association rules that identify library components that are often reused in combination by application components For example such a rule might tell us that application classes that inherit from a particular library class often override certain member functions By querying and/or browsing such association rules a 
developer can discover patterns for reusing library components We illustrate the approach using our tool CodeWeb by demonstrating characteristic ways in which applications reuse components in the ET application framework Keywords Software libraries software reuse data mining 1 Introduction Once a software library has been selected for a project there is still the substantial problem of training developers 
to use it This process is complicated by the fact that using a software library often requires some understanding of its fundamental components their relationships and various interactions between them This is particularly true with frameworks which tend to impose a structure on the application For example one often needs to know the fundamental classes in a framework their interactions and which methods should be overridden and how Current methods for learning to use a software library 
include reading the manual and/or books as well as taking a course Sparks Benner and Faris give this advice for framework reuse expect to train every staff member who will use a framework This often means having individuals attend a one-week course at the vendor site or training large groups at the project site 23 p A crucial aspect of these techniques is that example programs are used throughout to illustrate how to use the li 
brary Indeed most libraries come with many example programs to get the developer started Such example programs 227 whether in manuals/books or packaged with libraries 227 are particularly helpful because they demonstrate characteristic reuse of the library components by experienced software developers However they also tend to be toy programs which limits their scope considerably For example a user that needs to develop an application that makes heavy use of text drawing primitives 
may not be satis\002ed with toy examples that demonstrate only the most rudimentary concepts of the GUI domain One can explore additional reuse experience by going beyond toy examples distributed with a library and actually 002nding real-life applications written by others that also use that library With the emergence of the open source movement such applications and their source code are now in abundance on the internet This is also possible in large software companies where developers in one group may learn 
from applications written by another group However unlike toy examples it is more dif\002cult to learn characteristic reuse patterns in larger applications since there is so much source to browse To be sure there is valuable reuse experience to be gained but it is implicitly encoded and scattered throughout thousands of lines of code 


For this reason it is desirable to have tools that tell us explicitly the characteristic library reuse patterns in large applications To this end we have explored techniques used in data mining which are designed to 002nd patterns in vast collections of data The primary motivation for data mining has been in its potential to give a business a competitive advantage by better utilizing customer data 13 1 In this paper we show how data mining can be used to discover library reuse patterns in user-selected applications This can be helpful in building and debugging applications that use a particular library by observing how other developers have used that library in their applications Speci\002cally we consider the problem of discovering association rules that identify library components that are often reused in combination by application components For example such a rule might tell us that application classes that inherit from a particular library class often override certain member functions By querying and/or browsing such association rules a developer can discover patterns for reusing library components Moreover the association rules can be used to automatically warn developers when their application reuses library components in a way that differs from characteristic usage in applications written by others The paper is organized as follows Section 2 introduces the 002eld of data mining and discusses the problem of mining association rules Section 3 presents the concept of 223reuse boundaries\224 which we developed in earlier work 17 S ection 4 shows how to mine association rules in reuse boundaries to discover characteristic library reuse patterns in existing applications Section 5 presents experimental results Section 6 discusses related work Section 7 summarizes the work concluding with a number of open questions 2 Data Mining Data mining may be de\002ned as follows The process of discovering meaningful new correlations patterns and trends by sifting through large amounts of data stored in repositories and by using pattern recognition technologies as well as statistical and mathematical techniques 16 Data mining is widely used in business to gain a competitive edge For example credit card companies use data mining to approve credit card applications analyze credit holders buying behavior and detect fraud As another example retailers use data mining to understand customers buying habits and preferences An effective data mining application in the retail environment is shopping basket analysis  Progress in bar-code technology has made it possible to store basket data that stores items purchased on a per-transaction basis By using data mining technology one can 002nd patterns in items that are bought in combination Shopping basket analysis is often done by mining association rules 1 2 F o rmal l y  t he probl em i s t h e f ol l o wi ng Let I  f i 1 i 2 i m g be a set of literals called items Let D be a set of transactions where each transaction T is a set of items such that T 022 I  An association rule is an implication of the form 000 V x 2 X x 001  020 V y 2 Y y 021  which we write more compactly as X  Y where X 032 I  Y 032 I and X  Y    For example suppose that people who purchase bread and butter also purchase milk In that case the corresponding association rule is 223bread  butter  milk\224 The antecedent of the rule X consists of bread and butter and the consequent Y consists of milk alone Such rules are useful for analyzing data For example to determine how one might boost the sales of milk one could look for rules that have 223milk\224 in the consequent To determine the impact of discontinuing the sale of butter one could 002nd all rules that have 223butter\224 in the antecedent Incidently observe that as we are using sets throughout an item that occurs multiple times in a transaction is not treated any differently from one that occurs only once We say that a rule X  Y holds in the transaction set D with con\002dence c  if c  of transactions in D that contain X also contain Y Therule X  Y has support s  in the transaction set D if s  of transactions in D contain X  Y  Returning to our example suppose we 002nd that in 90 of transactions in which customers purchase bread and butter they also purchase milk Moreover say that 5 of transactions include all three items bread butter and milk In that case the con\002dence of the rule 223bread  butter  milk\224 is 90 while its support is 5 Support should not be confused with con\002dence While con\002dence is a measure of the rule's strength support corresponds to its statistical signi\002cance 1 p For example a rule a  b  c may have much higher con\002dence than a  c  which means that whenever we encounter a in a transactions it is more likely we 002nd c if b is also present So in that sense a  b  c is stronger than a  c and we should take it more seriously in our analysis of the data As a side note this notion of rule strength is different from logical implication in which case a  c would be considered stronger because it implies a  b  c  Now it may be that a  c has much higher support than a  b  c  This means that the con\002dence estimate for a  c is more reliable than that for a  b  c  So while a  b  c may be a much stronger rule we should still consider weaker rules such as a  c forwhichweare more certain of their con\002dence In this sense support is a measure of statistical signi\002cance However it is by com 


paring support numbers across several rules that we obtain insight into the relative statistical signi\002cance of the rules individual support numbers on their own are not as helpful Given a set of transactions D  the problem of mining association rules is the following Generate all association rules that have support and con\002dence greater then some user-speci\002ed minimum support and minimum con\002dence Several algorithms have been presented in the literature for 002nding all such association rules 1 2 3 4 24  T he part i c ular algorithm used in our experiments is Apriori 2 which works in two phases 1 it 002nds all sets of items that have support above the minimum support and 2 it uses these sets to generate all rules whose con\002dence is above the minimum con\002dence For additional details on this and other algorithms see the references cited above In Section 4 we mine association rules to identify library components that are often reused in combination by application components For example such a rule might tell us that application classes that inherit from a particular library class often override certain member functions Before showing how this is done we 002rst introduce the notion of 223reuse boundaries\224 in the following section 3 Reuse Boundaries In this section we present the concept of reuse boundaries which we developed in earlier work 17 R e us e boundaries show reuse relationships that cross from one software system to another That is those reuse relationships that are at the 223boundary\224 of the two software systems We use a directed graph to denote a reuse boundary where the nodes represent components and the edges represent reuse and membership relationships between them 3.1 Boundary Nodes Each node denotes a component  which is either a class or a function We consider any type as a class whether it appears in the source as a struct class interface or union Moreover we include all functions whether they are members of a class or not 3.2 Boundary Edges Edges represent reuse and membership relationships By reuse relationships we mean class inheritance and instantiation as well as function invocation and overriding We elaborate on these relationships in what follows 3.2.1 Membership In object-oriented languages classes contain member functions If class C contains a member function f thenwealso say that f is a member function of C  the relationship goes both ways 3.2.2 Class Inheritance and Instantiation The two most common techniques for reuse in software libraries are class inheritance and instantiation While we use the familiar notion of 223inheritance\224 we mean something quite speci\002c by 223instantiation\224 Speci\002cally we say that class or function A instantiates class B if and only if 1 it declares a possibly pointer variable of type B  and 2 that variable denotes a new instance of B created by A  It is not suf\002cient to merely declare a pointer to an instance of B created by a class/function other than A  Finally observe that if A is a class then the instantiation relationship reduces to the composition relationship since B is an intrinsic part of A  3.2.3 Function Invocation and Overriding The invocation relationship is a reuse relationship that indicates a call from one function to another We also look for the member function overriding relationship which acts like a callback from the base class to the derived class For example if class A inherits from base class B and overrides f  then we can view B as making a callback into class A  The reuse relationship is backward since B s f reuses A s f since any calls to it are diverted to A s f  3.3 Boundary Graph Given two software systems such as a software library and application the reuse boundary between them contains 1 components in the software systems that are involved in a direct reuse relationship that crosses from one software system to the other in either direction and 2 all relationships including membership relationships between components determined to be in the reuse boundary For example an application may have a component myWidget that inherits from a library component Widget In such a case Widget and myWidget are in a direct reuse relationship that crosses from one software system to another so both components go into the reuse boundary as well as the inheritance relationship between them directed from myWidget to Widget  The reuse relationship may also go the other way from the library to the application This is the case with the overriding relationship Suppose Widget de\002nes paint which is overridden in myWidget  In that case there is 


an overriding relationship from the paint member function in Widget to the paint member function in myWidget  Consequently both paint member functions go into the reuse boundary along with the overriding relationship between them directed from Widget s paint to myWidget s paint  Finally since we have determined that Widget myWidget  and their member functions paint are in the reuse boundary we also include the bidirectional membership relationship between Widget and its member function paint as well as that between myWidget and its member function paint  4 Mining Reuse Boundaries Now that we have introduced association rule mining in Section 2 and reuse boundaries in Section 3 we can demonstrate how to mine association rules in reuse boundaries to discover library reuse patterns in existing applications Speci\002cally we will identify library components that are often reused in combination by application components We do this in a way analogous to that described in Section 2 for discovering items that are typically purchased together in basket data Suppose we have a library L and sample applications A 1 A n  We 002rst compute reuse boundaries B  L A 1  B  L A 2  B  L A n   To simplify the exposition suppose no two applications share an identical application component that is a 2 A j implies a 62 A k for k 6  j  Now for every reuse boundary B  L A j  and for each application component a 2 B  L A j   we construct a transaction T a  f i 1 i m g where the items are those library components involved in a direct reuse relationship with a in B  L A j   Each item i k is of the form  type of reuse relationship    library component involved in reuse relationship   For example if an application component myWidget inherits from a library component Widget and overrides its member function paint  then we construct a transaction T myWidget  f class inherits Widget member function overrides paint g  Now given the set of transactions D  f T a j a 2 B  L A j  for some j g  we generate all association rules that have support and con\002dence greater than some userspeci\002ed minimum support and minimum con\002dence Returning to our example suppose we 002nd that 1 f class inherits Widget member function overrides paint g occurs as a subset of suf\002ciently many transactions to satisfy the support requirement and 2 suf\002ciently many transactions that contain class inherits Widget also contain Application Lines Transactions Draw 5,157 114 Write 5,016 109 ProgEnv 5,721 177 DebuggerFW 10,939 211 FileBrowser 1,565 62 IconEdit 1,781 56 TroffTool 1,210 38 ER 698 33 BrowseFW 463 21 VObEdit 371 20 Total 32,921 841 Table 1 Sample applications used to discover reuse patterns in the ET framework member function overrides paint to satisfy the con\002dence requirement In such a case we would generate the association rule class inherits Widget  member function overrides paint 5 Experimental Results To illustrate how mining reuse boundaries can be helpful in 002nding library reuse patterns we have performed experiments using the ET application framework 2 T h i s C framework provides not only GUI components but also ones for basic data structures and object input/output The particular version that we used in our experiments is 3b4 which consists of 52,724 lines of code We used ten sample applications to discover characteristic reuse patterns in ET Draw Write ProgEnv DebuggerFW FileBrowser IconEdit TroffTool ER BrowseFW and VObEdit Although these are among the examples distributed with the framework they are not toy programs In particular seven of these programs contain over 1,000 lines of code four contain over 5,000 lines and one has over 10,000 lines of code The combined line count for all applications is 32,921 The number of transactions as de\002ned in Section 4 for all ten applications is 841 Refer to Table 1 for individual application statistics We have built a reuse tool CodeWeb which follows the methodology described in Section 4 We ran the tool on ET and the ten sample applications to generate association rules with con\002dence of at least 25 and support of at least 35 As there are 841 transactions a support of 35 means rules must be supported by at least three transactions To keep the complexity of the computation down we restricted the form of the rules to a single literal in the antecedent and a single literal in the consequent The tool generated 8477 such rules 


Figure 1 The reuse boundary intersection for Draw and Write Clearly browsing thousands of association rules to identify reuse patterns is not feasible One possibility is to use these rules to automatically check whether an application being developed reuses library components in a way that is consistent with characteristic usage in the sample applications Moreover to reduce false warnings one might generate only association rules with suf\002ciently high con\002dence and support Another possibility is to manually explore the rules through a combination of querying and browsing We follow this approach in the remainder of this section Of course in doing so we also provide evidence that an automatic checker has potential utility while building and debugging applications that use a particular library In what follows we take a two step approach to exploring reuse patterns 1 we examine the reuse boundaries to identify fundamental library components and 2 we use a combination of querying and browsing of the association rules to discover characteristic reuse patterns involving such components 5.1 General Reuse Patterns In this section we consider reuse patterns of a general nature In particular we are interested in those reuse patterns that we expect to 002nd in a wide variety of applications based on the ET application framework One way to identify such patterns is to begin by 002nding fundamental library components that are reused in different kinds of applications To this end we consider the reuse boundaries for sample applications Draw and Write These applications are different in the sense that the Draw application is mostly graphical while the Write application is mostly concerned with text Generally speaking looking at different applications can be useful in determining important aspects of a library that are applicable to most applications independent of their purpose While we can look at the reuse boundaries separately for Draw and Write we shall 002rst consider components in the intersection of the two boundaries The reuse boundary intersection contains those library components and their relationships that are reused in both applications Consequently they tend to be particularly fundamental Figure 1 shows the reuse boundary intersection of Draw and Write Graphically our tool represents components in 


shaded rectangles and distinguishes classes from functions by a 223 suf\002x appended to function names Instantiation and inheritance relationships are shown by light and dark edges respectively Direct and indirect relationships are indicated by solid and dashed lines respectively Self-loops indicate method overriding in the library Bidirectional arrows indicate membership relationships Observe that the reuse boundary intersection directs the user to important framework classes such as Document  View  Command  Application  Object  VObject i.e visual object as well as relationships between them such as the fact that VObject instantiates Rectangle and inherits from Object The second step in our technique is to use a combination of querying and browsing to identify association rules pertaining to these fundamental library components For example if we were interested in reusing the Command class we could perform a query that 002nds all association rules with 223class inherits Command\224 in the antecedent and where the output is sorted in decreasing order by rule con\002dence One might then browse the results and perform additional queries We have followed such a procedure to identify association rules for classes Command  Application  Document  and View  A sampling of the rules is shown in Table 2 In addition to the support percentages we also include the actual number of transactions supporting each rule in parentheses From these rules one can learn important aspects about writing applications using ET For example while it may be apparent from Figure 1 that ET provides support for undo/redo since class Command has members DoIt and UndoIt  we obtain additional information concerning typical reuse of the Command class through the corresponding association rules See Table 2 part a In particular application classes that inherit from Command often override DoIt  UndoIt TrackMouse and TrackFeedBack  See rules 1\2264 Yet surprisingly only 56 of application classes actually override DoIt and UndoIt  It turns out that other application classes reuse Command for its mouse tracking functionality by overriding TrackMouse and TrackFeedBack  However of those application classes that do override DoIt  100 also override UndoIt and vice versa See rules 5 and 6 Moreover observe that while 100 of application classes that override RedoIt also override DoIt  only 57 of application classes that override DoIt also override RedoIt  See rules 7 and 8 Digressing for a moment we consider the utility of knowing that certain member functions tend to be overridden when inheriting from a library class After all member functions like DoIt and TrackMouse are declared virtual in the header 002les so it is not suprising that they would be overridden in applications However the whole point is not all virtual functions are overridden with equal frequency If a member function is overridden most of the time 227 or under certain circumstances 227 then the developer should consider overriding the function in his own application under similar circumstances Moreover our tool CodeWeb provides links into the corresponding application code so a developer can also use the same applications used for data mining to also demonstrate how the library components are actually reused in practice For example it may not be clear what code to write to override the DoIt and UndoIt member functions until you see it done in several sample applications Now returning to our example let's examine the reuse patterns for the Application class See part b rules 1\2268 Speci\002cally we 002nd that many classes that inherit from Application override DoMakeDocuments and some also override About  CanOpen  DoMakeManager and ExtCommand  Moreover of those that override ExtCommand  100 also call ExtCommand in the base class and vice versa See rules 7 and 8 Examination of the source shows that any commands with which the application is not familiar are diverted by a call to the Application base class for further processing Finally one can infer that developing an application using ET involves separating its model i.e data structure from its view the way it is depicted on the screen One can verify this by examining the source to Document and View respectively Again the corresponding association rules also yield useful information See parts c and d For example application components that inherit from Document often override DoMakeContent  DoMakeMenuBar  DoSetupMenu  Control and some also override CanLoad and ReturnObjectToStore Byexamining the source code one could infer among other things that DoMakeMenuBar creates the applications menu bar  and that ReturnObjectToStore returns that aspect of the model state that is to be stored on disk Also observe that 100 of application components that override CanLoad also override ReturnObjectToStore and vice versa Again one would see how to override these member functions by example in the sample applications While the reuse boundary intersection is a good place to start exploration it is worthwhile to later examine the individual reuse boundaries for other useful library classes For example the library class Dialog is not present in the reuse boundary intersection but is reused by application Write and many other GUI-based applications Since Dialog is typically reused many times in such applications we 002nd that the association rules inferred have higher support than the rules considered earlier in this section See part e 


Part Association Rules Conf Support a 1 class inherits Command  member function overrides DoIt 56 59 5 2 class inherits Command  member function overrides UndoIt 56 59 5 3 class inherits Command  member function overrides TrackMouse 56 59 5 4 class inherits Command  member function overrides TrackFeedBack 44 48 4 5 member function overrides DoIt  member function overrides UndoIt 100 83 7 6 member function overrides UndoIt  member function overrides DoIt 100 83 7 7 member function overrides RedoIt  member function overrides DoIt 100 48 4 8 member function overrides DoIt  member function overrides RedoIt 57 48 4 b 1 class inherits Application  member function overrides DoMakeDocuments 75 1.1 9 2 class inherits Application  member function overrides About 42 59 5 3 class inherits Application  member function overrides CanOpen 33 48 4 4 class inherits Application  member function overrides DoMakeManager 25 36 3 5 class inherits Application  member function calls ExtCommand 25 36 3 6 class inherits Application  member function overrides ExtCommand 25 36 3 7 member function calls ExtCommand  member function overrides ExtCommand 100 71 6 8 member function overrides ExtCommand  member function calls ExtCommand 100 71 6 c 1 class inherits Document  member function overrides DoMakeContent 100 1.1 9 2 class inherits Document  member function overrides DoMakeMenubar 89 95 8 3 class inherits Document  member function overrides DoSetupMenu 67 71 6 4 class inherits Document  member function overrides Control 56 59 5 5 class inherits Document  member function overrides CanLoad 44 48 4 6 class inherits Document  member function overrides ReturnObjectToStore 44 48 4 7 member function overrides CanLoad  member function overrides ReturnObjectToStore 100 48 4 8 member function overrides ReturnObjectToStore  member function overrides CanLoad 100 48 4 d 1 class inherits View  member function overrides Draw 86 71 6 2 class inherits View  member function calls GrPaintRect 86 71 6 3 class inherits View  class instantiates Point 71 59 5 4 class inherits View  class instantiates Rectangle 71 59 5 5 class inherits View  member function calls ForceRedraw 57 48 4 6 class inherits View  member function calls InvalidateRect 57 48 4 7 member function overrides Draw  member function calls GrPaintRect 75 2.1 18 8 member function calls GrPaintRect  member function overrides Draw 90 2.1 18 e 1 class inherits Dialog  member function overrides Control 82 1.7 14 2 class inherits Dialog  member function calls Control 82 1.7 14 3 class inherits Dialog  member function instantiates VObject 82 1.7 14 4 class inherits Dialog  member function overrides DoMakeContent 76 1.5 13 5 class inherits Dialog  member function overrides DoSetup 65 1.3 11 6 class inherits Dialog  member function calls EnableItem 65 1.3 11 7 class inherits Dialog  member function calls ShowOnWindow 65 1.3 11 8 class inherits Dialog  member function instantiates Rectangle 53 1.1 9 Table 2 Association rules for general reuse patterns Not all rules shown 


5.2 Specialized Reuse Patterns Generally speaking looking at the reuse boundaries of a certain kind of applications can help identify library reuse patterns that are useful for other applications of this type Of course we would also 002nd patterns of more general utility also For example by inspecting the reuse boundaries for development tools DebuggerFW and ProgEnv we can 002nd reuse patterns particularly relevant to building other software development tools In particular the reuse boundary intersection for DebuggerFW and ProgEnv contains classes CodeTextView  RegularExp and PrettyPrinter  Moreover ProgEnv additionally reuses classes CodeAnalyzer  AccessMembers and AccessObjPtrs  Searching for association rules with these classes in the antecedent is helpful in identifying their characteristic reuse patterns For example application classes that inherit from CodeTextView tend to override MakePrettyPrinter with 75 con\002dence and 0.36 support Some examination of the source code would show that MakePrettyPrinter determines which pretty printer to use which is a subclass of the PrettyPrinter class mentioned above Finally we should note that rules for specialized patterns tend to have lower support since by de\002nition specialized library components are reused in fewer applications Consequently one must be more careful about the utility of such rules 6 Related Work Various tools have been described in the literature that help developers learn to use a software library Excluding our previous work on reuse boundaries 17  w e d o not know of any other approaches that allow the user to select sample applications to demonstrate characteristic reuse of library components Data mining association rules in reuse boundaries improves upon our previous work by automatically identifying library components that are often reused in combination in applications Inferring this information in a manual way from many large reuse boundaries is impractical 227 particularly if one is interested in the con\002dence and support of the association rules Other researchers have used data mining techniques in the software engineering domain but for different purposes For example data mining has been used to decompose a software system into data cohesive subsystems to assist developers with reengineering and maintenance tasks 8 9 As another example a related technology machine learning  has been used in reengineering class hierarchies 22 and generating test cases Perhaps closest to our approach is a technique for extracting speci\002cations from software using machine learning 7  I n t hi s w ork i n s t rument ed code i s run o n a number of representative test cases generating examples of its behavior Inductive learning techniques are then used to generalize these examples forming a general description of some aspect of the system's behavior However this research differs from our own in that the sample inputs are used to extract speci\002cations while we use sample applications to discover characteristic reuse patterns In what follows we shall describe some tools that are speci\002cally designed to help developers learn to use a library and others that are more general in nature but are useful none-the-less useful for this purpose As discussed elsewhere 12 s u ch t ool s can be cat e gori zed as bot t o m-up or top-down We follow this distinction in the following presentation of related work 6.1 Bottom\255up Approaches Bottom-up approaches require that the user select and assemble architecturally compatible sets of components from a software library For example component retrieval tools are concerned with 002nding components that 002t a particular need Such work includes tools that use free-text indexing 11  f acets  21  and s peci\002cation m atching  18  Although these tools may help a developer 002nd individual components of interest they do not show how these components can be used in combination There are also tools that help a developer examine a software library in terms of architecture style etc 6 14 26 This may be helpful in understanding the design of the library which would facilitate reuse 227 particularly with frameworks However such tools require a bottom-up approach to understanding the essential components their relationships and collaborations These bottom-up approaches to learning to use a software library are akin to solving a Jigsaw puzzle 12 It i s not clear which components 002t together and how 6.2 Top\255down Approaches Top-down approaches start out with a subset of the software library that is particularly fundamental and typically reused in most applications One can learn from this subset and adapt or extend it to build a new application For example active cookbooks 20 and M i c ros o ft W i zards guide the developer through common tasks such as subclassing key classes where the developer is asked to answer some questions and skeleton code is generated automatically that reuses key library classes and provides a starting point for development 


However such methods are only applicable for the tasks for which they were designed and may not help the developer's fundamental understanding of the library Also there is no guarantee that the developers of the library would foresee all typical applications of that library Finally these methods simply generate skeleton code they do not present the user with examples on how to 002ll in and extend this skeleton code While there has been other research on the use of examples to illustrate software reuse 10 1 t h e w o rk m o st closely related with our own as far as we know is that on 223exemplars\224 12 Speci\002cally  a n e x e mplar i s a n e xecutable visual model consisting of one or more instances of at least one concrete class for each abstract class in a library By browsing these classes as well as their static relationships and dynamic interactions one can get a general understanding of how the framework works For example a GUI library might have an exemplar that consists of a window object together with its menu bar tool palette canvas and some widgets on the canvas Since libraries have only a few abstract classes a small number of instances suf\002ce in creating an exemplar The developer would not only explore the structural relationships in the exemplar but also the collaborative relationships among objects by observing message passing among these objects While exemplars may be helpful they are pre-selected and not representative of any particular class of applications Moreover they place an extra burden on the developers of the software library In contrast our approach allows the user to examine a particular aspect of the library that is of interest Moreover the tool is fully automated and works on any existing code Finally we note that our approach is also top-down One starts out with some fundamental library components as inferred by inspecting the reuse boundaries and then queries/browses association rules for such components Returning to the Jigsaw puzzle analogy observe that puzzle pieces are designed to 002t an outline Consequently it would be easier to start out with the outline and place pieces accordingly Top-down approaches identify those essential components in the library that one can extend and modify in an application 227 in essence the outline to the Jigsaw puzzle 7 Conclusions and Future Work In this paper we have shown how data mining can be used to discover library reuse patterns in user-selected applications This can be helpful in building and debugging applications that use a particular library by observing how other developers have used that library in their applications As an example we have shown how a developer might use our tool CodeWeb to identify reuse patterns in the ET application framework In our approach we mine association rules that identify library components that are often reused in combination by application components By querying and/or browsing such association rules a developer can discover patterns for reusing library components Moreover the association rules can be used to automatically warn developers when their application reuses library components in a way that differs from characteristic usage in applications written by others An important aspect of our approach is that it requires no extra effort on the part of the library developer and can be used with any existing software library Also it is important to note that our method is not intended to replace current techniques for learning to use libraries but rather to complement them While we have used the ET framework as a running example throughout this paper it is actually not the best candidate to demonstrate data mining While ET is elegant and well-known in the research literature which is partly why we used it here few applications have been written using it Our data mining approach works better with more applications We do not see this as a major shortcoming since most developers are interested in learning those libraries that are widely used in practice Currently we are carrying out a case study using the popular KDE libraries and over one hundred real-life applications based on them 1 In this paper we mined association rules at a reasonably high level of abstraction by considering classes functions and various reuse relationships between For some relationships such as method calls we have completely abstracted away the order in which they occur In future work it would be interesting to take into account ordering when generating association rules For example with an I/O library one might 002nd that 002les are typically processed by calling functions open  read\(\/write and close in that order Currently we extract all information statically from the source code However it may be interesting to incorporate dynamic information from running applications that use a particular library For example when determining method call relationships we may include only those that occur with a high frequency In this way it may be possible to abstract away non-essential calls thus focusing the user's attention to particularly fundamental association rules Finally one can view the approach described in this paper as learning from positive experience  That is library reuse that has worked in practice Presumably one would select 223stable\224 applications to demonstrate reuse patterns in 1 The KDE project aims to build a graphical desktop environment for Unix workstations that rivals Microsoft Windows See http://www.kde.org for details We have mined KDE reuse patterns by analyzing over 100 applications The resulting association rules are available at http://www.cs.washington.edu/research/projects/se/www/kde/reuse patterns 


a library However one can also mine negative experience  That is misunderstandings and problems that came up when reusing components from a software library For future work it would be interesting to determine if one can mine negative experience in an automated way 227 perhaps by analyzing application CVS logs for reuse patterns that were problematic and later corrected References 1 R  A g r a w al T  I m i elin sk i an d A  S w a m i  M in ing association rules between sets of items in large databases In SIGMOD  pages 207\226216 1993  R  A gra w al and R  S ri kant  F as t a l gori t h ms for m i n i n g association rules In Proceedings of the 20th VLDB Conference  pages 487\226499 1994  R  J  B ayardo Ef 002 c i e nt l y mi ni ng l ong pat t e rns from databases In SIGMOD 98  pages 85\22693 1998  R  J  B ayardo R  Agra w a l  and D  G unopulos Constraint-based rule mining in large dense databases In 15th International Conference on Data Engineering  1999 5 F  B er g a d a n o an d D  G u n e tti T e stin g b y m ean s o f i n ductive program learning ACM Transactions on Software Engineering and Methodology  5\(2\119\226145 1996  T  J  B iggers taf f  D es ign r eco v e ry for m aintenance and reuse Computer  22\(7\36\22649 1989  W  W  C ohen Induct i v e s p eci 002 cat i o n r eco v e ry U nderstanding software by learning from example behaviors Automated Software Engineering  2\(2\107\226129 1995  C  M ont es de Oca a nd D L C a rv er  I dent i 002 cat i o n of data cohesive subsystems using data mining techniques In Proceedings of the International Conference on Software Maintenance  pages 16\22623 1998  C  M ont es de Oca a nd D L C a rv er  A vi s u al repres entation model for software system decomposition In Proceedings of the 5th International Working Conference on Reverse Engineering  pages 231\226240 1998  G F i s c her  S  Henni nger  and D  R edmi l e s  Int e rt wi ning query construction and relevance evaluation In CHI 91  pages 55\22662 1991  W  B  Frak es and B  A  N ejmeh Softw a re reus e through information retrieval In 20th Hawaii International Conference on System Sciences  pages 530\226 535 IEEE 1987  D Gangopadhyay a nd S  Mi t r a Des i gn by frame w o rk completion Automated Software Engineering  3:219\226 237 1996  J  Ges s a rol i  Dat a mi ni ng A p o w erful t echnol ogy for database marketing Telemarketing  13\(11\64\22668 1995  R  Kazman and S  J  C arriere V i e w e x traction a nd view fusion in architectural understanding In 5th International Conference on Software Reuse  IEEE 1998 15 C D Kri v d a  B o o m in g b u s in ess i n t ellig en ce Midrange Systems  8\(12\32\22634 1995  C  D Kri vda U neart h i n g under g round dat a  LAN  May 1996 17 A Mich ail a n d D No tk in  I llu stratin g o b j ect-o rien ted library reuse by example A tool-based approach In 13th IEEE International Conference on Automated Software Engineering  pages 200\226203 1998  A Moormann-Zarems ki and J  M  W i ng S p eci 002 cation matching of software components ACM Transactions on Software Engineering and Methodology  6\(4\333\226369 1997  L R  Neal A s y s t em for e xample-bas ed programming In CHI 89  pages 63\22668 1989  W  P r ee G P o mber ger  A S c happert  a nd P  S o mmerlad Active Guidance of Framework Development Software-Concepts and Tools  16\(3\136\22645 1995 21 R Prieto Diaz a n d P  Freem an  C lassify in g s o f tw are for reusability IEEE Software  4\(1\6\22616 1987 22 G Sn eltin g a n d F  T i p  Reen g i n eerin g c lass h i erar chies using concept analysis In 6th ACM SIGSOFT International Symposium on the Foundations of Software Engineering  pages 99\226110 1998  S Sparks  K  B enner  and C  F aris  Managing objectoriented framework reuse Computer  29\(9\52\22661 1996  R  S r i k ant a nd R  Agra w a l  Mi ni ng general i zed as s o ciation rules In Proceedings of the 21st VLDB Conference  1995  A W e i n and E Gamma a nd R  Mart y  ET++\227 an object oriented application framework in C In OOPSLA  pages 46\22657 1988  A S  Y e h D R  Harri s  and M  P  C has e  Mani pulating recovered software architecture views In Proceedings of the International Conference on Software Engineering  pages 184\226194 1997 


CMP A Fast Decision Tree Classifier Using Multivariate Predictions  449 H Wang and C Zaniolo Mining Recurrent Items in Multimedia with Progressive Resolution Refinement  461 0 Zai'ane J Hun and H Zhu Panel Session 22 Is E-Commerce a New Wave for Database Research Moderator Anant Jhingran IBM T.J Watson Research Center USA Panelists Sesh Murthy IBM T.J Watson Research Center USA Sham Navathe, Georgia Institute of Technology USA Hamid Pirahesh IBM Almaden Research Center USA Krithi Ramamrithan University of Massachusetts-Amherst USA Industrial Session 23 Java and Databases Pure Java Databases for Deployed Applications  477 N Wyatt Database Technology for Internet Applications  700 A Nori Session 24 Association Rules and Correlations Finding Interesting Associations without Support Pruning  489 E Cohen M Datar S Fujiwara A Gionis P Indyk R Motwani J Ullman and C. Yang Dynamic Miss-Counting Algorithms Finding Implication and Similarity Rules with Confidence Pruning  501 S Fujiwara J Ullman and R Motwani Efficient Mining of Constrained Correlated Sets  512 G Grahne L Lakshmanan and X Wang Session 25 Spatial and Temporal Data Analyzing Range Queries on Spatial Data  525 J Jin N An and A Sivasubramaniam Data Redundancy and Duplicate Detection in Spatial Join Processing  535 J.-P Dittrich and B Seeger Query Plans for Conventional and Temporal Queries Involving Duplicates and Ordering  547 G Slivinskas C Jensen, and R Snodgrass xi 


Industrial Session 26 XML and Databases Oracle  The XML Enabled Data Management System  561 S Banerjee V Krishnamurthy M Krishnaprasad, and R Murthy XML and DB2  569 J Cheng and J Xu Session 27 High-Dimensional Data Independent Quantization An Index Compression Technique for High-Dimensional Data Spaces  577 S Berchtold, C Bohm H Jagadish H.-P. Kriegel and J Sander Deflating the Dimensionality Curse Using Multiple Fractal Dimensions  589 B.-U Pagel F Korn and C. Faloutsos Similarity Search for Multidimensional Data Sequences  599 S.-L Lee S.-J Chun D.-H Kim, J.-H Lee and C.-W Chung Session 28 Web-Based Systems WRAP An XML-Enabled Wrapper Construction System for Web Information Sources  611 L Liu C Pu and W. Hun Self-Adaptive User Profiles for Large-scale Data Delivery  622 U Cetintemel M Franklin and C. Giles Industrial Session 29 Main Memory and Small Footprint Databases In-Memory Data Management in the Application Tier  637 The TimesTen Team SQLServer for Windows CE -A Database Engine for Mobile and Embedded Platforms  642 P Seshadri and P. Garrett Join Enumeration in a Memory-Constrained Environment  645 I Bowman and G Paulley xii 


Plenary Panel Session 30 XML Databases   Moderator: Michael Carey, IBM Almaden Research Center USA Panelists Adam Bosworth, Microsoft Corporation USA David De Witt University of Wisconsin-Madison, USA Alon Levy University of Washington USA Bruce Lindsay IBM Almaden Research Center USA Jennifer Widom Stanford University USA Demo Session 1 Web Query Optimizer  661 V Zadorozhny L Bright L Raschid T Urhan and M Vidal ReQueSS: Relational Querying of Semi-structured Data  664 R Sunderraman The IDEAL Approach to Internet-Based Negotiation for E-Business  666 J Hammer C Huang Y Huang C Pluempitiwiriyawej M Lee H Li L Wang Y Liu and S Su READY A High Performance Event Notification Service  668 R Gruber B Krishnamurthy, and E Panagos A Multimedia Information Server with Mixed Workload Scheduling  670 G Nerjes DISIMA An Object-Oriented Approach to Developing an Image Database System  672 V Oria T Ozsu P Iglinski B Xu and L Cheng Demo Session 2 The Collaboration Management Infrastructure  677 H Schuster D Baker A Cichocki D Georgakopoulos and M Rusinkiewicz Assisting the Integration of Taxonomic Data The LITCHI Toolkit  679 I Sutherland J Robinson S Brandt A Jones S Embury W Gray R White and F Bisby TheaterLoc: Using Information Integration Technology to Rapidly Build Virtual Applications  681 G. Barish Y.4 Chen D Dipasquo, C Knoblock S Minton I Muslea and C Shahabi Lineage Tracing in a Data Warehousing System  683 Y Cui and J Widom xiii 


The Mentor-Lite Prototype A Light-Weight Workflow Management System  685 J Weissenfels M Gillmann 0 Roth, G Shegalov and W Wonner Location Prediction and Queries for Tracking Moving Objects  687 0 Wolfson B Xu and S Chamberlain Semiorder Database for Complex Activity Recognition in Multi-Sensory Environments  689 S Bhonsle A Gupta S Santini and R Jain Tutorial 1 Web Information Retrieval  693 M Henzinger Tutorial 2 Mobile and Wireless Database Access for Pervasive Computing  694 P Chrysanthis and E Pitoura Tutorial 3 Data Mining with Decision Trees  696 J Gehrke Tutorial 4 Directories Managing Data for Networked Applications  697 D Srivastava Tutorial 5 Indexing High-Dimensional Spaces Database Support for Next Decade\222s Applications  698 S Berchtold and D Keim xiv 


 T5.I2.D100K T10.I4.D100K T15.I4.D100K T10.I6.D400K T10.I6.D800K T10.I6.D1600K Optimizations across Databases 5 0 5 10 15 20 25 30 35 40 45 Improvement COMP TREE COMP-TREE 1 2 4 8 1 2 4 8 1 2 4 8 2 4 8 2 4 8 1 2 4 8 Processors Databases Figure 5 Effect of Computation and Hash Tree Balancing good as the COMP optimization The reason that the hash tree balancing is not suf\336cient to offset inherent load imbalance in the candidate generation in this case The most effective approach is to apply both optimizations at the same time COMP-TREE The combined effect is suf\336cient to push the improvements in the 40 range in the multiple-processor case On 1 processor only hash tree balancing is bene\336cial since computation balancing only adds extra cost 5.4 Short-circuited Subset Checking Figure 6 shows the improvement due to the short-circuited subset checking optimization with respect to the unoptimized version The unoptimized version is the Apriori algorithm due to Agrawal et al 5 The results are presented for dif ferent number of processors across dif ferent databases The results indicate that while there is some improvement for databases with small transaction sizes the optimization is most effective when the transaction size is large In this case we get improvements of around 25 r the unoptimized version To gain further insight into this optimization consider 336gure 7 It shows the percentage improvement obtained per iteration on applying this optimization on the T20.I6.D100K database It shows results only for the uni-processor case r similar results were obtained on more processors We observe that as the iteration k increases there is more opportunity for shortcircuiting the subset checking and we get increasing bene\336ts of up to 60 The improvements start to fall off t the high end where the number of candidates becomes small resulting in a small hash tree and less opportunity for short-circuiting It becomes clear that is an extremely effective 15 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 T5.I2.D100K T10.I6.D800K T15.I4.D100K T20.I6.D100K procs across Databases 0 5 10 15 20 25 Improvement 1 2 4 8 Figure 6 Effect of Short-circuited Subset Checking 23456789101112 Iterations 0 10 20 30 40 50 60 improvement T20.I6.D100K Figure 7  Improvement per Iteration  proc   16 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


optimization for larger transaction sizes and in cases where there are large number of candidate k itemsets 6 Conclusions In this paper e presented a parallel implementation of the Apriori algorithm on the SGI Power Challenge shared memory multi-processor We also discussed a set of optimizations which include optimized join and pruning computation balancing for candidate generation hash tree balancing and short-circuited subset checking We then presented experimental results on each of these Improvements of more than 40 were obtained for the computation and hash tree balancing The short-circuiting optimization was found to be extremely effective for databases with large transaction sizes Finally we reported the parallel performance of the algorithm While we d good speed-up we observed a need for parallel I/O techniques for further performance gains References  R Agra wal T  Imielinski and A Swami Database mining A performance perspecti v e  I n IEEE Trans on Knowledge and Data Engg  pages 5\(6 1993  R Agra wal T  Imielinski and A Swami Mining association rules between sets of items in lar ge databases In Proc M SIGMOD Intl Conf Management of Data  May 1993  R Agra wal H Mannila R Srikant H T o i v onen and A I V erkamo F ast disco v ery of association rules In U F et al editor Advances in Knowledge Discovery and Data Mining  MIT Press 1996  R Agra wal and J Shafer  P arallel mining of association rules design implementation and e xperience Technical Report RJ10004 IBM Almaden Research Center San Jose CA 95120 Jan 1996  R Agra wal and R Srikant F ast algorithms for mining association rules In Proc 20th VLDB Conf  Sept 1994  M Cierniak W  Li and M J Zaki Loop scheduling for heterogeneity  I n 4th IEEE Intl Symposium on High-Performance Distributed Computing also as URCS-TR 540 CS Dept Univ f Rochester  Aug 1995  M Holsheimer  M  K ersten H Mannila and H T o i v onen A perspecti v e on databases and data mining In 1st Intl Conf Knowledge Discovery and Data Mining  Aug 1995  M Houtsma and A Swami Set-oriented mining of association rules In RJ 9567  IBM Almaden Oct 1993  H Mannila H T o i v onen and I V erkamo Ef 336cient algorithms for disco v ering association rules In AAAI Wkshp Knowledge Discovery in Databases  July 1994  J S P ark M Chen and P  S Y u  A n e f fecti v e hash based algorithm for mining association rules In Proc M SIGMOD Intl Conf Management of Data  May 1995 17 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 J S P ark M Chen and P  S Y u  E f 336cient parallel data mining for association rules T echnical Report RC20156 IBM T J Watson Research Center Aug 1995  G Piatetsk y-Shapiro Disco v ery  presentation and analysis of strong rules In G P S et al editor  KDD  AAAI Press 1991  A Sa v asere E Omiecinski and S Na v athe An ef 336cient algorithm for mining association rules in large databases In Proc 21st VLDB Conf  1995  M J Zaki M Ogihara S P arthasarathy  and W  Li P arallel data mining for association rules on shared-memory multi-processors Technical Report 618 Department of Computer Science University of Rochester 618 1996 18 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


