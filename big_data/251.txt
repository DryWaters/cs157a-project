Index Miner I-Jen Chiang T.Y.Lin CA USA Index Software, Inc Department of Mathematics and Computer Science San Jose State University chiang  hugo.csie.ntu.edu.tw tvlin cs.sjsu.edu Abstract Index Miner is a Java-based data mining tool, which contains the methodologies of classification, clustering association rules visualization, attribute transformation and feature selection The paper briefly introduces this tool and discusses the methods that are implemented in this tool to show how to create and perform a learning process for a data 
in order the mining the patterns hidden in the data 1 INTRODUCTION There is no algorithm that is most adaptive to all tasks Therefore we develop a data mining tool containing some well-known algorithms of different kinds of applications such as classifications clustering association rules visualization attribute transformations and feature selections Index Miner is a generic data mining tool that provide users a large learning algorithms to analyze their problems with high volume data There are more than one hundred machine learning algorithms that cover classification clustering 
association rules and feature selections implemented in this tool It is convenient for users to build up a flow to do a learning process, i.e users load the proper database and filter some irrelevant attributes by using feature selection mechanisms or make data segmentation by clustering mechanisms and then use a classifier to classify the data or association rules finding mechanism to generate all important association rules The goal of Index Miner is the same as MLC++[l and Weka 2 project The Index Miner is 
not only the data mining tool but also provides the utilities for the researchers to analyze their data and easy to build up their own learning algorithms The performance statistics such as accuracy precision, recall and others are included in Index Miner This paper will generally give an outline of Index Miner In the next section we will review all the methods that are implemented in Index Miner The future work of Index Miner will be listed in the last section 2 
METHODS IN INDEX MINER This framework is implemented in Java programming language There are more than one hundred algorithms that have been implemented in Index Miner It covers almost all the functions of data mining, e.g., classifications clustering association rules and feature transformations and feature selections Users can create a learning procedure as shown in Figure.1 for the data that they want to analyze Users can follow the procedure to perform their learning schemes For classifications Index Miner provides three kinds of 
classifiers for classify the data The category classifiers are only suitable for making category data type classes prediction There are C4.5 CN2 CHAID support vector machine logistic regression Bayesian classifiers Ada Boosting and so on The numerical classifiers are proper for the numerical type data classes analyzing IBk linear regression and etc are the numerical classifiers Some classifiers, such as CART are adapt to both kinds of data types Feature selections that are also called attribute selections are to filter some attributes that are thought unimportant for 
the other data mining processes Under certain tolerated criteria we can ignore these attributes In general forward look-ahead methods and backward look-after methods are treated as the core technique for making attribute selections Wrapper Relief and some others are implemented in Index Miner Affinity groups is also called Market Basket Analysis and usually used to determine which things to go together With Affinity Groups analysis association rules are generated to identify cross-selling opportunities and design attractive marketing packages or groupings of product and services A priori 
and granular computing are implemented in Index Miner Clustering is one major data mining task segmenting a heterogeneous population into a number of more homogeneous subgroups clusters which are grouped together on the basis of self-similarity There are three clustering algorithms are implemented in Index Miner One is k-neighborhood algorithm another is EM algorithm and the other is COWEB Users can select the most proper algorithms to make a data segmentation The result of the 613 0-7695-1372-7101 10.00 0 2001 IEEE 


clustering can pass to the classifiers and association rules finders for further analyzing Besides the methods of classifications clustering association rules and feature selections attribute adjustment methods are in this tool to create or remove a novel attribute for making further learning 3 CONCLUSION Index Miner provides many machine learning algorithms for data analysis The users can easy create their learning flows However, some facilities such as 3D visualization are missed in this package In addition to add more learning algorithms in it we will build up fancy visualization tools 4 FWFERENCES l.R Kohavi D Sommerfield and J Dougherty Data Mining Using MLC Tool with AI pp 234-245 1996 2.1 H Witten and E Frank Data Mining Morgan Kaufmann Publishers 2000 550 36 14 01 Iris 654 39 17 22104 Ins 746 31 22111 03 is e50 34 15 02 111s 944 29 14 01 Ins Figure.1 The process flow of Index Miner Each time a user can easy build up a learning flow for analyzing the data The result of each learning method is shown as a text report or a table in a frame 614 


discovery over a temporal database 2.2 Incremental update on discovered sequential patterns Let IDBI be the number of data sequences in the original database DB and min-sup be the minimum support Mer some update of the database a few transactions are appended to DB These transactions can be sorted by cid into jdbfbl data sequences in the increment database db UD is the updated database combining all data sequences from DB and db UD  DB U db Let there be Ib customers appearing both in DB and db If all customers in db are new customers with respect to DR that is all cjds in db are different from those in DB jbj is zero Let Sung be Lhe set of all frequent k-sequences in LIB S2D be the set of all frequent k-sequences in LJD and the set of all sequential patterns in DB and UD be PB and SuD respectively Assume that 200or each sequential pattern s in DB its support count denoted by ScountDB is available With respect to the same minimum support min-sup a sequence s is a frequent sequence in the updated database UD if its support count is greater than min-supx totd data sequences in UD That is Sco,,,,:D is no less than min-supx jDBl+ldbI-161 XcO,,,,tDB X,,,,,,:b and are support unts of a sequence X in DB db and UD If there is no sane cid in DB and db XcOun~D  XcounFB  XGo,,,,:b A sequential pattern s in might not be in SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSD because of database update On the other hand a sequence s7 that is not in PB might turn out to be in S Consequently the problem of incremental update on sequential patterns is to find the new set SuD of frequent sequences in UD As shown in Fig 1 In order to find SuD previous approaches take all data sequences to compute sequential patterns and their supports With discovered pB and support counts the incremental algorithm updates supports of sequential patterns in SuD by scanning data sequences in db only if they were frequent in DB New candidate sequences, which might not exist in DB are generated in the same scan Some new candidate sequences are pruned if they do not have sufficient supports relative to db before the scan of DB starts The complexity of mining process is reduced due to the employment of previous knowledge and the increment database Updated database UD  DB  db data sequence 1 data sequence 2 Sequential pattem mining minimum support min-mp  p data sequence db data sequence a\re-execution mining algorithm on UD Original database DB data sequence 1 Sequential pattem mining PB data sequence 2 minimum support m~n~sup 1 frequent sequences  support counts  I   data sequencelDb l"MDQ Incremefit d&t&base db  data sequenoe 1 data sequence ldbl b incremental updating P Figure 1  Incremental update versus re-mining 2.3 Example of sequential patterns after database updated Consider a database with transactions sorted by customel id into 6 data sequences as shown in Fig 2 Assume minimum support is set to 33 i.e minimum support count of data sequences being 2 The sequential patterns are c\(l c\(2 3 4 5 8 5 3 and 3  1 UP 8>\(2 c\(8 1 NW WP 5 1P3 Customer Id Data Se uence 8 2 1 12 8 7 5 3 1 Fiaure 2 The oriainal database DB with 6 data sequences Mer some update activities assume the transactions appended to the database ai1 come from new customers The increment database, sorted by cid into data sequences is shown in Fig 3 With same minimum support it requires 3 data sequences to be a frequent sequence now Previous sequential patterns 3 8 2 2  1 2 8 5 1 5 3 and 3 1 are no longer 26 


frequent due to this update While 7 and 8 become nev sequential patterns because they have minimum supports now I Customer Id IData Sequence I Figure 3 Data sequences in the increment database db In cases of update when the customer id of new transactions appears in the original database these transacbons must be appended to the same customer to fom hisher data sequence For example assume the customers whose cids are 1 and 4 bought item 7 at later time and the data sequences for cid=l and cr&4 now are 8 2 1 7 and 1 4 7 respectively Fig 4 shows an example of data sequences which come from both old and new custw in the increment database The data sequences for mning in updated database Iff is shown in F1 5 Mter invalidating sequences q\(5p and i{8 lpi Me resulting sequentid patterns in this database are I 2 4 7 c\(8 1,2p and q8]\(7p for the given mimmum support 33 Figure 4 Data sequences in db with cids occurring in DB Figure 5 Merged data sequences in UD 3 Fast Sequential Pattern Update Algorithm FASTUP 3.1 Previous algorithms versus FASTUP algorithm Apriorz algorithm was designed to discover association rules  11 while Apt-ioriAII algorithm introduced in 121 was the first algorithm that deals with the problem of sequential patterns mining In subsequent work 1111 the same authors proposed GSP Generalized Sequential Pattern\algorithm that outperforms ApriortAll An algorithm called S*PADE Sequential PAttern Discovery using Equivalence classes was designed that uses simple join operations to find sequential patterns 13 However vertical database layout was used instead of horizonial database layout used in eadier approaches 12 111 Therefore the GSP algorithm is briefly reviewed here GSP algorithm makes multiple passes over the database In the first pass, frequent l-sequences with their supports are determined by counting the support of 1 itemsets In the subsequent passes, candidate k-sequences are generated from frequent \(k-I obtained in pass-\(k-1 Then the supports for these candidates are computed and those with minimum support become frequenl sequences This process is iterated until n6 more candidate sequences are formed In each pass every data sequence is checked to increment the suppon count of candidates contained in this data sequence Hence therc are two essential sub-processes in this algorithm 1 Candidate generation Let L denote the set of all frequent k-sequences and C denote the set of candidate k sequences Given Id C is generated by selectively join L with L itself If therc exist any k-l of a candidate which is not in Lk the candidate is pruned from C Candidates are inserted into a hash trcc to enable fast counting Please refer to lll 200or the detailed join operation and the hash tree mechanism 2 Support counting Every item and its following items in the checking data sequence is hashed to reach leaf buckets in the candidate hash tree The support of each candidate in the buckets if the candidate is cnntained in the data sequence is incremented Note that as the name GSP suggests it not otlly solves problems 200ormulared in previous section but it also solves problems generalized with constraints on pattern hierarchy and transaction-tirnc I I The algorithm described hefe is to solve the fundamental problem bf sequentid patterns without constraints The basic construct of our algorithm FASTUP is generation and support counting FASTUP algorithm has several arguments similar to the incremental association update algorithm FUP 5 Nevertheless the effect of similar to that of GSP with improvements on candidatc 27 


candidate reduction is more dramatic in sequence mining Moreover we have to consider whether appended data sequences are required to merge with old data sequences Features that distinguish FASTUP from GSP are listed as 200allows 1 During pass-k for each XES The support count of X is updated against db without re-scan DB Old frequent sequences that do not satisfr new support count are filtered out 2 During pass-k if XES and XgSk prune every candidate C t C such that X is a subsequence of C With this feature FASTUP has greater capability in candidate reduction by a simple check in db before counting starts in DB 3 During pass-k a k-sequence X where XgS with XCu  is added to Ct if Xcoun?z minpsupxldbl For each KEG The suppon count of X is updated against DB The generation of candidate sequence X requires less data sequences checking in db than in DB or in IJD Only the supports of new candidates instead of all candidates need to be checked in DB These features altogether enable FASTlJP to have better performance than re-execution GSP on updated database Previous frequent sequences and candidate sequences in DB that do not belong to UP are pruned away by siinple checks on db Without missing any potential new frequent sequences in UD fewer new candidates are generated from db for checking against D3 rlb 3.2 for sequential pattern mining Merge data seqvences of the same customer For the given data sequences in DB and db the sequential patiems in UD can be found by re-execution of GSP Transactions that come from the sane customer either in DB or in db are parts of the unique data sequence for that customer in UD Data sequences with same customer id in both databases must be merged into one data sequence before GSP starts Likewise FASTUP algorithm merges data sequences when necessary but relays practical information about discovered sequential pattems In order to retain as much information as possible and to keep smaller number of data sequences for subsequent mining processes we extract data sequences from DB and merge them to db The merging is accomplished as follows 1 With given data sequences sorted by cid in db and DB we check cids in db against DB to find any existence of that cid 2 For the found data sequence ds in DB the support counts of all frequent sequences contained in ds are decremented by one 3 The ds is merged into that data sequence ds with same cid in db with ds followed by ds  Apparently with sorted data sequence searching cid could be done in very short time With known sequences for checking decrement operations add slightly overhead in merging process After extraction and merging there is no data sequence in DB and db with same customer id FASTUP algorithm then could proceed to next stage 3.3 FASTUP algorithm Pass-1: find frequent 1-sequences in updated database 1 Scan db for all 1-sequence X to get XFountb to the failed set otherwise add Xto SIUD 3 In the same scan if X~SlD6/vy,,,~b min supxldb X could not be frequent otherwise add X to C 4 Scan U13 for each XEC to get XGounpB If XGo,,,,iDB X min supx\(lDBl+ldbl at the end of pass-1 add In comparison with GYP FASTUP discovers previous frequent 1 sequences that is still frequent, filters Out those that arc invalid now and generates potential candidate 1 sequences within a scan on increment database. Every new canbdate in the set of new candidate 1-sequences is then checked against the original database to see if it is frequent Contrast to GSP GSP takes every item as a cadidate and counts over the whole database FASTUP is obviously faster than GSP in this pass Pass-k: find frequent k-sequences in updated database 1 Generate C from Sk a5 GSP described 1111 C is characterized into two subsets Let ck CpSkDB c  C,-C  C consists of candidates that are also frequent k-sequence in DB mle C consists of remaining candidates that are newly generated 2 A previous frequent k-sequence X in DB which XE\(&""-C is not contained in C SuchX though in YkDB need not be checked against db 3 Scan db for each X in C to get XconnPb For each X in Ckl since XCOlVltDR is available wiihout checking DB Xis added to S if it has minimum support 4 In the same scan of db for each X in ck2 if Xco minpsupxldbl X could not be frequent Such X is removed from Ik2 This step reduces the number of candidates to be checked against DB 5 Scan DB for each XE compute XcountDB X is added to S>D if Xco,,,,pB Xcoo,tb2 minsupx\(lDBl+ldbl at the end of pass-k The above process is iterated until no more candidates are generated At each pass FASTUP updates supports of frequent sequences in DB which are still frequent in UD and generates most likely frequent candidates within one scan over small increment db Candidate sequences, which 1 IfXcS,D~d,,,DB XG,,p min supx\(pB~+ldbl put A X to S,"D 28 


do not have sufficient supports relative to db are pruned before they are verified by DB The set of candidates that FASTUP generated for further checking with DB is smaller than GSl Consequently FASTUP could be much faster than previous algorithms of sequential pattern mining Complete FASTUP algorithm Algorithm Merge-Data-Sequences I Let current data sequence be dsdb I I Let cid of current data sequence be cid I For-all data sequences in db do If cid is found in data sequence ds in DB then Forall frequent sequences contained in End-for Replace dsdb by ds merged with dsdb where do Decrement support count of this sequence by 1 transactions in ds followed by transactions in dsdb End-if End-for Algorithm-Fast-Update-Sequential-Patterns I Initialize aU~,,,,db to zero,Xis 1-sequence i.e 1 itemsets  For-all data sequences in db do  PASS-1 I Increment XGomp by 1 if current data sequence contains X End-for Forall 1-sequence X do IfX is frequent in DB then EXcoun Xcomtdb min-supx then Endjf IfXis not frequent in DB then If Xco,,,,tb min-supx Idb I then End-if add X to S,UD addXto I End-for For-allXin c do End-for Forall data sequences in DB do InitialIzeYco,,DB to zero ForallXin c do contains X Increment Xco,,,,tDB by 1 if current data sequence End-for End-for For-all X in C,do IfX  X,,,pb2 min-supx then add X to S End-for J All frequent 1-sequences  their counts accumulated I Pass-2 and beyond I k=2 Generate Ckfrom Sk.1 UD While Ckis not empty do  Initialize all x to zero xis k-sequence in ck I Increment Xco,,,,pb by 1 if current data sequence For-all data sequences in db do contains X End-for For-all k-sequence X in C do If X is frequent in DB then IfX Xco,,,,:b2 mm-supx\(\(DB\(+\(dbl then End-if If X is not frequent in DB then IfXc,,:b mm-supxldb then End-if End-for For-all X in C,..do End-for For-all data sequences in DB do add X to S addXto i2 Initialize Xco,,,,YB to zero For-all X in Ck2do Increment X,o,,"B by 1 if current data sequence contains X End-for End-for For-all X in Ck do IfXco,,,,tDB Xcom:b mzn-supx\(lDBl+ldbl then End-if add X to TkuD End-for I All frequent k-sequences and their counts accumulated  k=k+l Generate C,from IuD Endwhile 3.4 Examples on merging and FASTUP algorithm Example 1 Given a original database DB which combines sequences in Fig 2 and Fig 3 with total 9 data sequences If an increment database db in Fig 4 with total 5 sequences is appended, the sequences of cid=l and ci&4 would be extracted from DB and merged into db Now DB has 7 and db has 5 data sequences. The count for 8 2 l and 8 1 is decremented by 1 due to the extraction of data sequence with czd=l Likewise extraction of data sequence with cid=4 would cause support of I and 4 decreasing After extraction and merging FASTIJP can be applied correctly since no cid appears in both DB and db Example 2 Given a database DB and an increment database db such that after data sequences are merged IDB\(=lOOO and ldb1=125 For min-sup=S in last 29 


discovery after extraction and merging, found sequential patterns are listed in Table 1 Let us consider sequential patterns related to items 1 2 3 4 5 In order to find frequent 1-sequences in UD a scan on db is made at first Table 2 shows the result of the scan Now 1 and 3 remain frequent with counts updated to 120 and 95, both counts  8%x\(1000+125 i.e 90. <\(2 is no longer frequent since its count is only 85 5\cannot be frequent because its count in db being 9 is less than 8%x125 A scan on DB for new candidate 4 is then conducted. Suppose 4 70 4 is a new frequent 1-sequence with count 94 Before proceeding to 2-sequence counting  1,2  2\and 2\are eliminated from counting in db for having subsequence <\(2\which is not frequent in UD In fact candidate 2-sequences now consists of old frequent 2 sequences 1,3 and 3 new can&date 2 sequences  1,4  1 4 4  1 4 3\and 1 Note that the support count for 3 1 is not available since it failed to be frequent in DB and its count was not kept. After a scan on db for these candidates, the result is shown in Table 3 Now 1 3 remains frequent with count=93. Another counting on DB is only required for 1 4 and 3 4 to check if they have minimum support It is not necessary to check 1 since its count in db is less than minimum required. The discovery continues until no more candidate sequences are generated Frequent sequences Sequence Support Count I  1 100 S*DB 1,3 1,3  1 2  1 2 coun~B-83 Table 1 Sequential patterns and their counts in DB after merging and extraction 1 3 3 2 Table 2 1 sequences and their counts in db 1 3 co,,,,~B=86 3 2 co,~B=Sl Table 3 Candidate 2-sequences and their counts in db 4 Conclusion and Future Works Due to the nature of sequence permutation the problem of sequential pattern mining is more complicated than the discovery of association rules Without maintenance, valid of discovered patterns may change after update on database We propose FASTUP algorithm that efficiently solves the problem by incremental updating without re-mining the whole updated database from scratch Using frequent sequences and support counts discovered from original database FASTUP rapidly updates frequent sequences and their counts by scanning over increment database instead of whole updated database Fewer but more promising candidates are generated by just checking counts in increment database The simulation of our algorithm on synthetic data is underway Given the analysis on sequential pattern mining the performance of the algorithm could be much faster than previous algorithms for the maintenance of sequential patterns Further researches could be extended to problems of various minimum supports and problems of generalized sequential patterns such as patterns with is-a herarchy References  11 R Agrawal H Mannila R Srkant H Toivonen and A I Verkamo Fast Discovery of Association Rules Advances in Knowledge Discovery and Data Mining edited by U M Fayyad et al AAAllMIT Press pp. 307-328, 1996 2 R Agrawal and R Srikant Mining Sequential Pattems Proceedings of the 11th International Conference on Data Engineering \(ICDE'95\pp. 3-14, Taipei, Taiwan, 1995 3 R Agrawal and J Shafer Parallel Mining of Association Rules IEEE Transactions on Knowledge and Data Engineering Vol 8 No 6 pp. 962-969, Dec 1996 4 S Brin, R Motwani J Ullman and S Tsw Dynamic Itemset Counting and Implication Rule for Market Basket Data Proceedings of the 1997 SIGMOD Conference on Management of Data, pp. 255-264, 1997 30 


5 D W Cheung J Han V T Ng and C Y Wong Maintenance of Discovered Association Rules in Large Databases An Incremental Updating Technique Proceedings of International Conference on Data Engineering, 1996 6 J Han and Y Fu Discovery of Multi-Level Association Rules from Large Databases Proceedings of the 2 1 st International Conference on Very Large Data Bases, pp 420-43 1 Zurich Switzerland, Sep. 1995 7 S D Lee D Cheung B Kao A General Incremental Technique For Maintaining Discovered Association Rules Proceedings of the 5th International Conference On Database Systems For Advanced Applications, pp 185-1 94 Melbourne Australia Apr 1997 8 H Mannila and H Toivonen Discovering Generalized Episodes using Minimal Occurrences Proceedings of the Second International Conference on Knowledge Discovery and Data Mming KDD\22296 pp 146-151 Portland, 1996 9 H Mannila H Toivonen and A I Verkamo Discovering Frequent Episodes in Sequences Proceedings of the First International Conference on Knowledge Discovery and Data Mining \(KDD\22295 pp 210-215 Montreal Canada 1995  101 J S Park M S Chen, and P S Yu Using a Hash-Based Method with Transaction Trimming for Mining Association Rules IEEE Transactions on Knowledge and Data Engineering Vol 9 No 5 pp 81 3-825 1997 ll R Srikant and R Agrawal Mining Sequential Patterns Generalizations and Performance Improvements, Advances in Database Technology-5th Intemational Conference on Knowledge Discovery and Data Mining \(KDD\22295 pp. 269 274, Montreal Canada 1995 H Toivonen Discovery of Frequent Pattems in Large Data Collections, Ph.D thesis University of Helsinki, Finland 1996 M J Zaki Fast rvllning of Sequential Patterns in Very Large Databases Technical Report 668 The University of Rochester New York Nov 1997 31 


esp ecially supp orts the form ulation of activ e constrain ts on the data mo del Rules pro vide a useful lev el of abstraction allo wing the designer to fo cus on imp ortan t b eha vior The inheren t trigger concept for rules reliev es the designer from the task to explicitly con trol the constrain tc hec k Moreo v er rules can b e used to mo del ev en t handling to deriv ed new attribute v alues and asso ciations and to mo del strategies in business and engineering Esp ecially for this last asp ect it is p opular to use rules Consider e.g whic h roughly explain the business rule approac h Rules are also v ery common in the activ e database comm unit y  Similar to rule concepts in this area also our rules follo w the ev en t-condition-action paradigm But unlik e those approac hes our rules do not need explicit trigger ev en ts but ma y b e triggered automatically in resp onse of a relev an tc hange Moreo v er our rule concept supp orts constrain ts and actions on sev eral in terrelated ob jects whic h is not done in man y activ e database systems Because of its underlying formal seman tics on the basis of graph transformation this rule concept supp orts the analysis of a designed rule set concerning e.g con\015icts dep endencies and further prop erties As already men tioned ab o v e a notion of critical pairs  kno wn from term rewriting  has b een extended to graph transformation Plu93 can b e used to detect con\015icting rule applications Logical form ulas ma y b e used to ensure additional prop erties of the rule set e.g to ensure that a certain ob ject is created only if another is existing If a rule set do es not ensure the v alidit y of a certain set of form ulas the rule set is automatically corrected HW95  Visual editing of graph rules and their application are supp orted b y the graph transformation mac hine A GG whic h is implemen ted in Ja v a The visual la y out of the rules is v ery similar to that one used in this con tribution and th us to UML As a next step w ein tend to extend A GG b y analysis to ols as indicated ab o v e T o incorp orate rules in to existing OO-mo deling tec hniques A GG ma ybe in tegrated in to corresp onding mo deling to ols In JZ98  rules are em b edded in to so-called story 015o w diagrams whic h are also mean t to complemen t existing ob ject-orien ted mo deling tec hniques The em b edded rules describ e basic data op erations whic h are con trolled b y the surrounding story b oard i.e all rule applications ha v e to b e explicitly triggered b y con trol 015o w T urning from mo deling to programming there are sev eral approac hes to incorp orate rules in to ob ject-orien ted programming languages Most of the approac hes are based on concepts of the rule-based language OPS5 CW88  There are approac hes lik e Rete  where rules are added to C Also R LPSM97  incorp orates rules in to C Here the kind of rules are not general but restricted to so-called path-based rules A path-based rule con tains paths from a this'-ob ject only  i.e eac h rule is form ulated within the lo cal view of an ob ject The rule concepts of these in tegrations di\013er more or less from the one presen ted in this con tribution Ac kno wledgmen ts Man y thanks to Mic hael Rudolf for giving sev eral v aluable commen ts on a draft v ersion of this pap er References BK97 M Barnes and D Kelly  Pla y By The Rules Byte Magazin  June 1997 


Bo G Bo o c h Obje ct-Oriente dA nalysis and Design with Applic ations  Benjamin Cummings 1994 CMR   A Corradini U Mon tanari F Rossi H Ehrig R Hec k el and M L\177 ow e Algebraic Approac hes to Graph T ransformation P art I Basic Concepts and Double Pushout Approac h In CW88 T A Co op er and N W ogrin R ule-Base dPr o gr amming with OPS5  Morgan Kaufmann San Mateo California 1988 Hal98 The Haley En terprise Seamless In tegration of Rules and Ob jects Using the Rete Algorithm and C http://www.haley.com  1998 HW95 R Hec k el and A W agner Ensuring Consistency of Conditional Graph Grammars  A constructiv e Approac h Pr o c of SEGRA GRA'95 Gr aph R ewriting and Computation Ele ctr onic Notes of TCS  2 1995 http://www.elsevier.nl/lo cate/entcs/volume2.html  JZ98 J.-H Jahnk e and A Z 177 undorf Sp eci\014cation and Implemen tation of a Distributed Planning and Information System for Courses based on Story Driv en Mo delling In Pr o c of the 9th Int Workshop on softwar eSp e ci\014c ation and Design IseShima Jap an  pages 77{86 IEEE Computer So ciet y  1998 Ken97 S Ken t Constrain t Diagrams Visualising In v arian ts in Ob ject Orien ted Mo dels In Pr o c e e dings of OOPSLA'97 A CM Press 1997 LM95 M L\177 ow e and J M 177 uller Critical Pair Analysis in Single-Pushout Graph Rewriting In G V F eruglio and F R Llompart eds Pr o c Col lo quium on Gr aph T r ansformation and its Applic ation in Computer Scienc e T ec hnical Rep ort B19 Univ ersitat de les Illes Balears 1995 LPSM97 D Litman P F.P atel-Sc hneider and A Mishra Mo deling Dynamic Collections of In terdep enden t Ob jects Using P ath-Based Rules In Pr o c of the 1997 A CM-SIGPLAN Confer enc e on Obje ct-Oriente dPr o gr amming Systems L anguages and Applic ations  1997 Plu93 D Plump Hyp ergraph Rewriting Critical Pairs and Undecidabili t y of Con\015uence In M Sleep M Plasmeijer and M C v an Eek elen eds Term Gr aph R ewriting  pages 201{214 Wiley  1993 RBP  91 J Rum baugh M Blaha W Premerlani E Eddy  and W Lorenson Obje ctOriente dMo deling and Design  Pren tice Hall In ternational 1991 Roz97 G Rozen b erg ed Handb o ok of Gr aph Gr ammars and Computing by Gr aph Tr ansformations V olume 1 F oundations W orld Scien ti\014c 1997 Roz99 G Rozen b erg ed Handb o ok of Gr aph Gr ammars and Computing by Gr aph T r ansformations V olume 2 Applic ations L anguages and T o ols W orld Scienti\014c 1999 to app ear TER99 G T aen tzer C Ermel and M Rudolf A GG-Approac h Language and T ool En vironmen t In Roz99  see also http://tfs.cs.tu-b erlin.de/agg  UML97 Rational Soft w are Co op eration Uni\014ed Mo deling Language a v ailable via http://www.rational.com  1997 


It can also be added to cell CrossSales.3\(PC, printer one_year,\205 5  Distributed and Incremental Rule Mining There exist two ways to deal with association rules 267  Static that is, to extract a group of rules from a snapshot, or a history, of data and use "as is 267  Dynamic that is, to evolve rules from time to time using newly available data We mine association rules from an e-commerce data warehouse holding transaction data. The data flows in continuously and is processed daily Mining association rules dynamically has the following benefits 267  223Real-time\224 data mining, that is, the rules are drawn from the latest transactions for reflecting the current commercial trends 267  Multilevel knowledge abstraction, which requires summarizing multiple partial results. For example association rules on the month or year basis cannot be concluded from daily mining results. In fact multilevel mining is incremental in nature 267  For scalability, incremental and distributed mining has become a practical choice Figure 3: Distributed rule mining Incremental association rule mining requires combining partial results. It is easy to see that the confidence and support of multiple rules may not be combined directly. This is why we treat them as \223views\224 and only maintain the association cube, the population cube and the base cube that can be updated from each new copy of volume cube. Below, we discuss several cases to show how a GDOS can mine association rules by incorporating the partial results computed at LDOSs 267  The first case is to sum up volume-cubes generated at multiple LDOSs. Let C v,i be the volume-cube generated at LDOS i The volume-cube generated at the GDOS by combining the volume-cubes fed from these LDOSs is 345   n i i v v C C 1  The association rules are then generated at the GDOS from the centralized C v  214  The second case is to mine local rules with distinct bases at participating LDOSs, resulting in a local association cube C a,I a local population cube C p,I  and a local base cube C b,i at each LDOS. At the GDOS, multiple association cubes, population cubes and base cubes sent from the LDOSs are simply combined, resulting in a summarized association cube and a summarized population cube, as 345   n i i a a C C 1   345   n i i p p C C 1  and 345   n i i b b C C 1  The corresponding confidence cube and support cube can then be derived as described earlier. Cross-sale association rules generated from distinct customers belong to this case In general, it is inappropriate to directly combine association cubes that cover areas a 1 205, a k to cover a larger area a In the given example, this is because association cubes record counts of customers that satisfy   customer product merchant time area Doe TV Dept Store 98Q1 California Doe VCR Dept Store 98Q1 California customer product merchant time area Doe VCR Sears 5-Feb-98 San Francisco Joe PC OfficeMax 7-Feb-98 San Francisco customer product merchant time area Doe TV Fry's 3-Jan-98 San Jose Smith Radio Kmart 14-Jan-98 San Jose Association   population      base          confidence      support cube               cube                cube         cube                cube LDOS LDOS GDOS 


the association condition, and the sets of customers contained in a 1 205, a k are not mutually disjoint. This can be seen in the following examples 214  A customer who bought A and B in both San Jose and San Francisco which are covered by different LDOSs , contributes a count to the rule covering each city, but has only one count, not two, for the rule A  336  B covering California 214  A customer \(e.g. Doe in Figure 3\who bought a TV in San Jose, but a VCR in San Francisco, is not countable for the cross-sale association rule TV  336 VCR covering any of these cities, but countable for the rule covering California. This is illustrated in Figure 3 6  Conclusions In order to scale-up association rule mining in ecommerce, we have developed a distributed and cooperative data-warehouse/OLAP infrastructure. This infrastructure allows us to generate association rules with enhanced expressive power, by combining information of discrete commercial activities from different geographic areas, different merchants and over different time periods. In this paper we have introduced scoped association rules  association rules with conjoint items and functional association rules as useful extensions to association rules The proposed infrastructure has been designed and prototyped at HP Labs to support business intelligence applications in e-commerce. Our preliminary results validate the scalability and maintainability of this infrastructure, and the power of the enhanced multilevel and multidimensional association rules. In this paper we did not discuss privacy control in customer profiling However, we did address this issue in our design by incorporating support for the P3P protocol [1 i n  ou r data warehouse. We plan to integrate this framework with a commercial e-commerce system References 1  Sameet Agarwal, Rakesh Agrawal, Prasad Deshpande Ashish Gupta, Jeffrey F. Naughton, Raghu Ramakrishnan, Sunita Sarawagi, "On the Computation of Multidimensional Aggregates", 506-521, Proc. VLDB'96 1996 2  Surajit Chaudhuri and Umesh Dayal, \223An Overview of Data Warehousing and OLAP Technology\224, SIGMOD Record Vol \(26\ No \(1\ 1996 3  Qiming Chen, Umesh Dayal, Meichun Hsu 223 OLAPbased Scalable Profiling of Customer Behavior\224, Proc. Of 1 st International Conference on Data Warehousing and Knowledge Discovery \(DAWAK99\, 1999, Italy 4  Hector Garcia-Molina, Wilburt Labio, Jun Yang Expiring Data in a Warehouse", Proc. VLDB'98, 1998 5  J. Han, S. Chee, and J. Y. Chiang, "Issues for On-Line Analytical Mining of Data Warehouses", SIGMOD'98 Workshop on Research Issues on Data Mining and Knowledge Discovery \(DMKD'98\ , USA, 1998 6  J. Han, "OLAP Mining: An Integration of OLAP with Data Mining", Proc. IFIP Conference on Data Semantics DS-7\, Switzerland, 1997 7  Raymond T. Ng, Laks V.S. Lakshmanan, Jiawei Han Alex Pang, "Exploratory Mining and Pruning Optimizations of Constrained Associations Rules", Proc ACM-SIGMOD'98, 1998 8  Torben Bach Pedersen, Christian S. Jensen Multidimensional Data Modeling for Complex Data Proc. ICDE'99, 1999 9  Sunita Sarawagi, Shiby Thomas, Rakesh Agrawal Integrating Association Rule Mining with Relational Database Systems: Alternatives and Implications", Proc ACM-SIGMOD'98, 1998   Hannu Toivonen, "Sampling Large Databases for Association Rules", 134-145, Proc. VLDB'96, 1996   Dick Tsur, Jeffrey D. Ullman, Serge Abiteboul, Chris Clifton, Rajeev Motwani, Svetlozar Nestorov, Arnon Rosenthal, "Query Flocks: A Generalization of Association-Rule Mining" Proc. ACM-SIGMOD'98 1998   P3P Architecture Working Group, \223General Overview of the P3P Architecture\224, P3P-arch-971022 http://www.w3.org/TR/WD-P3P.arch.html 1997 


Plenary Panel Session 30 XML Databases   Moderator: Michael Carey, IBM Almaden Research Center USA Panelists Adam Bosworth, Microsoft Corporation USA David De Witt University of Wisconsin-Madison, USA Alon Levy University of Washington USA Bruce Lindsay IBM Almaden Research Center USA Jennifer Widom Stanford University USA Demo Session 1 Web Query Optimizer  661 V Zadorozhny L Bright L Raschid T Urhan and M Vidal ReQueSS: Relational Querying of Semi-structured Data  664 R Sunderraman The IDEAL Approach to Internet-Based Negotiation for E-Business  666 J Hammer C Huang Y Huang C Pluempitiwiriyawej M Lee H Li L Wang Y Liu and S Su READY A High Performance Event Notification Service  668 R Gruber B Krishnamurthy, and E Panagos A Multimedia Information Server with Mixed Workload Scheduling  670 G Nerjes DISIMA An Object-Oriented Approach to Developing an Image Database System  672 V Oria T Ozsu P Iglinski B Xu and L Cheng Demo Session 2 The Collaboration Management Infrastructure  677 H Schuster D Baker A Cichocki D Georgakopoulos and M Rusinkiewicz Assisting the Integration of Taxonomic Data The LITCHI Toolkit  679 I Sutherland J Robinson S Brandt A Jones S Embury W Gray R White and F Bisby TheaterLoc: Using Information Integration Technology to Rapidly Build Virtual Applications  681 G. Barish Y.4 Chen D Dipasquo, C Knoblock S Minton I Muslea and C Shahabi Lineage Tracing in a Data Warehousing System  683 Y Cui and J Widom xiii 


The Mentor-Lite Prototype A Light-Weight Workflow Management System  685 J Weissenfels M Gillmann 0 Roth, G Shegalov and W Wonner Location Prediction and Queries for Tracking Moving Objects  687 0 Wolfson B Xu and S Chamberlain Semiorder Database for Complex Activity Recognition in Multi-Sensory Environments  689 S Bhonsle A Gupta S Santini and R Jain Tutorial 1 Web Information Retrieval  693 M Henzinger Tutorial 2 Mobile and Wireless Database Access for Pervasive Computing  694 P Chrysanthis and E Pitoura Tutorial 3 Data Mining with Decision Trees  696 J Gehrke Tutorial 4 Directories Managing Data for Networked Applications  697 D Srivastava Tutorial 5 Indexing High-Dimensional Spaces Database Support for Next Decade\222s Applications  698 S Berchtold and D Keim xiv 


 T5.I2.D100K T10.I4.D100K T15.I4.D100K T10.I6.D400K T10.I6.D800K T10.I6.D1600K Optimizations across Databases 5 0 5 10 15 20 25 30 35 40 45 Improvement COMP TREE COMP-TREE 1 2 4 8 1 2 4 8 1 2 4 8 2 4 8 2 4 8 1 2 4 8 Processors Databases Figure 5 Effect of Computation and Hash Tree Balancing good as the COMP optimization The reason that the hash tree balancing is not suf\336cient to offset inherent load imbalance in the candidate generation in this case The most effective approach is to apply both optimizations at the same time COMP-TREE The combined effect is suf\336cient to push the improvements in the 40 range in the multiple-processor case On 1 processor only hash tree balancing is bene\336cial since computation balancing only adds extra cost 5.4 Short-circuited Subset Checking Figure 6 shows the improvement due to the short-circuited subset checking optimization with respect to the unoptimized version The unoptimized version is the Apriori algorithm due to Agrawal et al 5 The results are presented for dif ferent number of processors across dif ferent databases The results indicate that while there is some improvement for databases with small transaction sizes the optimization is most effective when the transaction size is large In this case we get improvements of around 25 r the unoptimized version To gain further insight into this optimization consider 336gure 7 It shows the percentage improvement obtained per iteration on applying this optimization on the T20.I6.D100K database It shows results only for the uni-processor case r similar results were obtained on more processors We observe that as the iteration k increases there is more opportunity for shortcircuiting the subset checking and we get increasing bene\336ts of up to 60 The improvements start to fall off t the high end where the number of candidates becomes small resulting in a small hash tree and less opportunity for short-circuiting It becomes clear that is an extremely effective 15 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 T5.I2.D100K T10.I6.D800K T15.I4.D100K T20.I6.D100K procs across Databases 0 5 10 15 20 25 Improvement 1 2 4 8 Figure 6 Effect of Short-circuited Subset Checking 23456789101112 Iterations 0 10 20 30 40 50 60 improvement T20.I6.D100K Figure 7  Improvement per Iteration  proc   16 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


optimization for larger transaction sizes and in cases where there are large number of candidate k itemsets 6 Conclusions In this paper e presented a parallel implementation of the Apriori algorithm on the SGI Power Challenge shared memory multi-processor We also discussed a set of optimizations which include optimized join and pruning computation balancing for candidate generation hash tree balancing and short-circuited subset checking We then presented experimental results on each of these Improvements of more than 40 were obtained for the computation and hash tree balancing The short-circuiting optimization was found to be extremely effective for databases with large transaction sizes Finally we reported the parallel performance of the algorithm While we d good speed-up we observed a need for parallel I/O techniques for further performance gains References  R Agra wal T  Imielinski and A Swami Database mining A performance perspecti v e  I n IEEE Trans on Knowledge and Data Engg  pages 5\(6 1993  R Agra wal T  Imielinski and A Swami Mining association rules between sets of items in lar ge databases In Proc M SIGMOD Intl Conf Management of Data  May 1993  R Agra wal H Mannila R Srikant H T o i v onen and A I V erkamo F ast disco v ery of association rules In U F et al editor Advances in Knowledge Discovery and Data Mining  MIT Press 1996  R Agra wal and J Shafer  P arallel mining of association rules design implementation and e xperience Technical Report RJ10004 IBM Almaden Research Center San Jose CA 95120 Jan 1996  R Agra wal and R Srikant F ast algorithms for mining association rules In Proc 20th VLDB Conf  Sept 1994  M Cierniak W  Li and M J Zaki Loop scheduling for heterogeneity  I n 4th IEEE Intl Symposium on High-Performance Distributed Computing also as URCS-TR 540 CS Dept Univ f Rochester  Aug 1995  M Holsheimer  M  K ersten H Mannila and H T o i v onen A perspecti v e on databases and data mining In 1st Intl Conf Knowledge Discovery and Data Mining  Aug 1995  M Houtsma and A Swami Set-oriented mining of association rules In RJ 9567  IBM Almaden Oct 1993  H Mannila H T o i v onen and I V erkamo Ef 336cient algorithms for disco v ering association rules In AAAI Wkshp Knowledge Discovery in Databases  July 1994  J S P ark M Chen and P  S Y u  A n e f fecti v e hash based algorithm for mining association rules In Proc M SIGMOD Intl Conf Management of Data  May 1995 17 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 J S P ark M Chen and P  S Y u  E f 336cient parallel data mining for association rules T echnical Report RC20156 IBM T J Watson Research Center Aug 1995  G Piatetsk y-Shapiro Disco v ery  presentation and analysis of strong rules In G P S et al editor  KDD  AAAI Press 1991  A Sa v asere E Omiecinski and S Na v athe An ef 336cient algorithm for mining association rules in large databases In Proc 21st VLDB Conf  1995  M J Zaki M Ogihara S P arthasarathy  and W  Li P arallel data mining for association rules on shared-memory multi-processors Technical Report 618 Department of Computer Science University of Rochester 618 1996 18 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


