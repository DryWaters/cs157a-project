APT-Structure  Ef\002cient Mining of Frequent Patterns Shiwei Zhu School of Economics and Management Beihang University Beijing 100191 China Email sherwinzhu@buaa.edu.cn Renqian Zhang School of Economics and Management Beihang University Beijing 100191 China Email zhangrenqian@buaa.edu.cn Guoping Xia School of Economics and Management Beihang University Beijing 100191 China Email gxia@buaa.edu.cn Abstract Frequent pattern mining is a key step in many data mining applications In this paper we propose a simple and novel pattern growth algorithm which uses a compact dat a structure named Array-based Pre\002x Tree\(APT The APT has a distinct feature that the space requirement can be predicta 
ble in advance The memory usage of APT is less than FP-Tree that uses pointer to maintain the link between parent and child no des and the traversal cost is lower The mining algorithm based o n APT uses top-down traversal strategy and un\002ltered pseudo construct conditional database which can improve computa tional performance Further computational experiments show that APT algorithm is more ef\002cient and performs better than FPGrow th and AFOPT Index Terms Frequent pattern mining association mining Array-based Pre\002x Tree I I NTRODUCTION Since frequent pattern mining was 002rst proposed by Agrawal et al.\(1993 for market basket analysis in the form of associ ation rule mining a large number of concerned algorithms hav 
e been proposed The frequent pattern mining can be depicted as follows Let I be a set of items A set X  f i 1   i k g 2 I is called an itemset or a k itemset if it contains k items A transaction over I is a couple T   tid I  where tid is the transaction identi\002er and I is an itemset A transaction T   tid I  is said to support an itemset X 022 I  if X 022 I  A transaction database D over I is a set of transactions over I  We omit I whenever it is clear from the context The support of an itemset X in D 
is the number of transactions that support itemset X in D  denoted as sup  X   Given a transaction database D and a support threshold min supp  a itemset is called frequent itemset or frequent pattern  if and only if sup  X  025 min supp  De\002nition 1 Let D be a transaction database over a set of items I  and min supp a minimal support threshold The collection of frequent itemsets in D with respect to min supp is denoted by F  D  min supp   f X 022 Ij 
supp  X D  025 min supp g  or simply F  if D and min supp are clear from context The problem of frequent pattern mining is to 002nd the F  D  min supp   given a set of items I  a transaction database D over I and minimal support threshold min supp  Existing algorithms can be classed into three categories Apriori FP-growth and Eclat The Aprior is the 002rst algorit hm proposed by Agrawal et al 1  w h i c h e m p l o y s a c a n d i d a t e generate-and-test approach Apriori is a breadth-\002rst alg orithm and is based on the downward closure property:A k 
itemset is frequent only if all of its sub-itemsets are frequent Park e t al 2 p r o p o s e d D H P a l g o r i t h m  w h i c h u s e h a s h i n g t e c h n i q u e t o speed up the item set counting Savasere et al 3 p r o p o s e d Partition algorithm which partition the transaction data base into multi small blocks in which local frequent item sets ar e 002rstly found and then the global frequent item sets are got TreeProjection 4 a l g o r i t h m c o n s t r u c t s a l e x i c o g r a p h i c a l tree and projects a large database transaction into a set of reduc ed item-based sub-databases Toivonen 5 p r o p o s e d S a m p l i n g algorithm which only scans the transaction database once Brin et al 6 p r o p o s e d D I C a l g o r i t h m  w h i c h n e e d s s c a n n i n g the transaction database 1.5 times FP-growth is a pattern growth algorithm proposed by Han et 
al 7  w h i c h w o r k s i n a d i v i d e a n d c o n q u e r w a y  F P g r o w t h is a depth-\002rst algorithm and does not generate the candidat e The pattern growth is achieved by the concatenation of the suf\002x pattern with the frequent patterns generated from a conditional FP-tree Pei et al 8 p r o p o s e d H M i n e a l g o r i t hm which explores a hyper-structure Liu et al 9 p r o p o s e d OP algorithm which opportunistically chooses array-base d or tree-based structure to represent the conditional databas e Liu et al 10 p r o p o s e d A F O P T a l g o r i t h m  w h i c h u s e a s c e n d ing frequency ordered pre\002x-tree to organize the condition al database Grahnea and Zhu 11 p r o p o s e d F P G r o w t h  a l g o rithm which use array technique for ef\002cient mining Both Aprior and FP-growth mine frequent patterns form 
a horizontal data format transaction database Zaki 12 p r oposed Equivalence CLASS Transfromation\(Eclat algorithm by exploring the vertical data format with a depth-\002rst sea rch order like FP-growth The computation is done by intersecti on of tid sets For dense dataset dEclat 13 i s p r o p o s e d  w h i c h uses a novel vertical data representation called Diffset t hat only keeps track of difference in the tid sets This pater proposes a new method to improve the mining ef\002ciency which is based on Array-based Pre\002x Tree APT The rest of paper is organized as follows The next section t he data structure of APT and the mining algorithm are depicted 
2010 International Conference on E-Business and E-Government 978-0-7695-3997-3/10 $26.00 © 2010 IEEE DOI 10.1109/ICEE.2010.354 1395 


Section 3 presents computational experiments that show the new algorithm is more ef\002cient than others In the last secti on the paper is concluded II M INING F REQUENT P ATTERNS U SING APT In this section we introduce the APT structure and then a novel algorithm named APT algorithm is developed to 002nd the frequent item set A APT Structure The APT Structure is used to compactly store the transaction database in computer's memory By using array structure th e traversal cost can be diminished Our general idea of APT Structure can be illustrated in the following example Fig 1 is an example transaction database which has 5 transactions Let the minimum support threshold is min supp  2 Following the Apriori property only frequent items will be in frequen t item set By scanning the transaction database the frequen t items f f:4,c:4,a:3,b:3,m:3,p:3 g can be found 0007\000,\000 000,\000W\000H\000P\000V 000\013\0002\000U\000G\000H\000U\000H\000G\000\014\000I\000U\000H\000T\000X\000H\000Q\000W\000\003\000L\000W\000H\000P\000V 000\024\000\023\000\023 000I\000\017\000D\000\017\000F\000\017\000G\000\017\000J\000\017\000L\000\017\000P\000\017\000S 000I\000\017\000F\000\017\000D\000\017\000P\000\017\000S 000\027\000\023\000\023 000E\000\017\000F\000\017\000N\000\017\000V\000\017\000S 000F\000\017\000E\000\017\000S 000\026\000\023\000\023 000E\000\017\000I\000\017\000K\000\017\000M\000\017\000R 000I\000\017\000E 000\025\000\023\000\023 000D\000\017\000E\000\017\000F\000\017\000I\000\017\000O\000\017\000P\000\017\000R 000I\000\017\000F\000\017\000D\000\017\000E\000\017\000P 000\030\000\023\000\023 000D\000\017\000I\000\017\000F\000\017\000H\000\017\000O\000\017\000S\000\017\000P\000\017\000Q 000I\000\017\000F\000\017\000D\000\017\000P\000\017\000S Fig 1 A transaction database Then the transaction database is scanned again to build APT structure by removing the infrequent items and merging the same transactions As shown in Fig 2 the left is FPTree representation and the right is APT structure In APT structure each row is corresponding to a transaction but without duplicated items with previous row In a row each entry includes three 002eld an item a count and a link to the next different row B The APT Algorithm Fig 3 shows the pseudocode of APT algorithm Given a transaction database D and a minimum support threshold min supp  APT algorithm scans the original database twice to mine all frequent item sets In lines 2-3 of the pseudocode  the transaction database is 002rst scanned all the items are counted and frequent items are sorted in ascending order of their supports denoted as I  f i 1  i 2      i n g  Then in line 4 we perform the second scanning of the transaction databas e to construct the APT structure In lines 5-9 the conditiona l database for each i 2 I is constructed denoted as D i  For each i 2 I  the depth traversal is performed in lines 10-15 Lines 17-31 are the pseudocode of procedure DepthTravese  When mining conditional database D i is 002nished because it contains the other items the branch needs to be inserted int o the remaining conditional database Provided the 002rst freq uent item of a branch is item j  then the branch will be inserted into D j  000U\000R\000R\000W 000I\000\035\000\027 000D\000\035\000\026 000F\000\035\000\026 000P\000\035\000\025 000S\000\035\000\025 000E\000\035\000\024 000E\000\035\000\024 000P\000\035\000\024 000F\000\035\000\024 000E\000\035\000\024 000S\000\035\000\024 a FP-Tree Structure 000I\000\035\000\027 000F\000\035\000\026 000D\000\035\000\026 000P\000\035\000\025 000S\000\035\000\025 000E\000\035\000\024 000P\000\035\000\024 000E\000\035\000\024 000F\000\035\000\024 000E\000\035\000\024 000S\000\035\000\024 b APT Structure Fig 2 The FP-Tree and APT structure 1 procedure APT D  min supp  2 First Scan D  Count and I  f i 1  i 2      i n g  3 Sort items in I in ascending order of their support 4 Second Scan D  Construct the APT structure 5 for all branch b 2 APT do 6 if i is the 002rst item then 7 Insert b into conditional database D i  8 end if 9 end for 10 for all item i 2 I do 11 frequent itemset p  f i g  12 F  F S p  13 DepthTravese D i  p  I  14 PushRight D i  15 end for 16 end procedure 17 procedure D EPTH T RAVESE  D p  p  I  18 Scan the D p  Count and I p  f i 1  i 2      i m g  19 for all branch b 2 D p do 20 if i is the 002rst item then 21 Insert b into conditional database D p S f i g 22 end if 23 end for 24 for all item i 2 I p do 25 frequent itemset p  p S f i g  26 F  F S p  27 DepthTravese D p S f i g  p  I p  28 PushRight D p S f i g  29 end for 30 return F  31 end procedure Fig 3 The APT Algorithm C The Conditional Database and Memory Usage Because to build the physical construction of the condition al database is expensive in memory and time the APT algorithm adopts the pesudo-construct strategy In APT only the bran ch link are saved in the conditional database so the construct ion cost is relatively low In the worst case the total memory us ed 
1396 


by the APT algorithm is 4 n  where n is the number of entry in APT structure Of the 4 n memory space 3 n is used to store the APT structure n is used to store the conditional database The exact number of entry is unknown before the APT structure is constructed but it is less than the total transaction dat abase item count Comparing with other frequent item set mining method the ef\002ciency of APT algorithm comes from the following aspects First APT algorithm adopts the frequent pattern gro wth method and depth-\002rst traversal strategy Second APT algo rithm uses pesudo-construct strategy to build the conditio nal database and the total memory consumption is determined by the APT structure which is unlike other frequent pattern growth algorithms Third APT algorithm uses array to build APT structure so the transaction traversal is faster than o ther methods such as link list III C OMPUTATION E XPERIMENTALS In this section we study the performances of APT FPGrowth and AFOPT algorithms on various real-world and arti\002cial data sets A Experimental Setup In our experiments to make it easier to bridge our benchmarks with previously published experimental results we u se three real-world data sets and one arti\002cal data set whose general characteristics are summarized in Table I TABLE I S OME CHARACTERISTICS OF EXPERIMENTAL DATA SETS  Data set Item Record Avg Length Source Retail 16470 88162 10.3 Belgian Retail store T10I4D100K 870 100000 10.1 IBM Almaden Wap 8460 1560 141.3 WebACE La1 29714 3204 151.1 LA Times TREC These data sets were obtained from various application domains Retail contains the retail market basket data from an anonymous Belgian retail store 1  T10I4D100K was generated using a data generator obtained from IBM Almaden which is often used in the association rule research community 2  Wap was from the WebACE project Each document corresponds to a web page listed in the subject hierarchy of Yahoo Finally  La1 was obtained from articles of the Los Angeles Times that was used in TREC-5 3  The FPGrowth and AFOPT algorithm are different implementations of FP-growth algorithm The former uses a novel array-based technique to reduces the need to traverse FP-tr ees and the later uses ascending frequency ordered pre\002x-tree and a top-down strategy The source code can found from http://\002mi.cs.helsinki.\002/src All the algorithms were coded in C and C build with Microsoft Visual C 2008 and run on a Microsoft Windows 7 Ultimate platform The experimental PC is installed a Inte l 1 Available at http://\002mi.cs.helsinki.\002/data 2 Available at http://\002mi.cs.helsinki.\002/data 3 Available at http://www.daviddlewis.com 2 4 6 8 10 12 x 10 3 10 2 10 3 10 4 10 5   support Execution time\(millisecond   APT FPGrowth  AFOPT  a Retail 2 4 6 8 10 12 x 10 3 10 2 10 3 10 4   support Execution time\(millisecond   APT FPGrowth  AFOPT  b T10I4D100K 5 10 15 20 25 30 10 0 10 5   support Execution time\(millisecond   APT FPGrowth  AFOPT  c Wap 0.5 1 1.5 2 2.5 3 10 3 10 4 10 5 10 6 10 7   support Execution time\(millisecond   APT FPGrowth  AFOPT  d La1 Fig 4 Computational times of APT FPGrowth and AFOPT Q9550 CPU 4 GB DDRIII 1066 MHz RAM and Seagate Barracuda 7200.11 500GB Hard Disk B Experimental Result First We would like to compare the performance of the APT FPGrowth and AFOPT Fig 4 shows the results of data sets Retail  T10I4D100K  Wap and La12  We can see that the APT has the best performance For Retail  we set the minimum support from 0.002 
1397 


2 4 6 8 10 12 x 10 3 10 2 10 3 10 4  support Execution time\(millisecond   Ascending Descending  a Retail 2 4 6 8 10 12 x 10 3 10 2 10 3 10 4  support Execution time\(millisecond   Ascending Descending  b T10I4D100K Fig 5 Computational times of APT with ascending and descen ding order to 0.0012 with corresponding absolute support from 2 to 13 When the minimum support is 0.002 there are 14246 frequent items and 1839084261 frequent item sets When the minimum support is 0.012 there are 8241 frequent items and 155111 frequent item sets When the minimum support is lower the APT is much faster than the others and when the minimum support gets higher the executing time is close d to others For T10I4D100K  the minimum support is from 0.002 to 0.0012 and the absolute support is from 2 to 12 When the minimum support is 0.002 there are 869 frequent items and 19561714 frequent item sets When the min support is 0.012 there are 866 frequent items and 286023 frequent item sets For Wap  because the number of transactions is small we set the minimum support from 2 to 12 with corresponding absolute support from 31 to 187 For La1  the minimum support is from 0.5 to 3 with corresponding absolute support from 16 to 96 When the minimum support is higher the executing times are closed because there are little frequent item sets However when the minimum suppor t decreases the frequent item sets increase substantially and computational times go up to 4661s and 3298s for FPGrowth and AFOPT respectively Second We compare the impact of item order for the performance of the APT Generally the descending order means more sharing entries and less memory usage But for traversal process the ascending means less depth and more performance Fig 5 shows the results of data sets Retail  T10I4D100K for APT with ascending and descending order Generally the execution time with ascen ding order is less than with descending order but the former need s more space than the later For Retail  there is obvious difference between ascending order and descending order B ut for T10I4D100K  there is little difference This is related to the property of transaction dataset IV C ONCLUSION In this paper we have proposed a new Array-based Pre\002x Tree data structure named APT structure which is a compact representation of transaction database and need less stora ge space than that of FP-Tree APT structure is used in our novel algorithm named APT algorithm for mining all frequent item sets The APT algorithm traverses the search space from top to down and store the conditional database using pseudoconstruct in the mining process Performance comparisons of APT algorithm against other well-known algorithms including FPGrowth and AFOPT have been done The results shows that the APT algorithm outperforms the others at all support levels in computational times The APT algorithm is simple and has a distinct feature that the space requirement is predictable in advance which has a linear relationship with the number of entries In the further we will study the performance on very large databases A CKNOWLEDGMENT This research is supported by the National Natural Science Foundation of China NSFC No.70871005 70671007 R EFERENCES 1 R  A g r a w a l  T  I m i e l i n s k i  a n d A  S w a m i   M i n i n g a s s o c i a tion rules between sets of items in large databases in Proceedings of the 1993 ACM SIGMOD International Conference on Management of Data  Washington DC 1993 pp 207216 2 J  P a r k  M  C h e n  a n d P  Y u   A n e f f e c t i v e h a s h b a s e d a l g o rithm for mining association rules SIGMOD Rec  vol 24 no 2 pp 175186 1995 3 A  S a v a s e r e  E  O m i e c i n s k i  a n d S  N a v a t h e   A n e f 002 c i e n t algorithm for mining association rules in large databases in VLDB 95 Proceedings of the 21th International Conference on Very Large Data Base s  San Francisco CA USA Morgan Kaufmann Publishers Inc 1995 pp 432 444 4 R  A g a r w a l  C  A g g a r w a l  a n d V  P r a s a d   A t r e e p r o j e c t i o n algorithm for generation of frequent itemsets Journal of Parallel and Distributed Computing  vol 61 pp 350371 2000 5 H  T o i v o n e n   S a m p l i n g l a r g e d a t a b a s e s f o r a s s o c i a t i o n rules Morgan Kaufmann 1996 pp 134145 6 S  B r i n  R  M o t w a n i  J  U l l m a n  a n d S  T s u r   D y n a m i c i t e m set counting and implication rules for market basket data ACM Press 19 97 pp 255264 7 J  H a n  J  P e i  a n d Y  Y i n   M i n i n g f r e q u e n t p a t t e r n s w i t h out candidate generation in Proceedings of the 2000 ACM SIGMOD International Conference on Management of Data  Dallas TX 2000 pp 112 8 J  P e i  J  H a n  H  L u  S  N i s h i o  S  T a n g  a n d D  Y a n g   H m i ne Hyperstructure mining of frequent patterns in large databases 2001 pp 441 448 9 J  L i u  Y  P a n  K  W a n g  a n d J  H a n   M i n i n g f r e q u e n t i t e m s ets by opportunistic projection in KDD 02 Proceedings of the eighth ACM SIGKDD international conference on Knowledge discovery an d data mining  New York NY USA ACM 2002 pp 229238 10 G  L i u  H  L u  a n d J  Y u   A f o p t  A n e f 002 c i e n t i m p l e m e n t a t ion of pattern growth approach in In Proceedings of the ICDM workshop  2003 11 G  G r a h n e a n d G  Z h u   E f 002 c i e n t l y u s i n g p r e 002 x t r e e s i n m ining frequent itemsets 2003 12 M  Z a k i  S  P a r t h a s a r a t h y  M  O g i h a r a  a n d W  L i   N e w a l gorithms for fast discovery of association rules in In 3rd Intl Conf on Knowledge Discovery and Data Mining  AAAI Press 1997 pp 283286 13 M  Z a k i a n d K  G o u d a   F a s t v e r t i c a l m i n i n g u s i n g d i f f s e ts 2001 pp 326335 
1398 


TABLE III  S IMULATION P ARAMETERS  Parameters for Flash Memory Space  Parameters for Modified FAST scheme  NAND Flash Memory Size 512 Mbytes Space for data blocks 192 ~ 414 MB Page Size 512 bytes Space for random log blocks 64 MB Writing speed 210.5 011  Space for prefetch sequential\ log blocks 64 ~ 128 MB Reading speed 200 011  Erasing speed 1.2 sec go to y of the data, and the other \(100x go to \(100y  of the data and thus 50:50 means no locality. Moreover we have conformed to the Zipfs law to generate the block reference within a particular file. The Zipf's law states that the product of rank number and frequency make up a constant; that is, while only a few blocks within a file are used very often, many or most are used rarely B  Experimental results In our experiment, we have evaluated our proposed method in three aspects. First, it is necessary to determine optimal amounts of training data to develop sequential patterns. Second, in case of using synthetic data, we will investigate how much the locality of reference affects the system performance. Lastly, we need to check the effect which results from adjusting the threshold of pattern weight In principle, we need to check effect which results from changing the size of data block, where the data block means a unit of data transfer; a file consists of a set of data blocks In case of MPEG data, a data block corresponds to GOP Group of Pictures\, whose size is not fixed. However, we have found that the processing time is not greatly dependent upon the size of data block, which implies that our proposed method does not need to have any regard for some special issues depending upon a particular file format 1  Effect of changes in the size of training data We expect that extracted patterns can get more salient as the size of training data get larger. For example, given an extracted pattern F 2 001\027 F 1 for 2,000 training files, one of its related patterns may be F 2 001\027 F 3 001\027 F 5 001\027 F 1 for 3,000 training files This section describes how much the size of training data can affect on performance of prefetching. In general, when developing a prediction model with machine learning algorithms, a larger training data always does not result in developing a better model [6  Fig. 3 shows changes in the processing time as the training data gets larger in size in case of using SYN and UCC data. In this figure, we can see that in order for prefetching to reduce the overall process time, the size of training data had better be greater than some threshold, but excessive amounts of training data causes an increase in process time; this is because excessive amounts of many training data cause pattern over-fitting which leads to prefetch too many files onto flash memory space. In our experiment, the optimal size of training data is 3,500 and 40,000 I/O requests for SYN and UCC data, respectively 2  Effect of changes in locality with the synthetic data This section describes how much the degree of reference of locality can influence on performance of prefetching for SYN data. In our experiment, we have generated the SYN data with three kinds of locality of reference; 2:8, 3:7, 4:6 Fig. 4 shows the processing time according to changes in reference of locality, it shows that our proposed method outperforms the conventional one for all types of locality and 2:8 of locality shows the best performance. On the whole, the processing time decreases as the degree of locality increases  3  Effect of changes in threshold of pattern weight As stated before, lower \(or higher\ threshold value of pattern weight can incur excessive prefetching operations. It is thus important to find the optimal threshold for the best performance   a\In case of SYN data  b\In case of SYN data Figure 3.Changes of processing time from varying the size of training data   Figure 4. Changes of processing time from varying reference of localit y 
284 


Fig. 5 shows the execution time according to changes in the threshold value of weight when using SYN and UCC data. From this figure, we can see that the execution time is greatly influenced by the threshold values. In contrast, in case of file-level prefetching, the change in threshold value of weight does not give a great effect on the execution time For both SYN and UCC data, when the threshold value is set to 2, the proposed method shows the shortest execution time In case of less than 3 \(i.e., prefetching all \(or most of\e objects belonging to the generated sequential patterns excessive prefetching causes a big increase in the execution time. Conversely, as the threshold value becomes higher than the optimal value, the favorable effect from prefetching decreases gradually V  S UMMARY  In this paper, we have proposed an intelligent two-level prefetching method in which sequential pattern mining is incorporated into the FAST-aware hybrid flash-disk storage system. In our work, the hybrid storage uses the flash memory as a cache space, and we focus on prefetching file or block\objects onto prefetch \(or sequential\og blocks to be accessed in the near future through sequential pattern mining. To achieve the best performance, it is very important to determine optimal values in terms of threshold of pattern weight and the size of training data. To be noted is that the proposed method works at the level of file and block objects   b\In case of SYN data   b\In case of SYN data Figure 5: Effect of changes in weight threshold In contrast, previous studies focused on prefetching block-level objects [1 i t h si m p l e he u r i s t i c s e v e n t h o ugh they cannot be applied to hybrid storage systems. On the whole, the proposed two-level prefetching is more effective than file-level prefetching in UCC and the synthetic data Empirical results show that in terms of the execution time the proposed method improves the I/O performance of hybrid storage by about 16% and 18% for UCC and SYN data, respectively, compared to the Top-N prefetching under the FAST scheme. We submit that two-level prefetching can help to significantly enhance the future commercial hybrid storage products. In the future, we plan to study a way of semi-automatically adjusting several parameters such as the weight threshold and the size of training data for sequential pattern mining A CKNOWLEDGMENT  This work was supported by the Basic Research Program through the Korea Science and Engineering Foundation funded by the Ministry of Education, Science and Technology \(Grant Number: R01-2007-000-206490  R EFERENCES  1  Hybrid drive: Wikipedia, http://en.wikipedia.org/wiki/Hybrid_drive 2  S. L. Min and E. H Nam, Current trends in flash memory technology: invited paper, Proceedings of the 2006 conference on Asia South Pacific design automation, 2006, pp. 332-333 3  Y.H. Bae, Design Technique of High Performance Flash Memory SSD \(Solid State Disk\, Journal of Korean Institute of Information Scientists and Engineers, Vol. 25, No. 6, 2007, pp.18-28 4  E. Gal and S. Toledo, Algorithms and Data Structures for Flash Memories, ACM Computing Surveys, Vol. 37, No. 2,  2005, pp.138 163 5  H.J. Kim, and S.G. Lee, An Effective Flash Memory Manager for Reliable Flash Memory Management, IEICE Transactions on Information and Systems, Vol. 85, No. 6, 2002, pp.950-964 6  S. W. Lee, D. J. Park, T. S. Ching, D. H. Lee, S. W. Park, and H. J Song, A Log Buffer-Based Flash Translation Layer Using FullyAssociative Sector Translation, ACM Transactions on Embedded Computing Systems, Vol. 6, No. 3, 2007, pp.18-44 7  R. Agrawal, R. Srikant, Mining sequential patterns, Proceedings of the 11th International Conference on Data Engineering \(ICDE'95 1995, pp.3-14 8  P.N. Tan, M. Steinbach, and V. Kumar, Introduction to Data Mining Addison-Wesley, 2006 9  E.P. Markatos and C. Chronaki, A Top-10 Approach to Prefetching on the Web, Proceedings of the INET 98 Conference, 1998   C.I. Ezeife, Y. Lu, and Y. Liu, PLWAP sequential mining: open source code, Proceedings of the 1st international workshop on open source data mining \(OSDM05\, 2005, pp.26-35   M.L. Chiang, Paul C.H. Lee, and R.C. Chang, Using data clustering to improve cleaning performance for flash memory, Software Practice and Experience, Vol.29, No.3, 1999, pp.267-290   Z. Li, Z. Chen, S. M. Srinivasan and Y. Zhou, C-Miner: Mining Block Correlations in Storage Systems, Proceedings of the 3rd USENIX Conference on File and Storage Technology \(FAST04 2004, pp.173-186  
285 


composition debugging model, are discussed in details. After the decision table is constru cted through collecting WSDL interface information, composition process specification, and testing execution information rule extraction algorithm in rough set reasoning is used to find the rules associated with system or service failures. In a ddition, the feasibility and effectiveness of our approach are validated by two examples and experiments. At present, we onl y consider the debugging problem for the common Web service system, the fault location for semantic Web services should be further explored in the on-going research A CKNOWLEDGMENT  This work was supported in part by the National Natural Science Foundation of China \(NSFC\under Grant No 60803046, China Postdoctoral Science Foundation under Grant No.2007041 0946, the Science Fo undation of Jiangxi Educational Committee under Grant No. GJJ10433, and the Youth Foundation of Jiangxi University of Finance and Economics. The author is grateful to Qiong Zhang for her warm-heart help, and thanks the anonymous reviewers for their insightful comments R EFERENCES  1 W. Han  Integrating Peer-to-Peer into Web Services Master thesis University of Saskatchewan, 2006  W3C Web S e rvi ces Activit y avai lable fro m  http://www w3.org 2002/ws/, accessed on July 2010  W o rld W i de W e b Cons ortiu m  W3C Web Services Description Language \(WSDL\ Version 1.1 March, 2001. Available at http://www. w3.org/TR/wsdl  W o r l d W i de W e b Consor tiu m  W 3C  Simple Object Access Protocol Version 1.2 April 2007, available at http://www.w3.org/TR/soap12  OASIS WSBP EL Technical Co mm i ttee  Web Services Business Process Execution Language, Version 2.0 available at http://docs oasis-open.org/wsbpel/2.0 /wsbpelv2.0.pdf  M. Aoya m a S Wee rawa rana, H Maruya m a and et al W eb  Services Engineering: Promises and Challenges Proc. of ICSE02  ACM Press, New York 2002, pp. 647-648  C. Liu L. Fei X Yan, and et al., Statistical Debuggin g: A Hypothesis Testing-Based Approach IEEE Transactions on Software Engineering 2006, vol. 32, no. 10, pp.1-17  W  Dickinson, D. Leon, and A Podgurski, Finding Failures by Cluster Analysis of Execution Profiles Proc. of ICSE01 2001, pp 339-348  Z. Li and Y Zhou, PRM iner: Automatically Extracting Implicit Programming Rules and Detecting Violations in Large Software Code Proc. of ESEC/ FSE05 2005, pp. 306-315  M. Renieris, and S. P Reiss, Fault LocalizationWith Nearest Neighbor Queries Proc. of ASE03 2003, pp. 30-39  C. Liu, Z Lian and J. Han, How Bayesians Debug Proc. of ICDM06 2006, pp.382-393  G. D. F a tta, S   Leue, and E. St e g antova D iscri m inative Pattern Mining in Software Fault Detection Proc. of SOQUA06 2006 pp.62-69  M. J Harrold, G. Rotherm e l, K Sayre, and et al., An Empirical Investigation of the Relationship Between Fault-revealing Test Behavior and Differences in Program Spectra Journal of Software Testing Verification and Reliability 2000, vol. 10, no.3, pp. 171-194  D. Jeffrey, N. Gup ta, and R. Gupta Fault Localizatio n Using Value Replacement Proc. of ISSTA08 2008, pp. 167-178  IBM W e b Services: Taking e-Busi ness to the Next Level White Paper, 2000, available from: http://www.ibm.com/developerworks/cn websphere/ download/pdf/e-businessj.pdf  S. Noikajana, and T. Suwannasart, W eb Service Test Case Generation Based on Decision Table Proc. of the 8th International Conference on Quality Software \(QSIC08 2008, pp. 321-326  C M a o Per form ing Co m b inator ial Testing on W e b Ser viceBased  Software Proc. of Intl Conf. on Computer Science and Software Engineering \(CSSE08 2008, vol.2, pp.755-758  T  Y Chen F.C  Kuo T  H T s e and et al  M eta m or phic T e sting and Beyond Proc. of the 11th International Workshop on Software Technology and Engineering Practice \(STEP03 2003, pp.94-100  Business Process Managem e nt Initiative Business Process Modeling Language \(BPML November, 2002  W 3 C  OWL-S: Semantic Markup for Web Services Nov. 22, 2004 available from: http://www.w3.org/ Submission/OWL-S  Z. Pawlak, Roug h Set Intl Journal of Information and Computer Science vol. 11, 1982, pp. 341-356  Jianhua Dai Research on Rough Set Theory and Its Applications in Knowledge Discovery \(Ph. D. Dissertation Library of Wuhan University, 2003, pp. 97104.   \(in Chinese  M Kry szkiewicz, Rou gh Set Approach to Inco m p l e t e Inform ation Systems Information Sciences 1998, vol. 112, pp. 39-49  C  M a o, Slicing W e b Ser vicebased Softwar e Proc. of IEEE International Conference on Service-Oriented Computing and Applications \(SOCA09 Taipei, Taiwan, December 14-15, 2009, pp 91-98  C M a o X Hu and Y L u  T owards a Softwar e Diagnosis M e tho d  Based on Rough Set Reasoning Proc. of the IEEE 8th International Conference on Computer and Information Technology \(CIT08  Sydney, Australia, July 811, 2008, pp. 718-723  I   Gr osclaude  M odelbased M o nitor ing of Co m ponentbased Software Systems Proc. of the 15th International Workshop on Principles of Diagnosis 2004, pp. 155-160  L  Ar dissono L  Console A Go y  and et al Enhancing W e b  Services with Diagnostic Capabilities Proc. of the 3rd IEEE European Conference on Web Services 2005, pp. 182-191  X Fu P Z ou  Z   Shang and et al   Fault Diagnosis f o r W e b Ser vice Composition Based on Bayesian Network, Computer Applications 2008, vol.28, no. 5, pp. 1095-1097.   \(in Chinese   
299 


        


9 Appendix Fig 6: Forest Cover Types of the U.S. \(Source. USGS National Atlas of US Summary of Forest Cover Type Data Type Multivariate Abstract The forest cover type for 30 x 30 meter cells obtai ned from US Forest Service \(USFS\ Region 2 Resource Information System RIS\ data Data Characteristics The actual forest cover type for a given observatio n \(30 x 30 meter cell\ was determined from US Fores t Service \(USFS\ Region 2 Resource Information System RIS data Independe nt variables were derived from data originally obta ined from US Geological Survey \(USGS\ and USFS data. Data is in raw form \(not scaled\ and contains binary \(0 or 1 columns of data for qualitative independent variables \(wilderness areas and soil types Summary Statistics Number of instances observations 581012 Number of Attributes 54 Attribute breakdown 12 measures, but 54 columns of data \(10 quantitativ e variables, 4 binary wilderness areas and 40 binary soil type variables Missing Attribute Values None 43 


   C4.2 Open GL has excellent documentation that could help the developer learn the platform with ease C4.3 Developer has very little ex perience in working with Open GL platform  For our case study, alternative B i.e. Adobe Director was the most favorable alternative amongst all the three. It catered to the reusability criteria quite well and aimed at meeting most of the desired operational requirements for the system   6. CONCLUSION & FUTURE WORK  The main contribution of this paper is to develop an approach for evaluating performance scores in MultiCriteria decision making using an intelligent computational argumentation network. The evaluation process requires us to identify performance scores in multi criteria decision making which are not obtained objectively and quantify the same by providing a strong rationale. In this way, deeper analysis can be achieved in reducing the uncertainty problem involved in Multi Criteria decision paradigm. As a part of our future work we plan on conducting a large scale empirical analysis of the argumentation system to validate its effectiveness   REFERENCES  1  L  P Am g o u d  U sin g  A r g u men ts f o r mak i n g an d  ex p lain in g  decisions Artificial Intelligence 173 413-436, \(2009 2 A  Boch m a n   C ollectiv e A r g u men tatio n    Proceedings of the Workshop on Non-Monotonic Reasoning 2002 3 G  R Bu y u k o zk an  Ev alu a tio n o f sof tware d e v e lo p m en t  projects using a fuzzy multi-criteria decision approach Mathematics and Computers in Simualtion 77 464-475, \(2008 4 M T  Chen   F u zzy MCD M A p p r o ach t o Selec t Serv ice  Provider The IEEE International Conference on Fuzzy 2003 5 J. Con k li n  an d  M. Beg e m a n   gIBIS: A Hypertext Tool for Exploratory Policy Discussion Transactions on Office Information Systems 6\(4\: 303  331, \(1988 6 B P  Duarte D e v elo p in g a p r o jec ts ev alu a tio n sy ste m based on multiple attribute value theroy Computer Operations Research 33 1488-1504, \(2006 7 E G  Fo rm an  T h e  A n a l y t ic Hier a rch y P r o cess A n  Exposition OR CHRONICLE 1999 8 M. L ease  an d J L  L i v e l y  Using an Issue Based Hypertext System to Capture Software LifeCycle Process Hypermedia  2\(1\, pp. 34  45, \(1990 9  P e id e L i u   E valu a tio n Mo d e l o f Custo m e r Satis f a c tio n o f  B2CE Commerce Based on Combin ation of Linguistic Variables and Fuzzy Triangular Numbers Eight ACIS International Conference on Software Engin eering, Artificial Intelligence Networking and Parallel Distributed Computing, \(pp 450-454 2007  10  X  F L i u   M an ag e m en t o f an In tellig e n t A r g u m e n tatio n  Network for a Web-Based Collaborative Engineering Design Environment Proceedings of the 2007 IEEE International Symposium on Collaborative Technologies and Systems,\(CTS 2007\, Orlando, Florida May 21-25, 2007 11 X. F L i u   A n In ternet Ba se d In tellig e n t A r g u m e n tatio n  System for Collaborative Engineering Design Proceedings of the 2006 IEEE International Symposium on Collaborative Technologies and Systems pp. 318-325\. Las Vegas, Nevada 2006 12 T  M A sub jec tiv e assess m e n t o f altern ativ e m ission  architectures for the human exploration of Mars at NASA using multicriteria decision making Computer and Operations Research 1147-1164, \(June 2004 13 A  N Mo n ireh  F u zzy De cisio n Ma k i n g b a se d o n  Relationship Analysis between Criteria Annual Meeting of the North American Fuzzy Information Processing Society 2005 14 N  P a p a d ias HERMES Su p p o rti n g A r g u m e n tative  Discourse in Multi Agent Decision Making Proceedings of the 15th National Conference on Artifical Intelligence \(AAAI-98  pp. 827-832\dison, WI: AAAI/MIT Press,  \(1998a 15  E. B T riantaph y llo u   T h e Im p act o f  Ag g r e g atin g Ben e f i t  and Cost Criteria in Four MCDA Methods IEEE Transactions on Engineering Management, Vol 52, No 2 May 2005 16 S  H T s a u r T h e Ev alu a tio n o f airlin e se rv ice q u a lity b y  fuzzy MCDM Tourism Management 107-115, \(2002 1 T  D W a n g  Develo p in g a f u zz y  T O P S IS app r o ach  b a sed  on subjective weights and objective weights Expert Systems with Applications 8980-8985, \(2009 18 L  A  Zadeh  F u z z y Sets   Information and Control 8  338-353, \(1965  152 


                        





