 Jeffrey Xu Yu 
SCC SCC 
Abstract 
2 
The Chinese University of Hong Kong Hong Kong China 2 Key Laboratory of High Con\223dence Software Technologies Ministry of Education CUHK Sub-Lab zwzhang,yu}@se.cuhk.edu.hk 3 Centre for Quantum Computation and Intelligent Systems University of Technology Sydney Australia Lu.Qin@uts.edu.au 
 computation is a fundamental graph operation on directed graphs where an 
227As an important branch of big data processing big graph processing is becoming increasingly popular in recent years Strongly connected component  
S 
 
1 3 1 
is a maximal subgraph 
of a directed graph 
Contract  Expand I/O Ef\336cient SCCs Computing Zhiwei Zhang 
1 
LuQin 
SCC SCC SCC 
G S G G G 
 By contracting each s of a graph 
DAG 
in which every pair of nodes is reachable from each other in 
whose nodes cannot 036t entirely in the main memory To overcome 
 In the literature there are I/O ef\036cient semi-external algorithms to compute all 
can 036t in the main memory However many real graphs are large and even the nodes cannot reside entirely in the main memory In this paper we study new I/O ef\036cient external algorithms to 036nd all s for a directed graph 
into a node a large general directed graph can be represented by a small directed acyclic graph  
 by assuming that all nodes of a graph 
the de\036ciency of the existing external graph contraction based approach that usually cannot stop in 036nite iterations and the external 
DFS 
sofall nodes in the graph are computed Both graph contraction phase and graph expansion phase use only I/O ef\036cient sequential scans 
based approach that will generate a large number of random I/Os we explore a new contraction-expansion based approach In the graph contraction phase instead of contracting the whole graph as the contraction based approach we only contract the nodes of a graph which are much more selective The contraction phase stops when all nodes of the graph can 036t in the main memory such that the semi-external algorithm can be used in computation In the graph expansion phase as the graph is expanded in the reverse order as it is contracted the 
SCC SCC 
SCC 
 computation which is a fundamental graph operation on directed graphs Here an 
computation algorithm and usually stops in a small number of iterations We further optimize our approach by reducing the size of nodes and edges of the contracted graph in each iteration We conduct extensive experimental studies using both real and synthetic webscale graphs to con\036rm the I/O ef\036ciency of our approaches 
I I NTRODUCTION Graph is an important data structure to model complex relationships among entities A road network a social network and the entire WWW can be modelled as graphs and all such graphs are huge In this paper we study the problem of strongly connected component  
and external sorts of nodes/edges in the graph Our algorithm leverages the ef\036ciency of the semi-external SCC SCC 
s on large graphs is highly demanded by many real applications that ne ed topological sort reachability query processing and graph pattern matching in graph processing 1 Topological sort is widely used in many applications especially in planning and scheduling In a topological sort nodes in a directed graph are ranked according to a partial order speci\336ed by the edges If there are cycles in the graph all nodes in a cycle are considered as equal rank 
in S to v in S to u in S 
for a given directed graph G 
thereis a directed path from u 
is a maximal subgraph S 
 Computing 
and v 
SCC 
 such that for every pair of nodes u 
and there is also a directed path from v 
through a directed path in a directed graph There are many applications in social networks biological networks software analysis and semantic web Because two nodes in an 
s in the graph In 16 H el l i ngs et al  p ropos e a n e f 336 ci ent algorithm for external bisimulation on graphs where all nodes are assumed to be in the reverse topological order and stored on disk This needs to 336nd all 
into a directed acyclic graph  
s in a preprocessing step 2 Reachability query is a widely studied query to ask whether a node u 
and are merged into one node This is done by 336nding all 
can reach another node v 
are reachable from each other in the literature almost all algorithms to process reachability queries over a general directed graph G 
SCC SCC SCC 
336rst convert G 
 An in-memory algorithm requires G 
to reside entirely in memory For the in-memory algorithm the Kosaraju-Sharir algorithm 3 can 336nd all 
into a node which needs to 336nd all 
to reside entirely in memory and a semi-external algorithm requires all nodes of G 
s in a prepossessing step such as 25   3  P a tter n m a tch i n g in XML data and graph data has been widely studied Computing 
DAG  by contracting an SCC SCC SCC SCC SCC 
s is an optimization technique to compress a large graph for processing pattern matching queries 15 In the literature there are ef\336cient in-memory and I/O ef\336cient semi-external algorithms to compute all 
sof a directed graph G 
s for a directed graph in linear time w.r.t the size of the graph by depth 336rst searching the graph twice in memory For the semi-external algorithm Zhang et al 26 propose an I/O ef\336cient algorithm to compute all 
using sequential scans of the graph on disk However due to the fact that the sizes of many real large graphs keep growing rapidly even the nodes of a graph cannot reside entirely in the main memory For example the social network graph in Facebook contains 1.11 billion active nodes and more th an 150 billion edges 1 As a small part of the entire web graph WEBSPAM1 http://newsroom.fb.com 978-1-4799-2555-1/14/$31.00 002 2014 IEEE ICDE Conference 2014 208 
sby constructing a special in-memory spanning tree of G 
SCC 


represents the set of directed edges in f such that for each s for a directed algorithm based on contraction used by Chiang et al 10 w h i c h i s for undirected graphs But for directed graphs the algorithm may end up an in\336nite loop and cannot compute all  denoted as k i 2 1 with 2 SCC to denote in to denote the set of out-neighbors of in respectively We have in to in in to in in in v G v G Here 2 s In this paper we study external algorithms for 12  I t i s t ri vi al t h at an y s upers et for a v e rt e x co v e r i s s t i l l a vertex cover A minimum vertex cover is a vertex that has the minimum set cardinality among all the vertex covers of can reach a node Fig 1 A Graph G is an equivalence relation which is re\337exive symmetric and transitive We use such that for every pair of nodes  Weuse and and and and is a sequence of  denoted  denoted and is the maximal set of nodes and and and and     267      267   002 002  002   002  003 002    004 002 002 002 002 006 007 006 006 004 007 002 b\002 002 002 002 007 t 004 scc 1 scc 2       002 002 002 v v v G v G v G v G v u v G v G v G v G v G v G v G v G v G v G v G v G v G is a subset  For any set of nodes computation The main contributions of this work are summarized below Firstly we analyze the de\336ciency of the existing DFS based algorithm 8 t h at cons umes a l ar ge number o f random I/Os and the contraction based algorithm 13 t hat n eeds large number of iterations and may end up an in\336nite loop Secondly we propose a new two-phase algorithm with graph contraction followed by graph expansion In graph contraction we only contract the number of nodes of the graph with bounded number of new edges generated We stop when all nodes can 336t in the main memory and process the contracted graph using an I/O ef\336cient sem i-external algorithm Using nodes contraction the number of iterations can be signi\336cantly reduced comparing to 13 In graph e xpans i on t h e remo v e d nodes are put back into the graph in a reverse order of their removal while the s In Section III we discuss existing solutions on both external and semi-external algorithms for computing  denoted by represents the set of nodes and is strongly connected to a node  A strongly connected component  to denote the in-degree out-degree and total degree of a node s of all nodes are computed We analyze the I/O cost of our approach and show that our algorithm can signi\336cantly reduce the number of random I/Os comparing to 8 T hi rdl y  w e i nt roduce t echni ques t o further reduce the I/O cost of our algorithm by reducing the number of nodes and edges generated in each iteration of graph contraction Finally we conduct extensive experimental studies using both real and synthetic web-scale graphs to con\336rm the I/O ef\336ciency of our approaches The remainder of this paper is organized as follows In Section II we discuss the preliminaries and give the problem statement for computing belongs to For any two nodes cannot 336t entirely in memory cannot reach a node nodes in is not strongly connected to node   Later Kumar and Schwabe 17 and B uchs baum et al 8 i m pro v e t he I O c ompl e x i t y t o s In Section IV we analyze the de\336ciency of existing external approaches and outline our two-phase approach with graph contraction followed by graph expansion We introduce the graph contraction phase in Section V and discuss the graph expansion phase in Section VI We study optimization techniques to further reduce the I/O cost of our algorithm in Section VII In Section VIII we report our 2 http://barcelona.research.yahoo.net/webspam/datasets/uk2007                                                        iffthereexistsno path from weuse Wehave        log                                       h i j id I/Os Chiang et al 10 propos e an algorithm with I/O complexity to denote the set of in-neighbors of to denote the set of in-neighbors and out-neighbors of to denote that node by maintaining the nodes that should not be traversed using tournament trees 17 a nd b u f fered repos i t ory trees 8 r e sp ecti v e ly  w h e r e to denote the to denote the set of  For simplicity we also use UK2007 2 contains 105,896,555 page s and 4 billion edges in 114,529 hosts in the UK domain in May 2007 In order to handle a graph  and we use or  A node  A node  A node of E V E E V E G G G G V G v V G u E G u E G V G V E V V G  v v E v v v v v v V v v V V v v V G V G V G u v V G weuse Each 267\267\267 sort sort i<k deg deg deg deg deg deg nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr u v u v u G  weuse in in in in in in    S G scan       005 007 where  SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC iff                                                 is the disk block size Despite their theoretical guarantees these algorithms are considered impractical for general directed graphs that encountered in real applications due to the large number of random I/Os generated Cosgaya-Lozano et al 13 s t udy a h euri s t i c e x ternal algorithm to compute all has a unique identity in respectively when it is obvious Each node  that in graph has a unique identity For each node  a naive way to externalize the inmemory DFS requires  then either l k m V E V E V E apath and for every pair of nodes G V M O O O B a b c d g e f G V E G V E V E v G G v v G v G v G v G G V u v G E G G p v k V v v v G v v v G v v G v v v G v v v v v G v v v G V v v V v v v v G v v u v S V M E B V B i i i j i j i j i j i 002 j i j i j i j i j j i i 003 j i j s i j s i j i k i s k s i 003 k Weuse   a vertex cover of where is a set of vertices that covers all  which speci\336es a unique total order among all nodes in  For each node    and   Given a graph  In other words each vertex covers its incident edges and a vertex cover of  Given a graph   iff there exists a path from    out out out out out out where such that if sthat 209 1 s experimental results We discuss the related work in Section IX and conclude the paper in Section X II P ROBLEM D EFINITION We model a directed graph as    1 


 003 003     i<f G G T V T G G G V V T v 0 T m m S G b e b 006 e 006 G M B M n m m G M B G M n V  c M n G M M G G i G G G M i G M G G G M G G G G G G M G G G G G V V T v T G O O G G v G c 327 V 005 c G T G O T T         0 1 2 0 0  with the same decreasing postorder it calls DFS DFS Depth First Search Based      2 327    log   2 327               is the block size and 013 compresses a graph iteratively by contraction until the graph can 336t in or a large number of small/mid sized which constructs a DFS tree for a graph    1 2 1 2 2 scan scan Input Output Here Thelast Inthe S G where forms an to denote the I/O cost of sequentially scanning all s into a node and compresses can 336t into main memory in a log number of iterations again to obtain a new DFS tree EM EM EM EM EM EM EM   A semi-external algorithm assumes that all nodes of the graph can reside entirely in the main memory i.e cannot reside entirely in the main memory For all I/O operations we follow the standard I/O model in W e u s e to denote the size of the main memory and use cannot 336t in  The key operation of s using an in-memory algorithm for are in the same  compute all strongly connected components  is a directed acyclic graph but cannot 336t in contains a large s by simulating the in-memory Kosaraju-Sharir algorithm 3 w hi ch t ra v ers e s t he graph twice using depth 336rst search The framework of Consider  and its decreasing postorder is edges For nodes  Cosgaya-Lozano et al 13 provide a heuristic algorithm called th iteration   by contracting an nodes in  The two external algorithms are based on contraction 13 a nd e x t e rnal dept h 336 rs t s earch  DFS  8 r e sp ecti v e ly  a n d th e tw o sem ie x ter n a l a lg o r ith m s are based on semi-external DFS 23 and a s p ecial s p anning tree by reversing every edge in  Comparing to the trivial external memory DFS which consumes to denote the I/O cost of external sorting cannot stop in a 336nite number of iterations for directed graphs in the following cases to compute all s for a graph Inthe abcdef gijklmh v G appears across a number of partitions and the partitions cannot be furthe r compressed by contraction Case-2 abcdef hgijmkl by reversing every edge in V E Algorithm 1 e f g b Fig 1 shows a graph nodes and for a constant in Fig 1 The 336rst DFS traverses through path through path  to compute all must 336t in of of of of the DFS tree has of on disk and updates Contraction Based    002  is the space for the entire graph  III E XISTING S OLUTIONS In the literature there are two external algorithms and two semi-external algorithms to compute all     267\267\267    267\267\267   When  3 Thus we introduce existing external DFS algorithms below In the literature external DFS algorithms are proposed by Kumar et al 17 and B uchs baum et al   8    8  i s an i m pro v ement for 17 The b as i c i d ea of 8  i s t o s i m ul at e t he i n t e rnal memory DFS algorithm by maintaining the visited nodes using an augmented external 2,4\ree called buffer repository tree BRT The I/O complexity for DFS using the algorithm in 8 i s        002 space The algorithm iteratively scans the edges of Tree Tree 002 b c d e b c d e f g  b c d e f g  is shown in Algorihtm 1 In the 336rst time traversal it obtains a decreasing postorder of nodes over the DFS tree obtained by s the probability of Case-1 to happen is high When i j k l  i j k l  S S M B j j j SCC SCC SCC SCC elements on disk and we use computes all elements once on disk In the I/O model 2  w e h a v e in decreasing postorder by traversing I/Os the algorithm in does not i m pro v e s i gni 336 cant l y es peci al l y on sparse graphs 5 and a l a r g e number o f random I O s are generated by the algorithm in 8 T hus  c omput i n g s for a directed graph and  Thereare2 SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC from sort sort sort is maintained in memory using s for a large directed graph th iteration to be a smaller with with limited memory in iterations is a constant Following the framework in Algorithm 1 a semi-external algorithm can be designed by applying semi-external DFS 23 w h en generat i n g the DFS tree line 1 and line 4 In 23  g i v en a g r a p h into smaller partitions in the literature some papers focus on semi-external algorithms by relaxing the condition Problem Statement M 013 In this paper we assume that the graph   1  2 sort  3 construct a graph  5 output that all nodes in a subtree of the virtual node  In brief it processes  and an external algorithm only assumes that at least two disk blocks can 336t in the main memory i.e subtrees representing becomes a DFS tree The semi-external 3 We do not need to construct a DFS tree explicitly We only need to obtain the DFS order of all nodes in the graph 210  With the decreasing postorder in the second DFS  the root DFS DFS DFS DFS DFS DFS computes sin M 013 belong to i.e to denote the size of each block on disk All data are read/written in blocks We assume s for a large directed graph The idea is taken from the contraction-based algorithm to compute all connected components for an undirected graph 10 G i v e n l i m i t e d m emory lines 1-2 It then constructs a graph and and and and contracts some partial s  and compresses s Case-1 An where               2 327     5 5 2 327 13 20     Since there is no ef\336cient external algorithm to compute all DFS DFS Semi-External Approach Example 2.1 Example 3.1    Semi and where where can 336t in  a directed graph BR of respectively 26  partitions in into a node Unlike the algorithm 10 w hi ch ens u res a n undi rect ed graph is a DAG liked graph the probability of Case-2 to happen is high Either case happens frequently in real world graphs line 3 Because line 4 Here all nodes in a subtree rooted at a child of the virtual node is in to until where G G G G G B B 267 m B f i i f i i i 1 i 2 i i i i i i S S E B V B a spanning tree M 013 G v 002 S  b 007 e e b B m m m m B 005 G 013 G 013 G c 327 B G G G G G G G G G V  E  E  a  h  m  B 005 G 013 G 013 V  G V E Weuse Tree Tree Tree Tree og    s based on external DFS is not I/O ef\336cient s  1 SCC SCC with the same postorder 4  all the since 


G 1                                         G 2 G 3 G 4 G 4 G 3 G 2 G 1 Fig 2 A Solution Overview DFS algorithm in 23 i s m uch m ore e f 336 ci ent t han t he e x t e rnal DFS algorithm in 8 H o w e v er  i t i s not opt i m i z ed for sof SCC SCC SCC SCC SCC SCC SCC i<l Semi     1 2  003  l i i i i l l l V 1 G i 003 V i V i 1 V i i V i i 212 V i 1 V i 1 l l 212 l l 212 l 212 l l 212 l l 212 l 212 i i i i i E  B V  B i i i i i i i i f Input do do V E V E G G G 1 V i G i G i 1 V i 1 004 i 003 G i i 003 V i 212 V i 212 V i 1 V 1 Output and based on s for each batch of removed nodes in a reverse order in the graph expansion phase As we will show later both the graph contraction phase and the graph expansion phase are processed using only sequential scans and external sorts In such a way all nodes/edges of the graph can be processed in blocks and the number of random accesses is minimized For  Thus our algorithm can always terminate 211 can be computed using algorithm when generating algorithm and external contraction based it belongs to is computed More speci\336cally given that all are generated where  we compute the   1   2  4  8 compute  on disk and updates the for a constant s for nodes s for nodes by removing a batch of nodes from c G G G G G V G G G G V G V G V G V G V G G G G V G V G V G V G V G V G G G G V G G G V E V G V G G G G Algorithm 2                                                         can generate a large number of random I/Os In this paper we propose a novel contraction-expansion based external algorithm to compute all  In this paper we aim to design an ef\336cient external algorithm to compute s is largely reduced Although  i.e with decreasing order of sort s for a graph are output since s by de\336ning a weaker order based on the depth of a node in a spanning tree  s of all nodes in batches in order to reduce the number of random I/Os used to access each node Our algorithm is processed in two phases namely graph contraction and graph expansion In the graph contraction phase a list of graphs using the semi-external algorithm n   005 f 212 212 212 003 212 212 212 212      212 can be found When updating the are computed using computation using the Kosaraju-Sharir algorithm Algorithm 1 This is because Algorithm 1 needs to maintain a total order decreasing postorder of nodes in the 336rst DFS line 1-2 to be used in the second DFS line 4 As a result in the 336rst DFS  nodes cannot be contracted or removed even if partial line 1 The graph contraction phase is shown in line 2-4 It iteratively generates anewgraph algorithm comparing to our can solve the problems Firstly  our algorithm computes the s are computed Our algorithm is a proper subset of can be contracted into one node and nodes that will not contribute to any new s can be removed from  Instead of accessing each node one by one in is generated by removing a batch of nodes from  the removed nodes are added back to the graph in the reverse order of their removal in the graph contraction phase i.e the lastly removed nodes in the graph contraction phase are 336rstly added back in the graph expansion phase When a node is added back the s for all nodes are computed after graph expansion The two phases are illustrated in Fig 2 where gray parts represent the nodes whose s have been found In order to improve the semi-external DFS based approach using Algorithm 1 Zhang et al 26 d e v el op a m ore e f 336 ci ent semi-external algorithm to compute all  Using the weaker order only one  It stops until all nodes of the graph can 336t in memory i.e  as introduced in Section III the I/O complexity of the algorithm is by removing a batch of nodes from in order Since algorithm For Ext EM Ext EM EM Ext Ext EM Ext EM Tree Tree Tree Tree 327 sof DFS DFS DFS 1 1 1 1 1 1 1 og  The I/O cost to compute all  IV A N EW C ONTRACTION E XPANSION A PPROACH Given that the contraction based     327 1 may end up in\336nite iterations and the DFS based  The high I/O cost is produced by the large number of random accesses when visiting nodes one by one on disk and it is costly to access each node using one random disk access In our algorithm instead of processing nodes one by one we process the nodes of  it is a contraction based algorithm with some critical problems as introduced in Section III Our contractionexpansion based algorithm with a smaller number of nodes and stops when the nodes of the graph can 336t in the main memory The graph expansion phase is shown in line 59 It 336rst computes all with increasing s for all nodes in to compute all in batches As shown in Algorithm 2 we contract the graph      while while SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC 1 M<c E 1 E i E i 1 E i 1        using line 6-9 Finally all with with BR BR BR BR  a directed graph G G G M V V G G G G V c V M c G G G V V V V G G i G G V V i V G O O G G V i G G V V V sof  all the is shown in Algorithm 2 Initially to Semi Semi Semi Semi Semi each partial the wemakesurethat andforeach needs to be constructed in memory The algorithm iteratively scans the edges of may not be able to terminate In our is much more ef\336cient than external DFS and external contraction based approaches it assumes that line 5 Then it iteratively computes all swhen sof can not 336t in memory 3 contract 7 until no new line 10 Below we analyze the de\336ciencies of the existing external DFS based in the graph contraction phase and add the removed nodes back to compute the using Inother words 005 1 2 1    003  1     1 1 2 1 1 2 1 1 2 1 1 2 1 1 1   267\267\267 267\267\267 267\267\267 003 327 sinagraph sin sin sin sin sin i Graph Contration Graph Expansion    In the graph expansion phase after computing all s of  5 compute all  6  9 combine  10 output all   which is higher than  


can be computed correctly for each graph  i.e  i.e  i.e  i.e  i.e  i.e The lemma can be derived easily from the above discussion 002 can be computed in v deg v G i v G i v G i    id      id                      the f f 002 002 t 002 002 212 r 004 002 212 004 002 002 212 002 002 002 002 002 002     002  002 002  Our stop condition is easier to be satis\336ed comparing to in iff in  In other words if by by by to be by joining in Input do      In the following given a graph  In the algorithm an operator   002 if 002 002  016  017 Output nbr nbr nbr deg deg deg deg deg  6  7  8 i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i V i E i v  id u E i u  id v V i v E out u V d v v V d E d V i 1 u v i i i i i i i i i i d d d d d 212 cannot be arbitrarily selected In order to make sure that all can be recovered using only algorithm the selection of nodes to be removed in each iteration does not rely on the order of edges stored on disk and thus our algorithm is much more stable than Furthermore our stop conditio n only requires that all nodes  Consider an arbitrary edge 9 10 sort nodes in where to 336t in the main memory Secondly even if cannot 336t in the main memory there are semi-external and external algorithms to 336nd an approximate minimum vertex cover for a graph is de\336ned among all nodes in is added to the vertex cover otherwise is added to the vertex cover In this paper given operator and and and and and and and and and and Algorithm 3 in in in in E E E for all v G v G v G v G v G v G v G id id which requires the whole graph Contractible The number of nodes in the contracted graph and edges  We start from the recoverable property i.e for any in the worst case the algorithm cannot be used directly in constructing operator speci\336es a unique total order among all nodes in the graph  As introduced before when constructing is a proper subset of preservable For any two nodes  the connectivity of preservable property is satis\336ed  In other words for any edge  For any scanned if respectively using external sort line 2-3 Since all edges are sorted in from graph by removing at least one node from  In order to reduce the number of iterations the number of nodes to be removed in each iteration should be as large as possible However the nodes to be removed in each iteration are in the same are in the same In order to reduce the number of iterations in the  When the graph in Section VII The basic algorithm to compute  the degrees of all nodes in  We will further reduce the size of operator given a graph  the algorithm in 7 s cans al l e dges o f on disk sequentially For each edge  we adapt the external algorithm in 7 t o cons t ruct should satisfy the following three properties from  For the external algorithm in 7  an alg o r ith m i s i n t r o d u ced to 336n d a v e r t e x co v e r w ith an approximation ratio using a sequential scan the degree of node should be smaller than the number of nodes in to other nodes in should be as small as possible This leads to the minimum vertex cover problem which is NP-hard 3  I n th e liter a tu r e  a lo t o f a p p r o x im a te algorithms have been developed to 336nd the vertex cover of a graph 200 200 006 006 003 006 003 003 003  Lemma 5.1 to be contracted 007 for all                                                a directed graph 2 return 325s neighbors in  we introduce how to construct the nodes Using the the contractible and recoverable properties are satis\336ed and by constructing 325s neighbors should be in iff either of the following two conditions holds 1 Ext EM EM EM Ext of of or using a single sequential scan of 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 G G V G G V G V G V G u V G G G V G V G V G V V V V V E V V V V V V E V V G H O V G v v V G V G V G  u  v V 003 003 003\005 is a vertex cover of SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC v u>v by sorting u G u G u v u v u G u G u v u v since u>v then ax 200 003 003 006 003 u>v Given 002      i i i i i i i i i G i V i 1 V i 1 E in E out V d v E in 002 E d E out 002 E d E d E d E d 002 V i 1 V i 1 V i 1 G i  is recoverable if and only if  To construct respectively We will show that by constructing  we 336rst investigate the properties of and eliminate duplicate nodes 11  Similarity if is shown in Algorithm 3 After initializing line 1 two edge lists are created on disk  We have the following lemma algorithm the cardinality of as follows can terminate in a 336nite number of iterations the contraction is unstable since it relies largely on the order of edges stored on disk It is possible that only a small number of nodes are contracted in each iteration In our with degree information of both nodes augmented on each edge for the ease of comparison of nodes using the is absent in sorted by node ids 1 is the maximum degree of nodes in line 4 Next we create another edge list  For the semiexternal algorithm in 9  Jam e s e t a l d e v e lo p a str eam in g algorithm to 336nd a vertex cover with the approximation ratio 2 by maintaining an in-memory hash table Get out out out out out then can be created in three steps Firstly by joining  the nodes of the contracted graph  either order by order by nodes order by id order by id order by id order by id De\036nition 5.1 can 336t in the main memory which is usually much smaller than the size of the whole graph Recoverable If a node Operator can be augmented into each edge V G G G G G G G G V i s G G G G V u v v G u v G v G G v G v G v V v V v G V G E G V E V G V v v u u v v u G V G V G G G H V G G G  G  u v  G  G G u v G V V V V E E G E E G V E E E E E  E E V u E               2 3 2  However since V E i v v v deg v deg  002 u v u v u deg u G i u deg u G i u deg u G i u deg u G i edges edges edges edges edges  Proof Sketch the newly contracted graph all The u                                    As con\336rmed in our experiments our algorithm can usually terminate in a small number of iterations In the following we discuss the two phases and propose techniques to further minimize the I/O cost V G RAPH C ONTRACTION In this section we introduce how to contract a graph  we should make sure that the nodes of   then  2  3  4  5   by grouping incoming edges a nd out-going edges for each node in is removed when constructing 


 we can add a new edge as follows For each node into each incoming edge can only reach such that all edges v  i.e  i.e  after the removal of nbr nbr nbr nbr nbr nbr nbr   006  id     006  id     006       006     006    006    006  if in in in in in in in in  all its neighbors in in in in by by by by in line 38 and constructs in line 8 The preserved edges line 9 Secondly we sort line 11 in in to in to in                  9    sequentially once and for each edge scanned add the larger node compared by the  and each pair of nodes can be augmented into each edge can be designed as follows For each node can be preserved in can be preserved in 267\267\267 267\267\267 267\267\267 267\267\267  because there does not exits an edge  new edges need to be added after the removal of return for all for all operator into Since Algorithm 3 computes a vertex cover and and and and and and and and  such that and and and and and  denoted  denoted and respectively which are the same as those used in Algorithm 3 line 1-2 Algorithm 4 constructs and and and and  for each edge is added to and can be constructed in three steps Firstly by joining and and and and In Inordertodo this we need to make sure that both out out out out out out out out out out out out out out out             As discussed above E v,v v v v v V E Givenagraph 002 002 v u v G v G v G v G v G v v v G v G v w  and vice versa Note that by removing a node  then the connectivity of  for each node or an edge  for any two nodes  for any two nodes  and the newly added edges by removing nodes from using a sequential scan all edges may contain duplicate nodes we sort needs to be constructed that maintains the  each of its in-neighbors by node ids and eliminate duplicate nodes by scanning once sequentially line 10 are in the same  from Lemma 5.1  we construct the edges on disk line 3 When scanning line 5 Secondly line 8-9 Since preservable property In other words after constructing through a path computed in Algorithm 3 is recoverable Next we prove that  The edges are constructed to ensure that no connectivity of node pairs will be destroyed We will prove it that the construction will introduce no new connectivity information among all nodes in to construct using a single sequential scan of is added into We only need to prove for any nodes is sorted by the non-augmented node of each edge line 6 Thirdly by joining cannot be added into from by grouping incoming and out-going edges for each node in consists of two parts namely the preserved edges in line 12-13 In order to construct SCC SCC SCC SCC be the edges of  and its out-neighbors line 6 the removed out-going edge of the contracted graph of the contracted graph is destroyed after the removal of node maintains the recoverable property such that for each removed node  the algorithm 336rst identi\336es the set of incoming edges to be removed denoted to be contracted the nodes of the contracted graph are in are in are sorted by can reach using a sequential scan the degree of node of should be in the same  Suppose with both ends in  by joining of of on 213  if Theorem 5.1 using a single sequential scan of all edges in from v  Thus the lemma holds can reach line 10 Thirdly by joining and the node set  and add a new edge in line 9-11 and union through through a path Input do do V V v E V V V V u v u V V V V V v v V V u G V V E V E V E v V V V V u w u w where Let foranypath Output id E i be the smallest node in the total order de\336ned by the operator is also augmented in the edge sort sort sorted by node ids constructed by Algorithm 4 is u>v by sorting u v u v u v u v u v u v u v u v u v u w u v u v u v then Proof Sketch then After constructing the removed incoming edges we augment the out-neighbors of 002 002 002  we can 336nd a path from d d d d d d i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i V i E i v  id u E i u  id v E i V i 212 V i 1 v E in V i 212 V i 1 v E out E del E add 007 E i V i 1 u E out E i V i 1 v E i V i 1 V i 1 v E pre E pre 007 E add i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i The set The I/O complexity of Algorithm 3 is Theedgeset Proof Sketch Proof Sketch u v u v u v u v nbr out u v u w u v u v u v                                                   preservable add add add add add add Inorder to maintain such connectivity in i i i i i i i G i V i 1 E i 1 E in 003 E out 003 E del 003 v 006 V i 1 002 E del 003 v 006 E del 002 E add 003\005 w 006 nbr out E del E add 003 E pre 003 u 006 V i 1 002 E pre 003 u 006 E pre E pre 003 u 006 v 006 V i 1 002 E i 1 003 E i 1 i i i with with form with with del del del del del del del is stored as an edge line 7 After creating is constructed in a way such that the contractible and recoverable properties are satis\336ed 002     002 002 002 212 004 002 212 002 002 002 002 002 002 002 002 002 002 006 t 006 is contractible We only need to prove that there exists a node  By De\336nition 5.1 the operator that is removed from using a sequential scan all edges Lemma 5.2 Lemma 5.3   To construct speci\336es a unique total order among all nodes in can still reach externally given  the edges of the contracted graph can still reach by sequential scan of order by order by order by id ordered by id edge order by id order by id order by id line 7 and a new edge Get Let if pre pre pre pre pre pre pre pre pre 7 8 such that v G i v G i E E V v E E E  V V V V V V G V V v v  G v  V O E G V G E G V E E u v u v G u v G v G u w V u w v G u w v G v u w v  w G v v v E u w v  w G v v G V v v G V E v v v E u w u w G w G E G V E G V E G E E E G G E E E E E E E V E V E V E E v E E E E E v G u G v v E E E V E u E E V E u v E E u w G G p u w G u w G v we only need to scan edges in if Algorithm 4   line 4 Line 5-8 construct E  a directed graph can be accessed in the same sequential scan of 002 002 002 002 002 002 r edges edges edges edges edges edges edges and Since in in in in in in in in in in in in in in in computed in Algorithm 3 is recoverable and contractible Omitted due to lack of space  It is true because  An algorithm to construct  By doing this for any pair of nodes  1  2  3  4  5  6  10  11  12  13   Algorithm 4 shows how to construct  This can be done using a single sequential scan of  When accessing each removed incoming edge   To prove for for for for for  remove the edge 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 


002  since each edge in  for any path as follows For each edge  andan upper bound of the number of new edges in i  327 deg i  002 002 i  327 deg  v G i  002 v 002 i  002 v 002 i   deg  u G i   002 002 i   deg  u G i   002 i   deg  u G i    w v v v w G G G G c e  e>d max max 002 g c b a l k f d g f g c k m e c k f e b l g v,G i v,G i v,G i v,G i v,G i 1 According to 11 003 with decreasing Fromthe construction of because for its two neighbors such that  sof is large the number of newly added edges can be very large However from the construction of  deg   we have deg   002  and in our experiments it is even possible that  Example 5.1   214 v  v v v v v  v v  E E a new edge  005 is a path on  The construction process is illustrated in the upper part of Fig 3 To prove  The construction process is illustrated in the lower part of Fig 3 002 Theorem 5.2 The I/O complexity of Algorithm 4 is is very loose since it ampli\336es 004 with with deg  with with is the maximum degree for all nodes in is preserved in de\336ned in De\336nition 5.1 is a path on  deg  v G  min  deg  v G  min  deg  v G  since there is an edge  iteratively Given graph Omitted due to lack of space 002 Bounding Edge Size in in in in in in in in in in  in   The total degrees of all nodes in nbr  is a planar graph Note that in Theorem 5.4 the upper bound                                                                                                                                      In practice b G  remove edge   We remove  022 002 wehave  u u v G G By the construction of v,G i v,G i v,G i in in in  v G in  v G v 1 1 1 i  i  i  i  i  i  i  i  i  i  i  i  i  i  deg  i  i  i  i  i  i  i  i  i  i i i j h i i j G G G G V v v v E v v V v E E v v E V E E v V V V V E  deg  E  deg O 1  deg   deg  V E E  E  deg  V V V E G V E V V a b  a G let v v v v v v v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G sort       002  there exists a node i i i i i i i i i i i i i i i i i i i i i i i i i u 006 nbr i i u 006 nbr u 006 nbr i i i i i is the arboricity 11 of gr aph i  002 Proof Sketch i i E i min i i i i i i i i i  i i i v 006 V i 212 V i 1 004 u 006 nbr in v 006 V i 004 u 006 nbr in i i i i i i i i i i i i 212 i i i i i  i i i u G u G u G u G u G u G u G When deg  vv 3 4 2 1  deg   deg   deg  2 2   min  min 1 1  2 1 2 2 2 3 2 3 3 4 3 4 4 4 4 we can\336ndapathfrom VI G RAPH E XPANSION The graph contraction phase stops when all nodes of the contracted graph on  The new path on  The new path From the above discussion when a node  a node  Thus deg   node  thus out out out  v G b>a Fig 4 Graph Contraction Example                               and scan  scan  from As proved in 11 for any graph from  the number of new edges in nodes and 14 In section VII we propose techniques to further reduce      deg  SCC  002 s of SCC if  In u,v d G d G 1 1 1 1 1 1 1  1 1 1 1 1 1 1  deg  1 1 is bounded by 1 1 1 1 1 1 1 1 1 1  1 1  out out  out  out  out  out  out  out  out  out  out  327 i i i i i i v 002 V i 212 V i 1 deg v 002 V i 212 V i 1 deg V i 212 V i 1 002 u 002 nbr in V i 212 V i 1 002 u 002 nbr in v 002 V i 002 u 002 nbr in E i min  deg  v G 002 002 002 002     327 deg 002 nbr  n deg  002 212 005 002 2   002 Proof Sketch 002 212 002 nbr  n deg  005 2 327   n 003 005 2   where  005 min  023    212   002 212 002 nbr 002 nbr  5  8  3  4 since on path on path and add a new edge  from using the information computed in new edges are added into for any graph  Theorem 5.3 holds 002 Theorem 5.4 The number of new edges in Fig 4 shows the graph contraction phase for are the set of nodes preserved in is constructed since  Thus the degree of any removed node cannot be too large The following two theorems give an upper bound of the degree for any removed node  Using such a way the newly constructed is removed only if for all are the newly added edges when constructing by operator  Suppose the main memory can only keep three nodes The graph contraction phase stops after can be computed using the semi-external algorithm Semi  The graph expansion phase computes all SCC is a newly added edge from the construction of and add two new edges   After removing can be constructed from is removed from can be constructed from only contains nodes with small degrees in to in to in respectively Theorem 5.3 is 003 is 002 is usually small For example if to 004 in the second 327 327 327 p v v v p p p E p G p u w G u w G p E v p p p G O  v G G E V v u v E E v u E E E 002 E 002 G E E 002 E G 002 G G 002 002 G 002 E V G G G G G G G G G G  b V  d c e d G c e G G G G G G G G G G i G G u,v path and and  and  and  when constructing and and and is added in and has 9 and and and is counted at most twice in the summation We also have 003 edges by removing parallel edges and self circles In a similar way can 336t in memory such that the SCC be the predecessor and successor of can be processed using Semi Fig 3 Paths in 002 020    002 Proof Sketch    021  deg    deg   deg  005         of Eq 1 and as analyzed in Theorem 5.3 the set for a certain graph in Fig 1 The grey nodes in each  and the dashed edges in each from path For any 327     006   1  1  1  1  f c>d where deg 


are sorted by are sorted by computed in  we can derive that  Because v SCC v G i                                                                                                                                 can be computed using The procedure to augment the and 002 212 002 002 002 002 212 t 006 006 007 006 006 006 006 006 002 212 006 006 006 006 002 212 024 b 017 024  006 024   002 212 002 002 002 b 006 006 002 002 002 212 004 004 002 212 024 b 017 024 024 002 212 212 024 002 212 024 212      002 002 212 reverse all edges in then in in in in in by by by line 3 where in  In line 12 in in Algorithm 5  As a result both  As a result          006  id     006    006        id     Algorithm 5 computes all r 020  002 002 006 002 002 017  Expansion Given any two nodes i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i V i V i 1 E i E i V i 212 V i 1 E 002 out E E v  id u E V i 212 V i 1 v E E V i 212 V i 1 u V i 212 V i 1 u V i 212 V i 1 v  SCC  id u i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i  according to Lemma 6.2  can be computed as can be calculated using G G G 9 According to the recoverable property of in Lemma 5.2 for any node and and and and and and and and and and and  such that and and and and and and and and and according to the sin  G G G G G G v G G G G G G G G G G E E can be computed using           in in in in in in in in in in in in in in in in in in in in in in in in in in in in Procedure augment Proof Sketch Proof Sketch Proof Sketch Proof Sketch Proof Sketch id id id    augment augment are computed in is generated by reversing every edge in  Finally all nodes in preservable property of according to Lemma 5.3 We start with the following lemma are not easy to 336nd and can be computed using that keeps the incoming edges of only the removed nodes is augmented in each edge of all nodes preservable property in Lemma 5.3 For node of each removed node is shown in line 8-14 In the procedure a new edge set  According to the  the algorithm augments the become out-neighbors in in order to augment  In line 13 edges by a sequential scan of in Lemma 5.3 we only need to compute are not easy to compute In the following we show that it is enough to 336nd through a path  according to Lemma 6.3 there does not exist another node in Lemma 6.2 and Lemma 6.3 together in order to compute  s of nodes in Lemma 6.1 suggests a way to compute from from line 10 In line 11 edges and 336nd and in graph  for any node and For any node For any node and For any node and only if by node ids 7  s into the in-neighbors and out-neighbors of the removed nodes in line 4 the are computed denoted as by sequential scan of for each for each possibly V V V V V w V V u v w w v w w u v V V v w v w V V  G  G v v v v v v V V V v v v u u v v V V V V v V V G G  G G V G V E E  E V u u u u v  u  u V V V V V E V V V V is shown in Algorithm 5 In order to join G G and Input Proof Sketch w G w G w G w G w G Note that in-neighbors in the SCC The I/O complexity of Algorithm 5 is for a node Suppose there exists into the in-neighbors of to put the in-neighbors of each node in  to 336nd two nodes information into the outneighbors of the removed nodes using Since possibly the same in through a path suppose all of nodes in  Thus only with a single node in  our external algorithm to compute For node  In line 5 by combining 002 002 However  Since wehave      SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC by sorting by sorting sort sort G Asaresult   return SCC i return 2\If with v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G v v v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G v v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G v G  if there exists another node is correctly 215 nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr nbr       the SCC  1  2  3  4 SCC del 003  8  11  12  14   i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i G i G i 1 G i 1 G i E i 003 E i E 002 in 003 augment E 002 out 003 augment v 006 E 002 in 002 E 003 E 002 003 v 006 V i 1 002 E 002 003 v 006 E 002 E 002 003 v 006 E 002 002 SCC i 1 E 002 003 v 006 E 002 E 002 i i i i i i i i i i i i i i i i i i i i i i i i i i i i i i Lemma 6.1 Lemma 6.2 Lemma 6.3 Lemma 6.4  Theorem 6.1 Theorem 6.2 s of all nodes in s of all nodes in sin with with with with with information into the in-neighbors of the removed nodes using  we discuss computing is trivial We prove is returned line 7  We 336rst investigate some properties of    then   line 2 and augments the thesetofall sorted by node ids SCC i 1 sorted by node ids SCC i scan out out out out out out out out out out out out out out out out out out out out out out out out out out out out Given in graph There are two situations 1 If is an ef\336ciently After augmenting the  with in Omitted due to lack of space nodes order by order by id order by id order by id order by is created by joining are sorted line 6 and   graph G for each removed node sof                                                                                               267\267\267 267\267\267 sfor all nodes in since   since  from Lemma 6.1 we have  As a result  there exists  Thus    002 002 002 002 002 002 002 002 002 u v u v u v u v SCC u G i 1 u v SCC u G i 1 u G i 1 and its extracted graph    edges edges edges edges edges the  u G u G u G u G u G u G u G u u G u v u v u v E i E i 1  Thefollowing lemma shows that V s V G v v u w u G v v G u G u v G v G v u w V u v G u w u v u w s v v v v v G v u u v v u v v  v G v G v  u v G G v E E E E E E 002 V E V E 002 E 002 E 002 E 002 V s v E 002 E 002 V V G G O G v v G Output    5 SCC i 003 SCC i 1 007 SCC del  6 sort SCC i  10  13    for for for for for  1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 


1 2 3 3 3 3 1 3 1 1 1 1 1 1 2 1 1 1 1 1 2 G G G G G G G c g f k G G G h h G G i G G G G G G V V v u V v V v v G v v v G V v G u v u v V v v V V E E V V E V v V E v V u V u v V V u T T s V T s  T T V G G i E E E E u E i i i i i i i i i i i i i i i i i i i i i i i i i i i i i d d i d d i d i i i i i i i i i i i i 212 i i 212 i i f G   and and and and and and and can be handled similarly In such a way Type-2 nodes can be effectively reduced in is generated from two can be computed In c G c G c G in in in itself is an is still a vertex cover of in line 4 of Algorithm 3 by joining in into into in in the in the next iteration of  In the following we introduce techniques to re duce the nodes and edges when constructing G  Thus the key point to reduce the I/O cost of the  when adding nodes into from  before adding can be removed from is removed can be removed from and Get SCC and there is no need to add v G v G v G v G v G v G v G v G v G v G v G h G h G h G h G E in each graph in each graph Example 6.1  when generating can be removed because  we check whether Node Reduction has been covered by node b e l j VII I/O C OST M INIMIZATION In this section we show how to optimize our contractionexpansion based is a Type-1 node from constructed in the from which is computed using can only hold                                                                                                                                                                             Type-2 nodes are order sensitive i.e if node in line 8-9 of Algorithm 3 for each edge smallest nodes using operator line 2 of Algorithm 3 A sequential scan of Fig 5 shows the process of the graph expansion phase to expand the graphs in order of  when constructing  if there does not exit another node may not be a Type-2 node Note that our aim is to reduce nodes in To remove Type-1 node  we only keep the nodes with both using a dictionary  In addition it is straightforward that each edge denoted by light gray nodes and has already been computed using Algorithm 3 the following two types of nodes can be removed from are Type-2 nodes after scanned suppose G are the removed nodes when constructing denoted by dark gray nodes In with a single node Finally there are two in Algorithm 3 Such an operation does not generate any extra I/O cost in Algorithm 3 In order to reduce Type-2 nodes when scanning all edges in which many not reside entirely in the main memory Suppose algorithm on approach by further reducing the I/O cost The I/O cost can be reduced in two ways 1 to reduce the number of graphs constructed in the graph contraction phase and 2 to reduce the number of nodes and edges for each graph s in later iterations A Type-2 node th graph contraction phase without increasing the I/O complexity Although sSCC g g f i i c k b l k i j G c d e b a l g f h i k j m SCC f g e c f c e f g b i l j k d or 0 Any node with              6 4                       1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 212    Thus     in later iterations as  Since SCC SCC SCC SCC SCC SCC SCC nodes respectively has been added into  Such edges can be reduced in a lazy way when generating Type-1 For a node Type-2 For a node is a valid node set of with  Similarly the with with with will be removed in with G G needs to be added after line 2 of Algorithm 3 to eliminate parallel edges in  0 We develop two methods to reduce the edge size in order to reduce the intermediate results We will discuss the ef\336ciency in our performance studies Firstly for parallel edges with the same form out out out out out out out out 0 deg deg deg deg deg deg deg deg nbr nbr nbr nbr nbr nbr nbr nbr u G u v u v u v u v u w v>u in in in in in in in in in in in i i i i i i i i i i i i i  all nodes nodes in memory since a node with higher degree are less possible to be removed from 4 3 2 1  However such a solution needs to check whether Semi u>v generated in the graph contraction phase in Fig 4 The dashed circles in each graph algorithm is to reduce the number of nodes and number of edges cannot be combined with other nodes to form new  According to the node selection condition in Lemma 5.1 without generating any extra I/O cost in Algorithm 3 can be removed because when  Given graph such that Lemma 7.1 can reside entirely in the main memory By doing so we can reduce the number of Type-2 nodes in Edge Reduction can be removed from 0 SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC s are computed namely 002 212 002 002   024    002 002 002 004 004   002       wehave to make sure that th iteration According to the stop condition of graph contraction reducing the number of graphs is equivalent to reducing the number of nodes Omitted due to lack of space is an  and there is no need to include again The situation for to cover the edge Given  0  Fig 5 Graph Expansion Example computed according to Lemma 6.4 This can be done in line 8 of Algorithm 4 by checking whether 216 if  By applying the  for node s of node  for node  Thus node with a single node in without introducing new I/O cost thus we only reduce those Type-1 and Type-2 nodes that are easy to be identi\336ed The following lemma can be used to reduce Type-1 nodes or or  we only maintain the top  only one of them needs to be kept in 212 1 2  suppose  200  200   A Type-1 node  4 3 2 1 4 3 3 4 3 2 1 1 1 1 G E  G G V V V V E V V v V V v v V V   V V V  V E  E w            0  0     and nodes  If so edge  we introduce two ways to reduce the number of edges when generating  it is possible that G   017      Proof Sketch Ext Ext 002 002 002 002 g G G  


Size of Largeincrease The reasons are twofold Firstly when increases according to the node selection scheme to construct decrease There are two reasons Firstly when the memory size increases the stop condition for graph contraction is easier to be satis\336ed since more nodes can 336t in memory Secondly when the memory size increases the costs of the external sorts in both graph contraction and graph expansion phases decrease  Average Degree Number of Largeincreases the time and I/O consumptions for both increases the number of iterations in graph contraction increases This is because when number of edges increases the cost to sort and scan edges in each iteration increases thus more time and I/Os are consumed in each iteration                                     2 4 1 u E  V v E    u v  G  V E M V M V K G V V M KB Range 25M,50M,100M,150M,200M 2,3,4,5,6 200M,300M,400M,500M,600M 400K 8K 20,30,40,50,60 30,40,50,60,70 10K to in the operator in line 4 both in line 4 and augmented in all nodes in in line 5-7 VIII P ERFORMANCE S TUDIES In this section we conduct experimental studies by comparing four external algorithms for is the number of bytes to keep a node in memory We set the max time cost to be 24 hours If a test does not stop in the time limit we will denote it using until all nodes form an to Size of Small The results are shown in Fig 7\(a and Fig 7\(b for time and I/O costs respectively When the memory size increases the time and I/O costs for both 100M 400M 40 1 1 50 TABLE I R ANGE AND D EFAULT V ALUE FOR P ARAMETERS Parameter in all cases since more nodes/edges are removed in each iteration in Operator  operator speci\336es a unique total order among all nodes in the graph operator in line 9 when generating algorithm needs to hold and and and and and used in introduced in 26  w h i ch is cu r r e n tly th e m o s t I O ef 336cien t sem i e x t er n a l algorithm for and  Secondly when and out out out out out out out Fig.6\(a and Fig 6\(b show the time and I/O costs when varying the number of edges of WEBSPAM-UK2007 from 20 to 100 respectively v G v G v G v G v G v G v G v G v G v G v G v G v G v G 002 212 327 327  002 002 327 327 327 327 327       2 cannot stop in the time limit even if the graph contains only 20 of the edges When Size of 8 our e x t e rnal cont ract i on-e xpans i o n b as ed algorithm Algorithm 2 and our algorithm by applying the optimization techniques introduced in Section VII in new edges are added into In Algorithm 3 in order to make use of the new s The graphs contain nodes from 25M to 200M with average degree varying from 2 to 6 A synthetic graph is generated as follows We construct a graph computation namely the external contraction based 13 t he e x t e rnal DFS based by randomly selecting all nodes in SCC SCC SCC SCC SCC SCC  we apply the algorithm computation The  Finally additional random nodes and edges are added to the graph The parameters for synthetic datasets and their default values are shown in Table VIII outperforms 1PB 1PB since it cannot stop in all cases Memory Size need to be computed in Ext Ext Ext Ext EM Ext EM Ext Ext Ext Ext Ext Ext Ext Ext    3  002  For the semi-external algorithm  In our experiments we use a real large web graph and several synthetic datasets The real web graph is WEBSPAM-UK2007 4  which consists of 105,896,555 web4 barcelona.research.yahoo.net/webspam/datasets/uk2007/links   4H   8H   12H   16H   20H   24H   INF   20   40   60   80   100   Time\(hour Ext-SCC-Op   Ext-SCC                           DFS-SCC                 Largein in in in in in in 2 plus one disk block in the main memory that is Size of MassiveNumber of Massive\(a Time Vary Memory   1M   2M   3M   4M   5M   6M   7M   8M   INF   400M   600M   800M   1G   Number of I/Os Ext-SCC-Op   Ext-SCC                       DFS-SCC               iff one of the following three conditions holds 1 b I/Os Vary Memory Fig 7 WEBSPAM-UK2007 Varying Memory Size pages in 114,529 hosts in the UK domain The graph contains 105,895,908 nodes and 3,738,733,568 edges with the average degree 35 per node For synthetic data we generate 3 different kinds of datasets denoted Massive.The 4K,6K,8K,10K,12K 6K,8K,10K,12K,14K u w u G u G u G u G u G u G u G  For any  containing different sizes of and Small 327     V i i i i i d d d i i De\036nition 7.1 DFS Op Op Op Op Op Op 217 before adding  The default memory size is  In our experiments we do not show the results of  thus more iterations are needed according to the stop condition of graph contraction in 327 Semi add Datasets Exp-1 Performance on WEBSPAM-UK2007 in Algorithm 3 more nodes will be selected in id id 200K,300K,400K,500K,600K as follows DFS SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC  By considering  All the algorithms are implemented using Visual C 2005 and tested on a PC with Intel Core2 Quar 2.66GHz CPU and 3.5GB memory running Windows XP The disk block size is  according to Theorem 5.3 nodes with small degrees are removed when constructing 256 400   256 400 Default INF 327 deg deg deg deg deg deg deg deg deg deg deg deg deg deg deg deg deg deg deg deg deg  4 w V V E V G V G   u  v V G G E E E E G where can be further reduced We rede\336ne the operator Number of SmallD M s s s i i i i i i i 1 1 1 1 1 1 u>v 4  Secondly using operator  and for each removed node  s 336rst Then we add edges among the nodes in an  We vary the memory size from                     a Time Vary Graph Size   1M   2M   3M   4M   5M   6M   7M   8M   INF   20   40   60   80   100   Number of I/Os Ext-SCC-Op   Ext-SCC                           DFS-SCC                 b I/Os Vary Graph Size Fig 6 WEBSPAM-UK2007 Varying Graph Size Percent   4H   8H   12H   16H   20H   24H   INF   400M   600M   800M   1G   Time\(hour Ext-SCC-Op   Ext-SCC                       DFS-SCC               


SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC increases the time and I/O costs for both dataset dataset The results for both Largedatasets are similar to those in the Massive When either the average   800 105 895 908 8  256  847 200 600 25 200 50 12 30 70 f I/Os SmallTo test the synthetic data we vary the memory size M   K  M M M M M M M M M M D D D D K s s s of nodes from 2 to 6 The time and I/O costs on Largedo not have signi\336cant impact on the ef\336ciency of our algorithms as long as by 20 on average for both time and I/O consumptions Fig 8\(c and Fig 8\(d show the results on Large 1 1 4  the costs for both d I/Os Vary Degree   c Time Vary Degree   25 327         Size and G M G M V V V V V V V K E G Wevary the node size decrease sharply The reason is that in order to process the graph using in all test cases to to is smaller the decrease rate is larger This is because when is smaller more iterations are needed for both to  and the time and I/O costs are shown in Fig 9\(a and Fig 9\(b respectively When to to respectively Fig 9\(g and Fig 9\(h show the time and I/O costs when varying the number of 4   s and and and and and and and and Wevary the average degree Size   Size   Time\(hour Number of I/Os Time\(hour Number of I/Os Time\(hour Number of I/Os Time\(hour Number of I/Os Time\(hour Number of I/Os Time\(hour Number of I/Os Time\(hour Number of I/Os 2H   3H   4H   5H   INF   200M   300M   400M   500M   600M   Ext-SCC-Op   Ext-SCC                           DFS-SCC                 200K   400K   600K   800K   1M   1.2M   INF   200M   300M   400M   500M   600M   Ext-SCC-Op   Ext-SCC                           DFS-SCC                 1H   2H   3H   4H   5H   INF   200M   300M   400M   500M   600M   Ext-SCC-Op   Ext-SCC                           DFS-SCC                 200K   400K   600K   800K   1M   1.2M   INF   200M   300M   400M   500M   600M   Ext-SCC-Op   Ext-SCC                           DFS-SCC                 1H   2H   3H   4H   5H   INF   200M   300M   400M   500M   600M   Ext-SCC-Op   Ext-SCC                           DFS-SCC                 200K   400K   600K   800K   1M   1.2M   INF   200M   300M   400M   500M   600M   Ext-SCC-Op   Ext-SCC                           DFS-SCC                 8H   12H   16H   20H   INF   25M   50M   100M   150M   200M   Ext-SCC-Op   Ext-SCC                           DFS-SCC                 1M   2M   3M   4M   5M   INF   25M   50M   100M   150M   200M   Ext-SCC-Op   Ext-SCC                           DFS-SCC                 2H   4H   6H   8H   10H   INF   2   3   4   5   6   Ext-SCC-Op   Ext-SCC                           DFS-SCC                 400K   600K   800K   1M   1.2M   INF   2   3   4   5   6   Ext-SCC-Op   Ext-SCC                           DFS-SCC                 2H   3H   4H   5H   INF   4K   6K   8K   10K   12K   Ext-SCC-Op   Ext-SCC                           DFS-SCC                 400K   600K   800K   1M   INF   4K   6K   8K   10K   12K   Ext-SCC-Op   Ext-SCC                           DFS-SCC                 2H   3H   4H   5H   INF   30   40   50   60   70   Ext-SCC-Op   Ext-SCC                           DFS-SCC                 400K   600K   800K   1M   INF   30   40   50   60   70   Ext-SCC-Op   Ext-SCC                           DFS-SCC                 e Time Small,andwhen increase This is because when n in Synthetic Data in Synthetic Data DFS DFS DFS Exp-5 Vary Op Op Op Op Op Op Op Op Op Op Op Op Ext  The time and I/O costs on Massiveare shown in Fig 9\(c and Fig 9\(d respectively When decrease When f I/Os Vary Ext Ext Ext Ext Ext Ext Ext Ext Ext Ext Ext Ext Ext Ext Ext Ext Ext Ext Ext Ext Ext Ext Ext Ext  V  V Number in Synthetic Data c Time Large\(a Time Vary e Time Vary cannot stop in limited time in all cases Similar to the results on the real dataset in Fig 7 when dataset and Fig 8\(e and Fig 8\(f show the results on Smallconsume less than 1 hour increases the time and I/O consumptions for both consumes more than 20 hours while both are the number of nodes and the number of edges of the graph As a result the size of memory is needed thus when the memory size is dataset are shown in Fig 8\(a and Fig 8\(b respectively dataset and this is true for all the remaining test cases when varying other parameters in synthetic data In the following due to the lack of space we only show the test results on the Large and in the graph contraction phase the contraction rate decreases when the number of iterations increases since the graph becomes denser with larger number of iterations is larger and the cost on each iteration to scan and   Exp-4 Vary Average Degree in Synthetic Data from from increases the time and I/O consumptions for both and the number of outperforms outperforms cannot stop within the time limit when outperforms in all cases When the memory increases from increases the time and I/O costs for both When a Time Massive\(b I/Os Massiveis larger is larger the gap between is larger This is because when number of edges is larger more edges can be pruned by the edge reduction techniques used in increases the number of edges increases As a result more iterations are needed and larger cost is consumed in each iteration as analyzed in Exp-1 when varying the graph size size increases or the number of are not in\337uenced much As anal yzed in Section VII the key factors that in\337uence the cost of Num   Num Fig 9 Synthetic Data Largecan be directly applied on the original graph to output all                       Fig 8 Synthetic Data Vary Memory Size outperforms  and Smallincrease This is because the stop condition for graph contraction is harder to be satis\336ed when  sort nodes/edges is larger when   Fig 9\(e and Fig 9\(f show the time and I/O costs when varying the average no iteration is needed and size from SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC 1H   4H   200K   1H   200K   1H   200K   sfrom b I/Os Vary g Time Vary h I/Os Vary        218 d I/Os LargeSemi Semi Exp-2 Vary Memory Size Exp-3 Vary Node Size   


are 336xed This also explains why the results in the three datasets Massiveis a primitive operation in directed graph exploration which has been studied for both internal memory model and external memory model In the internal memory model strongly connected components of a directed graph can be computed in s for a directed graph with the assumption that the nodes of the graph cannot reside entirely in memory We overcome the de\336ciencies of the existing external    sort sort computation algorithms and propose a new two-phase algorithm with graph contraction followed by graph expansion We analyze the I/O cost of our approach and show that our algorithm can signi\336cantly reduce the number of random I/Os We propose techniques to further reduce the I/O cost of our algorithm and con\336rm the I/O ef\336ciency of our approaches using extensive experiments on both real and synthetic web scale graphs The work was supported by grant of the Research Grants Council of the Hong Kong SAR China No 418512 R EFERENCES  J  A bello A  L  Buchs baum  a nd J  W e s t brook A f unctional a pproach to external graph algorithms s of a graph Zhang et al 26 i mpro v e s uch a n a l gori t h m by constructing and maintaining a special in-memory spanning tree of the graph The semi-external algorithms 23 an d  2 6  are introduced in details in Section III Other than the problem of 336nding time based on DFS 12  A naive way to externalize the internal DFS algorithm requires s Such an algorithm may end up an in\336nite loop and cannot compute all  33\(2 2001  H  Y ildir im  V  C haoji and M  J  Z aki Grail Scalable reachability index for large graphs s repeatedly until the graph 336ts in memory then an internal memory algorithm is used to 336nd the 336nal sor DFS tree on external directed graphs several problems in the external memory model are studied in the literature Dementiev et al 14 p ro vi de an i m pl ement a t i o n o f a n e xt ernal m emory minimum spanning tree algorithm based on the ideas of 22 which performs extremely well in practice even though theoretically inferior to the algorithms of 1   1 0   A jw an i e t al 4 6  propos e i mpl e ment at i ons of e x t e rnal undi rect ed breadth-\336rst search algorithm with the idea from 18 Ul rich Meyer et al 20 21  19  des i gn and i mpl e ment pract i c al I/O-ef\336cient single source shortest paths algorithm on general undirected sparse graphs Surveys about designing I/O ef\336cient algorithms for massive graphs can be found at 24 5  X C ONCLUSIONS In this paper we study I/O ef\336cient algorithms to 336nd all  3\(1 2010  J  Hellings  G  H  F letcher  and H  H averkort Ef\336cient external-memory bisimulation on dags In  3\(1 2010  Z  Z h ang J  X Y u  L  Q in L  C hang a nd X L i n I/O e f 336 cient Computing sccs in massive graphs In scan by maintaining the list of nodes that should not be traversed using tournament trees 17 and b uf fered repos i t o ry t rees 8  respectively Despite their theoretical guarantees these algorithms are considered impractic al for general directed graphs that encountered in real applications Cosgaya-Lozano and Zeh 13 p res e nt a c ont ract i o n b as ed al gori t h m w hi ch cont ract s V M E B V B 2 are similar as stated in Exp-2 IX R ELATED W ORK Finding strongly connected components of a directed graph V G V G E G E V E E V E  14\(1 1985  T  H  Cor m en C  S tein R  L  R i v es t and C  E  L eis e r s on  2003  U Me yer a nd N Z e h I/O-ef 336c ient undirected shortest paths with unbounded edge lengths In s Both DFS based algorithm 8 and c ont ract i o n b as ed algorithm 13 a re i n t roduced i n det a i l s i n S e ct i o n III In addition to external algorithms there are semi-external algorithms for ACM Comput Surv Introduction to Algorithms IFIP TCS         Proc of ESA\22202 Proc of ESA\22206 SIAM J Comput Commun ACM Proc of SIGMOD\22213  32\(3 2002 2 A  A ggar w a l a nd J  S  V itter  T h e i nput/output com p le xity of s o r ting and related problems  31\(9 1988  A  V  A ho J  E  Hopcroft a nd J  D Ullm an I/Os Chiang et al 10 propos e a n a l gori t h m with I/O complexity  Addison-Wesley 1983 4 D  A jw ani R D e m e ntie v  and U  M e y er  A com putational s tudy of external-memory bfs algorithms In  2006  D  A jw ani a nd U Me yer   6\(1 2011  A  L  Buchs baum  M  H  G oldw a sser S Venkatasubramanian and J Westbrook On external memory graph traversal In  2002  J  S  V itter  E x ter n al m e m o r y algor ithm s and d ata s tr uctur e s   2007 7 E  A ngel R Cam p igotto a nd C L a f o r e s t  A nalys i s a nd com p ar is on of three algorithms for the vertex cover problem on large graphs with low memory capacities  1995  N  Chiba a nd T  N i s h izeki A r bor icity and s ubgr aph lis ting algor ithm s   2009  R Dem e ntie v  P  Sanders  D  S chultes  and J  F  S ibe y n E ngineering an external memory minimum spanning tree algorithm In  2012  V  K u m a r a nd E  J  Schw abe Im pro v e d a lgorithm s and d ata s tructures for solving graph problems in external memory In  2002  U  M e yer a nd V  O s ipo v  D es ign a nd im plem entation o f a pr actical i/o-ef\336cient shortest paths algorithm In  2009  U Me yer a nd N Z e h I/O-ef 336c ient undirected shortest paths In  2006  J  F  S i be yn E x ter n al connected com p onents  I n  2013 A CKNOWLEDGMENT  Algorithmic Operations Research          267        and computation which assume that all nodes of the graph can 336t in the main memory Sibeyn et al 23 propose a semi-external DFS  which can be used to 336nd all og  pages 457\320468 2012  Y  J  C hiang M T  Goodrich E  F  Gro v e  R  T am as s i a D E  V e ngrof f and J S Vitter External-memory graph algorithms In  Proc of ALENEX\22207 Proc of SIGMOD\22212 Proc of SODA\22295 Proc of SEA\22209 PVLDB Proc of ALENEX\22209 Proc of ESA\22203 PVLDB                    McGraw-Hill 2001  A  Cos g ayaL o zano a nd N  Z e h A h eur i s tic s t r o ng connecti vity algorithm for large graphs In Algorithmica LargeProc of SPAA\22202 G O O O O Algorithmics of Large and Complex Networks Data Structures and Algorithms SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC SCC  Later Kumar and Schwabe 17 a nd B u chs b aum e t a l  8  i mprove the I/O complexity to  chapter 1 Design and Engineering of External Memory Traversal Algorithms for General Graphs Springer 2009  D  A jw ani U Me yer  and V  O s i po v  Im pro v e d e xternal m em ory b fs implementation In  2000  J  Cheng Y  K e  S  Chu and C Cheng E f 336 cient p roces s i ng of distance queries in large graphs a vertex cover approach In  2004  W  F a n J  L i  S  M a H W a ng and Y  W u Graph hom om orphis m revisited for graph matching  1996  K Mehlhorn a nd U Me yer  E xtern al-memory breadth-\336rst search with sublinear i/o In  2004  J  F  Sibe yn J  Abello a nd U Me ye r Heuristics for semi-external depth 336rst search on directed graphs In Proc of SWAT\22204  and SmallProc of SODA\22206 Proc of SODA\22200 219 Proc of SPDP\22296 Proc of SIGMOD\22212 


                  


             


 





 17  Jar r e n  A   B al d w i n  is  a  Ch i c a g o  n a t i v e  a n d  c u r r e n t l y  se r v e s a s t h e  l e a d  E l e c t r i c a l  En g i n e e r  a t  B a y  A r e a  s t a r t u p   Oc u l e v e  I n c   He  g r a d u a t e d  fr o m  t h e  U n i v e r s i t y  o f Il l i n o i s  wi t h  a  B  S   i n  2 0 0 9  an d  r ecei v ed  an  M  S   i n  El e c t r i c a l  En g i n e e r i n g  f r  St a n f o r d  U n i v e r s i t y  i n  2 0 1 2   Ja r r e n  d e v e l o p e d  h a r d w a r e  a n d  so f t w a r e  sy st e m s f o r  a  w i d e  ra n g e  o f  f i e l d s   i n c l u d i n g  s p a c e  s c i e n c e  s y s t e m s  a n d  m e d i c a l  de vi c e s  a s  a N A S A  A m es  i nt e r n i n t he  In t e l l i g e n t  S y s t e m s     1  2  3   4   5   6   7   8   9   10   11   12   13   


                        


                           


   












































     2 8    b 4      1 8             1 2     1  8 2  


1 9    8      2 1       1     2    8    2 3\f        


     8 D 4 9  F  \b 1 8 #J 9 1     2 1   2 #-@ 1   2 9  E 1   1   2 9      6  


    8  8   1  D 1         1 F  \b0         2 D    F  \b 1 8  9  


  1 9  1   E 1  2 9     1 1 F  \b       1    18   F   1    1 #-$+  \b  2 2  


1 D     1 #-$+.B- 0/:% .0             9 1      18    1 6     1 2  1  1  


1   6      2    1 2 E 8 D 1      1 2   1   1 #-4  #-@E     2  1  1  1       


 8     1          2 F    6   F  2   8    2 C<CC/C N\bO 5      


CD    b$44NO F P Q 6   2 b$$$ ,=\b\bA  A N,O 2 C C  b$$4N  92 2   f  9-\b$$4 B N?O  !-    91  2 1 HH111-18-N+O    -1 :3%   2     0-4 


     b N4O 2   2- \f  C b$@$ \b# >\b\b$3\b$N@O  f :.% 9 /9 \f    1  6  f 2  4   A254 


Advantages of Our M ethod Advantages of Our M ethod Exploit the memory v ertical data format utilizes slidin g windows to g form a much larger database to analyze  Flexibility in Choosing what to choose  Choosing what to choose to build the rules Computational and memory efficiency We have a team working only on this aspect 45 Associative IDS for NextGen Frameworks Dr S Dua LA Tech 45 


Preliminary Results Intra transaction Relations Data rate simulator NH-134 Mb HOP PATH update \(Y/N Inference 11.5 Y Y 2 0.120 N N      Y   n 0.345 N NH134 Y/N   Inf 1 0.150 N N 2 0 120 Y N Inter transaction Relations 2 0  120 Y N       5 5.55 0.456 Y Relations  n 0.345 N N Nmap on DMRL nmap.org 


Anticipated Outcome Anticipated Outcome Develop algorithm capable of learning from a given heterogeneous diverse Develop algorithm capable of learning from a given heterogeneous diverse data ff Dynamic algorithmic f ramework designed to shi f t modalities and sampling rates based on complex logic Flexibility of integration into the Snort intrusion detection system 47 Associative IDS for NextGen Frameworks Dr S Dua LA Tech 47 


References References Aircraft Cockpit Image courtesy USAF http://www.faa.gov htt p   www.faa g ov  air traffic  technolo gy  p g  _ gy  Acharya R Dua S Du X Sree V Chua C K Automated Diagnosis of Glaucoma Using Texture and Higher Order Spectra Features To appear in IEEE Transactions on Information Technology in Biomedicine  Du X Dua S 2011 Cancer Prognosis Using Support Vector Regression in Imaging  Modality World Journal of Clinical Oncology 2  1   44 49 Du X Dua S 2010 Salient Frame Extraction Using Support Vector Regression and Motion Features pp 5 Proc of the National Aerospace and Electronics Conference July 14 16 2010 D M P D S 2010 Di i i ti Ft d Cl ifi ti Mthd f D essaue r  M  P  D ua S  2010  Di scr i m i na ti ve F ea t ures an d Cl ass ifi ca ti on M e th o d s f or Accurate Classification 1st ed vol 7704 pp 14 Bellingham WA Proceedings of SPIE Dessauer M P Dua S 2010 Low Resolution Vehicle Tracking using Dense and Reduced Local Gradient Features Maps 1st ed vol 7694 pp 8 Bellingham WA Proceedings of SPIE SPIE 


Acknowledgements Acknowledgements Fundin g A g encies  US 4 1 Million direct fundin g g g 4 g LA BoR NIH NSF AFRL AFOSR and NASA Research Team Samuel Kasimalla Brandy McKnight Dr Pradeep Chowriappa Connor Johnson Vasanth Nair Mihir Chowriappa  Connor Johnson  Vasanth Nair  Mihir Karnik Mohit Jain and Swadheen Songmen Associative IDS for NextGen Frameworks Dr S Dua LA Tech 49 All the respective Logos belong to their owners 


Rf d Rdi R e f erence d R ea di ngs Copyright of cover pages held by respective publishers 


Thank You Questions Thank You  Questions Dr Sumeet Dua E mail sdua@latech.edu Web http://dmrl.latech.edu Associative IDS for NextGen Frameworks Frameworks Dr S Dua LA Tech 51 Image Source roadtrafficsigns.com 


