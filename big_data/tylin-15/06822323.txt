We downloaded from GitHub, Inc., a portfolio of recently updated open source Scala projects containing 16,500 source files with 2.3 million lines of code and 223,000 methods written by hundreds of programmers. A related paper found in this çbig dataé of functional programs non-Gaussian distributions of lines of code and cyclomatic complexity and speculated that the distributions resembled those of phenomena known to be fractal in structure, following power laws. In this paper we show that power-laws are the best, most parsimonious explanation of the distributions according to 
Abstract 
Power-Laws and Structure in Functional Programs Ron Coleman Computer Science Department Marist College Poughkeepsie, NY 12601, United States Matthew A. Johnson Computer Science Department Marist College Poughkeepsie, NY 12601, United States   
 
R  KeywordsÑPower-laws; minimum description length functional programming; Scala 
I I NTRODUCTION  Computer programs have structur S o ft w a r e  complexity metrics have been developed, more than 100 by some estimates, to quantify this structure, which is manifest in the lexical organization or çstyleé of source code [2 Ko k o l   Brest, and Zumer reported evidence of fractal structures as 
2 analysis and minimum description length principles. We show furthermore that the data are robust and the power-law explanations are persistent even when the largest project in the portfolio, the Scala compiler and standard library, is removed. To our knowledge these findings are the first such report in the literature of powerlaw distributions of software complexity in functional programs 
long-range correlations of characters, operators, and strings in a collection of 20 FORTRAN programs [4   Kok o l  an d B r es t  studied a similarly small sample of randomly generated Pascal programs and identified fractal structures therein, too [5  T h eir  goal had been to devise a new type of software complexity metric founded on fractal statistics [6  In dee d  K o k o l a n d others working in this line developed fractal metrics  The  advantage of their method, they pointed out, is it is language independent. The disadvantage is the fine details in character operator, and string patterns obscure and ignore semantics of higher-level structures, scope, declaration, selection, iteration etc., that are indispensible in understanding and refactoring program complexity. Nevertheless, the authors allege [5 t h e fractal metric is correlated with measures like lines-of-code 
LOC\and McCabeês cyclomatic complexity 
M per se M 
9 In contrast, in this paper we are not studying source  as in Kokol et al [4,5,6,7,8 b u t d i st ri b u ti o n s o f  co m p lex ity  measures about source, in our case, Scala [10  S cal a is  a  modern Java Virtual Machine \(JVM l a ngua ge t h a t b l e n d s  functional and object styles and in many ways exemplifies what appears to be a renaissance of interest in functional programming [12, 13, 14, 15, 16, 17, 18, 19, 20 ve l opi ng practical applications. Indeed, the paper [21 an aly zed  L O C  and of çtrendingé Scala functional programs downloaded from the repositories of GitHub, Inc. [22  t o in v estig ate  assertions by functional programming proponents that elaboration of the lambda calculus is a better way to 
M M M M 
modularize the structure of programs and hence, reduce complexity T ha t p a p e r re por t e d a m o ng ot he r t hi ngs t ha t  LOC and for Scala codes were correlated just as Hatton had found for FORTRAN and C codes [2 w e ve r   t h e  frequency distributions of LOC and for Scala source reported by [2 e r e  d i st i n c t i v e l y no n-G a ussi a n I n ot her words, the Scala programs appeared to be highly modular in structure with a preponderance of short \(LOC\0023\, straight-line  1\ethods which seemed to support Hughesê contentions regarding why functional programming matters [2 Ye t  2 1 only speculated that the nonGaussian distributions of LOC and might follow power-laws, possibly being fractal [25 
We explore the matter here and find empirical evidence that power-laws are the best explanation of the data according to R L H H D L D H b R b basis M 
2  analysis [2  W e s h ow f u rth erm or e th at p o w e rlaw s are a l s o  the most parsimonious explanation according to minimum description length \(MDL\principles [27 a m e l y  i f  2 where 
 s the length of a hypothesis to model the frequency distribution and     is the or number of unique values of LOC or 
D H L H D H H A Scala projects 
 
 
in given then    is minimized when is a power-law. Finally we show that power-laws are the most parsimonious account of the data even if the largest project in the portfolio, the Scala project \(i.e., the compiler and standard library being largely written in Scala\ere removed from the portfolio. To our knowledge, these results are the first such report in the literature of power-law distributions of software complexity measures in functional programs and particularly, Scala II M OTIVATIONS AND M ETHODS  
The paper [21  com pil ed a p o r t f o l i o of S cal a p r o j ec ts  hosted on GitHub, Inc  whi c h c l a i m s  t o b e t he  w o r l dês largest open source community D u r i ng t h e p e r i o d  15 3 0 June 2013, we selected and downloaded all the projects that GitHub had identified as being recently updated by the project developers. They included the Scala compiler/standard library 10  th e  T w itter   In c  se rv e r  an d li b r a r i e s  2 9   sev e r al la r g e  commercially inspired projects like Lift [3 A k k a  3 1   a n d Casbah  a n d m a n y sm a l l e r a n d l e ss er kn o w n p r oj ec t s  fo r computational finance, computer graphics, networking, web services, cryptographic algorithms, and artificial intelligence among others. One exception was the Twitter source. The portfolio initially included some but not all the Twitter projects 
2014 International Conference on Computational Science and Computational Intelligence 978-1-4799-3010-4/14 $31.00 © 2014 IEEE DOI 10.1109/CSCI.2014.112 652 
2014 International Conference on Computational Science and Computational Intelligence 978-1-4799-3010-4/14 $31.00 © 2014 IEEE DOI 10.1109/CSCI.2014.112 168 
2014 International Conference on Computational Science and Computational Intelligence 978-1-4799-3010-4/14 $31.00 © 2014 IEEE DOI 10.1109/CSCI.2014.112 168 
2014 International Conference on Computational Science and Computational Intelligence 978-1-4799-3010-4/14 $31.00 © 2014 IEEE DOI 10.1109/CSCI.2014.112 168 


    
B Sclastic Sclastic decision points M C Line counts D Estimating M M M E  N 2 P 1 where E N P M if while case-match M filter count find E Model selection M f  x  c x c R H H f  f  c x c e cln x  002 d H R f f 
002 002 
written in Scala. Yet in the interests of possible future research 21 g a th e r e d al l 4 1 S c a l a p r o j e c ts o n th e  T w itter  p a g e  o f  GitHub [29  ev en if  th ey  w eren  t r ecen t l y u pda te d  T h e o t h e r  exception was Casbah, a database project. It had been used in testing of the compiler kit \(see below\ and was included in the portfolio for the sake of completeness. In total, the portfolio contains 262 Scala projects with 16,500 source files, 2.3 million LOC \(i.e., 1.5 million LOC without comments\ and 223,000 methods To analyze the complexity of Scala programs, [21  developed an experimental compiler kit, called The kit is almost entirely written in Scala and completely hosted by GitHub  S cl a s t i c i s  n o t par t o f t h e po rt fo l i o o f  proj ec t s we  study here.\ As a thorough review of Scala and Sclastic are beyond the scope of this paper, we offer only a minimalist outline of them. Readers may wish to consult Odersky, Spoon and Venners [10 an d  o r th e S c last ic so u r c e  o n  GitHu b   3 3    Suffice it to say that Scala implements functional programming constructs with an object-oriented approach That is, there is the class structure, which contains zero or more functions also known as methods. While functions objects may be named or anonymous, they are instantiated, invoked, etc within the scope of a class The Sclastic compiler reads Scala source directly from the GitHub zip download in three distinct phases. The decommenting phase strips the source of comments and empty lines. The parser phase identifies lexical objects, scopes methods, and see below\. The final phase, the method compiler, calculates LOC and per method A line in Scala is a sequence of characters terminated by a newline character. There are, however, two line counting considerations in relation to methods. First, class definitions may have statements outside of a method, the lines of which Sclastic interprets as class constructors. Second, Scala permits inner definitions of method and classes, that is, methods within methods, classes within classes, etc. In this situation there is the çnominalé line count, which is the count of lines within the lexical scope of a method or class definition including all inner definitions. There is also the çeffective line count. This is the count of lines of a method or class excluding inner definitions. We used only the effective line count when calculating LOC per method Sclastic uses a combination of two approaches to estimate The first approach is based on an analysis of program flow given by McCabe [9   and are the number of edges and nodes respectively, in the program flow graph, and is the number of exit points for a given method. However, McCabe also provided a functionally equivalent simplification for Equation 1, namely 003 + 1 2 where \003 is the number of Boolean selection statements or decision points in a procedure. The signatures of decision points for Scala are  and statements and and || operators. The signatures of these decision points are hardé in the sense that they are part of the Scala language Sclastic stores the çhard-codedé signatures in a database, that is, a çbook,é which Sclastic queries when compiling the source to calculate \003 As for the second approach, counting hard decision points alone is inadequate for properly estimating because Scala source may also make decisions in the context of high-order functions that take Boolean returning function objects. We call these higher-order functions çpredicate contexts.é Some examples of predicate contexts are methods like   and which are defined on collections in the Scala standard library. However, Scala language designers may some day refactor the standard collections. Programmers may also extend the standard library and add new collections with new predicate contexts or develop collections with predicate contexts that are independent of the standard library. For these reasons the signatures of predicate contexts cannot be known in advance. They must be learned in an adaptive or çelastic manner that depends on the input source code. Thus, Sclastic makes one extra pass over the entire portfolio to collect the soft signatures and store them in the book during the parsing phase To calculate \003 Sclastic queries the book and counts the number the hard and soft decision points within the lexical scope of a method When [21 a p pli e d th e a b ov e m e th ods t o th e p o r tf ol io i t  obtained frequency distributions of LOC and per method that were distinctively non-Gaussian, resembling those of physical and aesthetic phenomena known to follow power-laws  A ho m o ge neo us po w e r la w ha s the func ti o na l for m   3 where and \004 are constants We test six other, alternative hypotheses and use  corresponds to one of four functional forms in the table below x  x p owe r la w c * x exponential c * E x logarith m   c L x + a p olynomial, deg=d c 000\023 005 c 000L x 000L  for i=1..d c 000\023 c 000\024 x + c 000\025 x ^ 2 In the case of polynomial functions, we use 1-4. We use Microsoft Excel to fit the frequency distributions to each and compute the x\nnote greater parsimony. To approximate this ideal, the function, $, converts x\o a string. $ removes white space and parentheses and reduces power, exponential, and log functions to single letters 
Table 1 Hypotheses ctional forms, and transformations 
002 000\003 002 002 x 
2 analysis and MDL principles to rank them. Each hypothesis 2 statistic We posit that çsimpleré formulations of 
H 
653 
169 
169 
169 


Table 2 Figure 1 LOC distributions with a compiler/standard library project Figure 2  distributions with \(+\ an d compiler/standard library project  Table 3 Results of fittin g each model distribution with the Scala p ro j ect in a nd without \(o\e Scala d without \(o\he Scala t o the LOC fre q uenc y  the p ortfolio 
preserves variable names and precisions numerical constants generated by Microsoft E returns the number of characters in the s  x gives a çnaÔveé or statistically uni n of x For instance, for the model x\ = 191838x 2.615  we have 191838x 2.615 191838*x Here $\(191838x 2.615 len = 15 We use  x We model L\(D|H L\(D|H  is the basis, which is to say, the nu m unique values of LOC and In a conventio n b asis is the number of unique bins excludin g zero frequency counts There is a need to create a çtrueé histogra m distributions with zero frequency bins. T compare like distributions from different Kolmogorov-Smirnov \(K-S\est [34   III D ATA  The table below gives data for the te n sorted by the number of methods. \(The LO C comments and empty lines Rank Project LOC Metho d 1 Scala 247,134 57,00 2 ScalaTest 169,968 16,60 3 Delite 41,125 8,92 4 Lift 58,407 8,69 5 Akka 65,713 8,27 6 SBT-0.13 35,949 6,91 2 7 Spire-2.10.0 17,162 4,88 8 Scalaz-Seven 27,847 4,85 9 Finagle 41,081 4,67 2 10 BIDMat 14,141 3,72 The Scala project is by far the largest number of methods. For this reason, we test with and without the Scala project to rule o u this project may have on the aggregate statisti c and formats of E xcel x  s tring. In effect n formative length 2.615 s the fitness of  ny MDL theory n d simplicity into L H\+L\(D|H\ We e n take the length 4 5 m ber of observed n al histogram, the g those bins with m of the LOC and he purpose is to portfolios using n largest projects C are stripped of d s % total 9 26 5 7 9 4 5 4 9 4 2 3 5 2 5 2 2 2 7 2 in LOC and the the distributions u t potential biases c s The scatter plot in the figur e representation of the frequency dist r with \(+\ and without \(o\ the Scala p r  The scatter plot in the figur e representation of the frequency di s with \(+\ and without \(o\ the Scala p r  IV R ES U The table below gives the mo d distribution with the Scala project i n where the basis 88 x e below gives a graphical r ibution of LOC per method r ojec t using log-log scales  e belo w gives a graphical s tribution of per method r ojec t using log-log scales  H\ L\(D|H L\(H L\(D|H 15 91.7 106.7 17 108.6 125.6 
2 as the primary means to assess However, using 2 alone ignores p arsimo n provides one means that takes both fitness a n account. Specifically, we look to minimize L compute L\(H\ as shown in Table 1 above th e of the resulting string. That is L\(H 2  L 492094x 2.311 0.96 3147.6e 0.064x 0.81 2  
1 10 100 1,000 10,000 100,000 1,000,000 
 
L OC / method 
U LTS  d els for the LOC frequency n the portfolio, sorted by 
Freq L Freq 
f len f f F Minimum description length principle R R   f len 000\003 b R 2  where b M M f len H b f R M R 
  
002 002\003 002\003\003 002\004\003\003\003 002\003\004\003\003\003 002\003\003\004\003\003\003 002\004\003\003\003\004\003\003\003 002 002 002 002 003 002\003\003 002\004\003\003\003 002\003 002\003\003 
M 
M   method 
654 
170 
170 
170 


Table 4 Results of fitting each model to the LOC frequency distribution not including the Scala project in the portfolio Table 5  Results of fitting each model to the frequency distribution with the Scala project in the portfolio Table 6 Results of fitting each model to the frequency distribution not including the Scala project in the portfolio 
  
not b f R M b  f   R  M not b  f  R A Scala project P M P B Straight-line effect log c x log x log c 002 log c 002 log c R M C Power-law vs. exponential models R D Log models 
 
0.039x 4 6.5834x 3 372.13x 2 8035.3x+52286 0.43 46 204.7 250.7 0.083x 3 19.237x 2  1294.1x + 23854 0.33 36 266.7 302.7 10602ln\(x\ + 35029 0.31 15 283.9 298.9 13.829x 2 1200.8x 21084 0.21 25 419.0 444.0 105.53x + 7818.7 0.09 16 977.8 993.8 The table below gives the models for the LOC frequency distribution including the Scala project in the portfolio where the basis 87 x frequency distribution with the Scala project in the portfolio where the basis 50 x  L\(H  L\(D|H L\(H L\(D|H 256689x 2.661 0.98 15 51.0 66.0 2358.3e 0.119x 0.81 17 61.7 78.7 0.0519x 4 8.698x 3 490.48x 2 10633x+69893 0.40 45 125.0 170.0 14049ln\(x\ + 46810 0.31 15 161.3 176.3 1.0482x 3 133.75x 2  4866.5x + 47952 0.29 37 172.4 209.4 16.979x 2 1520.4x 27704 0.17 25 294.1 319.1 331.09x + 13714 0.07 15 714.3 729.3 The table below gives the models for the frequency distribution including the Scala project in the portfolio where the basis 46 x  L\(H  L\(D|H L\(H L\(D|H 191838x 2.615  0.98 15 46.9 61.9 2159.1e 0.12x  0.81 16 56.8 72.8 0.039x 4 6.5834x 3 372.13x 2 8035.3x+52286 0.42 46 109.5 155.5 10602ln\(x\ + 35029 0.32 15 143.8 158.8 0.7495x 3  96.509x 2 3564x 35300 0.29 35 158.6 193.6 13.829x 2 1200.8x 21084 0.17 25 270.6 295.6 259.14x + 10678 0.07 15 657.1 672.1 V D ISCUSSION  The K-S test indicates the two LOC distributions are statistically identical 0.999\ with and without the Scala project. The K-S test indicates similarly for the distributions  0.996\. Thus, the Scala project apparently does not bias the results. First, we interpret this to mean the data is robust Second, the large-scale structural pattern in the Scala source is independent of project and by implication, independent of programmer While we did not apply trend lines to Figures 1 and 2, they nevertheless exhibit a high degree of linearity, at least by visual inspection. This condition is symptomatic of power-laws when plotted on log-log scales. That is, if a power-law is the generating process, then  004    where  is the line slope and  the intercept. We have 0 in each case and  006 5 \(see Tables 3 Ö 6\hese correspond to the observed slopes and intercepts in the figures. There is a small çbowé in the LOC curve which may account for the slightly, consistently higher compared to LOC The Tables 3 Ö 6 show consistently the closest competitor of the power-law interpretation is the exponential interpretation in terms of While the log models do not overall compare well with power-law or exponential models, the fitness of the log models is consistently better than the polynomial models except for the highest degree polynomial model. Even here the log is hardly distinguishable from the fourth degree polynomial. We account 
002 
M M 
2  L\(H L\(D|H L\(H L\(D|H 350467x 2.247  0.96 15 90.6 105.6 2728.4e 0.064x 0.87 17 100.0 117.0 0.0016x 4 0.478x 3 49.527x 2 1977.7x + 24241 0.47 46 185.1 231.1 5226ln\(x\ + 20539 0.41 14 212.2 226.2 0.0591x 3 13.793x 2  934.87x + 17239 0.35 37 248.6 285.6 2.2758x 2 344.08x 10889 0.22 25 395.5 420.5 78.583x + 5803.2 0.10 16 870.0 886.0 The table below gives the models for the 2  2  2 for 2 and MDL. This is perhaps not surprising Exponential distributions are similarly ubiquitous in natural and artificial phenomena. For example, consider radio and light emissions from galaxies, oil field reserve sizes, foreign exchange rate variations, country sizes, etc. [35 Al t h o ugh w e  might investigate further for a better fit using some sort of exponential interpretation, we suspect such a model will not likely be as parsimonious 
    
655 
171 
171 
171 


                                   
IEEE Transactions on Software Engineering Cybernetics and systems SIGPLAN SIGPLAN Proceedings of FESMA Proceedings Computer Aided Systems Theory - EUROCAST'99 IEEE Transactions on Software Engineering Programming in Scala Clojure Programming Functional JavaScript: Introducing Functional Programming with Underscore.js Functional Programming Using F An Introduction to Functional Programming Through Lambda Calculus Introducing Erlang Haskell: The Craft of Functional Programming Functional Programming for Java Developers: Tools for Better Concurrency, Abstraction, and Agility The Register Empirical Software Engineering Fractals, Chaos, Power Laws: Minutes from an Infinite Paradise Applied Regression Analysis Advances in Minimum Description Length: Theory and Applications Lift in Action: The Simply Functional Web Framework for Scala Practical Non-Parametric Statistics Eur. Phys. J 
 
L H E Linear models R 
for this because the log models are very compact, that is considering only its  For this reason, we consider a relatively attractive alternative, however implausible The linear models appear to fail utterly compared to the other. The linear models are extremely simpleÑnote their L\(H\Ñbut not very plausible. In our view, this observation supports the elegance of power-law explanations. That is, the power-law models are as simple as the linear models by L\(H and at the same time plausible by C ONCLUSIONS  Why Scala programs might be structured with a preponderance of short, straight-line methods that seem to follow power-laws, is an intriguing question. Consider the codes were created by hundreds of programmers, 262 or more of them, each one presumably with a different programming style. Consider also minimalist and çpermissiveé Scala grammar, in which, at least anecdotally, styles vary widely. We will only suggest that the data regarding power-laws do not contradict arguments that mathematical expressiveness of functional languages lends itself to writing modular codes. On the contrary, the data seems to support these claims. However we leave open questions of whether these data are unique to Scala specifically and whether they apply to functional programs generally Thus, we believe it might be worthwhile to investigate other languages, functional and imperative, and consider how they compare with these results for Scala.  The data are only suggestive that the distributions may also be fractal in structure. This is something to pursue for future research Finally, future work might also investigate more closely specific projects in the portfolio, e.g., we alluded to the Twitter project A CKNOWLEDGEMENTS  We thank the reviewers for their feedback, which we have tried to incorporate here R EFERENCES  1 
S. McConnell, Code Complete: A Practical Handbook of Software Construction, 2 nd ed., Microsoft Press, 2004 2 D. Tran-Cao, G. LÈvesque, and J.G. Meunier, çA Field Study of Software Functional Complexity Measurement,é Proceedings of the 14 th  International Workshop IWSM/MetriKon 2004, Shaker, Aachen, 2004 pp 175-193, ISBM 3-3822-3383-0 3 E. J. Weyuker, çEvaluating software complexity measures 14\(9\, 1988, p1357Ö1365 4 P. Kokol, J. Brest, and V. Zumer, çLong-range correlations in computer programs 28\(1\, 1997, p43-57 5 P. Kokol, J. Brest, çFractal structure of random programs  notices 33\(6\, 1998, p33-38 6 P. Kokol çSearching for fractal structure in computer programs 29\(1\, 1994 7 P. Kokol, V. Podgorelec, and J. Brest, çA wishful complexity metric editors: Combes H, et al\ Technologish Institut, 1998, p235-246 8 V. Podgorelec, P. Kokol, and M. Zorman, çA fractal software complexity metric analyzer A Selection of Papers from the 7th International Workshop on Computer Aided Systems Theory Vienna Austria, September 29 - October 2, 1999 9 T. McCabe, çA complexity measure vol. 2, no. 4, 1976, p308  M. Odersky, L. Spoon, and B. Venners Artima 2011  Oracle, Inc., http://oracle.com.  Accessed 9 Nov 2011  C. Emerick, B. Carper, and C. Grand OêReilly 2012  M. Fogus OêReilly, 2013  M.R. Hansen and H. Rischel  Cambridge University Press, 2013  G. Michaelson Dover Publications, 2011  S. St. Laurent OêReilly, 2013  S. Thompson Peason Education Ltd, 2011  D. Wampler OêReilly, 2011  Twitter, Inc., http://twitter.com. Accessed 9 Nov 2013   C. Me tz, çTwitter jilts Ruby for Scala  http://www.theregister.co.uk/2009/04/01/twitter_on_scala/. Accessed 1 Jul 2013  R. Coleman and M. Johnson, çA study of complexity in functional programs Springer, draft submitted for review on 4 Oct 2013. A copy can be downloaded at http://foxweb.marist.edu/users/ron.coleman/pubs/EMSE-D-1300147.pdf. Accessed 15 Nov 2013  GitHub, Inc., http://github.com. Accessed 9 Nov 2013  J. Hughes, çWhy Functional Programming Matters,é Research Topics in Functional Programming, ed. Turner D, Addison-Wesley, 1990, pp. 17 42  L. Hatton, çThe role of empiricism in improving the reliability of future softwareé, TAIC 2008  M. Schroeder Dover, 2009  N.R. Draper and H. Smith Wiley, 3 rd ed 1998  P. Grunwald, çA tutorial introduction to the minimum description length principle eds. Grunwalk, Myung, and Pitt, MIT Press, 2004  GitHub, Inc., çTrending Scala repositories on GitHub today https://github.com/trending?l=scala. Accessed 23 Jun 2013  Twitter, Inc., çTwitter is built on open source software http://twitter.github.io/. Accessed 30 Jun 2013  T. Perrett Manning , 2011  Typesafe, Inc., http://akka.io/. Accessed 29 June 2013  10gen, Inc. http://10gen.com. Accessed 3 Jul 2013  Sclastic, http://github.com/roncoleman125/Sclastic. Accessed 12 Aug 2013  J. Conover Wiley, 1995  J. Laherrere, D. Sornette, çStretched exponential distributions in nature and economy: 'Fat tails' with characteristic scales B2 525-539, 1998   
2 and MDL VI 
 
656 
172 
172 
172 


 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 0 20 40 60 80 100 120 140 160 180 Number of Algorithms Milliseconds Latency of Workîow start latency Fig 5 This chart gives the average latency between the minimum and maximum start time for algorithms running in parallel in a single stage of the workîow as the number of algorithms is increased from 2 to 16 each update phase The server and client libraries coordinate re-mapping transparently C Roles  Dependencies The STINGER execution model with pub/sub enables one algorithm to use the results of another algorithmês computation An example use case might be a community detection algorithm that uses connected components information as well as the PageRank scores of each vertex as input to the computation To fully implement this feature the STINGER server coordinates algorithm dependencies and scheduling without the need to double buffer result sets When a client registers with the server it expresses its dependencies by giving the string identiìers of algorithms that it subscribes to The server constructs a directed acyclic graph DAG of algorithms and schedules their execution in a parallel level-synchronous manner Each algorithm remaps the data structure and any other client result sets at the beginning of execution ensuring that the data subscribed to is most current The overhead of running multiple single-threaded algorithms in parallel within the workîow is plotted in Figure 5 In the gure the start latency computed as the difference between the start of the pre-processing phase of the earliest algorithm and the same point for the latest algorithm is measured as the number of processes is increased from 2 to 16 The gure demonstrates a small cost to adding algorithms likely due to sequentially sending the start messages which could be improved through parallelization or switching from TCP to UDP On average the latency between the end of the pre-processing phase of an algorithm and the beginning of the pre-processing phase of an algorithm dependent on it was approximately 29 milliseconds To avoid freezing the system algorithms must respond before a watchdog timer runs out typically about ve seconds If an algorithm cannot keep up with the forward progress of the system it is placed back in initialization state and can re-join the computation after it has reset its internal state An example timeline in Figure 6 shows the interaction between client algorithms and the server Today STINGER supports only required dependencies However optional dependencies may aid system exibility In our example of community detection using PageRank scores if PageRank was running the community detection algorithm could utilize the results through the pub/sub mechanism However if PageRank was not available the community detection algorithm would compute the score itself or provide an alternate means of scoring The corollary to optional dependencies are role-based algorithms Calculating optimal results of many graph queries is NP-Complete or worse As a result many heuristic approximations have been proposed In a system like STINGER several clients could run each computing a different heuristic approximation A role-based system would enable each to advertise that they are computing the same metric but in a different way Other clients subscribing to their results could utilize one several or all of the result sets as appropriate V E XTERNAL I NTERFACES Each client algorithm can produce a very large dense result vector during each update cycle A client producing a single double-precision oating point value for each vertex in the graph consumes 8 GB assuming one billion vertices in the graph It is prohibitive to send 8 GB to an analyst workstation every minute The memory bandwidth of the server is much higher than the network bandwidth between the server and the workstation The analyst usually does not need all of this data but rather is looking for speciìc data points As a result we can minimize client bandwidth by performing as much of the operation on the server where the data is already in memory before sending the results to the client at the very last moment For this reason the STINGER execution model employs a special class of algorithm client known as the monitor process It is a standalone process that is scheduled like a client algorithm but cannot publish data and is dependent on all other algorithms in the system By virtue of this attribute it is always scheduled in the last update slot and has access to all other algorithms result stores In Figure 6 the HTTP Endpoint is a monitor process that we will now describe Our primary monitor process is an HTTP endpoint that serves a RESTful interface to the algorithm result stores and graph data Using the embedded Mongoose HTTP server we accept JSON-RPC POST requests The JSON-RPC protocol is a simple remote procedure call that utilizes JSON 
880 


 022\002\035\023\030 022\027\004\004!\026\033\010%\012&\003\010\003\037\010\033\027\026 017\025\030 017\015\014\002 022\027\026\026\003\037\010\003\011\012\022\027\004\005\027\026\003\026\010\021 017\025\030 017\015\014\002 017\025\030 017\007\031\003\025\007\026 017\025\030 017\015\014\002 017\025\030 017\017/0 014\002\035\016\032\030\025\012\014\003\020\036\003\020  005 006\005\006\007\006\010 Fig 6 This timeline shows the interaction between client algorithms monitor processes and the STINGER server as a batch of edge insertions and del etions are applied to the graph In this example the Community Detection algorithm is registered as dependent on PageRank and Connected Components algorit hms a JavaScript GUI for sentiment and topic tracking b JavaScript tool for subgraph connectivity visualization Fig 7 Examples of two analytics visualizations built on the STINGER streaming framework formatting to encode a method and parameters JSON is a convenient choice because it is ubiquitous in web-based client-side computing RapidJSON is an open source C library for parsing and formatting JSON strings and was chosen for performance Basic RPC methods include querying what algorithms are running and the data description of each algorithm More advanced methods perform queries on the client data stores For example we provide a method to return the top/bottom n values from a data array This method sorts all of the data inmemory and extracts only the values of interest An optional parameter to all methods returns the vertex identiìer strings with the result Sampling over a data array is achieved by an optional parameter that speciìes the number of samples or the bucket size and includes exponential sampling Combining sampling with sorting effectively computes a histogram on the server returning kilobytes instead of gigabytes A similar RPC method returns the results for a speciìc set of vertices Another method performs a reduction over the data array such as a sum min or max Each time a query is made the requester chooses to receive the current results immediately or wait for an update If waiting for an update the HTTP server will not respond to the request until the next batch of edges is processed In cases where a streaming algorithm does not exist or the results are input-dependent such as a connectivity query we extend our RESTful API by implementing sessions For example if the query is What are the shortest paths between vertex A and B  we would register our query with the 
881 


server which would create a session compute the current shortest paths and return the edge list to the requester with a session identiìer In subsequent requests the requester need only reference the session identiìer and receive a list of edge insertions and deletions since the last query that can be used to keep the requester in sync with the server The visualization corresponding to such a query can be seen in Fig 7\(b We have also used monitor processes to periodically checkpoint the state of the graph to disk for an additional layer of resilience Monitor processes can perform tasks such as checking the consistency of metadata within the data structure to identify errors We provide a monitor process that periodically snapshots a client result store to a MongoDB instance VI C ONCLUSION As data volumes continue to grow it will become impossible to store all raw data that is collected At each time step data will be computed and analyzed and only those elements perceived to be most important will be stored This environment will create the need for new infrastructures and execution models for computation In this paper we have described the STINGER framework for streaming data analytics The system utilizes heterogeneous clusters to ingest data from multiple social media services form in-memory graph representations of relational data store raw data in traditional databases for historical search and give analysts up-to-the-minute insight into a suite of streaming analytics The system design is focused on performance and modularity minimizing latency and increasing throughput The infrastructure that we have described is free and open source software It is BSD licensed and available at www.stingergraph.com  In Figure 7 you will nd screenshots of several web-based tools that have been implemented on the STINGER architecture These tools combine complex graph analytics topic classiìcation text sentiment analysis and geolocation for real-time streaming data analysis R EFERENCES  T witter  Goal  April 2012 http://blog.uk.twitter com/2012/04/goal.html  F acebook K e y f acts  May 2012 http://newsroom.fb.com/content/default.aspx?NewsAreaId=22  D Ediger  K Jiang J Riedy  and D A Bader  Massi v e streaming data analytics A case study with clustering coefìcients in Workshop on Multithreaded Architectures and Applications MTAAP  Atlanta Georgia Apr 2010  D Ediger  E J Riedy  D A Bader  and H Me yerhenk e T racking structure of streaming social networks in 5th Workshop on Multithreaded Architectures and Applications MTAAP  May 2011  J Riedy and D Bader  Multithreaded community monitoring for massive streaming graph data in Parallel and Distributed Processing Symposium Workshops PhD Forum IPDPSW 2013 IEEE 27th International  May 2013 pp 1646Ö1655  R McColl O Green and D Bader   A ne w parallel algorithm for connected components in dynamic graphs in Conference on High Performance Computing HiPC 2013 IEEE 20th International  December 2013  U Kang C E Tsourakakis and C F aloutsos Pe gasus A peta-scale graph mining system implementation and observations in Proceedings of the 2009 Ninth IEEE International Conference on Data Mining  ser ICDM 09 Washington DC USA IEEE Computer Society 2009 pp 229Ö238  G Male wicz M H Austern A J Bik J C Dehnert I Horn N Leiser  and G Czajkowski Pregel A system for large-scale graph processing in Proceedings of the 2010 ACM SIGMOD International Conference on Management of Data  ser SIGMOD 10 New York NY USA ACM 2010 pp 135Ö146  A Buluc  and K Madduri Parallel breadth-ìrst search on distributed memory systems in Proceedings of 2011 International Conference for High Performance Computing Networking Storage and Analysis  ser SC 11 New York NY USA ACM 2011 pp 65:1Ö65:12  J E Gonzalez Y  Lo w  H Gu D Bickson and C Guestrin Po wergraph Distributed graph-parallel computation on natural graphs in Proceedings of the 10th USENIX Conference on Operating Systems Design and Implementation  ser OSDIê12 Berkeley CA USA USENIX Association 2012 pp 17Ö30  M Zaharia M Cho wdhury  M J Franklin S Shenk er  and I Stoica Spark Cluster computing with working sets in Proceedings of the 2Nd USENIX Conference on Hot Topics in Cloud Computing  ser HotCloudê10 Berkeley CA USA USENIX Association 2010 pp 10Ö10  D A Bader  J Berry  A Amos-Binks D Cha v arr  a-Miranda C Hastings K Madduri and S C Poulos STINGER Spatio-Temporal Interaction Networks and Graphs STING Extensible Representation Georgia Institute of Technology Tech Rep 2009  R McColl D Ediger  J Po ovey C D and D Bader A performance evaluation of open source graph databases in Parallel Programming for Analytics Applications PPAA 1st Workshop on  Sept 2 pp 1Ö5  Google Protocol b uf fers  http://code.google.com/apis/protocolb uf fers  D Ediger  R McColl J Riedy  and D A Bader  STINGER High performance data structure for streaming graphs in The IEEE High Performance Extreme Computing Conference HPEC  Waltham MA Sep 2012 best paper award  K Lang Finding good nearly balanced cuts in po wer la w graphs  Yahoo Research Tech Rep 2004  S L yubka Mongoose  https://code.google.com/p/mongoose  JSON-RPC W orking Group JSON-RPC 2.0 speciìcation  http://www.jsonrpc.org/speciìcation  RapidJSON  https://code.google.com/p/rapidjson 
882 


            


       


        


             


      


 14   Variable name="Request_ID" kind="linkToIndication" dataType="UINT16" units="none   Variable name="Result" kind="indication" dataType="UINT16" units="none   Enumeration    Option name="No_Error value="1 description Request was successful  are valid   Option name="Failure value="2 description Request could not be fulfilled  Variables returned are invalid   Enumeratio n   Variable   Variable name="Device_ID" kind="ID" dataType="UINT16" units="none    Variable name="RSSI" kind="signalStrength" dataType="UINT16" units="none    Variable name="Battery_Status" kind="batteryLife" dataType="UINT16" units none    Variable name="Architecture" kind="hardwareArchitecture" dataType="UINT08" units="none     Enumeration   Option name="cc2430" value="1" description="The device is a TI cc2430 board   Option name="cc2530" value="2 description="The device is a TI cc2530 board   Enumeration    Variable    Variable name="TIM_Type" kind="nodeType" dataType="UINT08" units="none     Enumeration   Option name="coordinator" value="1" description="The node is a cting as a ZigBee  coordinator   Option name="router" value="2" description="The node is acting as a ZigBee  router     name="end device value="3 description="The node is acting as a ZigBee  end device   Enumeration    Variable   DataReplyMsg   Request   Interface     Interface id="3" name="Thermistor" description="Thermistor service interface   Request   CommandMsg id="1" name="DVS_GET_TEMPERATURE.request   Variable name="Re quest_ID" kind="linkToIndication" dataType="UINT32" units="none   Variable name="Device_ID" kind="ID" dataType="UINT32" units="none   CommandMsg   DataReplyMsg id="1" name="DVS_GET_TEMPERATURE.indication   Variable name="R equest_ID" kind="linkToIndication" dataType="UINT32" units="none   Variable name="Result" kind="indication" dataType="UINT08" units="none   Enumeration   Option name="No_Error value="1 description="Request was successful  are valid   Option name="Failure value="2 description="Request could not be fulfilled  Variables returned are invalid   Enumeration   Variable   Variable name="Temperature kind="tempera ture dataType="FLOAT64 units="F rangeMin="0 rangeMax="100" accuracy="0.10   Variable name="Thermistor_Status" kind="thermistorStateIndication" dataType="UINT08" units="none   Enumeration   Option name="No_Error" value 1" description="The device has detected no errors   Option name="Error" value="2" description="The device has detected an error   Enumeration   Variable   DataReplyMsg   Request   Request   Command Msg id="2" name="DVS_GET_SENSOR_RATE.request   Variable name="Request_ID" kind="linkToIndication" dataType="UINT32" units="none   Variable name="Device_ID" kind="ID" dataType="UINT32" units="none   CommandMsg   DataReplyMs g id="2" name="DVS_GET_SENSOR_RATE.indication   Variable name="Request_ID" kind="linkToIndication" dataType="UINT32" units="none   Variable name="Result" kind="indication" dataType="UINT08" units="none   Enumeration    Option name="No_Error value="1 descr iption="Request was successful  are valid   Option name="Failure value="2 description Request could not be fulfilled  Variables returned are invalid   Enumeration   Variable   Variable name="Sensor_Publish_Rate" kind="duration" dataType="FLOAT64" units="s   DataReplyMsg   Request   Request  


 15   CommandMsg id="3" name="DVS_SET_SENSOR_RATE.request   Variable name="Request_ID kind="linkToIndication" dataType="UINT32" units="none   Variable name="Device_ID" kind="ID" dataType="UINT32" units="none    Variable name="Sensor_Publish_Rate" kind="rateChangeRequest" dataType="FLOAT64" units="s   CommandMsg    DataReplyMsg id="3" name="DVS_SET_SENSOR_RATE.indication   Variable name="Request_ID" kind="linkToIndication" dataType="UINT32" units="none   Variable name="Result" kind="indication" dataType="UINT08" units="none   Enumerat ion   Option name="No_Error value="1 descri ption="Request was successful Variables returned are valid   Option name="Failure value="2 description Request could not be fulfilled  Variables returned are invalid   Enumeration   Variable   Variable name="Sensor_Publish_Rate" kind="duration" dataType="FLOAT64" units="s    Variable name="Sensor_Publish_Rate_Status kind="PublishRateStateIndication dataType="UINT08 units="none   Enumer ation   Option name="Not_Supported value="1 description="The sensor device does not implement this rate   Option name="Rate_Changed value="2 description="The sensor device has updated its publish rate   Enumerat ion   Variable   DataReplyMsg   Request   Notification   DataMsg id="1" msgRate="1" msgArrival="PERIODIC" name="DVS_GET_TEMPERATURE_PERIODIC.indication   Variable name="Temperature kind="temperature dataType="FLOAT64  units="F rangeMin="0 rangeMax="100" accuracy="0.10   Variable name="Thermistor_Status" kind="thermistorStateIndication" dataType="UINT08" units="none   Enumeration   Option name="No_Error" value="1" description="The de vice has detected no errors   Option name="Error" value="2" description="The device has detected an error   Enumeration   Variable   DataMsg   Notification   Interface  xTEDS    


 16  ES   1 a   Gi l s t r a p    Ba l d w i n   S      Fa u l t  T o l e r a n c e  i n  e  Wi r e l e s s  S e n s o r  Ne t wo r k s    I E E E  Ae r o s p a c e   2 0 1 0  P 1 4 8 0 5  2 Al e n a   R  a  F  O s s e n f o r t  J  I nt e l l i ge nt  W i r e l e s s  Se n s o r  N e t w o r k s  f o r  Sp a c e c r a f t  H e a l t h  M o n i t o r i n g    AA  In fo t e c h  C o n fe re n c e  2 0 1 2  3 C om pl e t e  s t a nda r d doc um e nt s  a nd w hi t e  pa pe r s  a r e  av ai l ab l e at  t h e e o r g  w e b  p a g e   e o r g S ta n d a r d s  Zi g B e e Ne t wo r k De v i c e s  Ov e r vi e w  a s px  4 G 133 1 2013  S pa c e  P l ug d Pl a y  A r c h i t e c t u r e  St a n d a r d s  D e v e l o p m e n t G u id e b o o k P u b lis h e d 2 0 1 3  5 P l u g d Pl a y   Pn P  St r u c t u r e s  f o r  Sa t e l l i t e  A p p l i c a t i o n s   ht t p   w w w  a f s bi r s t t r  c om  P ubl i c a t i ons  D oc um e nt s  I nnov n 042309 Sp a c e W o r k s 6 pdf  6 I EEE  ht t p   w w w  ni s t  gov e l  i s d i e e e  i e e e 1451 c f m  7 Z a ck  r ef er en ce U R L   ht t p   v as t  u ccs  ed u  p r o j ect s  t r au m ag p s _ f i l es  d o cs  ch i p co n  Z k f   8 C C 2 530 R e f e r e nc e  U R L   www t i  c o m  l i t  d s  s y m l i n k  cc2 4 3 0 f   9 R ef er en ce A r ch i t ect u r e f o r  S p ace I n f o r m at i o n  Ma n a g e m e n t   C C S D S  3 1 2  0 G 0  Gr e e n  B o o k   M a r c h  2013  0 D DS  r e f e r e n c e  UR L   p o r t a l s  g  dds    1 A AC  M i c r o t e c  r e f e r e n c e  UR L   p p n p a a c m ic r o te c c o m in d e x p h p in tr o d u c tio n to ug d pl a y ht m l  2 D ig i r e f e r e n c e U R L  ht t p   w w w  di gi  c om  pr oduc t s  Zi g B e e   3 P B o o n m a a n d J S u z u k i  T o w ar d  I n t er o p er ab l e Pu b l i s h  Su b s c r i b e  C o m m u n i c a t i o n  b e t w e e n  W i r e l e s s  Se n s o r  N e t w o r k s  a n d  A c c e s s  Ne t wo r k s    I n  Pr o c   o f  IE E E  In t e r n a t i o n a l  W o r k s h o p  o n  In f o r m a t i o n  R e t r i e v a l  i n  Se ns or  N e t w or k s   I R SN  L a s V e g a s N V J a n u a r y 2 0 0 9   B IO G R A P H Y  Ri c h a r d  L   Al e n a  is  a   En g i n e e r  i n  t h e  I n t e l l i g e n t  S y s t e m s  Di v i s i o n  a t  NAS A Am e s   M r   Al e n a  wo r k e d  o n  t h e G r o u n d  D at a Sy s t e m  a n d  p e r f o r m e d  Co m m u n i c a t i o n s  A n a l y s i s  d u r i n g  ope r a t i ons  f or  t he  L C R O S S  L una r  Mi s s i o n  a n d  o n  a v i o n i c s  a n d  s o f t w a r e  a r c h i t e c t u r e s  f o r  Lu n a r  S u r f a c e  S y s t e m s  f o r  h u m a n  m i s s i o n s   H e  w a s  t h e  c o le a d  f o r  th e  A d v a n c e d  D ia g n o s tic  S y s te m s  f o r  I n l Sp a c e  St a t i o n   I SS  Pr o j e c t   d e v e l o p i n g  m o d e l d di a gnos t i c  t ool s  f or  s pa c e  ope r a t i ons   H e  w a s  t he  c hi e f  ar ch i t ect  o f  a f l i g h t  ex p er i m en t  co n d u ct ed  ab o ar d  S h u t t l e an d  M i r  u s i n g  l ap t o p  co m p u t er s   p er s o n al  d i g i t al  as s i s t an t s  an d  s er v er s  i n  a w ir e le s s  n e tw o r k  f o r  th e  I S S  H e  w a s  a ls o  th e  te c h n ic a l le a d  f o r  th e  D a ta b u s  A n a ly s is  T o o l f o r  In t e rn a t i o n a l  S p a c e  S t a t i o n  o n or bi t  di a gnos i s   H e  w a s  gr oup l e a d f or  I nt e l l i ge nt  M obi l e  T e c hnol ogi e s   de ve l opi ng pl a ne t a r y e xpl or a t i on s ys t e m s  f or  f i e l d s i m ul a t i  Al e n a  h o l d s  a n  M  S   i n  E l e c t r i c a l  E n g i n e e r i n g  a n d  Co m p u t e r  S c i e n c e  f r o m  t h e  U n i v e r s i t y  o f  Ca l i f o r n i a   Be r k e l e y   H e  i s  t h e  w i n n e r  o f  t h e  N A S A  S i l v e r  S n o o p y  Awa r d  i n  2 0 0 2   a  NAS A Gr o u p  Ac h i e v e m e n t  Awa r d  i n  1998 f or  hi s  w or k on t he  I S S  P ha s e  1 P r ogr a m T e a m a n d  a  Sp a c e  Fl i g h t  A w a r e n e s s  A w a r d  i n  1 9 9 7    Joh n  O s s e n f or t  is  a C om put e r  S ci en t i s t  an d  em p l o y ee o f     at  N A S A  A m es  R es ear ch  Ce n t e r    cu r r en t l y  w o r k i n g   th e  D is c o v e r y  a n d  S y s te m s  H e a lth  re s e a rc h  a re a  in te g r a tin g  f a u lt ma n a g e me n t  t e c h n ol ogi e s  w i t h ad v an ced  t es t i n g  an d  de m ons t r a t i on of  t he  O r i on M ul t i pur pos e  C r e w  V e hi c l e   I n  th e  p a s t h e  h a s  wo r k e d  i n  n e t wo r k i n g  a n d  s y s t e m s  ad m i n i s t r at i o n  o n  s ev er al  ex p l o r at i o n  p r o j ect s  an d  pa r t i c i pa t e d i n ous  fi e l d  s i m u l a t i o n s   a s s i s t i n g  i n  a l l  p ect s  o f  w i r ed  an d  w i r el es s  n et w o r k  d es i g n   d ep l o y m en t   tr o u b le s h o o tin g  a n d  m a in te n a n c e  J o h n  h a s  a  d u a l B A  de gr e e  i n A nt hr opol ogy a nd E a s t  A s i a n S t udi e s  f r om  Wa s h i n g t o n  U n i v e r s i t y  i n  S t   L o u i s    Th o m  S t o n e  is  a  S e n io r  C o m p u te r  Sc i e n t i s t  w i t h  C o m p u t e r  Sc i e n   h  Ba c h e l o r s  d e g r e e  a t  SU NY  St o n y  B r o o k   Mr   S t o n e  h a s  be e n a t  N A S A  A R C  e m pl oye d by va r i ous  c ont r a c t or s  s i nc e  1989  wo r k i n g  on a dva nc e d ne t w or ki ng  He  wa s  a n  e n g i n e e r  wi t h  t h e  NAS A Sc i e n c e  I n t e r n e t  p r o j e c t  o f f i c e  w h e r e  h e l ed  t h e p r o j ect  t h at  b r  re l i a b l e  In t e rn e t  c o n n e c t i o n s  t o  re m o t e  l o c a t i o n s  i n c l u d i n g  U  S   ba s e s  i n A nt a r c t i c a  i nc l udi ng M c M ur do S t a t i on a nd Am u n d s o n  S c o t t  S o u t h  P o l e  S t a t i o n   He  wa s  p r i n c i p a l  en g i n eer  f o r  co m m u n i cat i o n s  f o r  t h e N A S A  S ear ch  f o r  t er r es t r i al  I n t el l i g en ce  S E T I   p r o j ect  an d  w as  a s en i o r  en g i n eer  f o r  t h e S p ace S t at i o n  B i o l o g i cal  R es ear ch  P r o j ect   Be f o r e  h i s  i n v o l v e m e n t  w i t h  N A S A   S t o n e  w a s  e m p l o y e d  i n  th e  c o m p u te r  a n d  c o m m u n ic a tio n s  in d u s tr y  a n d  ta u g h t te le c o m m u n ic a tio n s a t th e u n d e r g ra d u a t e  l e v e l    


 17  Jar r e n  A   B al d w i n  is  a  Ch i c a g o  n a t i v e  a n d  c u r r e n t l y  se r v e s a s t h e  l e a d  E l e c t r i c a l  En g i n e e r  a t  B a y  A r e a  s t a r t u p   Oc u l e v e  I n c   He  g r a d u a t e d  fr o m  t h e  U n i v e r s i t y  o f Il l i n o i s  wi t h  a  B  S   i n  2 0 0 9  an d  r ecei v ed  an  M  S   i n  El e c t r i c a l  En g i n e e r i n g  f r  St a n f o r d  U n i v e r s i t y  i n  2 0 1 2   Ja r r e n  d e v e l o p e d  h a r d w a r e  a n d  so f t w a r e  sy st e m s f o r  a  w i d e  ra n g e  o f  f i e l d s   i n c l u d i n g  s p a c e  s c i e n c e  s y s t e m s  a n d  m e d i c a l  de vi c e s  a s  a N A S A  A m es  i nt e r n i n t he  In t e l l i g e n t  S y s t e m s     1  2  3   4   5   6   7   8   9   10   11   12   13   


                        


                           


   












































     2 8    b 4      1 8             1 2     1  8 2  


1 9    8      2 1       1     2    8    2 3\f        


     8 D 4 9  F  \b 1 8 #J 9 1     2 1   2 #-@ 1   2 9  E 1   1   2 9      6  


    8  8   1  D 1         1 F  \b0         2 D    F  \b 1 8  9  


  1 9  1   E 1  2 9     1 1 F  \b       1    18   F   1    1 #-$+  \b  2 2  


1 D     1 #-$+.B- 0/:% .0             9 1      18    1 6     1 2  1  1  


1   6      2    1 2 E 8 D 1      1 2   1   1 #-4  #-@E     2  1  1  1       


 8     1          2 F    6   F  2   8    2 C<CC/C N\bO 5      


CD    b$44NO F P Q 6   2 b$$$ ,=\b\bA  A N,O 2 C C  b$$4N  92 2   f  9-\b$$4 B N?O  !-    91  2 1 HH111-18-N+O    -1 :3%   2     0-4 


     b N4O 2   2- \f  C b$@$ \b# >\b\b$3\b$N@O  f :.% 9 /9 \f    1  6  f 2  4   A254 


Advantages of Our M ethod Advantages of Our M ethod Exploit the memory v ertical data format utilizes slidin g windows to g form a much larger database to analyze  Flexibility in Choosing what to choose  Choosing what to choose to build the rules Computational and memory efficiency We have a team working only on this aspect 45 Associative IDS for NextGen Frameworks Dr S Dua LA Tech 45 


Preliminary Results Intra transaction Relations Data rate simulator NH-134 Mb HOP PATH update \(Y/N Inference 11.5 Y Y 2 0.120 N N      Y   n 0.345 N NH134 Y/N   Inf 1 0.150 N N 2 0 120 Y N Inter transaction Relations 2 0  120 Y N       5 5.55 0.456 Y Relations  n 0.345 N N Nmap on DMRL nmap.org 


Anticipated Outcome Anticipated Outcome Develop algorithm capable of learning from a given heterogeneous diverse Develop algorithm capable of learning from a given heterogeneous diverse data ff Dynamic algorithmic f ramework designed to shi f t modalities and sampling rates based on complex logic Flexibility of integration into the Snort intrusion detection system 47 Associative IDS for NextGen Frameworks Dr S Dua LA Tech 47 


References References Aircraft Cockpit Image courtesy USAF http://www.faa.gov htt p   www.faa g ov  air traffic  technolo gy  p g  _ gy  Acharya R Dua S Du X Sree V Chua C K Automated Diagnosis of Glaucoma Using Texture and Higher Order Spectra Features To appear in IEEE Transactions on Information Technology in Biomedicine  Du X Dua S 2011 Cancer Prognosis Using Support Vector Regression in Imaging  Modality World Journal of Clinical Oncology 2  1   44 49 Du X Dua S 2010 Salient Frame Extraction Using Support Vector Regression and Motion Features pp 5 Proc of the National Aerospace and Electronics Conference July 14 16 2010 D M P D S 2010 Di i i ti Ft d Cl ifi ti Mthd f D essaue r  M  P  D ua S  2010  Di scr i m i na ti ve F ea t ures an d Cl ass ifi ca ti on M e th o d s f or Accurate Classification 1st ed vol 7704 pp 14 Bellingham WA Proceedings of SPIE Dessauer M P Dua S 2010 Low Resolution Vehicle Tracking using Dense and Reduced Local Gradient Features Maps 1st ed vol 7694 pp 8 Bellingham WA Proceedings of SPIE SPIE 


Acknowledgements Acknowledgements Fundin g A g encies  US 4 1 Million direct fundin g g g 4 g LA BoR NIH NSF AFRL AFOSR and NASA Research Team Samuel Kasimalla Brandy McKnight Dr Pradeep Chowriappa Connor Johnson Vasanth Nair Mihir Chowriappa  Connor Johnson  Vasanth Nair  Mihir Karnik Mohit Jain and Swadheen Songmen Associative IDS for NextGen Frameworks Dr S Dua LA Tech 49 All the respective Logos belong to their owners 


Rf d Rdi R e f erence d R ea di ngs Copyright of cover pages held by respective publishers 


Thank You Questions Thank You  Questions Dr Sumeet Dua E mail sdua@latech.edu Web http://dmrl.latech.edu Associative IDS for NextGen Frameworks Frameworks Dr S Dua LA Tech 51 Image Source roadtrafficsigns.com 


