Materialized Views in Data Mining Bogdan Czejdo Department of Mathematics and Computer Science Loyola University czejdo@loyno.edu Mikolaj Morzy Marek Wojciechowski Maciej Zakrzewicz Institute of Computing Science Poznan University of Technology f mmorzy,marek,mzakrz g cs.put.poznan.pl Abstract Data mining is an interactive and iterative process It is highly probable that a user will issue a series of similar queries until he or she receives satisfying results Currently available mining algorithms suffer from long process 
ing times depending mainly on the size of the dataset As the pattern discovery takes place mainly in the data warehouse environment such long processing times are unacceptable from the point of view of interactive data mining On the other hand the results of consecutive data mining queries are usually very similar This observation leads to the idea of reusing materialized results of previous data mining queries in order to improve performance of the system In this paper we present the concept of materialized 
data mining views and we show how the results stored in these views can be used to accelerate processing of data mining queries We demonstrate the use of materialized views in the domains of association rules discovery and sequential pattern search 1 Introduction Data mining is a non-trivial process of identifying valid novel potentially useful and ultimately understandable patterns in large volumes of data Data mining systems are evolving from systems dedicated to and specialized in particular tasks or domains to general-purpose systems which 
are tightly coupled with the existing database technology This integration allows for the development of universal data mining environments that constitute a set of knowledge discovery algorithms and a data warehouse Data warehouses form excellent data sources for several mining techniques but require a powerful back-end database engine From a user\222s point of view the execution of a data mining algorithm and the discovery of a set of patterns is an answer to a sophisticated database query A user limits the 
mined dataset e.g by the means of a standard SQL query and determines the values of parameters that control a given algorithm In return the system discovers the patterns and presents them to the user When the process starts the user does not know the exact goal of the exploration Rather he achieves satisfying results in several consecutive steps In each step the user veri\036es the discovered patterns and suitably to his needs expectations and experience modi\036es either the mined dataset or algorithm parameters or both In other words the user discovers interesting and useful re 
sults in a series of runs with the run environment slightly tuned in each run The basic problem in data mining is the processing time of data mining queries Data mining algorithms often equire minutes or hours to answer a simple query On the other hand mining practice shows that the majority of data mining queries are only minor modi\036cations of previous queries Given these circumstances data mining systems should try to exploit the results of previous queries instead of running a complete mining algorithm for each query In this paper we discuss techniques of reusing material 
ized results of previous queries stored in materialized views in the context of frequent itemsets association rules and sequential patterns Materialized views have been thoroughly examined and successfully applied in traditional database management systems We propose to follow this path and introduce materialized views to data mining systems Considering data mining queries 036nding materialized views suitable for answering a given query is dif\036cult Query de\036ning a materialized view can differ from the current query both in algorithm parameters and the mined dataset 
We show when and how materialized views can be used to answer a data mining query guaranteeing correctness of the answer All examples presented in this paper are expressed in MineSQL  a declarative SQL like data mining language 12  Proceedings of the 13th International Workshop on Database and Expert Systems Applications \(DEXA\22202 1529-4188/02 $17.00 \251 2002 IEEE 


2 Basic de\336nitions 2.1 Frequent sets and n rules Let L  l 1 l 2   l m be a set of literals called items  An itemset X is a non-empty set of items  X 022 L  The size of an itemset X is the number of items in X Let D be a set of variable size itemsets where each itemset T in D has a unique identi\036er and is called a transaction We say that a transaction T contains an item x 2 L if x is in T  We say that a transaction T contains an itemset X 022 L if T contains every item in the set X The support of e itemset X is the percentage of transactions in D that contain X  The problem of mining frequent itemsets in D consists in discovering all itemsets whose support is above a userde\036ned support threshold An association rule is an implication of the form X  Y where X 022 L  Y 022 L  X  Y    We call X the body of a rule and Y the head of a rule The support of the e X  Y in D is the support of the itemset X  Y  The con\336dence of e rule X  Y is the percentage of transactions in D containing X that also contain Y The problem of mining association rules in D consists in scovering all association ules whose support and con\036dence are above user-de\036ned um support and minimum con\036dence thresholds 2.2 Sequential patterns Let L  l 1 l 2   l m be a set of literals called items  An itemset is a non-empty set of items A sequence is an ordered list of itemsets and is denoted as X 1 X 2 X n   where X i is an itemset  X i 022 L  X i is called an element of the sequence The size of a sequence is the number of items in the sequence The length of a sequence is the number of elements in the sequence We say that a sequence X  X 1 X 2 X n  is a subsequence of a sequence Y  Y 1 Y 2 Y m  if there st integers i 1  i 2    i n such that X 1 022 Y i 1 X 2 022 Y i 2   X n 022 Y i n  We call Y i 1 Y i 2 Y i n  an occurrence of X in Y  Let D be a set of variable length sequences called datasequences  where for each sequence S  S 1 S 2 S n   a timestamp is associated with each S i  With no time constraints we say that a sequence X is contained in a datasequence S if X is a subsequence of S  We consider the following user-speci\036ed time constraints while looking for occurrences of a given sequence in a given data-sequence minimal and maximal gap allowed between consecutive elements of an occurrence of the sequence called min-gap and max-gap  and time window that allows a group of consecutive elements of a data-sequence to be merged and treated as a single element as long as their timestamps are within the user-speci\036ed window-size  The support of a sequence X 1 X 2 X n  in D is the fraction of data-sequences in D that contain the sequence A sequential pattern is a sequence whose support in D is above the user-speci\036ed minimum support threshold 2.3 Related work The work on materialized views started in the 80s The basic concept was to use materialized views as a tool to speed up queries and serve older copies of data Multiple algorithms for view maintenance were developed    The problem of association rule discovery was introduced in In t h e p aper  d i s co v e ry of frequent i t e ms et s was identi\036ed as the key step in association rule mining In 2 t h e a ut hors p ropos ed an ef 036 c i e nt frequent i t e ms et di s covery algorithm called Apriori that became the basis for many her mining algorithms The idea of sequential pattern discovery was 036rst presented in 3 In 4 t i m e c ons t r ai nt s w ere i ncorporat ed into the problem and a sequential pattern discovery algorithm called GSP was introduced Incremental mining was 036rst discussed in 7 in th e c o n text of association rules A novel algorithm called FUP was proposed to ef\036ciently discover frequent itemsets in an incremented dataset exploiting previously discovered frequent itemsets Incremental mining was also analyzed in the context of sequential patterns e.g 14 The notion of interactive and iterative knowledge discovery 036rst appeared in 13  T he aut hors pos t u l a t e d t o c reate a knowledge cache that would keep recently discovered frequent itemsets along with their support value Besides presenting the notion of knowledge cache the authors introduced several maintenance techniques for such cache and discussed using the cache contents when answering new frequent set queries To facilitate interactive and iterative sequential pattern discovery 14 propos ed t o mat e ri al i z e p at terns discovered with the least restrictive selection criteria and answer incoming queries by 036ltering the materialized pattern collection The concept of Knowledge and Data Management Systems was 036rst introduced in In t h e opi ni on of t h e a uthors KDMSs should replace contemporary database management systems by integrating data and knowledge related activities in one central place The authors also de\036ned the notion of a data mining query and suppressed the need to tightly integrate knowledge discovery systems with the existing database and data warehouse infrastructure to provide a framework for advanced applications Proceedings of the 13th International Workshop on Database and Expert Systems Applications \(DEXA\22202 1529-4188/02 $17.00 \251 2002 IEEE 


3 Data mining queries 3.1 Queries Several declarative data mining query languages have been proposed so far 6    S uch l anguages can be used to separate user applications from data mining algorithms In this paper we use a multipurpose data mining query language called MineSQL 12 t o formul at e e xample queries MineSQL employs the concept of data mining queries to express data mining tasks MineSQL syntax mimics that of standard SQL and allows for tight and seamless integration of data mining queries with traditional database queries MineSQL currently allows to issue commands that discover frequent itemsets association rules and sequential patterns MineSQL de\036nes a set of additional data types e.g SET SEQUENCE RULE as well as a set of operators and functions for those data types e.g CONTAINS BODY\(x HEAD\(x SIZE\(x LENGTH\(x The following data mining query discovers all frequent itemsets with support higher than 20 and containing an item milk Mining takes place in the part of the database that contains transactional data for the 4th quarter of 2001 MINE ITEMSET FROM SELECT SET\(PURCHASED ITEM FROM PURCHASES WHERE DATE OF PURCHASE  22201.10.2001\222 AND DATE OF PURCHASE  22231.12.2001\222 GROUP BY TRANSACTION ID WHERE SUPPORT\(ITEMSET  0.2 AND ITEMSET CONTAINS TO SET\(\222milk\222 Two classes of constraints can be seen in the above example tabase constraints are placed within WHERE clause in the SELECT subquery Database constraints de\036ne the source dataset i.e the subset of the original database in which data mining is performed Mining constraints are placed within the WHERE clause in the MINE statement Mining constraints de\036ne the conditions that must be met by discovered patterns 3.2 Relationships between results of data mining queries In 5 t hree relations hips which o ccur b etween tw o d ata mining queries Q 1 and Q 2 have been identi\036ed Two data mining queries are equivalent if for all datasets they both return the same set of patterns and the values of statistical signi\036cance measures e.g support for each pattern are the same in both cases A data mining query Q 1 includes a data mining query Q 2 if for all datasets each pattern in the results of Q 2 is also returned by Q 1 with the same values of the statistical signi\036cance measures A data mining query Q 1 dominates adataminingquery Q 2 if for all datasets each pattern in the results of Q 2 is also returned by Q 1  and for each pattern returned by both queries its values of the statistical signi\036cance measures evaluated by Q 1 are not less than is case of Q 2  Relationships described above occur between the results of data mining queries and can be used to identify the situations in which a query Q 1 can be ef\036ciently answered using the materialized results of another query Q 2  Those relationships are general in nature and can be applied to various types of patterns frequent sets association rules sequential patterns and various constraint models General idea of using materialized query results is the following If for a given query results of a query equivalent to it including it or dominating it are available the query can be answered without running a costly mining algorithm In case of equivalence no processing is required since the queries have the same results In case of inclusion one scan of the materialized query results is necessary to 036lter out patterns that do not satisfy constraints of the included query n case of dominance one scan of the source dataset is necessary to evaluate the statistical signi\036cance of materialized patterns 036ltering out the patterns that do not satisfy constraints of the dominated query is also required 3.3 Data mining views Traditional views are used mainly to hide dif\036cult query structures from a user Views also provide independence of applications from the schema changes occurring in the database All changes must be re\037ected only in the de\036nition of the view and no modi\036cation is required in end-user applications Every access to the view triggers the execution of the query that de\036nes the view Data mining is an interactive and iterative process and data mining queries tend to be fairly complicated Data mining views hide the complexity of the algorithm from an application and simplify access to discovered patterns The notion of a data mining view was introduced in 11  The following MineSQL statement creates a data mining view V SEQ PATS  The view presents sequential patterns discovered in the CUST TRANSACTIONS table having the support exceeding 0.2 using the following time constraints max-gap of 100 min-gap of 1 and no window-size the default value of 0 is used CREATE VIEW V SEQ PATS AS MINE PATTERN MAXGAP 100 MINGAP 1 FROM SELECT SEQUENCE\(T TIME ITEM FROM CUST TRANSACTIONS GROUP BY C ID WHERE SUPPORT\(PATTERN Data mining views provide additional independency layer between the database and the end-user application Slight modi\036cations of algorithm parameters or explored Proceedings of the 13th International Workshop on Database and Expert Systems Applications \(DEXA\22202 1529-4188/02 $17.00 \251 2002 IEEE 


dataset are re\037ected only in the view de\036nition whilst the application does not notice any changes Besides the user is separated from the technical details of the algorithm and can perform repetitive data mining tasks without knowing the details of syntax of the MINE statement As with traditional views every access to the data mining view triggers the execution of the underlying algorithm The algorithms for pattern discovery are usually timeconsuming Processing e of a data mining query could easily become unacceptable from the point of interactive mining The solution to this problem is materialization of previously obtained results of data mining queries A materialized data mining view is a database object storing the results of a data mining query frequent sets association rules sequential patterns With every materialized view a time period can be associated after which the view is automatically refreshed The following statement creates the materialized data mining view MV SEQ PATS  The view is to be refreshed automatically once a week CREATE MATERIALIZED VIEW MV SEQ PATS REFRESH 7 AS MINE PATTERN MAXGAP 100 MINGAP 1 FROM SELECT SEQUENCE\(T TIME ITEM FROM CUST TRANSACTIONS GROUP BY C ID WHERE SUPPORT\(PATTERN Materialized data mining views can be refreshed either automatically or on user\222s demand In most cases such refresh can be performed by one of the incremental mining algorithms instead of running the complete discovery algorithm Additional advantage of materialized views is the fact that data mining usually takes place in a data warehouse where changes to base relations and thus to the stored patterns do not happen continually over time but are accumulated and loaded to the data warehouse during data warehouse refresh process The patterns discovered and stored in the materialized view remain valid for a long period of time until next data warehouse refresh Validation of patterns can be postponed until next warehouse refresh event 4 Using materialized data mining views in data mining query execution In many cases contents of the materialized view can be used to answer a query that is similar to the query de\036ning the view For example if the query de\036ning the view Q v includes a given query Q then the latter can be answered by simply reading the contents of the view and pruning those patterns that do not meet the conditions formulated in Q  The key issue is identi\036cation of syntactic differences leading to situations in which one query can be ef\036ciently answered using the results of another query In our analysis we consider only materialized views containing frequent sets and sequential patterns Even if the 036nal goal is discovery of association rules we propose to materialize frequent sets for two reasons As it was also observed by other researchers generation of rules from itemsets is straightforward 1  a n d m a ter i alized item s ets can b e used to answer more itemset and rule queries 13  4.1 Frequent sets Given two queries Q 1 and Q 2 we say that Q 2 extends database constraints of Q 1 if syntactic differences between the queries imply that the source dataset or Q 2 will always be a subset of the source dataset for Q 1  We say that Q 2 extends mining constraints of Q 1 if for an arbitrary collection of patterns 036ltering it according to the outer WHERE clause of Q 2 will lead to a subset of the results of 036ltering it according to the outer WHERE clause of Q 1  Depending on circumstances given the query Q and the results of the query Q v stored in a materialized view several mining methods are available Incremental mining refers to the situation when one of the incremental discovery algorithms is executed on extended dataset This method is used when the query Q v extends database constraints of Q  Another possibility is complementary mining This method can be utilized when the query Q v extends mining constraints of Q all patterns available in the view will be present in the answer to the query In this case there is no need to compute the support of some patterns because it can be read from the materialized view Verifying mining is possible when Q extends pattern constraints of Q v and has the same database constraints this case corresponds to the inclusion relationship from  The method consists in reading materialized view and pruning away those patterns that do not satisfy extended mining constraints of Q  Finally full mining refers to running a complete data mining algorithm that does not exploit results of previous queries This method has to be applied when for a given query materialized views supporting incremental complementary or verifying mining are not available Let us consider the following example We are given the following de\036nition of a materialized data mining view Q v  MINE ITEMSET FROM SELECT SET\(PURCHASED ITEM FROM PURCHASES GROUP BY TRANSACTION ID HAVING COUNT  5 WHERE SUPPORT\(ITEMSET  0.3 and the following data mining query Q  MINE ITEMSET FROM SELECT SET\(PURCHASED ITEM Proceedings of the 13th International Workshop on Database and Expert Systems Applications \(DEXA\22202 1529-4188/02 $17.00 \251 2002 IEEE 


FROM PURCHASES GROUP BY TRANSACTION ID WHERE SUPPORT\(ITEMSET  0.5 The query Q extends mining constraints of Q v by setting a higher value of minimum support On the other hand the query Q v extends database constraints of Q by adding the HAVING clause To answer Q using the contents of Q v the following steps need to be taken First verifying mining is performed to prune patterns with support not exceeding 0.5 Next incremental mining is performed on the part of the database consisting of transactions shorter than 5 items 4.2 Sequential patterns Similarly to frequent itemset discovery materialized views can be successfully utilized in sequential pattern search Apart from the mining and database constraints in sequential pattern discovery time constraints are also present in data mining queries These time constraints are min-gap  max-gap and window-size  The relationships of extending mining and database constraints de\036ned in the previous section carry over to sequential patterns Additionally we say that Q 2 extends time constraints of Q 1 if it tightens at least one of the time parameters without relaxing any emaining parameters All the query processing techniques involving materialized views incremental mining complementary mining and verifying mining are also valid for sequential patterns provided that the current query Q and the query Q v de\036ning a materialized view have the same time constraints If Q v extends time constraints of Q full mining has to be performed On the other hand if Q extends time constraints of Q v with the same mining and database constraints Q can be answered by re-evaluating the support of patterns returned by Q v using the time constraints of Q and pruning the patterns not satisfying the minimum support threshold of Q this case corresponds to dominance relationship from 5   Th is tech n i q u e can b e u s ed as th e i n itial s tep b ef o r e incremental complementary and verifying mining if differences in mining and database constraints suggest a given method and additionally Q extends time constraints of Q v  5 Conclusions We have addressed the problem of employing materialized data mining views to optimize data mining queries in large data warehouses Materialized data mining views are physical data warehouse structures created explicitly or implicitly used to store precomputed results of selected data mining queries We showed that in some situations a new data mining query can be mapped to an existing materialized data mining view and it can be answered without the need to run a complete data mining algorithm We classi\036ed mining methods exploiting materialized results of previous data mining queries and identi\036ed situations in which those methods are applicable in the context of two main data mining techniques frequent itemset discovery and sequential pattern discovery In practical data mining systems a cost-based query optimizer should be responsible for using the described methods for seamless rewriting of users\222 queries to shorten their execution time Designing such a data mining query optimizer is one of our future research goals References 1 R  A g r a w a l  T  I mie lin sk i A Sw a m i M i n i n g a sso c i a tio n rules between sets of items in large databases In Proc of the 1993 ACM SIGMOD Conference  1993 2 R  A gr a w al  R  S r i kant  F ast A l gor i t h ms f o r M i n i n g A ssoci ation es In Proc of the 20th VLDB Conference  1994 3 R  A gr a w al  R  S r i kant  M i n i n g S equent i a l P at t e r n s I n Proc of the 11th ICDE Conference  1995 4 R  A gr a w al  R  S r i kant  M i n i n g S equent i a l P at t e r n s G e ner alizations and Performance Improvements In Proc of the 5th EDBT Conference  1996 5 E  B a r a lis G  P sa ila  I n c re me n t a l re 036n e m e n t o f m in in g queries In Proc of the 1st DaWaK Conference  1999 6 S  C e r i R M e o  G Psa ila  A Ne w S QL-lik e O p e ra to r f o r Mining Association Rules In Proc of the 22nd VLDB Conference  1996 7 D  W  L  C h eung J H a n V  N g  a nd C  Y  W ong Mai n t e nance of discovered association rules in large databases An incremental updating technique In Proc of the 12th ICDE Conference  1996  A  G upt a I S  Mumi ck M ai nt enance of Mat e ri al i zed V i e w s Problems Techniques and Applications IEEE Data neering Bulletin Special Issue on Materilaized Views and Data Warehousing  18\(2 1995 9 T  I mie lin sk i H M a n n ila  A Da ta b a se Pe rsp e c t i v e o n K n o wledge Discovery Communications of the ACM  39\(11 1996  T  I m i e l i n ski  A  V i r m ani  A  A bdul ghani  D at ami n e A p plication programming interface and query language for data mining In Proc of the 2nd KDD Conference  1996  T  Morzy  M W o j c i echo w ski  M Z a krze wi cz Mat e ri al i zed Data Mining Views In Proc of the the 4th PKDD Conference  2000  T  Mor z y  M W o j c i echo w ski  M Z a kr ze w i cz D a t a Mi ni ng Support in Database Management Systems In Proc of the 2nd DaWaK Conference  2000 13 B Na g  P  De sh p a n d e  D  J  D e W itt Usin g a Kn o w le d g e Cache for Interactive Discovery of Association Rules In Proc of the 5th KDD Conference  1999  S  Par t hasar a t h y  M J Z a ki  M  O gi har a  S  D w a r k adas I ncremental and interactive sequence mining In Proc of the 1999 ACM CIKM Conference  1999  N  R oussopoul os M at er i a l i zed V i e w s a nd D a t a W a r e houses SIGMOD Record  27\(1 1998 Proceedings of the 13th International Workshop on Database and Expert Systems Applications \(DEXA\22202 1529-4188/02 $17.00 \251 2002 IEEE 


The associativity holds true when a and 7 do not have Inner-patterns of classes C and B respectively. Otherwise, the associativity does not hold For example if Walbl,bl Be\(blcl and y=\(d and A shown in Figure 7 is the Qmam of the algebra then a CR\(AB B R\(CP aibibi~i.bi~2.czdi a R\(AB 8 R\(CP   2\A-Complement I The A-Complement operator is a binary operator which concatenates the pattems of two operand association-sets over Complement-pattems It is used to identify the object instances in two classes which are not associated with each other in A of Figure 7 The A-Complement operator is defined as follows a I R\(A,B B  t 7 I f+a'.BJ.amb ax R\(AB A a,\200 a'Ab BJ or  3 m amEa A H V n b,EB or f=B  3 n bnE B A e V am\200 a 1 The result of an A-Complement operation is an association-set Each of its patterns is formed by concatenat ing two patterns \(one from each operand association-set via a Complement-pattem ax where a and b be to a and c respectively, and the Complement-pattem a,b is in A In the special case when a\(or B is an empty association-set or does not have Inner-pattems of A\(or B then all pattems of B<or a that have Inner-patterns of A\(or B are retained in the resulting association-set An example of the A-Complement operation is shown in Figure 8b It operates over the association between classes B and C a does not appear in the resultant association-set because it contains no Inner attems of B a cannot be A Com lemented with B and 8 because it is connected with and i2 by Inter-pattems blcl and blcl in a respectively P a B Y b FFb IP\(B.C ci@---edl C2 U 62 si e  e  e 4 dl a4 b3 52 az e C3 a4 b3 c3 e a4  b3 Figure 8b Example of A-Complement Operation Under the same conditions as given in the Associate operator R\(A,B need not be specified with the A Complement operator unless there is an ambiguity The A Complement operator is commutative and associative For the similar reason described for the Associate operator, the associ ativity holds true conditionally a I R\(A,B B  B I R\(BA a commutativity a,x I R\(A,B Ply I R\(C.D 7\(z associativity  a\(x I R\(AB Ply I R\(CP Y\(Z if cetx A BWI 3 A-Select 6 The A-Select is a unary operator which operates on the association-set a to produce a subset of pattems that satisfy a specified predicate P A pattem in the operand association-set is retained iff the predicate is evaluated true for that pattern o\(a   1 7 I 9  a1  P\(a  where a is defined by an algebraic expression and P  TlelT202   T Each term Tl\(i=1,2  a is a comparison between two expressions and i=1,2  a-1 is a Boolean operator  or v  P\(a represents that a pat tern is evaluated true for that predicate The expressions on the left and right-hand sides of a comparison operation may contain constants functions and/or operations on object instances but cannot both be constants The comparison tenns are type sensitive i.e the results of the two expressions in a term must be data of the same type for primitiveclasses or both IIDs for nonprimitiveclasses I and  are the legitimate comparisons for numerical types  and  for character string and m c,z and  for set types The comparison OK is performed by comparing their ODD portions since m>s are the concatenation of the class identifiers and Oms A single valued object or a single III can be treated either as its own data type in numerical, string or JJD comparison or as a set type containing one element in set comparison As an example of A-Select we assume that there are two associated classes S for stack and Q for queue To select associated stack and queue object pairs in which the object on the top of the stack is located in the front or the tail of the queue, the algebraic expression can be written as o\(S*Q a set-union operation For the top equals the front and the bottom equals the tail we have o\(S*Q  top\(S Q r bottom\(S  Q 4 A-Project n Similar to the projection operation in the relational alge bra an A-Project operation projects a given pattem over some subpattem s However in relational algebra, the relationship among the projected attributes is not important Whereas in A-algebra the associations among the projected subpattems must be maintained so that the associations among the object instances in these subpattems will be retained The A-Project operator is defined as follows Wa TI where a is an association-set defined by an A-algebra expres sion wel eh     e is a set of expressions which specify subpattems to be projected; and T=\(tlrt2    t is a set of ordered sets of classes. Each ordered set tl defines a path for connecting two projected subpatterns specified by the E expressions It contains a minimal number of classes along the path which can uniquely identify that path The result of an A-Project is an association-set which contains object association pattems corresponding to the pro jected subexpressions specified in E Each pair of subpattems is connected by either a D-inter-pattern or a Dcomplement pattem depending on whether the path connecting these two subpattems contains all Inter-patterns or not The function of D-inter-pattem and Derived-complement-pattern is to retain the original associations among object instances before the projec tion operation Figure 8c shows an example of A-Project from a pattern a over A*B and D For al the subpattems a,b and d satisfy A*B and D respectively. Therefore they are kept in the result Accordingto the path specification a D Complement-pattern bydl is a to the result thus y'==\(albl dl bid  i.e albl bid  is produced for the same reason Since a does not have a subpattem satisfy ing A*B only \(d3 is retained Figure Bc Example of A-Project Operation 28 


5 NonAssociate  The NonAssociate operator is a binary operator used to identify the association pattems in one operand association-set that are not associated over a specilied association with any pattem in the other association-set and vise versa based on the pattems in A The NonAssociate operator is defined as follows The result of a NonAssociation operation is an association-set Each of its pattems is formed by concatenat ing two pattems a and via a Complement-pattem a,bn under the condition that a is not associated with any and vice versa Furthermore, in the special case where the pattems of a\(or  have Inner-pattems of A\(or B and cannot be con catenated with any pattems of B\(or a then these pattems of Mor B will be retained in the result if one of the following three conditions holds 1 P\(or a is an empty association-set 2 all pattems of mor a do not have Inner-pattems of B\(or A or 3 all pattems of mor a that have Inner attems of B\(or A can be concatenated with pattems of Mor 8 An example of the NonAssociate operation is shown in Figure 8d In the example a and P are dropped due to the existence of blcz in Figure 7 a2 is dro ped because it does not contain an Inner-pattem of class B 8 is dropped because it does not contain an Inner-pattem of class C 7 is in the resultant association-set because b2 is not associated with c in a shown in Fi ure 7 and none other pattem in a is associ ated with cq  exists because b2 is not associated with c3 in a 4 a Y Figure 8d Example of NonAssoclate Operation Note that the NonAssociate operator produces a resultant association-set which is a subset of that produced by the A Complement operator NonAssociate is not a primitive opera tor since it can be expressed by other operators However it is very useful for query formulation and is therefore included in the set of A-algebra operators Under the same conditions as given in the Associate operator R\(A,B need not be specified unless there is an ambiguity The NonAssociate operator is commutative but not associative a  R\(A,B P  B  R\(B.A a commutativity 6 A-Intersect 0 The A-Intersect operation is convenient for constructing a pattem with a branch a lattice or a network structure since a pattem in such a structure can be viewed as the intersection of two pattems Conceptually the A-Intersect operator is equivalent to the JOIN operator in the relational algebra It operates on two operand association-sets over a set of specilied classes Two pattems one from each association-set are combined into one if they contain the same set of Inner pattems for each specified class 29 qx 4Wl P,Y   y I r  a'.B V CLnE WI Y ECLn,a EBI AV CL,\200 IWI tf ECLn,P Ea I Figure 8e shows an example of the A-Intersect operation over classes B and C The resultant association-set contains four attems which are the intersection of a'np a1nS2 a and aznP2 respectively since they all have Inner pattems b and cz Other pattems a3 a P3 8 fail to produce new pattems because they either have no Inner-pattem in both classes B and C or have no common Inner-pattem of class C a B I e   CCI g:q   Tl 2 dl c  a1 bl cZ 63 Figure 8e Example of A-Intersect Operation The set of classes W can be omitted when the A Intersect operation is performed on all the common classes of its operands i.e  W X  Y 1 is implied Since a network structured pattem can be transformed into a set of other simple pattems an A-Intersect operation for building a complex pattem can be replaced by an Associate operation followed by an A-Select operation The A-Intersect operator is commutative conditionally associative and idempo tent ao\(W P=Po{W a commutativity associativity alx dW1 I Ply 4Wz 712 if Wit-\(W~l ZI A\(\(WzI-\(WiI XI aoa=a idempotency if a is a homogeneous association-set  alx W t Ply 4w21 7IZl The associativity is not always true because there are cases in which a pattem of P that fails to intersect with any pattems of y may succeed by first intersecting with a pattem of a in the operation 4 W1 1 and then intersecting with a pat tem of y in the operation 4 W2 Now we define three set operators which are different from the corresponding set operators in relational algebra since they operate on heterogeneous structures rather than union-compatible relations 7 A-Union Similar to the UNION operation of the relational alge bra A-Union combines two association-sets into one How ever these two association-sets may contain heterogeneous association structures It is important for A-algebra to be able to operate on heterogeneous structures because some prior operations may produce heterogeneous association-sets and may need to be further processed over the object instances of a common class against other pattems of associations Unlike the relational algebra and other 0-0 query languages union compatibility is not a restriction in A-algebra For this reason A-algebra has more expressive power Any query thaf can be expressed by a single expression in other languages cm be expressed as a single A-algebra expression but not vise versa The A-Union operation is defined as follows 


a+B 71 YE~VY~EB 1 The A-Union operator is commutative idempotent a+fl=p+a a  B  7  Q  B  7 a+a=a 8 A-Difference  associative and commutativity associativity idempotenc y  The A-Difference implements the same concept as the DIFFERENCE operator in relational algebra but with two differences First its operands do not have to be union compatible Secondly a pattem in the minuend is retained if it does not contain any of the pattems in the subtrahend The example depicted in Figure 8f shows that a and a3 are dropped since they both contain p a B 1 Figure Bf Example of A-Difference Operation 9 A-Divide  The A-Divide operator implements the concept that a group of pattems with certain common features contains another set of pattems a+lwlB rI?=s t WB'EG where a is a subset of pattems of a which have common Inner-pattems for all classes of  W If  W 1 is not specified the A-Divide operation retains all the pattems of a each of which contain at least one pattem of g and they together con tain all pattems of B Figure 8g shows an example of a being divided by B with respect to class B The A-Divide operation retains a a2 and a since they all contain Inner-pattem b of B and together contain all pattems of p U B 7  2 Figure 89 Example of A-Divide Operation 3.3.3 Precedence  The precedence relationships of the above operators are as follows Unary operators have higher precedence than binary operators The precedence of the seven binary associa tion operators is given in the following order I 1  0   and  Parentheses can be used to alter the precedence rela tionships  3.3.4 Querv Examples We have formally defined nine association operators and given their simple mathematical properties Before exploring other properties we give some examples to illustrate how these operators are used to express queries for processing an 0-0 database There can be many alternative expressions for the same query Choosing the best one for execution is the task of a query optimizer The mathematical properties of these operators can be used for that purpose It is straightfoxward to write an algebraic expression for a subgraph with a linear stmcture The expression for Query 1 given in Section 2 can be fomiulated as follows by navigat ing the schema graph Figure 1 from class TA up to class SS ll\(TA*GRAD*Student*Person*SS  Shown below is the expression for Query 2 Section 2 The expression for this query can be easily constructed by specifymg the a expression \(defining the operand association set of A-Project first and then attaching the E T clause ll o\(Name  Section Teacher*Faculty*Spciality+Section*\(Student*GPA.Student Earned Credit Section,,Specialty,GPA,Eamed Credit Section:!$xialty,Sec tion:GPA,Section To write this expression the user may first trace the Schema Graph to specify a graph as shown in Figure 3 Then label each edge of the graph with an operator  1 or  depending on the semantics of the query For this query every edge is labeled by an  Since the query does not require that Student and Teacher relate to the same Section of a Course the two branches should be A-Unioned for further processme The A-Select operation ensures that only the 7Is department is under consideration The result of this expres sion will contain two types of pattems Section-Specialty and GPASection-Earned Credit as specifies by the E TI clause of the A-Project%peration Note that this query cannot be phrased in a single relational algebraic expression since the union of heterogeneous structures is involved Some other query examples are given below Their corresponding pattems are depicted in Figure 9 The interpre tations of these queries are left to the reader Query 3 List the names of students who teach in the same departments as their major departments n\(Student*Person*Name8tudent*~p~ent Student*Grad*TA*Teacher*Department mame Query 4 List the section of those sections which have not been assigned a mm or a teacher ll\(Section#*\(Section!Room#+Section!Teacher  Query 5 List the names of students who take courses 6010 and 6020 ll\(Name*Person*S tudent*Enrollment*Course*Course ptudat O\(Course or  Again we stress that the above association pattem expressions represent the intemal algebraic operations that need to be performed if the dynamic inheritance mothod is used The highlevel query statements that the user uses can be much simpler due to the inheritance of attributes in the gen eralization hierarchy or lattice Query 4 Teacher Ouery 3 My pe;m"sEynl  section A H d R Te?&er Grad TA  13 Course#-6010 Query 5 Enrollmen1 Courrs Figure 9 Patterns for Query 3 4 5 30 1 


4 Additional Properties of the Operators In Section 3.3 we have shown some properties of the individual operators Many other properties have been stu died These properties are important for query decomposition and query optimization Due to space limitation we shall only give the distributivity properties of some operators with respect to other operators a distributive property of  with respect to  a R\(A.B B  y  a R\(A,B P  a IR\(A,B y a 1 R\(A.B B  y  a 1 R\(A,B B  a I R\(A,B 7 a4X P+r B+aolXly b distributive property of 1 with respect to  c distributive property of 0 with respect to   These three properties hold true for the same reasons First the A-Union operation simply lumps together pattems of two association-sets without modifying them Second for operation  1 or 0 the decision whether a new pattem is pro duced or not is determined only based on the structure of the two pattems being operated on and is independent of the other pattems in the operand association-sets d distributive property of  with respect to E XI R\(CLI.CLZ Ply 4Wl Y{Z  alx R\(CLI,CLdl Ply 4WuXl qx R\(CLI,CLZ ylz aIx I R\(CL,,CLdI Ply 4Wl ylzt e distributive property of I with respect to E  six I R\(CLi,CLdI P,y 4WuXJ a I R\(CLi.CLz Y~Z f distributive property of  with respect to 0 alxt IR\(CL,.CLJI Yt 4W Y\(zJ  alxt R\(CLI,CLZ Ply 4WuXl alx R\(CLI.CLdI ylzt Distributive properties d e and f hold true under the following three conditions i CL,EW and ii XnY=XnZ=+.and iii a is a homogeneous association-set The first condition ensures that the  I and  operations are performed on the intersection of  and  othenvise it does not make sense to have an operation between a and 7 The second condition states that patterns of a are non overlapping with pattems of P and 7 The third condition states that on the right-hand side of the expression only the pattems having the same pattems of a as their subpattems will succeed in the A-Intersect operation The above mathematical properties are the basis for query optimization since they provide ways for transforming a query expression into alternative expressions which produce the same result but with different performances For example the associativity holds true for the two Associate operations in the expression A  B  C Thus either order of evaluation will produce the same result Similar to the optimization of consecutive JOIN operations in relational databases the order of their execution should depend on their selectivities similar to the selectivity of a JOIN operation As a second example, the following expression defines a complex pattem as shown in Figure loa expr  A  B*E*F  B  C*D*H 0 C*C By applying the distributivity of the operators it can be writ ten as below expr  A  B*E*F  B*C*D*H 0 B*C*G  A*B*E*F  A*\(B*C*D*H 0 B*C*G  A*B*E*F  A*B*C*D*H A*B*C*G The final expression and the intermediate expressions are the altematives for evaluation Among them the final expression is particularly suitable for a parallel system since it is an A Union of two sub-expressions each of which can be evaluated independently and produces a homogeneous association-set with simpler structure see Figure lob Its processing will be more efficient than the processing over heterogeneous association-set The second subexpression can be further optimized using other properties of its operators ABEF  EF a b Figure 10 Example of Query Optimization 5 Conclusion The mathematical foundation of the relational model namely the relational algebra and the relational calculus has contributed to the success and popularity of the relational model and relational database management systems Although the recently introduced 0-0 DBMSs and their underlying models exhibit several desirable features that are suitable for modeling and processing complex objects found in more advanced database applications they still do not have a solid mathematical foundation Such a foundation is imponant for the efficient manipulation of 0-0 databases and for the design of high-level query languages to ease the user's task in access ing and manipulating 0-0 databases In this paper we have presented an algebra for 0-0 database processing In this algebra objects object instances and their associations in an 0-0 database are uniformly represented by association pattems Nine algebraic operators have been introduced for manipulating pattems of heterogene ous and homogeneous structures The result of performing an A-algebra expression is an association-set The closure pro peq of the algebra allows the result of an algebraic expres sion to be further processed by the algebra Several mathematical properties of the A-algebra opera tors have been described The A-algebra is complete in the sense that all possible subdatabases that are derivable from an 0-0 database can be expressed in terms of A-algebra expres sions The proof of completeness is done by induction on the number of classes in SG More mathematical properties their proofs and the completeness issue are presented in a forth coming paper SUW ALA89a ALA89b REFERENCES Alashqur A.M A,Query Model and Query and Knowledge Definition Languages for Object oriented Databases doctoral dissertation Univer sity of Florida 1989 Alashqur A.M Su S.Y.W and Lam H 0.QL A Query Language for Manipulating Object oriented Databases Proceedings of the 5th Intl Conference on VLDB Amsterdam The Nether lands 1989, pp 433-442 31 


BAT841 CAR881 I COD701 COD721 COL891 871 LAM89 J LEC88 MAC851 W861 Alashqur A.M Su S.Y.W and Lam H A Rule-based Language for Deductive Object Oriented Databases Proceedings of the 6th Inter national Conference on Data Engineering Los Angeles CA Feb 5-9 1990 Bancilhon F et al FAD a Powerful and Si ple Database Language Proceedings of the 13th VLDB Conference Brighton 1987 Banerjee J et al Queries in 8ject-oriented Databases Proceedings of the 4th Intl Confer ence on Data Encrineerine Los Angeles CA  97-105 I I  1988 pp 31-38 Batory D.S and Buchmann A.P Molecular Obiects Abstract Abstract Data Tvws and Data M6deIsi A Framework Proceedings Intl Confer ence on VLDB 1984, pp 172-184 Carey M J et al A Data Model and Query Language for EXODUS ACM-SIGMOD Confer ence 1988, pp. 413-423 Chuang H S Operational Role Processing in a Prototype OSAM KBMS Master's thesis University of Florida 1990 Codd E A Relational Model of Data for Large Shared Data Bank CACM Vol 13 No 6 1970 pp 377-387 Codd E R:lational Completeness of Database Sublanguages in Data Base Systems Rustin R ed Prentice-Hall Inc Englewook Cliffs NJ Colby L S A Recursive Algebra and Query Optimization for Nested Relations ACM SIGMOD Conference 1989 pp 273-283 Fishman D H et al Iris An Object-Oriented Database Management System ACM Transaction on Office Infomation Systems 51 1987 pp49 69 Goldberg A Introducing the Smalltalk-80 Sys tem Byte Aug 1981. pp.14-26 Hammer M and Mcleod D Database Descrip tion with SDM A Semantic Association Model Kim W et al Composite Object Support in an Object-oriented Database System Proceedings of King R Sembase A Semantic DBMS the Proceedings of the First Intemational Workshop on Expert Database Systems Oct 1984, pp.151 171 Lam H et al Prototype Implementation of an Object-oriented Knowledge Base Management System Proceedings of PROCIEM 89 Orlando Lecluse C Richard P and Velez F 02 an Object-Oriented Data Model ACM-SIGMOD Conference 1988, pp 425-433 MacGregor R ARTEL--A Semantic Front-End to Relational DBMSs Proceedings of VLDB 85 Atlanta GA April 1988 Maier D et al Development of an Object oriented DBMS Proc of OOPSLA 86 Confer ence Sept 29  Oct 2 Portland Oregon pp 472-482 1971 pp.65-98 ACM TODS Vol 6 NO 3 1981 pp 351-368 OOPSLA, Oct 4-8 1987 FL pp 118-125 FL NOV 13-15, 1989 SU86 SUSS SU89 ZD087 Manola F and Dayal U PDM An Object Oriented Model Int'l Workshop On Object Oriented Database Systems 1986, pp 18-25 Pant S An Intelligent Schema Design Tool for OsAM Master's thesis University of Florida 1990 Rowe L A and Stonebraker M R The POSTGRES Data Model Proceedings of the 13th VLDB Conference Brighton 1987 pp 83-96 Shaw G M and ZdoNc S B A Query Alge bra for Object-Oriented Databases IEEE Trans on Data Engineering 12\(3 pp 154-162 Feb 1990 Shipan D The Functional Data Model and the Data Language DAPLAX ACM Trans Database System ql March 1918 Singh M Transaction Oriented Rule Processing in an Object-Oriented Knowledge Base Manage ment System Master's thesis University of Florida 1990 Su S.Y.W Modeling Integrated Manufacturing Data With SAM IEEE Computer January Su S.Y.W et al An Object-oriented Comput ing Environment for Productivity Jmprovement in Automated Design and Manufacturing Project Summary PROCIEM 88,Orlandq E Nov 14-15 1988 Su S.Y.W Kxishnamurthy V and Lam H An Object-oriented Semantic Association Model OsAM AI in Industrial Engineering and Manufacturing Theoretical Issues and Applica tions Kumara S Soyster A.L and Kashyap R.L eds American Institute of Industrial Engineering 1989 Su S.Y.W Guo M and Lam H Association Algebra A Mathematical Foundation for Object Oriented Databases to be submitted to Trans on Knowledge and Data Engineering Tsurt S and Zaniolo C An Implementation of GEM  Supporting a Semantic Data Model on a Relational Back End Proceedings of the ACM SIGMOD Jntl Conference on the Management of Data 1984 pp 286-295 Frederick Ty The Design and Implementation of a Graphics Interface for an Object-oriented Language Master's thesis University of Florida 1988 Zaniolo C The Database language GEM Proceedings of the ACM SIGMOD Intl Confer ence on the Management of Data 1983 Zdonik S B Skarra A H and Reiss S P An Object Server for an Object-oriented Database System Intemational Workshop on Object oriented Database Systems Pacific Grove CA Sept 1986 Zdonik S.B The implementation of a Shared Clustered Memory System for an 0-0 Database System ACM Trans on Office Information Sys tems Apr 1987 1986 pp.34-49 32 I 


It can also be added to cell CrossSales.3\(PC, printer one_year,\205 5  Distributed and Incremental Rule Mining There exist two ways to deal with association rules 267  Static that is, to extract a group of rules from a snapshot, or a history, of data and use "as is 267  Dynamic that is, to evolve rules from time to time using newly available data We mine association rules from an e-commerce data warehouse holding transaction data. The data flows in continuously and is processed daily Mining association rules dynamically has the following benefits 267  223Real-time\224 data mining, that is, the rules are drawn from the latest transactions for reflecting the current commercial trends 267  Multilevel knowledge abstraction, which requires summarizing multiple partial results. For example association rules on the month or year basis cannot be concluded from daily mining results. In fact multilevel mining is incremental in nature 267  For scalability, incremental and distributed mining has become a practical choice Figure 3: Distributed rule mining Incremental association rule mining requires combining partial results. It is easy to see that the confidence and support of multiple rules may not be combined directly. This is why we treat them as \223views\224 and only maintain the association cube, the population cube and the base cube that can be updated from each new copy of volume cube. Below, we discuss several cases to show how a GDOS can mine association rules by incorporating the partial results computed at LDOSs 267  The first case is to sum up volume-cubes generated at multiple LDOSs. Let C v,i be the volume-cube generated at LDOS i The volume-cube generated at the GDOS by combining the volume-cubes fed from these LDOSs is 345   n i i v v C C 1  The association rules are then generated at the GDOS from the centralized C v  214  The second case is to mine local rules with distinct bases at participating LDOSs, resulting in a local association cube C a,I a local population cube C p,I  and a local base cube C b,i at each LDOS. At the GDOS, multiple association cubes, population cubes and base cubes sent from the LDOSs are simply combined, resulting in a summarized association cube and a summarized population cube, as 345   n i i a a C C 1   345   n i i p p C C 1  and 345   n i i b b C C 1  The corresponding confidence cube and support cube can then be derived as described earlier. Cross-sale association rules generated from distinct customers belong to this case In general, it is inappropriate to directly combine association cubes that cover areas a 1 205, a k to cover a larger area a In the given example, this is because association cubes record counts of customers that satisfy   customer product merchant time area Doe TV Dept Store 98Q1 California Doe VCR Dept Store 98Q1 California customer product merchant time area Doe VCR Sears 5-Feb-98 San Francisco Joe PC OfficeMax 7-Feb-98 San Francisco customer product merchant time area Doe TV Fry's 3-Jan-98 San Jose Smith Radio Kmart 14-Jan-98 San Jose Association   population      base          confidence      support cube               cube                cube         cube                cube LDOS LDOS GDOS 


the association condition, and the sets of customers contained in a 1 205, a k are not mutually disjoint. This can be seen in the following examples 214  A customer who bought A and B in both San Jose and San Francisco which are covered by different LDOSs , contributes a count to the rule covering each city, but has only one count, not two, for the rule A  336  B covering California 214  A customer \(e.g. Doe in Figure 3\who bought a TV in San Jose, but a VCR in San Francisco, is not countable for the cross-sale association rule TV  336 VCR covering any of these cities, but countable for the rule covering California. This is illustrated in Figure 3 6  Conclusions In order to scale-up association rule mining in ecommerce, we have developed a distributed and cooperative data-warehouse/OLAP infrastructure. This infrastructure allows us to generate association rules with enhanced expressive power, by combining information of discrete commercial activities from different geographic areas, different merchants and over different time periods. In this paper we have introduced scoped association rules  association rules with conjoint items and functional association rules as useful extensions to association rules The proposed infrastructure has been designed and prototyped at HP Labs to support business intelligence applications in e-commerce. Our preliminary results validate the scalability and maintainability of this infrastructure, and the power of the enhanced multilevel and multidimensional association rules. In this paper we did not discuss privacy control in customer profiling However, we did address this issue in our design by incorporating support for the P3P protocol [1 i n  ou r data warehouse. We plan to integrate this framework with a commercial e-commerce system References 1  Sameet Agarwal, Rakesh Agrawal, Prasad Deshpande Ashish Gupta, Jeffrey F. Naughton, Raghu Ramakrishnan, Sunita Sarawagi, "On the Computation of Multidimensional Aggregates", 506-521, Proc. VLDB'96 1996 2  Surajit Chaudhuri and Umesh Dayal, \223An Overview of Data Warehousing and OLAP Technology\224, SIGMOD Record Vol \(26\ No \(1\ 1996 3  Qiming Chen, Umesh Dayal, Meichun Hsu 223 OLAPbased Scalable Profiling of Customer Behavior\224, Proc. Of 1 st International Conference on Data Warehousing and Knowledge Discovery \(DAWAK99\, 1999, Italy 4  Hector Garcia-Molina, Wilburt Labio, Jun Yang Expiring Data in a Warehouse", Proc. VLDB'98, 1998 5  J. Han, S. Chee, and J. Y. Chiang, "Issues for On-Line Analytical Mining of Data Warehouses", SIGMOD'98 Workshop on Research Issues on Data Mining and Knowledge Discovery \(DMKD'98\ , USA, 1998 6  J. Han, "OLAP Mining: An Integration of OLAP with Data Mining", Proc. IFIP Conference on Data Semantics DS-7\, Switzerland, 1997 7  Raymond T. Ng, Laks V.S. Lakshmanan, Jiawei Han Alex Pang, "Exploratory Mining and Pruning Optimizations of Constrained Associations Rules", Proc ACM-SIGMOD'98, 1998 8  Torben Bach Pedersen, Christian S. Jensen Multidimensional Data Modeling for Complex Data Proc. ICDE'99, 1999 9  Sunita Sarawagi, Shiby Thomas, Rakesh Agrawal Integrating Association Rule Mining with Relational Database Systems: Alternatives and Implications", Proc ACM-SIGMOD'98, 1998   Hannu Toivonen, "Sampling Large Databases for Association Rules", 134-145, Proc. VLDB'96, 1996   Dick Tsur, Jeffrey D. Ullman, Serge Abiteboul, Chris Clifton, Rajeev Motwani, Svetlozar Nestorov, Arnon Rosenthal, "Query Flocks: A Generalization of Association-Rule Mining" Proc. ACM-SIGMOD'98 1998   P3P Architecture Working Group, \223General Overview of the P3P Architecture\224, P3P-arch-971022 http://www.w3.org/TR/WD-P3P.arch.html 1997 


Plenary Panel Session 30 XML Databases   Moderator: Michael Carey, IBM Almaden Research Center USA Panelists Adam Bosworth, Microsoft Corporation USA David De Witt University of Wisconsin-Madison, USA Alon Levy University of Washington USA Bruce Lindsay IBM Almaden Research Center USA Jennifer Widom Stanford University USA Demo Session 1 Web Query Optimizer  661 V Zadorozhny L Bright L Raschid T Urhan and M Vidal ReQueSS: Relational Querying of Semi-structured Data  664 R Sunderraman The IDEAL Approach to Internet-Based Negotiation for E-Business  666 J Hammer C Huang Y Huang C Pluempitiwiriyawej M Lee H Li L Wang Y Liu and S Su READY A High Performance Event Notification Service  668 R Gruber B Krishnamurthy, and E Panagos A Multimedia Information Server with Mixed Workload Scheduling  670 G Nerjes DISIMA An Object-Oriented Approach to Developing an Image Database System  672 V Oria T Ozsu P Iglinski B Xu and L Cheng Demo Session 2 The Collaboration Management Infrastructure  677 H Schuster D Baker A Cichocki D Georgakopoulos and M Rusinkiewicz Assisting the Integration of Taxonomic Data The LITCHI Toolkit  679 I Sutherland J Robinson S Brandt A Jones S Embury W Gray R White and F Bisby TheaterLoc: Using Information Integration Technology to Rapidly Build Virtual Applications  681 G. Barish Y.4 Chen D Dipasquo, C Knoblock S Minton I Muslea and C Shahabi Lineage Tracing in a Data Warehousing System  683 Y Cui and J Widom xiii 


The Mentor-Lite Prototype A Light-Weight Workflow Management System  685 J Weissenfels M Gillmann 0 Roth, G Shegalov and W Wonner Location Prediction and Queries for Tracking Moving Objects  687 0 Wolfson B Xu and S Chamberlain Semiorder Database for Complex Activity Recognition in Multi-Sensory Environments  689 S Bhonsle A Gupta S Santini and R Jain Tutorial 1 Web Information Retrieval  693 M Henzinger Tutorial 2 Mobile and Wireless Database Access for Pervasive Computing  694 P Chrysanthis and E Pitoura Tutorial 3 Data Mining with Decision Trees  696 J Gehrke Tutorial 4 Directories Managing Data for Networked Applications  697 D Srivastava Tutorial 5 Indexing High-Dimensional Spaces Database Support for Next Decade\222s Applications  698 S Berchtold and D Keim xiv 


 T5.I2.D100K T10.I4.D100K T15.I4.D100K T10.I6.D400K T10.I6.D800K T10.I6.D1600K Optimizations across Databases 5 0 5 10 15 20 25 30 35 40 45 Improvement COMP TREE COMP-TREE 1 2 4 8 1 2 4 8 1 2 4 8 2 4 8 2 4 8 1 2 4 8 Processors Databases Figure 5 Effect of Computation and Hash Tree Balancing good as the COMP optimization The reason that the hash tree balancing is not suf\336cient to offset inherent load imbalance in the candidate generation in this case The most effective approach is to apply both optimizations at the same time COMP-TREE The combined effect is suf\336cient to push the improvements in the 40 range in the multiple-processor case On 1 processor only hash tree balancing is bene\336cial since computation balancing only adds extra cost 5.4 Short-circuited Subset Checking Figure 6 shows the improvement due to the short-circuited subset checking optimization with respect to the unoptimized version The unoptimized version is the Apriori algorithm due to Agrawal et al 5 The results are presented for dif ferent number of processors across dif ferent databases The results indicate that while there is some improvement for databases with small transaction sizes the optimization is most effective when the transaction size is large In this case we get improvements of around 25 r the unoptimized version To gain further insight into this optimization consider 336gure 7 It shows the percentage improvement obtained per iteration on applying this optimization on the T20.I6.D100K database It shows results only for the uni-processor case r similar results were obtained on more processors We observe that as the iteration k increases there is more opportunity for shortcircuiting the subset checking and we get increasing bene\336ts of up to 60 The improvements start to fall off t the high end where the number of candidates becomes small resulting in a small hash tree and less opportunity for short-circuiting It becomes clear that is an extremely effective 15 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 T5.I2.D100K T10.I6.D800K T15.I4.D100K T20.I6.D100K procs across Databases 0 5 10 15 20 25 Improvement 1 2 4 8 Figure 6 Effect of Short-circuited Subset Checking 23456789101112 Iterations 0 10 20 30 40 50 60 improvement T20.I6.D100K Figure 7  Improvement per Iteration  proc   16 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


optimization for larger transaction sizes and in cases where there are large number of candidate k itemsets 6 Conclusions In this paper e presented a parallel implementation of the Apriori algorithm on the SGI Power Challenge shared memory multi-processor We also discussed a set of optimizations which include optimized join and pruning computation balancing for candidate generation hash tree balancing and short-circuited subset checking We then presented experimental results on each of these Improvements of more than 40 were obtained for the computation and hash tree balancing The short-circuiting optimization was found to be extremely effective for databases with large transaction sizes Finally we reported the parallel performance of the algorithm While we d good speed-up we observed a need for parallel I/O techniques for further performance gains References  R Agra wal T  Imielinski and A Swami Database mining A performance perspecti v e  I n IEEE Trans on Knowledge and Data Engg  pages 5\(6 1993  R Agra wal T  Imielinski and A Swami Mining association rules between sets of items in lar ge databases In Proc M SIGMOD Intl Conf Management of Data  May 1993  R Agra wal H Mannila R Srikant H T o i v onen and A I V erkamo F ast disco v ery of association rules In U F et al editor Advances in Knowledge Discovery and Data Mining  MIT Press 1996  R Agra wal and J Shafer  P arallel mining of association rules design implementation and e xperience Technical Report RJ10004 IBM Almaden Research Center San Jose CA 95120 Jan 1996  R Agra wal and R Srikant F ast algorithms for mining association rules In Proc 20th VLDB Conf  Sept 1994  M Cierniak W  Li and M J Zaki Loop scheduling for heterogeneity  I n 4th IEEE Intl Symposium on High-Performance Distributed Computing also as URCS-TR 540 CS Dept Univ f Rochester  Aug 1995  M Holsheimer  M  K ersten H Mannila and H T o i v onen A perspecti v e on databases and data mining In 1st Intl Conf Knowledge Discovery and Data Mining  Aug 1995  M Houtsma and A Swami Set-oriented mining of association rules In RJ 9567  IBM Almaden Oct 1993  H Mannila H T o i v onen and I V erkamo Ef 336cient algorithms for disco v ering association rules In AAAI Wkshp Knowledge Discovery in Databases  July 1994  J S P ark M Chen and P  S Y u  A n e f fecti v e hash based algorithm for mining association rules In Proc M SIGMOD Intl Conf Management of Data  May 1995 17 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 J S P ark M Chen and P  S Y u  E f 336cient parallel data mining for association rules T echnical Report RC20156 IBM T J Watson Research Center Aug 1995  G Piatetsk y-Shapiro Disco v ery  presentation and analysis of strong rules In G P S et al editor  KDD  AAAI Press 1991  A Sa v asere E Omiecinski and S Na v athe An ef 336cient algorithm for mining association rules in large databases In Proc 21st VLDB Conf  1995  M J Zaki M Ogihara S P arthasarathy  and W  Li P arallel data mining for association rules on shared-memory multi-processors Technical Report 618 Department of Computer Science University of Rochester 618 1996 18 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


