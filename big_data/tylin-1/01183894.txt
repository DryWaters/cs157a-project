A Theory of Inductive Query Answering Luc DE RAEDT Manfred JAEGER Sau Dan LEE Heikki MANNILA tinst. fur Informatik University of Freiburg Georges Koehler Allee 79 D-79110 Freiburg, Germany deraedt@informatik.uni-freiburg.de danleeminformatkuni-freiburg.de t Helsinki Institute of Information Technology PO Box 26 FIN-00014 Univ of Helsinki Finland mannila@cs.helsinki.fi  MPI Informatik Stuhlsatzenhausweg 85 D-66 123 Saarbriicken Germany jaegermmpi-sb.mpg.de Abstract We introduce the boolean inductive query evaluation problem which is concerned with answering inductive queries that 
are arbitrary boolean expressions over mono tonic and anti-monotonic predicates Secondly we develop a decomposition theory for inductive query evaluation in which a boolean query Q is reformulated info k sub-queries Q  Qa A QM that are the conjunction of a monotonic and an anti-monotonic predicate The solution to each sub que'y can be represented using a version space We investi gate how the number of version spaces k needed to answer the query can be minimized Thirdly for the pattern do main of strings 
we show how the version spaces can be represented using a novel data structure called the version spuce me and can be computed using a variant of the fa mous Apriori alnorithm Finally we present some experi ments that validate the appmach 1 Introduction Many data mining problems ad ss the problem of fin ing a set of patternsthat satisfy a constraint Formally this can be described as the task of finding the set of patterns TIL D C  ip E L 
I Q\(q D i.e those patterns p satisfying query Q on database D Here C is the language in which the patterns or rules are described and Q is a pred icate or constraint that determines whether a pattern p is a solution to the data mining task or not  151 This framework allows us to view the predicate or the constraint Q as an in ductive query to an inductive database system It is then the task of the inductive database management 
system to effi ciently generate the answers to the query This view of data mining as a declarative querying process is also appealing as the basis for a theory of data mining Such a theory would be analogous to traditional database theory in the sense that one could study properties of different pattern languages L different types of queries and query languages as well as different types of databases Such a theory could also serve as a sound basis for developing algorithms that solve induc tive queries It is precisely such a theory that 
we introduce in this pa per More specifically we study inductive queries that are boolean expressions over monotonic and anti-monotonic predicates An example query could ask for molecular frag ments that have frequency at least 30 per cent in the active molecules or frequency at most 5 per cent in the inactive ones  141 To the best of our knowledge this type of boolean inductive query is the most general type of inductive query that has been considered so far in the data mining litera ture Indeed most contemporary approaches to 
constraint based data mining use either single constraints such as min imum frequency e.g 2 a conjunction of monotonic con straints, e.g 17 101 or a conjunction of monotonic and anti-monotonic constraints e.g 4 141 However  has studied a specific type of boolean constraints in the context of association rules and item sets It should also be noted that even these simpler types of queries have proven to be useful across several applications which in turn explains the popularity of constraint based mining in the literature Our theory of boolean inductive queries is first of 
all con cerned with characterizing the solution space Th\(Q,D C using notions of convex sets or version spaces 13 12 161 and border representations 15 This type of representa tions have a long history in the fields of machine learning 13 12 161 anddatamining 15.31 Thesedataminingand machine leaming viewpoints on border sets have recently been unified by 4 141 who introduced the level-wise ver sion space algorithm that computes the S and G set w.r.t a conjunction of monotonic and anti-monotonic constraints 0-7695-1754-4/02 517.00 Q 2002 IEEE 123 


In the present paper we build on these results to develop a decomposition approach to solving arbitrary boolean queries over monotonic and anti-monotonic predicates More specifically we investigate how to decompose ar bitrary queries Q into a set of sub-queries Qh such that Th\(Q,D,C  Ui Th\(Q,,D,C k is minimal and each Th\(Qi,D;C can be represented using a single version space This results in an operational and effective decom position procedure for solving queries Indeed the overall query Q is first reformulated into the sub-queries Q which can then be solved by existing algorithms such as the level wise version space algorithm of 4 Our theory is then instantiated to answer boolean queries about string patterns String patterns are widely applicable in the many string databases that exist today e.g in DNA nr in proteins Furthermore, the present work is to a large extent motivated by the earlier MolFea system 14 41 in which conjunctive queries \(over anti-monotonic and mono tonic constraints for molecular features were solved using a version space approach MolFea features are essentially strings that represent sequences of atoms and bonds For string patterns we introduce a novel data structure i.e ver sion space trees for compactly representing version spaces of strings Version space trees combine ideas of version spaces with those of suffix trees They have various desir able properties Most notably they can be computed using a variant of traditional level wise algorithms for tries, rec ognizing whether a string belongs to the version space is linear in the size of the string and the size of the version space tree is at most quadratic in the size of the elements in the S set of the version space This paper is organized as follows In Section 2 we de fine the inductive query evaluation problem and illustrate it on the pattern domains of strings and item-sets in Section 3 we introduce a decomposition approach IO reformulate the original query in simpler sub-queries in Section 4 we introduce version space trees that compactly represent the solutions to a sub-query in the pattern domain of strings in Section 5 we report on some experiments in this domain and finally in Section 6 we conclude 2 Boolean Inductive Queries A pattern language C is a formal language for specifying patterns Each pattern 4 E C matches or covers\a set of examples  which is a subset of the universeU of possible examples In general pattern languages will not allow to represent all subsets P\(U of the universe Example 2.1 Let 1  til   in be ajinite set of pos sible items and U  2 be the universe of item sets The terminology used here is similarto that in concepl-learning where U would be the space of examples P\(U the set of possible concepts and C the set of concept-descriptions over Z The traditional pattern language for this domain is Cz  U A pattern 4 E CI covers the set   C Z I 4  An alternative, less expressive, pattern lan guage is the language CZ C Lr of item sets of size at most k Example 2.2 Let C be a finite alphabet and Uz  C the universe of all strings over C We will denote the empty string with e The traditional pattern language in this do main is   A pattern q5 200 covers the set  denotes that 4 is a substring of  An alternative more expressive, lan guage is the language of all regular expressions over C One pattern is more general than a pattern  written 4  if and only if 2  A pattern predicate defines a primitive property of a pat tern, usually relative to some data set D a set of examples and sometimes other parameters For any given pattern it evaluates to either true or false We now introduce a number of pattern predicates that will be used for illustrative purposes throughout this paper Most of these predicates are inspired by MolFea 14 Our first pattern predicates are very general in that they can be used for arbitrary pattern languages minfreq\(y,n,D evaluates IO true iff p is a pattern that occurs in database D with frequency at least 71 E N The frequency f\(4 D of a pattern 4 in a database D is the \(absolute\number of data items in D covered by 4 Analogously the predicate maxfreqb 71 D is defined   E E I 4 C  where 4 ismoregeneral\(p.rl is a predicate that evaluates to true iff pattern p is more general than pattern  Dual to the ismoregeneral predicate one defines the ismorespecific predicate The following predicate is an example predicate tailored lengthatmost@,n evaluates to true for p E LE iff p has length at most 71 Analogously the length at least predicate is defined In all the preceding examples the pattern predicates have the form pred@,params or pred@,D,params where params is a tuple of parameter values D is a data set and p is a pattern variable We also speak a bit loosely of pred alone as a pattern predicate and mean by that the collection of all pattern predicates obtained for different parameter values params We say that m is amonotonic predicate if for all possible parameter values params and all data sets D towards the specific domain of string-patterns over LE V#,$EC suchthat m D,params  m\(d,D,params 124 


I  The class of anti-monotonic predicates is defined du ally Thus min-freq, ismoregeneral, and length-atmost are monotonic, their duals are anti-monotonic A pattern predicate pred@,D,params that can he ap plied to the patterns from a language C defines relative to D the solution set Th\(pfed D,params   E C I pred D,params  rue Furthermore for mono tonic predicates m these sets will be monotone i.e for all gk$~C:$~Tlr\(m,C t$~Th\(m,C Example2.3 Consider the string data set D  abc abd cd d cd Here we have pattern fre quencies f\(abc,D  1 f\(cd,D  2 f\(c,D  3 f\(abcd D  0 And trivially f\(e D  ID1  5 Thus the following predicates evaluate to true min.freq\(c 2 DJ min.freq\(cd 2 DJ max.freq\(abc 2 D max.freq\(cd 2 DJ The pattern predicare rn  min_freq\(p 2 D de jines Th\(m Cx  E a b c d ab,cd and the pattern predicate a  max-freq\(p 2 D defines the infnire set Th\(a,Cx   c,c,d Thedefinition ofTh\(pred\(p D,params C isextended in the natural way to a definition of the solution set Th\(Q C for boolean combinations Q of pattern predi cates over a unique pattern variable Th\(-Q C  C  Th\(Q,L Th\(Q1 V Qz,C  Th\(Q1,C U Th\(Qz,CC The predicates that appear in Q may reference one or more data sets D1    D To emphasize the different data sets that the solution set of a query depends on we also write Th\(Q,D1  D,:C Q,D,C Q,C We are interested in computing solution sets Th\(Q D C for boolean queries Q that are constructed from monotonic and anti-monotonic pattern predicates As anti-monotonic predicates are negations of monotonic predicates we can, in fact, restrict our attention to mono tonic predicates We can thus formally define the boolean inductive query evaluationproblem addressed in this paper Given a language C of patterns a set of monotonic predicates M  ml\(p,D1:paramsl  m,\(p,D,,params a query Q that is a boolean expression over the predi cates in M and over a single pattern variable Find the set of patterns Th\(Q D1    D,,C i.e the solution set of the query Q in the language C with respect to the data sets D1    D  125 3 A decomposition approach The query evaluation problem for a query Q will he solved by decomposing Q into k sub-queries Q such that Q is equivalent to Q1 V  V Qk and then computing Th\(Q,D,C as UiTh\(Q D C Furthermore, each of the sub-queries Q will be such that Th\(Q;,D C is a version space \(also called a convex space\and therefore can he ef ficiently computed for a wide class of pattern languages C and queries Q Definition 3.1 Let C be a pattern language, and I C C I has dimension I ifV 222  E C  4 5  5  and  E I j  E I I has dimension k if it is the union of k subsets of dimension 1 but not the union of k  1 subsets of dimension 1 A query Q has dimension k with respect to the pattern language C if k is the maximal dimension of any solution setTh\(Q,D,C ofQ\(whererhemarimumistaken w.L all possible data sets 222D and w.rt thejixed language CJ IfQ hasdimension 1 w.r.t C,thenTh\(Q,D;C sion space I61 or a convex space 131 Version spaces are particularly useful when they can be represented by bound ary sets i.e by the sets G\(Q D C of their maximally general elements, and S\(Q D C of their minimally gen eral elements For the theoretical framework of the present section we need not assume boundary representability for convex sets However concrete instantiations of the general method we here develop like the one described in sections 4 and 5 usually will assume pattern languages in which con vexity implies boundary representability Example 3.2 Reconsider the string domain Let Q1  Qz  ismoregenera/\(p abcde A ength.at/easr\(p 3 isrnorespecific\(p ab A ismorespecific\(p uw A\(/ength;rt/east\(p 6 V min.freq\(p 3 D The query Q1 does not reference any dataset and Th\(Q1 C  abcde ab bcde abc bcd cde This set of solutions is completely characterized by S\(Q1,C  abcde andG\(Q1,Cx  abc,bcd,cde Th\(Q2 D,Cx cannot in general be represented using a single version space Howeves as our general method will show the dimension of Th\(Q2 D CE is at most two so that it can be represenred as the union of two version spaces With the following definition and lemma we provide an alternative characterization of dimension k sets Lemma 3.3 Let I C C Call a chain 41 5 42,s   5 Qzk-l C an altemaring chain of length k for I if i E I for all odd i and i 6 I for all even i Then the dimension of I is equal to the maximal k for which there exists in C an alternating chain of length k for I 


Example 3.4 Consider the following queries Q3  ismoregenera/\(p a A ismarespecific\(p a Q4  ismoregeneral\(p c and Q5  Q3 V Qs Then c k a is an alternating chain of length 2 for WQ5>.cd Given Q and L we are now interested in computing the dimension k of Q and transforming Q into a disjunction V2=,Qi such that each Th\(Qi,D,L is a version space The approach we take is to first evaluate Q in a reduced pattern language CGQ so that the desired partition VQ can be derived from the structure of Th\(Q The solution set Th\(Q L$\(Q does not depend on the datasets V that Q references. and the complexity of its computation only depends on the size of Q but not on the size of any datasets Definition3.5 ForaqueryQ lerM\(Q  ml  mn be the ser of monoronic predicates contained in Q where predicates rhar only differ wirh respect to parameter values also are considered distinct Define LM\(Q  ZM\(Q A subset Q C M\(Q is called admissible if there exists darn sers V such thar Th\(Amic A,,eg vnj,\222D,L is notempty LetC$yQ  Q E LM\(Q I 4 admissible Forthepredicares mi wedefineTh\(mi LM\(Q respec rively Th mi L%yQ os rhe set of admissible Q that con rain mi By rhe general definition this also derermines WQ LM\(Q and\222WQ C$Q Example 3.6 Using only monotonic predicares rhe query QZ from example 3.2 can be rewritten as vnl A Q A m3 V m4 wirh ml  not-ismorespecific\(y ab m2  not-ismorespecific\(p uw m3  not-/ength_at/east\(p G ma  min.freq 3 D where e.g not-ismorespecific is the monotonic comple ment of the anri-monoronic predicate ismorespecific; note that this is distinct from ismoregeneral Here every Q C  ml      m4 is admissible a wirness for the admissibility of  m3 md for insrance is a daroser D in which rhe srring abuw appears ar leasr three times i.e abuw E Th\(Tml A rn2 A m3 A ma D LE Figure I a shows CM\(Q  CzQ2 where e.g pat rern  m3 m4 is just represented by its 224index string\224 34 Now consider a variant Q6 of Qz obtained by replacing m wirh m  not-/ength.at/east 4 Here nor every Q 5 ml m2,m\222\222,m4 is admissi ble as ismorespecifiijp ab A isrnorespecific\(y uw im plies lengthatleas 4 we have that neither m\224 nor  nf3  m4 are admissible. These are the only two inadmissi ble subsets of M\(Q so rhar C$Q6 here is as infgure 1 b a b Figure 1 Pattern languages LGQ Assuming that we can decide admissibility of subsets of M\(Q for the types of pattern languages and pred icates we have considered so far admissibility can al ways be decided we can construct LzQ and compute Th\(Q,L$\(Q These solution sets are indicated for the queries QZ and QB in their respective languages LzQ by circles in figure 1 One sees that Th\(Q2,Lz;Q2 has dimension 2 and Th\(Q6 LMo has dimension 1 This gives an upper bound for the dimensions of the solutions ta the query Theorem 3.1 The dimension of Th\(Q C$yQ is an upper bound for the dimension of Th\(Q D C for all datasets 222D The dimension of Th\(Q LM\(Q is greater or equal the dimension of Th\(Q C$\(Q and therefore also can serve as an upper bound for the dimension of Th\(Q V L In general, this will be a coarser bound for S for instance we obtain for Th\(Q LM\(Q the same structure as shown for QZ in figure 1 a\and therefore only the bound 2 When Th\(Q,L$yQ is of dimension k we can de fine each of its convex components  as a solution to a query Qh in the predicates mi if Q1  Q1 are the max imal and   the minimal elements of Ihr then I  Th\(&h,L$\(Q for Qh  Vi mj A V~I Am;c mj 1 Theorem33 Th\(Qh,V,L is convex for all darasers V and Th\(Q,V,L  Th\(Vk=,Qh,\222D,L  Uk,lTh\(Qh,v,LC Example 3.9 Continuing from example 3.6 we can par tition Th\(Q2 L$yQ2 into WO convex components Il  ma m m4 and I2  l We rhus obtain the de 126 


composition of the query QZ into the two subqueries QZ  QZ1  ismorespecifidp ub A isrnorespecifidp uw Amin-freq\(p 3 D ismorespecifidp ab A ismorespecific\(p uw A/ength-at/east\(p 6 A min.freq\(p 3 D Fur Q6 we have that Th\(Q6 C$;Qe consists of one ver sion space I nu so that Q6 is equivalent to the query QBI  The suh-queries I lo which the original query Q is reduced not only are known to have convex solution sets Th\(Qh,D:C they also are of a special syntactic form Qh  Qh,M A Qh,a where Qh,M defines a mOnOlOlle set Th\(Qh,M:V C and Qh,a defines an anti-monotone set Th\(Qh,a D L This factorization of Qh facilli tates the computation of the border sets G\(Q,,:D,C and S\(Qh,'D C for which the level wise version space algo rithm 4 141 can be used In the following section we will present an algorithm that for queries in the string domain uses the syntactic form of the Qh for efficiently computing and representing the solution sets Th\(Qh 2 C with ver sion space trees isrnorespecific\(y ab A isrnorespecifidp uw A/ength.at/east\(p 4 4 Version space trees In this section we introduce a novel data structure called the version space tree that can be used to elegantly represent and index a version space of strings e.g the Th\(Qh 2 Cr introduced in the previous section Further more we present effective algorithms that compute version space trees containing all strings that satisfy the conjunction of a monotonic and an anti-monotonic predicate as in the queries Qh 4.1 The data structure A trie is a tree where each edge is labelled with a symbol from the alphabet C Moreover the labels on every edge emerging from a node must be unique Each node n in a trie thus uniquely represents the string s\(n containing the characters on the path from the root r to the node n The root node itself represents the empty string e A sum trie is a trie with the following properties For each node TL and for each suffix t of s\(n there is also a node n in the trie representing t i.e t  s\(n Each node n has a sum link su&\(n  n where s\(d represents the suffix obtained from s\(n by drop ping the first symbol The root node represents c which has no suffixes We define su&\(rout  I where I is a unique entity o 9 Figure 2 An example version space tree Suffix tries have been well studied in the literature 18 191 However we make some importantdeviationsfromthe main stream approach instead of building a suffix trie on all the suffixes of a single string we are indexing all the suffixes of aset of strings; thus multiple strings are stored in the trie we usefilly labelled tries in which each node is la belled with either  or 8 the  label to indicate nodes that are interesting to us say: belong to the ver sion space and e for those that are not because we need to store labels and counts for all substrings represented in the trie we do not coalesce chains of nodes with only one out-going edge into a single edge label Note that a fully labelled trie may contain nodes for which its label as well as those of its descendants are all e Thus the node as well as the suhtrie helow it are unin teresting. Therefore in practice we will often use a pruned labelled trie. This is a fully labelled trie with the additional property that all leaf nodes have the sign e Both trees have the same semantics and each fully labelled tree has a unique equivalent pruned tree Furthermore,as most of our results are valid for both types of trees we will often employ the term "labelled trie Now a version space tree V is a labelled trie that rep resents a version space of strings over Cx More for mally let V he a set of strings of dimension I Then the corresponding pruned version space trie T is such that V  U I n is a node in T with label and s\(n  2  Fig ure 2 illustrates the pruned version space tree representing Th\(Q D LE where Q7  is_more4eneral\(t abcde A is.morespecific\(t bc V ismoreApecific\(t cde A version space tree VST representing version space V has the following properties 1 All leaf nodes are labelled e 2 Along every path from root to a leaf there is at most one sign change \(from e to a cf. Lemma 3.3 3 If S  min V then VST will 1 have a leaf corre sponding to each s E S and 2 have a node corre sponding to each suffix s of each s E S for which s E v 127 


4 Therefore the number of nodes in the version space tree VST is at most C,,&,l where Is1 denotes the length of the suing However the size of a VST is usually much smaller 5 Testing whether a strings belongs to the version space represented by a version space VST is linear in IsI as the VST can be interpreted as a deterministic automa ton on inputs 6 Property 3 can be used as the basis for an algorithm for constructing a version space tree based on S and G I For a given version space tree one can easily and ef ficiently construct the S and G-sets Indeed the S set will contain all leafs I of the version space tree to whom no suffix pointer points: and the G-set will con tain all nodes g with label  whose parent node has label e and for which the node sufJix\(g either does not exist or also has the label 0 As one can see there is a close correspondence between version spaces of strings and version space trees We will now show that there is also a close correspondence between version space trees and algorithms such as Apriori 2 4.2 The algorithms In this section we sketch the VST algorithm to build a version space tree that satisfies the conjunction a AQ of an anti-monotonic predicate a and a monotonic one QM This form of query corresponds to the one of the queries Qh that would be generated by our decomposition over anti-monotonic and monotonic constraints\approach Al gorithm VST is a level-wise algorithm based on the well known Apriori 21 algorithm The algorithm assumes I that the version space tree to be computed is finite and 2 that the alphabet C is given It consists of two phases DESCEND top-down growing of the version space tree us ing the monotonic predicate QM ASCEND bottom-up marking of the version space tree us ing the anti-monotonic predicate  Both phases are designed to minimize the number of database scansz As such they both exhibit the cyclic pattern candidate generation, candidate testing database scan and pruning The cycle terminates when no more new candidates patterns are generated Since only the monotonic pattern predicate is handled in the descend phase we can reuse the idea of Apriori The algorithm searches the strings satisfying j,f in a top-down 222As m Apriori one only needs to scan the data se at most once for each level of the me breadth-first manner At each depth level k the descend algorithm first expands the nodes found in the previous iteration Lk-1 The nodes resulting from the expansion constitute the set ck These candidate nodes are then tested against the predicate QM The testing involves one database scan for the whole iteration The candidate patterns in ck that satisfy the constraints are put into LI Those that do not are pruned away from the lree This process is repeated in a level wise fashion until ck becomes empty All generated nodes are labelled with  and the necessary suffix links are set up during this phase Note that the sets ck and Lk are the same as the candi date sets and \223large\224 sets in the Apriori algorithm More over the generation of C from Lk_l also mimics the Aprion-join operation in the Apriori algorithm.\222 The de scend algorithm makes use of the suffix like and parent child relationship of a suffix trie to perform the join effi ciently More specifically the candidate child nodes of a node 71 in Lk-1 as well as the edges\correspond to the children of the node suffU\(7i So the major difference be tween DESCEND and Apriori is that the former also orga nizes the discovered strings into a suffix trie facilitating the join operation and the second phase of the VST algorithm The second phase is implemented with algorithm AS CEND This phase handles the anti-monotonic con straint QA Here we assume that we have the set FO of leaf nodes in the tree T generated during the descend phase While DESCEND works top-down ASCEND starts from the leaves and works upwards It first checks the leaf nodes against the predicate Qa The labels of all the nodes n that do not satisfy Qa are changed into e In addition all their ancestors are also labelled as 8 This is sound due to the anti-monotonicity So we can propagate these 8 marks upwards until we have marked the root with 0 Actually we can stop as soon as we reach an ancestor al ready marked with e as another such leaf node 71\222 may share some ancestors with n So all the ancestors from that point upwards have already been marked with 8 Secondly for those nodes p in FO that satisfy a the label remains unchanged i.e e Furthermore, we will enter their parent into the set Fl and remove possible duplicates Fl con tains the nodes to be considered at the next iteration This process is then repeated until Fk becomes empty So after these two phases namely DESCEND and then ASCEND both the monotonic and the anti-monotonic con straints are handled With a simple tree traversal we can prune away those subtrees that contain only 8 labels The    are some differences here since we are dealing with strings in stead of sets E.g while Apriori-join generates item set a b c from a b and a c the descend algorithm generates abc from ab and bc because these are the only immedialely shorter substrings of abc At the same ume it is not hard to imagine a vaiiant of the version space wee al ganthm for use with item se Indeed the kind of trie searched is quite similw to some of the data smctures used by e.g 13 I I 128 


  result is a tree that is a pruned suffix trie representing the version space of strings that satisfy the query QA A QM Theorem 4.1 The VST algorifhm performs ar mosf 2111 database scans where m is length of fhe longest sfrings safisfying the monotonic quew QM 5 Experiments We have implemented the VST algorithm and performed experiments on datasets of command histories collected from 168 Unix users over a period of time 7 The users are divided into four groups computer scientists experienced programmers novice programmers and non-programmers The corresponding data sets are denoted 223sci\224, \223exp\224. \223nov\224 and \223non\224. respectively. When each user accesses the Unix system he first logs in then types in a sequence of com mands and finally logs out Each command is recorded as a symbol in the database The sequence of commands from log in to log out constitutes a login session, and is mapped to a string in our experiment Each user contributes to many login sessions in the database Table 1 gives some statistics on the data In the first set of experiments we determined solutions of queries minfreq\(p n D for the four different datasets and for thresholds n that were selected so as to produce solution sets of around 300 frequent string patterns Table 1 summa rizes the datasets the queries and their solutions. Timings wall-clock time on a Pentium III 600 Mhz are reponed as well Whereas the first set of experiments only used the minfreq predicate the second set of experiments involves the computation of two version space trees TI and Tz cor responding to the queries Qs and QQ Qs  min.freq\(p nun 24 A maxfreq\(p sci 60 QQ  minfreqb nm 80 A max_freq\(p ezp 36 QS and Qs are conjunctions of an anti-monotonic predicate and a monotonic one thus their solution space is a version space Furthermore, they are the suh-queries that are gener ated for the query Qlo  Qs V QS using the decomposition approach outlined in Section 3 The results of the second experiment are shown in Ta ble 2 Each row shows the time the algorithm spent on building that tree The columns of the table show the num ber of nodes and total length of strings represented by those nodes Each of the five sub-column in each case shows the number for a subset of the nodes in the final trie The col umn 223all\224 shows the figure for all trie nodes The columns 223e\224 and 2230\224 show the figure aggregated over nodes with the respective labels only The columns 223S\224 and 223G\224 show the figures for the maximally specific strings and the mini mally specific strings respectively For what concerns the query Qlo there are in total 401 strings in its answer set and together they have length 1953 Our experimental results confirm our claim that the sets Sand G constitute a compact representation of the set of all patterns satisfying the given constraints Qw and QA From Table 2 it can be seen that the total length of strings for S and G together is always smaller than that for all interesting patterns \(i.e e In the case of 4 the space saving is significant Moreover algorithm VST is also very efficient in terms oftime and space This shows that using suffix tries in the mining of string patterns is a promising approach The longest pattern found represented by the deepest node in either TI or T2 having a e label was 223pix urnacs pix umacs pix urnacs pix urnacs pix umacs pix urnacs pix urnacs pix macs pix umacs pix\224 which has a length of 19 6 Conclusions We have described an approach to the general pattern discovery problem in data mining The method is based on the decomposition of the answer set to a collection of com ponents defined by monotonic and anti-monotonic predi cates Each of the components is a convex set or version space the borders of which can be computed using the level wise version space algorithm or  for the pattern domain of strings  using the VSTalgorithm which employs a novel data structure called the version space tree Experiments have been presented that validate the approach The results we have presented in this paper are by no means complete, a lot of open problems and questions re main First it seems possible to adapt the version space trees and algorithm for use in other domains \(such as item sets However at present it is unclear how lo do this for some more expressive domains such as Datalog queries or even the string domain where one is using a coverage rela tion based on subsequence matching rather than substring matching Secondly for the string domain it is possible to funher optimize these algorithms for specific predicates e.g involving frequency counting on adatabase of strings Thirdly we are at present also studying set operations on version space lrees Such operations would allow us to per form some of the logical operations directly on solution spaces Fourlhly the framework seems also useful in the context of optimizing a sequence of inductive queries Here it would be interesting to see how the results to previous sub\queries could be reused for more efficiently answer ing the next question Although there are many remaining questions, the au thors hope that the introduced framework provides a sound theoretical framework for studying these open questions as well as for developing practical inductive database systems based on the idea of inductive querying 129 


Data set nov exP non sci D number number of of users sequences 55 5164 36 3859 25 1906 52 7751 minimum frequent execution frequency strings time n found seconds 24 294 3.24 80 292 2.88 80 293 0.72 48 295 4.89 memory used bytes 56994 88706 59754 94290 Suffix Trie TI l'2 lime number of nodes total length of strings sec 8 181allI S IG 8 le1 all I S I G 2.55 166 40 206 104 68 472 75 547 305 147 5.51 237 18 255 85 15 1489 23 1512 416 24 Acknowledgements This work was partly supported by the European IST ET project cInQ References I R. Agrawal and R Srikant Fast algorithms for mining association rules In Pmc VLDB 1994 2 R. Agrawal T Imielinski, A Swami Mining associa tion rules between sets of items in large databases In Pmc SIGMOD pp 207-216, 1993 3 R Bayardo Efficiently mining long patterns from databases In Pmc SIGMOD 1998 4 L. De Raedl S Kramer The level wise version space algorithm and its application to molecular fragment finding In Pmc IJCAI 2001 5 L De Raedt. Query evaluation and optimisation in in ductive databases using version spaces. In Pmc EDBT Workshop on DTDM 2002 6 B Goethals J Van den Bussche On supporting in teractive association rule mining In Pmc DAWAK LNCS Vol 1874 Springer Verlag 2000 7 S Greenberg Using unix Collected traces of 168 users Research Report 881333145 Department of Computer Science University of Calgary Canada 1988 8 D Gunopulos H Mannila S Saluja. Discovering All Most Specific Sentences by Randomized Algorithms In Pmc ICDT LNCS Vol 1186 Springer Verlag 1997 9 J Han Y Fu K Koperski W Wang, and 0 Zaiane DMQL A Data Mining Query Language for Rela tional DatabasesIn Pmc SIGMOD'96 Workshop on Research Issues on Data Mining and Knowledge Dis covery Montreal Canada June 1996 lo J Han L V S Lakshmanan,andR.T Ng. Constrainl Based Multidimensional Data Mining Computer Vol 32\(8 pp 46-50.1999 Ill 1 Han J Pei and Y Yin Mining frequent pat terns without candidate generation In Pmc SIGMOD 2000 12 H Hirsh Generalizing Version Spaces Machine 13 H Hirsh Theoretical underpinnings of versionspaes I41 S Kramer L De Raedt C Helma. Molecular Feature Learning.Vol 17\(1 5-46 1994 In Pmc IJCAI 1991 Mining in HIV Data In Pmc SIGKDD 2001 I51 H Mannila and H Toivonen Levelwise search and borders of theories in knowledge discovery Data Min ing and Knowledge Discovery Vol 1,1997 16 T Mitchell Generalization as Search Anifcial Inrel igence Vol 18 2 pp 203-226.1980 17 R T Ng L V.S Lakshmanan J Han and A. Pang Exploratory mining and pruning optimizations of con strained associations rules In Pmc SIGMOD 1998 1181 E Ukkonen On-line construction of suffix trees Al gorithmica 14\(3 I91 P Weiner Linear pattern matching algorithm In Pmc 14th IEEE Symposium on Switching and Automata Theory pages 1-11,1973 130 


 A A A A A A A A B B B B B B B A B A B A B A B AB A B A A A A B B B A B A B A A B B B B A B A B A B A B A B A B A disjoint B A inside B A contains B A equals B A meets B A covered by B A covers B A overlaps B A B A B A B A B A B AB Figure 4 Topology and resolution increase with minimum bounding circles 64Mb of main memory Since the Apriori algorithm uses the number of transactions as support and we wanted to compare our algorithm with Apriori we have implemented MaxOccur and the na\250 021ve with transaction based support MaxOccur1 The second version of MaxOccur MaxOccur2 used the object-based support as presented in Algorithm 3.1 Table 9 shows the average execution times for the four algorithms with different image set sizes and 033 0 0  05 for Apriori 223Na\250 021ve\224 and MaxOccur1 and 0  0035 for MaxOccur2 The results are graphically illustrated in Figure 5 Clearly MaxOccur scales well with both versions treating one thousand images in 1.3 seconds on average regardless of the size of the data set The running time for 002ltering the frequent item-sets with 033 0  the maximum support threshold line 16 of Algorithm 3.1 is negligible since it is done in main memory once the frequent item-sets are determined Moreover the calculation of the total number of items line 4 of Algorithm 3.1 is done during the 002rst scan of the data set and has limited repercussion on the algorithms execution time The major difference between Apriori and MaxOccur is in ascertaining the candidate item-sets and counting their repeated occurrences in the images Obviously MaxOccur discovers more frequent item-sets The na\250 021ve algorithm also 002nds the same frequent item-sets but is visibly capable of less performance in execution time The left graphic in Figure 6 shows the average number of frequent item-sets discovered with the three algorithms Apriori found on average 109 different frequent k-item-sets while MaxOccur1 and Na\250 021ve found 148 on the same data sets and MaxOccur2 found 145 on average The discrepancy between MaxOccur1 and MaxOccur2 is basically due to the different de\002nition of support The price we pay in performance loss with MaxOccur is gained by more frequent item-sets and thus more potentially useful association rules with recurrent items discovered ofimages Apriori Na\250 021ve MaxOccur1 MaxOccur2 10K 6.43 70.91 13.62 13.68 25K 15.66 176.69 32.35 34.11 50K 30.54 359.38 66.07 67.44 75K 44.93 514.33 97.27 101.23 100K 60.75 716.01 130.12 137.81 Table 9 Average execution times in seconds with different number of images 0 100 200 300 400 500 600 700 800 10K 25K 50K 75K 100K Apriori MaxOccur1 MaxOccur2 Na\357ve time images Figure 5 Scale up of the algorithms 6 Discussion and conclusion We have introduced in this paper multimedia association rules based on image content and spatial relationships between visual features in images using coarse to 002ne resolution approach and we have demonstrated the preservation and changes in topological features during resolution re\002nement We have put forth a Progressive Resolution Re\002nement approach for mining visual media at different resolution levels and have presented two algorithms for the discovery of content-based multimedia association rules These rules would be meaningful only in a homogeneous image collection a collection of semantically similar images or received from the same source channel Many improvements could still be added to the multimedia mining process to speed up the discovery or to re\002ne or generalize the discovered results 017 One major enhancement in the performance of the multimedia association rule discovery algorithms is the addition of some restrictions on the rules to be discovered Such restrictions could be given in a metarule form Meta-rule guided mining consists of dis#ofimages 033 0 0  25 0  20 0  15 0  10 0  05 10K 1.43 2.20 2.70 5.06 13.51 25K 2.80 4.78 6.31 11.20 32.35 50K 6.27 9.28 11.59 22.74 66.07 75K 8.24 13.57 17.69 33.94 97.27 100K 11.32 17.63 23.13 46.74 130.12 Table 10 Average execution time in seconds of MaxOccur with different thresholds 


 0 20 40 60 80 100 120 140 160 MaxOccur2 MaxOccur1 Na\357ve Apriori Apriori MaxOccur1 MaxOccur2 Na\357ve F k  Figure 6 Frequent item\255sets found by the dif\255 ferent algorithms covering rules that not only are frequent and con\002dent but also comply with the meta-rule template For example with a meta-rule such as 223 H-Next-to X Y   Colour x red  Overlap Y Z   P  Y Z  224 one need only to 002nd frequent 3-item-sets of the form f HNext-to\(red Y  Overlap Y 003  P  Y 003  g where Y is an attribute value and P a visual descriptor or spatial relationship predicate Obviously such a 002lter would greatly reduce the complexity of the search problem A method for exploiting meta-rules for mining multilevel association rules is given in  017 We have approximated an object in an image to a locale which is an area with a consistent visual feature such as colour Objects in images and videos are obviously more complex In a recent paper 9 re gions and their signatures are used as objects in a similarity retrieval system A computationally ef\002cient way to identify distinct objects in images is however still to be proposed Automatically identifying real objects and using spatial relationships between real objects would reduce the number of rules discovered and make them more signi\002cant for some multimedia applications 017 Object recognition or identi\002cation in image processing and computer vision is a very active research 002eld Accurately identifying an object in a video for example as being an object in itself is a very dif\002cult task We believe that data mining techniques can help in this perspective Multimedia association rules with spatial relationships using the motion vector of locales as a conditional 002lter can be used to discover whether locales moving together in a video sequence are part of the same object with a high con\002dence 017 There are many application domains where multimedia association rules could be applied and should be tested such as global weather analysis and weather forecast medical imaging solar surface activity understanding etc We are investigating the application with Magnetic Resonance Imaging MRI to discover associations between lesioned structures in the brain or between lesions and pathological characteristics Further development and experiments with mining multimedia data will be reported in the future References 1 R  A gr a w al and R  S r i kant  F ast a l gor i t h ms f o r m i n i n g a ssociation rules In Proc VLDB  pages 487\226499 1994 2 M  J  E genhof er  Spatial Query Languages  PhD thesis University of Maine 1989 3 M  J  E genhof er and J  S har ma T opol ogi cal r e l a t i ons between regions in r 2 and z 2 In Advances in Spatial Databases SSD'93  Singapore 1993 4 U  M  F ayyad S  G  D j or go vski  a nd N  W e i r  A ut omat i n g the analysis and cataloging of sky surveys In U Fayyad G Piatetsky-Shapiro P Smyth and R Uthurusamy editors Advances in Knowledge Discovery and Data Mining  pages 471\226493 AAAI/MIT Press 1996 5 Y  F u a n d J Han  M e ta-ru le-g u i d e d m in in g o f a sso ciatio n rules in relational databases In Proc 1st Int Workshop Integration of Knowledge Discovery with Deductive and ObjectOriented Databases  pages 39\22646 Singapore Dec 1995 6 J  H an an d Y  F u  Disco v e ry o f mu ltip le-le v el asso ciatio n r u l es from large databases In Proc VLDB  pages 420\226431 1995 7 Z  N  L i  O R Z a 250 021ane and Z Tauber Illumination invariance and object model in content-based image and video retrieval Journal of Visual Communication and Image Representation  10\(3\:219\226244 September 1999 8 R  M iller a n d Y  Y a n g  Asso ciatio n r u l es o v e r i n t erv a l d ata In Proc ACM-SIGMOD  pages 452\226461 Tucson 1997 9 A  N atse v  R Rasto g i  a n d K Sh im W ALR U S A s imilar ity retrieval algorithm for image databases In Proc ACMSIGMOD  pages 395\226406 Philadelphia 1999  R Ng L  V  S  L akshmanan J  H an a nd A Pang E x ploratory mining and pruning optimizations of constrained associations rules In Proc ACM-SIGMOD  Seattle 1998 11 R Srik an t a n d R Ag ra w a l M i n i n g q u a n titati v e asso ciatio n rules in large relational tables In Proc ACM-SIGMOD  pages 1\22612 Montreal 1996  P  S t ol or z H  N a kamur a  E  M esr obi an R  M unt z E  S h ek J Santos J Yi K Ng S Chien C Mechoso and J Farrara Fast spatio-temporal data mining of large geophysical datasets In Proc Int Conf on KDD  pages 300\226305 1995  O  R  Z a 250 021ane Resource and Knowledge Discovery from the Internet and Multimedia Repositories  PhD thesis School of Computing Science Simon Fraser University March 1999  O  R  Z a 250 021ane,J.Han,Z.-N.Li,J.Y.Chiang,andS.Chee MultiMediaMiner A system prototype for multimedia data mining In Proc ACM-SIGMOD  Seattle 1998  O  R  Z a 250 021ane J Han Z.-N Li and J Hou Mining multimedia data In CASCON'98 Meeting of Minds  Toronto 1998 


18001  balancing mechanism which requires further investi gation 4.5 Speedup Figure 12 shows the speedup ratio for pass 2 vary ing the number of processors used, 16 32 48 and 64 where the curve is normalized with the 16 processor execution time The minimum support value was set to 0.4 4.5 0.5 1 1 0 I 10 20 30 40 50 60 70 number of mxessors Figure 12 Speedup curve NPA HPA and HPA-ELD attain much higher lin earity than SPA HPA-ELD an extension of HPA for extremely large itemset decomposition further in creases the linearity HPA-ELD attains satisfactory speed up ratio This algorithm just focuses on the item distribution of the transaction file and picks up the extremely frequently occurring items Transferring such items could result in network hot spots HPA-ELD tries not to send such items but to process them locally. Such a small mod ification to the original HPA algorithm could improve the linearity substantially 4.6 Effect of increasing transaction Figure 13 shows the effect of increasing transac tion database sue as the number of transactions is increased from 256,000 to 2 million transactions We used the data set t15.14 The behavior of the results does not change with increased database size The minimum support value was set to 0.4 The num ber of processors is kept at 16 As shown each of the parallel algorithms attains linearity 5 Summary and related work In this paper we proposed four parallel algorithms for mining association rules A summary of the four database size Sizeup 0 I 0 500 loo0 1500 uxw amount of transaction thousands Figure 13 Sizeup curve algorithms is shown in Table 5 In NPA the candi date itemsets are just copied amongst all the proces sors Each processor works on the entire candidate itemsets NPA requires no data transfer when the supports are counted However in the case where the entire candidate itemsets do not fit within the mem ory of a single processor the candidate itemsets are divided and the supports are counted by scanning the transaction database repeatedly Thus Disk 1/0 cost of NPA is high PDM, proposed in 6 is the same as NPA which copies the candidate itemsets among all the processors Disk 1/0 for PDM should be also high The remaining three algorithms SPA HPA and HPA-ELD partition the candidate itemsets over the memory space of all the processors Because it better exploits the total system's memory, disk 1/0 cost is low SPA arbitrarily partitions the candidate itemsets equally among the processors Since each processor broadcasts its local transaction data to all other pro cessors the communication cost is high HPA and HPA-ELD partition the candidate itemsets using a hash function which eliminates the need for transac tion data broadcasting and can reduce the comparison workload significantly HPA-ELD detects frequently occurring itemsets and handles them separately which can reduce the influence of the workload skew 6 Conclusions Since mining association rules requires several scans of the transaction file its computational requirements are too large for a single processor to have a reasonable response time This motivates our research In this paper we proposed four different parallel algorithms for mining association rules on a shared nothing parallel machine and examined their viabil 29 


Table 5 characteristics of algorithms ity through implementation on a 64 node parallel ma chine the Fujitsu AP1000DDV If a single processor can hold all the candidate item sets parallelization is straightforward It is just suf ficient to partition the transaction over the proces sors and for each processor to process the allocated transaction data in parallel We named this algo rithm NPA However when we try to do large scale data mining against a very large transaction file the candidate itemsets become too large to fit within the main memory of a single processor In addition to the size of a transaction file a small minimum support also increases the size of the candidate itemsets As we decrease the minimum support computation time grows rapidly but in many cases we can discover more interesting association rules SPA HPA and HPA-ELD not only partition the transaction file but partition the candidate itemsets among all the processors We implemented these al gorithms on a shard-nothing parallel machine Per formance evaluations show that the best algorithm HPA-ELD attains good linearity on speedup by fully utilizing all the available memory space which is also effective for skew handling At present we are doing the parallelization of mining generalized association rules described in 9 which includes the taxonomy is-a hierarchy Each item belongs to its own class hierarchy In such mining associations between the higher class and the lower class are also examined Thus the candidate itemset space becomes much larger and its computation time also takes even longer than the naive single level association mining Parallel pro cessing is essential for such heavy mining processing Acknowledgments This research is partially supported as a priority research program by ministry of education We would like to thank the F\221ujitsu Parallel Computing Research Center for allowing us to use their APlOOODDV sys tems References l R.Agrawal T.Imielinski and ASwami 223Min ing Association Rules between Sets of Items in Large Databases\224 In Proc of the 1993 ACM SIGMOD International Conference on Manage ment of Data pp207-216 May 1993 2 R.Agrawal and RSrikant 223Fast Algorithms for Mining Association Rules\224 In Proc of the 20th International Conference on Very Large Data Bases pp.487-499 September 1994 3 J.S.Park M.-S.Chen and P.S.Yu 223An Effec tive Hash-Based Algorithm for Mining Associ ation Rules\224 In Proc of the 1995 ACM SIG MOD International Conference on the Manage ment of Data SIGMOD Record Vo1.24 pp.175 186 June 1995 4 H.Mannila H.Toivonen and A.I.Verkamo 223Ef ficient Algorithms for Discovering Association Rules\224 In KDD-94:AAAI Workshop on Knowl edge Discovery in Databases pp.181-192 July 1994 5 A.Savasere, E.Omiecinski and S.Navathe 223An Effective Algorithm for Mining Association Rules in Large Databases\224 In Proc of the 21th International Conference on Very Large Data Bases pp.432-444 September 1995 6 J.S.Park M.-S.Chen and P.S.Yu 223Efficient Parallel Data Mining for Association Rules\224 In Proc of the 4th International Conference on In formation and Knowledge Management pp.31 36 November 1995 7 T.Shintani and M.Kitsuregawa 223Considera tion on Parallelization of Database Mining\224 In Institute of Electronics Information and Com munication Engineering Japan SIG CPS Y95 88 Technical Report Vo1.95 No.47 pp.57-62 December 1995 8 T.Shimizu T.Horie and H.Ishihata 223Perfor mance Evaluation of the APlOOO Effects of message handling broadcast and barrier syn chronization on benchmark performance-\224  In S WO PP 22292 9.2 ARC 95 Information Processing Society of Japan Vo1.92 No.64 1992 9 R.Srikant and R.Agrawal 223Mining Generalized Association Rules\224 In Proc of the 21th Inter national Conference on Very Large Data Bases pp.407-419 September 1995 30 


Plenary Panel Session 30 XML Databases   Moderator: Michael Carey, IBM Almaden Research Center USA Panelists Adam Bosworth, Microsoft Corporation USA David De Witt University of Wisconsin-Madison, USA Alon Levy University of Washington USA Bruce Lindsay IBM Almaden Research Center USA Jennifer Widom Stanford University USA Demo Session 1 Web Query Optimizer  661 V Zadorozhny L Bright L Raschid T Urhan and M Vidal ReQueSS: Relational Querying of Semi-structured Data  664 R Sunderraman The IDEAL Approach to Internet-Based Negotiation for E-Business  666 J Hammer C Huang Y Huang C Pluempitiwiriyawej M Lee H Li L Wang Y Liu and S Su READY A High Performance Event Notification Service  668 R Gruber B Krishnamurthy, and E Panagos A Multimedia Information Server with Mixed Workload Scheduling  670 G Nerjes DISIMA An Object-Oriented Approach to Developing an Image Database System  672 V Oria T Ozsu P Iglinski B Xu and L Cheng Demo Session 2 The Collaboration Management Infrastructure  677 H Schuster D Baker A Cichocki D Georgakopoulos and M Rusinkiewicz Assisting the Integration of Taxonomic Data The LITCHI Toolkit  679 I Sutherland J Robinson S Brandt A Jones S Embury W Gray R White and F Bisby TheaterLoc: Using Information Integration Technology to Rapidly Build Virtual Applications  681 G. Barish Y.4 Chen D Dipasquo, C Knoblock S Minton I Muslea and C Shahabi Lineage Tracing in a Data Warehousing System  683 Y Cui and J Widom xiii 


The Mentor-Lite Prototype A Light-Weight Workflow Management System  685 J Weissenfels M Gillmann 0 Roth, G Shegalov and W Wonner Location Prediction and Queries for Tracking Moving Objects  687 0 Wolfson B Xu and S Chamberlain Semiorder Database for Complex Activity Recognition in Multi-Sensory Environments  689 S Bhonsle A Gupta S Santini and R Jain Tutorial 1 Web Information Retrieval  693 M Henzinger Tutorial 2 Mobile and Wireless Database Access for Pervasive Computing  694 P Chrysanthis and E Pitoura Tutorial 3 Data Mining with Decision Trees  696 J Gehrke Tutorial 4 Directories Managing Data for Networked Applications  697 D Srivastava Tutorial 5 Indexing High-Dimensional Spaces Database Support for Next Decade\222s Applications  698 S Berchtold and D Keim xiv 


 T5.I2.D100K T10.I4.D100K T15.I4.D100K T10.I6.D400K T10.I6.D800K T10.I6.D1600K Optimizations across Databases 5 0 5 10 15 20 25 30 35 40 45 Improvement COMP TREE COMP-TREE 1 2 4 8 1 2 4 8 1 2 4 8 2 4 8 2 4 8 1 2 4 8 Processors Databases Figure 5 Effect of Computation and Hash Tree Balancing good as the COMP optimization The reason that the hash tree balancing is not suf\336cient to offset inherent load imbalance in the candidate generation in this case The most effective approach is to apply both optimizations at the same time COMP-TREE The combined effect is suf\336cient to push the improvements in the 40 range in the multiple-processor case On 1 processor only hash tree balancing is bene\336cial since computation balancing only adds extra cost 5.4 Short-circuited Subset Checking Figure 6 shows the improvement due to the short-circuited subset checking optimization with respect to the unoptimized version The unoptimized version is the Apriori algorithm due to Agrawal et al 5 The results are presented for dif ferent number of processors across dif ferent databases The results indicate that while there is some improvement for databases with small transaction sizes the optimization is most effective when the transaction size is large In this case we get improvements of around 25 r the unoptimized version To gain further insight into this optimization consider 336gure 7 It shows the percentage improvement obtained per iteration on applying this optimization on the T20.I6.D100K database It shows results only for the uni-processor case r similar results were obtained on more processors We observe that as the iteration k increases there is more opportunity for shortcircuiting the subset checking and we get increasing bene\336ts of up to 60 The improvements start to fall off t the high end where the number of candidates becomes small resulting in a small hash tree and less opportunity for short-circuiting It becomes clear that is an extremely effective 15 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 T5.I2.D100K T10.I6.D800K T15.I4.D100K T20.I6.D100K procs across Databases 0 5 10 15 20 25 Improvement 1 2 4 8 Figure 6 Effect of Short-circuited Subset Checking 23456789101112 Iterations 0 10 20 30 40 50 60 improvement T20.I6.D100K Figure 7  Improvement per Iteration  proc   16 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


optimization for larger transaction sizes and in cases where there are large number of candidate k itemsets 6 Conclusions In this paper e presented a parallel implementation of the Apriori algorithm on the SGI Power Challenge shared memory multi-processor We also discussed a set of optimizations which include optimized join and pruning computation balancing for candidate generation hash tree balancing and short-circuited subset checking We then presented experimental results on each of these Improvements of more than 40 were obtained for the computation and hash tree balancing The short-circuiting optimization was found to be extremely effective for databases with large transaction sizes Finally we reported the parallel performance of the algorithm While we d good speed-up we observed a need for parallel I/O techniques for further performance gains References  R Agra wal T  Imielinski and A Swami Database mining A performance perspecti v e  I n IEEE Trans on Knowledge and Data Engg  pages 5\(6 1993  R Agra wal T  Imielinski and A Swami Mining association rules between sets of items in lar ge databases In Proc M SIGMOD Intl Conf Management of Data  May 1993  R Agra wal H Mannila R Srikant H T o i v onen and A I V erkamo F ast disco v ery of association rules In U F et al editor Advances in Knowledge Discovery and Data Mining  MIT Press 1996  R Agra wal and J Shafer  P arallel mining of association rules design implementation and e xperience Technical Report RJ10004 IBM Almaden Research Center San Jose CA 95120 Jan 1996  R Agra wal and R Srikant F ast algorithms for mining association rules In Proc 20th VLDB Conf  Sept 1994  M Cierniak W  Li and M J Zaki Loop scheduling for heterogeneity  I n 4th IEEE Intl Symposium on High-Performance Distributed Computing also as URCS-TR 540 CS Dept Univ f Rochester  Aug 1995  M Holsheimer  M  K ersten H Mannila and H T o i v onen A perspecti v e on databases and data mining In 1st Intl Conf Knowledge Discovery and Data Mining  Aug 1995  M Houtsma and A Swami Set-oriented mining of association rules In RJ 9567  IBM Almaden Oct 1993  H Mannila H T o i v onen and I V erkamo Ef 336cient algorithms for disco v ering association rules In AAAI Wkshp Knowledge Discovery in Databases  July 1994  J S P ark M Chen and P  S Y u  A n e f fecti v e hash based algorithm for mining association rules In Proc M SIGMOD Intl Conf Management of Data  May 1995 17 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 J S P ark M Chen and P  S Y u  E f 336cient parallel data mining for association rules T echnical Report RC20156 IBM T J Watson Research Center Aug 1995  G Piatetsk y-Shapiro Disco v ery  presentation and analysis of strong rules In G P S et al editor  KDD  AAAI Press 1991  A Sa v asere E Omiecinski and S Na v athe An ef 336cient algorithm for mining association rules in large databases In Proc 21st VLDB Conf  1995  M J Zaki M Ogihara S P arthasarathy  and W  Li P arallel data mining for association rules on shared-memory multi-processors Technical Report 618 Department of Computer Science University of Rochester 618 1996 18 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


