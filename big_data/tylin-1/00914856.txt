Mining Frequent Itemsets with Convertible Constraints  Jian Pei Jiawei Han Simon Fraser University Burnaby, B.C., Canada V5A 1 S6  peijian han cs.sfu.ca Abstract Recent work has highlighted the importance of the constraint-based mining paradigm in the context offrequent itemsets associations correlations sequential patterns and many other interesting patterns in large databases In this paper we study constraints which cannot be han dled with existing theory and techniques For example avg\(S 0 U median\(S 0 U sum\(S 0 v S can 
con tain items of arbitrary values 0 E   s are customar ily regarded as 223tough 222\222 constraints in that they cannot be pushed inside an algorithm such as Apriori We develop a notion of convertible constraints and systematically analyze classib and characterize this class We also develop tech niques which enable them to be readily pushed deep inside the recently developed FP-growth algorithm for frequent itemset mining Results from our detailed experiments show the effectiveness of the techniques developed 1 Introduction It has been well recognized that 
frequent pattern min ing plays an essential role in many important data mining tasks However frequent pattern mining often generates a very large number of frequent itemsets and rules which re duces not only the efficiency but also the effectiveness of mining since users have to sift through a large number of mined rules to find useful ones Recent work has highlighted the importance of the paradigm of constraint-based mining the user is allowed to express his focus in mining by means of a rich class of constraints that capture application semantics Besides al lowing user exploration and control the paradigm allows many of these 
constraints to be pushed deep inside mining thus pruning the search space of patterns to those of interest to the user and achieving superior performance Itemset constraints have been incorporated into associ ation mining IO A systematic method for the incorpo ration of two large classes of constraints-anti-monotone 221The work was supported in part by grants from the Natural Sciences and Engineering Research Council of Canada and the Networks of Centres of Excellence of Canada \(NCWIRIS-3 Laks V.S Lakshmanan Concordia University  IIT  Bombay Montreal, Quebec  Mumbai 
India laks  it.iitb.ernet.in and succinct-in frequent itemset mining is presented in 7 61 A method for mining association rules in large dense databases by incorporation of user-specified con straints that ensure every mined rule offers a predictive ad vantage over any of its simplifications, is developed in 2 Constraint-based mining of correlations by exploration of anti-monotonicity and succinctness as well as monotonic ity is studied in 4 While previous studies cover a large class of useful constraints many other useful and natural constraints re main For example consider the constraints 
avg\(S 0 v median\(S B v and sum\(S 0 v 0 E I The first two are neither anti-monotone, nor monotone nor succinct The last one is anti-monotone when 0 is 5 and all items have non-negative values If S can contain items of arbi trary values sum\(S 5 v is rather like the first two con straints Intuitively this means these constraints are hard to optimize In this paper we investigate a whole class of constraints that subsumes these examples The 
main idea is that constraints that exhibit no nice properties do so in the presence of certain item orders. We make the following contributions 0 We introduce Section 3 the concept of convert ible constraints and classify them into three classes convertible anti-monotone convertible monotone and strongly convertible This covers a good number of useful constraints which were previously regarded tough, including all the examples above 0 We characterize Section 3 the class of convertible constraints using the notion of prejix monotone func tions and study the arithmetical closure properties of such functions As 
a byproduct we can show that large classes of constraints involving arithmetic are convert ible e.g maz\(S S  v is convertible anti monotone and median\(S  min\(S  v is convert ible monotone 0 We show that convertible constraints cannot be pushed deep into the basic Apriori framework However, they can be pushed deep into the frequent pattern growth mining We thus develop Section 4 algorithms for fast mining of frequent itemsets satisfying the various constraints 0 We report our results from a detailed set of experi 433 1063-6382/01$10.00 0 2001 IEEE 


ments which show the effectiveness of the algorithms developed\(Section 5 and finally we conclude the study in Section 7 Transaction ID 10 20 30 40 2 Problem Definition Frequent Itemset Min ing with Constraints Items in transaction a b c d f b c d f 7 g h a c d e f c e f 99 Let I  ill i2  im be a set of all items where an item is an object with some predefined attributes e.g price weight etc A transaction T  tid It is a tuple where tid is the identijier of the transaction and It G I A transac tion database 7 consists of a set of transactions An itemset S 2 I is a subset of the set of items A k-itemset is an itemset of size k We write itemsets as S  ijl ij2  ijk omitting set brackets An itemset S is contained in a transaction T  tid It if and only if S G It The support sup S of an itemset S in a transaction database 7 is the number of transactions in 7 containing S Given a support threshold  1 5 5 IT an itemset S is frequent provided sup\(S 2  A constraint C is a redicate on the powerset of the set satisfies a constraint C if and only if C\(S is true The set of itemsets satisfying a constraint C is satc I   S I S G I A C\(S  true We call an itemset in satc\(1 valid Problem definition Given a transaction database 7 a support threshold  and a set of constraints C the prob lem of mining frequent itemsets with constraints is to find the complete set of frequent itemsets satisfying C i.e find Fc  s I s E satc\(I A up\(S 2  of items I i.e C  2 P  true false An itemset S Many kinds of constraints can be associated with fre quent itemset mining Two categories of constraints suc cinctness and anti-monotonicity were proposed in 7 61 whereas the third category monotonicity was studied in 3 4 81 in the contexts of mining correlated sets and fre quent itemsets We briefly recall these notions below 2 3 4 acdf bcdf  ac ad a f bc, bd bf,'cd c,,'cf cg df e f fg acd acf I adf I bed bcf 9 bdf I cdf I cef 7 cfg  Definition 2.1 Anti-monotone, Monotone, and Succinct Constraints A constraint C is anti-monotone if and only if whenever an itemset S violates C so does any superset of S A constraint Cm is monotone if and only if when ever an itemset S satisfies C so does any superset of S Succinctness is defined in steps as follows 0 An itemset I C I is a succinct set if it can be ex pressed as ap I for some selection predicate p where U is the selection operator 0 SP G 2 is a succinct powerset if there is a fixed number of succinct sets 11  I   Ik I such that SP can be expressed in terms of the strict powersets of I1      Ik using union and minus 0 Finally a constraint C is succinct provided satc I is a succinct powerset We can show the following result Theorem 2.1 A constraint C is both anti-monotonic and monotonic ifand only ifC\(S true for all itemset S or C\(S Theorem 2.2 Every succinct constraint involving only ag gregate functions can be expressed using conjunction and/or disjunction of monotone and anti-monotone con stra ints false for all itemset S Table 2 Frequent itemsets with support threshold  2 in transaction database 7 in Table 1 Let each item have an attribute value such as profit with the concrete value shown in Table 3 In all constraints such as sum\(S B w we implicitly refer to this value Table 3 The values such as profit\of items in Ex ample 1 The constraint range\(S 5 15 requires that for an itemset S the value range of the items in S must be no greater than 15 It is an anti-monotone constraint in the sense that if an itemset say ab violates the constraint any of its supersets will violate it and thus ab can be re moved safely from the candidate set during an Apriori-like frequent itemset mining process 7 However the con straint Cavg  awg\(S  25 is not anti-monotone nor monotone nor succinct which can be verified by read ers For example avg\(df  10  30  25 vio 434 


lates the constraint However, upon adding one more item a awg\(adf  40  10  30  25 adf satisfies Cawg This example scratches the surface of a large class of useful constraints involving awg median etc as well as arithmetic Exploiting them in mining calls for new tech niques, which is the subject of this paper 3 Convertible Constraints and Their Classifi cation Before introducing the concept of convertible constraint we motivate it with an example Example 2 Suppose we wish to mine frequent itemsets over transaction database 7 in Table 1 with the support threshold e  2 and with constraint C E uwg\(S  25 The complete set of frequent itemsets satisfying C can be obtained by first mining the frequent itemsets without using the constraint i.e Table 2 and then filtering out those not satisfying the constraint. Since the constraint is neither anti monotone, nor monotone, nor succinct, it cannot be directly incorporated into an Apriori-style algorithm E.g itemset fg satisfies the constraint, while its subset g and its superset dfg do not If we arrange the items in value-descending order U f g d b h c e we can observe an interesting property as follows Writing itemsets w.r.t this order leads to a no tion of a prefix E.g a f d has a f and a as its prefixes Interestingly the average of an itemset is no more than that of its prefix according to this order 3.1 Convertible Constraints The observation made in Example 2 motivates the fol lowing definition We will frequently make use of an order\222 over the set of all items and assume itemsets are written ac cording to this order Definition 3.1 Prefix itemset Given an order R over the set of items I an itemset S\222  ilia  il is called aprejix of itemset S  ili2  i w.r.t R where I 5 m and items in both itemsets are listed according to order R S\222 is called a properprejix of S if 1  m We next formalize convertible constraints as follows Definition 3.2 Convertible Constraints A constraint C is convertible anti-monotone provided there is an order R on items such that whenever an itemset S satisfies C so does any prefix of S It is convertible monotone provided there is an order R on items such that whenever an item set S violates C so does any prefix of S A constraint is convertible whenever it is convertible anti-monotone or monotone   221Unless otherwise stated every order used in this paper is assumed to be total over the set of items Note that any anti-monotone resp monotone con straint is trivially convertible anti-monotone resp., convert ible monotone just pick any order on items Example3 We show uwg\(S 0 w where 0 E L  is a convertible constraint Let R be the value-descending order Given an item set S  ala   satisfying the constraint uwg\(S  w where items in S are listed in the order R For each prefix S\222=al...akofS\(lIk<I ak+l  al-1 2 a we have avg\(S\222 2 avg\(S\222 U ak+l 2   awg\(S 2 w This implies S\222 also satisfies the constraint So constraint awg\(S 2 w is convertible anti-monotone Similarly it can be shown that constraint awg\(S 5 w is convertible monotone Interestingly if the order R-l i.e the reversed order of R is used the constraint awg\(S  w can be shown convertible monotone For lack of space we leave this as an exercise to the reader In summary constraint uwg\(S 0 w is convertible con straint Furthermore, there exists an order R such that the constraint is convertible anti-monotone w.r.t R and con vertible monotone w.r.t R-\222 As another example let us examine the constraints with function sum\(S Example4 Constraint sum\(S 5 w is anti-monotone if items are all with non-negative values However if items are with negative zero or positive values the constraint be comes neither anti-monotone, nor monotone nor succinct Curiously this constraint exhibits a 223piecewise\224 con vertible monotone or anti-montone behavior If w _ 0 in the constraint the constraint is convertible anti-monotone w.r.t item value ascending order Given an itemset S  ala2  a such that sum\(S 5 w where items are listed in value ascending order For a prefix S\222  ala   aj 1 5 j 5 I if aj 5 0 that means a1 5 a2 5  5 aj-1 5 aj 5 0 So sum\(S\222 5 0 5 w On theother hand if aj  0 we have 0  aj 5 aj+l 5   5 al Thus sum\(S\222  sum\(,\224  sum\(aj+l  U  w Therefore sum\(,!?\222 5 w in both cases which means S\222 satisfies the constraint If w 5 0 in the constraint it becomes convertible mono tone w.r.t item value descending order We leave it to the reader to verify this Similarly we can also show that if items are with nega tive zero or positive values constraint sum\(S 2 w is con vertible monotone w.r.t value ascending order when w  0 and convertible anti-monotone w.r.t value descending order when U 5 0 The following lemma can be proved with a straightfor ward induction Lemma 3.1 Let C be a constraint over a set of items I 1 C is convertible anti-monotone if and only if there ex ists an order R over I such that for every itemset S 435 


anditem a E Isuch thatVx E S,x R a C\(SU a implies C\(S 2 C is convertible monotone if and only if there exists an order R over I such that for every itemset S and item a E I such that Vx E S x R a C\(S implies C\(S U a The notion of prefix monotone functions, introduced be low is helpful in determining the class of a constraint We denote the set of real numbers as R Definition 3.3 Prefix monotone functions Given an or der R over a set of items I a function f  2  R is a prefix monotonically increasing function w.r.t R if and only if for every itemset S and its prefix S w.r.t R f\(S 5 f\(S A function g  2  R is called a prejx monotonically decreasing function w.r.t R if and only if for every itemset S and its prefix S w.r.t R g\(S L g\(S We have the following lemma on the determination of prefix monotone functions The proof is similar to that of Lemma 3.1 Lemma 3.2 Given an order R over a set of items I 1 A function f  2  R is a prejx decreasing function w.~t R if and only iffor every itemset S and item a such that Vz E S 2 R a f\(S 2 f S U a 2 A function g  2  R is a prejx increasing function w.~t 72 if and only iffor every itemset S and item a suchthatV.cE S,zRa,g\(S ig\(SU{u It turns out that prefix monotone functions satisfy inter esting closure properties with arithmetic. An understanding of this would shed light on characterizing a whole class of convertible functions involving arithmetic The following theorem establishes the arithmetical closure properties of prefix monotone functions We say a function f  2  R is positive, provided VS C 1  f\(S  0 Theorem 3.1 Let f and f be pre$x decreasing functions and g and g be prefix increasing functions w.~t an order 72 respectively Let c be a positive real number 1 Functions f\(S  c.g\(S andg\(S g'\(S are prefi increasing functions Functions g\(S  c f S and f S f S are pre$x decreasing functions 2 rf f and g are positive functions then f S x f S is prefix decreasing, and g\(S x g'\(S is prejix increas ing 3 A constraint h\(S 2 U resp h\(S 5 U is convertible anti-monotone resp monotone ifand only if h prefi decreasing Similarly h\(S 2 U resp h\(S 5 w is convertible monotone resp., anti-monotone if and only ifh is prejx increasing Example 5 As an illustration, notice that uvg\(S is a pre fix decreasing function w.r.t value-descending order and aug\(S 2 20 is convertible anti-monotone w.r.t the same order Also max\(S is a prefix increasing function w.r.t this order From Theorem 3.1 it follows that l/uvg\(S is prefix increasing and hence max\(S S is prefix increasing Consequently we immediately deduce that max\(S S 5 U is convertible anti-monotone w.r.t this order We know from Theorem 2.2 that a succinct constraint can be expressed in terms of conjunction and/or disjunction of anti-monotone and monotone constraints By definition every monotone/anti-monotone is convertibly so A natural question is what is the relationship between succinct con straints and convertible constraints The following theorem settles this question Theorem 3.2 Every succinct constraint is either anti monotone or monotone or convertible Proof Sketch The proof of the theorem is constructed by induction on the structure of satc\(I of a succinct con straint C according to the definition of succinctness 3.2 Strongly convertible constraint Some convertible constraints have the additional desir able property that w.r.t an order R they are convertible anti monotone, while w.r.t its inverse R-l they are convertible monotone E.g aug\(S 5 w is convertible monotone w.r.t value ascending order and convertible anti-monotone w.r.t value descending order see also Example 3 This property provides great flexibility in data mining query op timization Definition 3.4 \(Strongly convertible constraint A con straint C is called a strongly convertible constraint pro vided there exists an order R over the set of items such that C is convertible anti-monotone w.r.t R and convertible monotone w.r.t R-I Notice that median\(S 0 U 0 E  is also strongly convertible Clearly not every convertible con straint is strongly convertible E.g ma;c\(S S 5 U is convertible anti-monotone w.r.t value descending order when all items have a non-negative value. However it is not convertible monotone w.r.t value ascending order The following lemma links strongly convertible con straints to prefix monotone functions Lemma 3.3 Constraint f S 0 U is strongly convertible, if and only ifthere exists an order R over the set of items such that f is a prefi decreasing function w.Kt R and a prejx increasingfunction w.rt R 21t is also prefix decreasing w.r.t this order 3Assuming all items have non-negative values 41t says the proportion of the max price of any item in the itemset over the average price of the items in the set cannot go over certain limit 436 


For example avg\(S and median\(S are both prefix de creasing w.r.t value descending order and prefix increasing w.r.t value ascending order There still exist some constraints that cannot be pushed by item ordering For example the constraint avg\(S  median\(S  O5 does not admit any natural ordering on items w.r.t which it is convertible We call such constraints inconvertible 3.3 Summary: a classification on constraints As a general picture, constraints only involving aggre gate functions can be classified into the following cate gories according to their interactions with the frequent item set mining process anti-monotone monotone, succinct and convertible which in turn can be subdivided into convert ible anti-monotone and convertible monotone The inter section of the last two categories is precisely the class of strongly convertible constraints \(which can be treated either as convertible anti-monotone or monotone by ordering the items properly Figure 1 shows the relationship among the various classes of constraints ccmvcmhlc wnvcnihle convenihle Figure 1 A classification of constraints and their re lationships Some commonly used convertible constraints are listed in Table 4 4 Mining Algorithms In this section, we explore how to mine frequent itemsets with convertible constraints efficiently The general idea is to push the constraint into the mining process as deep as possible, thereby pruning the search space In Section 4.1 we first argue that the Apriori algorithm cannot be extended to mining with convertible constraints efficiently Then a new method is proposed by examining an example Section 4.2 presents the algorithm 31Cd for mining frequent itemsets with convertible anti-monotone constraints Algorithm FIC which computes the com plete set of frequent itemsets with convertible monotone constraint, is given in Section 4.3 Section 4.4 discusses mining frequent itemsets with strongly convertible con straints The constraint requires the median item in the itemset is with the av erage value 4.1 Mining frequent itemsets with convertible con straints An example We first show that convertible constraints cannot be pushed deep into the Apriori-like mining Remark 4.1 A convertible constraint that is neither mono tone nor anti-monotone nor succinct cannot be pushed deep into the Apriori mining algorithm Rationale As observed earlier for such a constraint e.g avg\(S 5 v subsets \(supersets\of a valid itemset could well be invalid and vice versa Thus within the levelwise framework no direct pruning based on such a constraint can be made In particular whenever an invalid subset is eliminated without support counting its supersets that are not suffixes cannot be pruned using frequency For example itemset df in our running example violates the constraint avg\(S  25 However an Apriori-like al gorithm cannot prune such itemsets Otherwise, its superset adf which satisfies the constraint, cannot be generated Before giving our algorithms for mining with convertible constraints, we give an overview in the following example Example 6 Let us mine frequent itemsets with con straint C  avg\(S  25 over transaction database 7 in Table 1 with the support threshold   2 Items in every itemset are listed in value descending order R 40 f\(30 dzo 410 b\(O h\(-10 20 e\(-30 It is shown that constraint C is convertible anti-monotone w.r.t R The mining process is shown in Figure 2 R a-f-g-d-bc-e Figure 2 Mining frequent itemsets satisfying con straint avg\(S  25 By scanning 7 once we find the support counts for ev ery item Since h appears in only one transaction, it is an infrequent items and is thus dropped without further con sideration The set of frequent l-itemsets are a f g d b c and e listed in order R Among them, only a and f satisfy 431 


Constraint f\(S 5 v f is a prefix decreasing function I  Yes  f\(S 5 v f is a prefix increasing function Yes   Convertible Convertible Strongly anti-monotone monotone convertible Table 4 Characterization of some commonly used SQL-based convertible constraints  means it depends on the specific constraint the constraint6. Since C is a convertible anti-monotonecon straint, itemsets having g d b c or E as prefix cannot satisfy the constraint. Therefore, the set of frequent itemsets satis fying the constraint can be partitioned into two subsets 1 The ones having itemset a as a prefix w.r.t 2232 i.e 2 The ones having itemset f as a prefix w.r.t 2 i.e those containing item a and those containing item f but no n The two subsets form two projected databases 5 which are mined respectively 1 Find frequent itemsets satisfying the constraint and having a as a prefix First n is a frequent itemset satisfying the constraint Then the frequent itemsets having a as a proper prefix can be found in the sub set of transactions containing n which is called n projecred database Since n appears in every transac tion in the a-projected database it is omitted The n projected database contains two transactions bcdf and cde f Since items b and e is infrequent within this pro jected database, neither ab nor ne can be frequent So they are pruned The frequent items in the a-projected database is f d c listed in the order R Since nc does not satisfy the constraint there is no need to create an ac-projected database To check what can be mined in the a-projected database with af and ad as prefix respectively we need to construct the two projected databases and mine them This process is similar to the mining of a projected databases The a f projected database con tains two frequent items d and c and only a fd satisfy the constraint. Moreover since a f dc does not satisfies the constraint the process in this branch is complete Since a fc violates the constraint there is no need to construct a f c-projected database The ad-projected database contains one frequent item c but adc does not satisfy the constraint Therefore the set of fre quent itemsets satisfying the constraint and having a as prefix contains a a f a f d and ad 221The fact that itemset g does not satisfy the constraint implies none of any I-itemsets after g in order R can satisfy the constraint avg 2 Find frequent itemsets satisfying the constraint and having f as a prefix Similarly the f-projected database is the subset of transactions containing f with both n and f removed It has four transactions bcd bcd!y C~E and ceg The frequent items in the pro jected database are g d 6 c e listed in the order of\221R Since only itemsets fg and fd satisfy the constraint we only need to explore if there is any frequent item set having f!g or fd as a proper prefix which satisfies the constraint The projected fg-database contains no frequent itemset with fg as a proper prefix that sat isfies the constraint Since b is the item immediately after d in order K and fdb violates the constraint any itemset having fd as a proper prefix cannot satisfy the constraint Thus f and fg are the only two frequent itemsets having f as a prefix and satisfying the con strain t In summary the complete set of frequent itemsets satis fying the constraint contains 6 itemsets n f af nd nfd fg Our new method generates and tests only a small set of itemsets 4.2 FXd Mining frequent itemsets with convert ible anti-monotone constraint Now let us justify the correctness and completeness of the mining process in Example 6 First we show that the complete set of frequent itemsets satisfying a given convertible anti-monotone constraint can be partitioned into several non-overlapping subsets It leads to the soundness of our algorithmic framework Lemma 4.1 Consider a transaction database 7 a support threshold and a convertible anti-monotone constraint C w.~t an order 72 over a set of itenis I Let al a   a be the itenis satisfying C The coniplete set offrequent item sets satisjj!ing C can be partitioned into in disjoint subsets the jth subset 1 5 j 5 m contains frequent itemsets sat isfying C and having aj as a prejix We mine the subsets of frequent itemsets satisfying the constraint by constructing the corresponding projected database 438 


Definition 4.1 Projected database Given a transaction database 7 an itemset a and an order R 1 Itemset p is called the max-prefix projection of trans action tid It E 7 w.r.t R if and only if 1 a C It and p C It 2 a is a prefix of j3 w.r.t R and 3 there exists no proper superset y of p such that y 5 It and y also has a as a prefix w.r.t R 2 The a-projected database is the collection of max prefix projections of transactions containing a w.r.t R Remark4.2 Given a transaction database 7 a support threshold  and a convertible anti-monotone constraint C Let a be a frequent itemset satisfying C The complete set of frequent itemsets satisfying C and having a as a prefix can be mined from the a-projected database The mining process can be further improved by the fol lowing lemma Definition 4.2 \(Ascending and descending orders An order R over a set of items I is called an ascending order for function h  2  R if and only if 1\for items a and b h\(a  h\(b implies a R 6 and 2 for itemsets a U a and a U b such that both of them have a as a prefix and a R b f\(a U a 5 f\(a U b R-l is called a descending order for function h For example, it can be verified that the value ascending order is an ascending order for function aug\(S and a de scending order for function maz\(S S Lemma 4.2 Given a convertible anti-monotone constraint C E f\(S 6 v 6 E I w.bt ascending/descending order R over a set of items I where f is a prefix function Let a be a frequent itemset satisfying C and al a2    a be the set of frequent items in a-projected database listed in the order of R 1 Ifitemset a U ai 1 5 i  m violates C forj such that i  j 5 m itemset Q U  aj also violates C 2 If itemset a U aj 1 5 j  m satisfies C but a U  aj  aj+l violates C no frequent itemset having a U  aj as a properprefi satisfies C Based on the above reasoning we have the algo rithm FICA as follows for mining Frequent ltemsets with  Convertible Anti-monotone constraints Algorithm 1 FICA Given a transaction database 7 a support threshold  and a convertible anti-monotone con straint C w.r.t an order R over a set of items I the algo rithm computes the complete set of frequent itemsets satis fying the constraint C Method Call fiea 0,T function fieQ a a is the itemset as prefix and 71 is the projected database 1 2 3 4 5 Scan 71 once find frequent items in 71 Let I be the set of frequent items within 71 such that Vu E I C\(a U a  true If I  0 return, else Vu E I output a U a as a frequent itemset satisfying the constraint If C is in form off S 8 where f is a prefix function and 0 E 5  using Lemma 4.2 to optimize the mining by removing items b from I such that there exists no frequent itemset satisfying C and having a U  b as a proper prefix Scan 71 once more Vu E I generate a U a projected database 71,u For each item a in II call fiea\(a U a 71au{a Rationale The correctness and completeness of the algo rithm has been reasoned step-by-step in this section The efficiency of the algorithm is that it pushes the constraint deep into the mining process so that we do not need to gen erate the complete set of frequent itemsets in most of cases Only related frequent itemsets are identified and tested As shown in Example 6 and in the experimental results the search space is decreased dramatically when the constraint is sharp 4.3 3X Mining frequent itemsets with mono tone constraints In the last two subsections an efficient algorithm for mining frequent itemsets with convertible anti-monotone constraints is developed. Under similar spirit an algorithm for mining frequent itemsets with convertible monotone constraints can also be developed Due to lack of space instead of giving details of formal reasoning, we illustrate the ideas using an example and then present the algorithm Example 7 Let us mine frequent itemsets in transaction database 7 in Table 1 with constraint C G avg\(S 5 20 Suppose the support threshold   2 In this example, we use the value descending order R exactly as is used in Ex ample 6 Constraint C is convertible monotone w.r.t order R After one scan of transaction database 7 the set of fre quent 1-itemsets is found Among the 7 frequent 1-itemsets g d 6 c and e satisfy the constraint C According to the definition of convertible monotone constraints, frequent itemset having one of these 5 itemsets as a prefix must also satisfy the constraint That is the g d b e and e projected database can be mined without testing constraint C because adding smaller items will only decrease the value of avg But a and f-projected databases should be mined with constraint C testing However as soon as its fre quent k-itemsets for any k satisfy the constraint, constraint checking will not be needed for further mining of their pro jected databases We present the algorithm TZCM for mining frequent itemsets with convertible monotone constraint as follows 439 


Algorithm 2 FIC Given a transaction database 7 a support threshold and a convertible monotone constraint C w.r.t an order R over a set of items I the algorithm com putes the complete set of frequent itemsets satisfying the constraint C Method Call ficm 0,7,1 function ticm TI check-flag 1 Scan 71 once find frequent items in TIa If check-flag is 1 let f be the set of frequent items within 71 such that Vu E I C\(a U a  true and 1 be the set of frequent items within 71 such that Vb E I C\(a U b  false If check-flag is 0 let I be the set of frequent items within 71 and I be 0 2 Vu E I output Y U a as a frequent itemset satisfy ing the constraint 3 Scan 71 once more Vu E fliUIl generate au{a projected database 71,u 4 Foreach itema inI~~,callfic,\(aU{a},7~au~a 0 Foreach itemainfI;,call fic,\(aU{a},71 1 Rationale The correctness and completeness of the algo rithm can be shown based on the similar reasoning in Sec tion 4.2 Here, we analyze the difference between 31CM with an Apriori-like algorithm using constraint-checking as post-processing Both F1CM and Apriori-like algorithms have to gener ate the complete set of frequent itemsets no matter whether the frequent itemsets satisfy the convertible monotone con straint The frequent itemsets not satisfying the constraint cannot be pruned. That is the inherent difficulty of convert ible monotone constraint The advantage of TICM a ainst Apriorix-like algo rithms lies in the fact that FIG only tests some of fre quent itemsets against the constraint. Once a frequent item set satisfies the constraint, it guarantees all of frequent item sets having it as a prefix also satisfy the constraint. There fore, all that testing can be saved An Apriori-like algorithm has to check every frequent itemset against the constraint In the situation such that constraint testing is costly such as spatial constraints, the saving over constraint testing could be non-trivial. Exploration of spatial constraints is beyond the scope of this paper 4.4 Mining frequent itemsets with strongly convert ible constraints The main value of strong convertibility is that the con straint can be treated either as convertible anti-monotone or monotone by choosing an appropriate order The main point to note in practice is when the constraint has a high selec tivity fewer itemsets satisfy it converting it into an anti monotone constraint will yield maximum benefits by search a is the itemset as prefix 71 is the a-projected database and check-flag is the flag for constraint checking space pruning When the constraint selectivity is low \(and checking it is reasonably expensive\then converting it into a monotone constraint will save considerable effort in con straint checking The constraint awg\(S  w is a classic example 5 Experimental Results To evaluate the effectiveness and efficiency of the algo rithms, we performed an extensive experimental evaluation In this section we report the results on a synthetic trans action database with IOOK transactions and 10K items The dataset is generated by the standard procedure described in l In this dataset the average transaction size and aver age maximal potentially frequent itemset size are set to 25 and 20 respectively The dataset contains a lot of frequent itemsets with various length This dataset is chosen since it is typical in data mining performance study The algorithms are implemented in C All the exper iments are performed on a 233MHz Pentium PC with 128MB main memory running Microsoft WindowsNT To evaluate the effect of a constraint on mining frequent itemsets we make use of constraint selectivity where the selectiviy S of a constraint C on mining frequent itemsets over transaction database 7 with support threshold is de fined as  of frequent itemsets NOT satisfying C  of frequent itemsets 6 Therefore a constraint with 0 selectivity means every fre quent itemset satisfies the constraint, while a constraint with 100 selectivity is the one cannot be satisfied by any fre quent itemset The selectivity measure defined here is con sistent with those used in 7,61 To facilitate the mining using projected databases we employ a data structure called FP-tree in the implementa tions of FICA and FIC FP-tree is first proposed in SI and also be adopted by 8,9 It is a prefix tree structure to record complete and compact information for frequent item set mining A transaction database/projected database can be compressed into an FP-tree while all the consequent projected databases can be derived from it efficiently We refer readers to 5 for details about FP-tree and methods for FP-tree-based frequent itemset mining Since FP-growth 5 is the FP-tree-based algorithm mining frequent itemsets and is much faster than Apriori we include it in our experiment. Comparison among FICA 3ZCM and FP-growth makes more sense than using pure Apriori as the only reference method 5.1 Evaluation of FZCA To test the efficiency of FZCd w.r.t constraint selec tivity in mining frequent itemsets with convertible anti monotone constraints, we run a test over the dataset with 440 


160 g 140 f 120 s 100 1 Figure 3 Scalability with constraint selectivity            A     FP-gmwth h FIC\(A 20 D FIC\(A 80  04 i 00 02 04 06 08 10 Support threshold Figure 4 Scalability with support threshold support threshold   0.1 The result is shown in Fig ure 3 Various settings are used in the constraint for various selectivities As can be seen from the figure 31CA achieves an al most linear scalability with the constraint selectivity As the selectivity goes up i.e fewer itemsets satisfy the con straint 31CA cuts more search space since one frequent itemset not satisfying the constraint means all frequent itemsets having it as a prefix can be pruned We compare the runtime of both Apriori and FP-growth in the same figure All these two methods first compute the complete set of frequent itemsets and then use the constraint as a filter So their runtime is constant w.r.t constraint selectivity However only when the constraint selectivity is 0 i.e every frequent itemset satisfies the constraint does FICA need the same runtime as FP-growth In all other situations FICA always requires less time We also tested the scalability of FZC\224 with support threshold and the number of transactions respectively The corresponding results are shown in Figure 4 and Figure 5 From these figures we can see that 3ZCA is scalable in both cases Furthermore the higher the constraint selectiv ity the more scalable FZCA is That can be explained by the fact that 3ZCd always cuts more search space using constraints with higher selectivity 5.2 Evaluation of FZCM As analyzed before convertible monotone constraint can be used to save the cost of constraint checking but it cannot cut the search space of frequent itemsets In our experi ments since we use relatively simple constraints, such as those involving avg and sum the cost of constraint check ing is CPU-bound However the cost of the whole frequent itemset mining process is I/O-bound This makes the effect of pushing convertible monotone constraint into the mining process hard to be observed from runtime reduction In our experiments 31CM achieves less than 3 runtime benefit 0 200 400 600 800 1000 Number of transactions K Figure 5 Scalability with number of transactions in most cases However if we look at the number of constraint tests performed, the advantage of FICM can be evaluated objec tively FZC can save a lot of effort on constraint testing Therefore in the experiments about 31C\222 the number of constraint tests is used as the performance measure We test the scalability of 3ZCM with constraint selec tivity in mining frequent itemsets with convertible mono tone constraint The result is shown in Figure 6 The fig ure shows that FZCM has a linear scalability When the constraint selectivity is low, i.e most frequent itemsets can pass the constraint checking most of constraint tests can be saved This is because once a frequent itemset satisfies a convertible monotone constraint every subsequent frequent itemset derived from corresponding projected database has that frequent itemset as a prefix and thus satisfies the con straint, too We also tested the scalability of 31CM with support threshold The result is shown in Figure 7 The figure shows that FZCM is scalable Furthermore the lower the con straint selectivity the better the scalability FZCM is In summary our experimental results show that the method proposed in this paper is scalable for mining fre quent itemsets with convertible constraints in large transac tion databases The experimental results strongly support our theoretical analysis 6 Discussions: Mining Frequent Itemsets with Multiple Convertible Constraints We have studied the push of single convertible con straints into frequent itemset mining 223Can we push mul tiple constraints deep into the frequent pattern mining pro cess?\222 Multiple constraints in a mining query may belong to the same category e.g all are anti-monotone or to different categories Moreover different constraints may be on dif ferent properties of items e.g some could be on item price 441 


1  0 20 40 60 80 100 Selectivity Figure 6 Scalability with constraint selectivity others on sales profits the number of items etc As shown in our previous analysis unlike anti monotone, monotone and succinct constraints convertible constraints can be mined only by ordering items properly However different constraints may require different and even conflicting item ordering Our general philosophy is to conduct a cost analysis to determine how to combine mul tiple order-consistent convertible constraints and how to se lect a sharper constraint among order-conflicting ones The details will not be presented here for lack of space 7. Conclusions Constraints involving holistic functions such as median algebraic functions such as avg or even those involving dis tributive functions like sum over sets with positive and neg ative item values are difficult to incorporate in an optimiza tion process in frequent itemset mining The reason is such constraints do not exhibit nice properties like monotonicity etc. A main contribution of this paper is showing that by im posing an appropriate order on items, such tough constraints can be converted into ones that possess monotone behavior To this end we made.a detailed analysis and classification of the so-called convertible constraints We characterized them using prefix monotone functions and established their arithmetical closure properties As a byproduct we shed light on the overall picture of various classes of constraints that can be optimized in frequent set mining While con vertible constraints cannot be literally incorporated into an Apriori-style algorithm they can be readily incorporated into the FP-growth algorithm Our experiments show the effectiveness of the algorithms developed We have been working on a systematic implementation of constraint-based frequent pattern mining in a data min ing system More experiments are needed to understand how best to handle multiple constraints An open issue is given an arbitrary constraint, how can we quickly check if it is strongly convertible We are also exploring the use of constraints in clustering 160000   t 221FP-growth tFIC\(M 20 tFIC\(M 80 0.0 0.2 0.4 0.6 0.8 1.0 Support threshold Figure 7 Scalability with support threshold References I R Agrawal and R Srikant. Fast algorithms for mining asso ciation rules In Proc 1994 Int Con Very Large Data Bases VLDB\22294 pages 487-499 Santiago, Chile, Sept 1994 2 R J Bayardo R Agrawal and D Gunopulos Constraint based rule mining on large dense data sets In Proc 1999 Int Conj Data Engineering ICDE\22299 Sydney, Australia Apr 1999 3 S Brin R Motwani and C. Silverstein Beyond market bas ket Generalizing association rules to correlations In Proc 1997 ACM-SIGMOD Int Con Management of Data SIG MOD\22297 pages 265-276 Tucson Arizona May 1997 4 G Grahne L Lakshmanan and X Wang Efficient min ing of constrained correlated sets In Proc 2000 Int Con Data Engineering \(ICDE\222OO pages 5 12-521 San Diego CA Feb 2000 5 J Han J Pei and Y Yin Mining frequent patterns with out candidate generation In Proc 2000 ACM-SIGMOD Int Con Managementof Data \(SIGMOD\222OO pages 1-12 Dal las, TX May 2000 6 L V S Lakshmanan R Ng J Han and A Pang Opti mization of constrained frequent set queries with 2-variable constraints In Proc 1999 ACM-SIGMOD Int Con Man agement of Data SIGMOD\22299 pages 157-168 Philadel phia PA June 1999 7 R Ng L V S Lakshmanan J Han and A Pang Ex ploratory mining and pruning optimizations of constrained associations rules In Proc 1998 ACM-SIGMOD Int Con Management of Data SlGMOD\22298 pages 13-24 Seattle WA June 1998 8 1 Pei and J Han Can we push more constraints into fre quent pattem mining In Proc 2000 Int Con Knowl edge Discovery and Data Mining KDD\222OO pages 350 354, Boston MA Aug. 2000 9 J Pei J Han and R Mao CLOSET An efficient algorithm for mining frequent closed itemsets In Proc 2000 ACM SIGMOD Int Workshop Data Mining and Knowledge Dis covery DMKD\222OO pages 1 1-20 Dallas TX May 2000 lo R Srikant Q Vu and R Agrawal. Mining association rules with item constraints In Proc 1997 Int Con Knowledge Discovery and Data Mining KDD\22297 pages 67-73 New port Beach CA Aug 1997 442 


expect this optimization to be of greatest bene\336t when the transaction sizes are large r example if our transaction is T 000 f A\000 B 000 C\000 D\000 E g  k 000 3 fan-out 000 2 then all the 3-subsets of T are f ABC,ABD,ABE,ACD,ACE,ADE,BCD,BCE,BDE,CDE g  Figure 2 shows the candidate hash tree C 3  We ave to increment the support of every subset of T contained in C 3  We egin with the subset AB C  and hash to node 11 and process all the itemsets In this downward path from the root we mark nodes 1 4 and 11 as visited We then process subset AD B  and mark node 10 Now consider the subset CDE  We see in this case that node 1 has already been marked and we can preempt the processing at this very stage This approach can r consume a lot of memory r a n fan-out F  for iteration k  e need additional memory of size F k to store the 337ags In the parallel implementation we have to keep a VISITED 336eld for each processor bringing the memory requirement to P\000F k  This can still get very large especially with increasing number of processors In we sho w a mechanism by which further reduces the memory requirement to only k 000F  The approach in the parallel setting yields a total requirement of k 000F 000P  5 Experimental Evaluation Database T I D Total Size T5.I2.D100K 5 2 100,000 2.6MB T10.I4.D100K 10 4 100,000 4.3MB T15.I4.D100K 15 4 100,000 6.2MB T20.I6.D100K 20 6 100,000 7.9MB T10.I6.D400K 10 6 400,000 17.1MB T10.I6.D800K 10 6 800,000 34.6MB T10.I6.D1600K 10 6 1,600,000 69.8MB Table 2 Database properties 5.1 Experimental Setup All the experiments were performed on a 12-node SGI Power Challenge shared-memory multiprocessor Each node is a MIPS processor running at 100MHz There\325s a total of 256MB of main memory The primary cache size is 16 KB 64 bytes cache line size with different instruction and data caches while the secondary cache is 1 B 128 bytes cache line size The databases are stored on an attached 2GB disk All processors run IRIX 5.3 and data is obtained from the disk via an NFS 336le server We used different synthetic databases with size ranging form 3MB to 70MB 2  and are generated using the procedure described in These databases mimic the transactions in a retailing en vironment Each transaction has a unique ID followed by a list of items bought in that transaction The 2 While results in this section are only shown for memory resident databases the concepts and optimization are equally applicable for non memory resident databases In non memory resident programs I/O becomes an important problem Solutions to the I/O problem can be applied in combination with the schemes presented in this paper These solutions are part of future research 11 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


  0 500 1000 1500 2000 2500 0 2 4 6 8 10 12 Number of Large Itemsets Iterations Large Itemset at Support = 0.5 222T5.I2.D100K\222  222T10.I4.D100K\222   222T15.I4.D100K\222   222T20.I6.D100K\222   222T10.I6.D400K\222   222T10.I6.D800K\222   222T10.I6.D1600K\222  Figure 3 Large Itemsets per Iteration data-mining provides information about the set of items generally bought together Table 2 shows the databases used and their properties The number of transactions is denoted as jD j  average transaction size as j T j  and the average maximal potentially large itemset size as j I j  The number of maximal potentially large itemsets j L j 000 2000 and the number of items N 000 1000 We refer the reader to for more detail on the database generation All the e xperiments were performed with a minimum support value of 0.5 and a leaf threshold of 2 i.e max of 2 itemsets per leaf We note that the  improvements shown in all the experiments except where indicated do not take into account initial database reading time since we speci\336cally wanted to measure the effects of the optimizations on the computation Figure 3 shows the number of iterations and the number of large itemsets found for different databases In the following sections all the results are reported for the CCPD parallelization We do not present any results for the PCCD approach since it performs very poorly and results in a speed-down on more than one processor 3  5.2 Aggregate Parallel Performance Table 3 s actual running times for the unoptimized sequential and a naive parallelization of the base algorithm Apriori for 2,4 and 8 processors without any f the techniques descibed in sections 3 and 4 In this section all the graphs showing  improvements are with respect to the data for one processor in table 3 Figure 4 presents the speedups obtained on different databases and different processors for the CCPD parallelization The results presented on CCPD use all the optimization discussed 3 Recall that in the PCCD approach every processor has to read the entire database during each iteration The resulting I/O costs on our system were too prohibitive for this method to be  12 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


Database 1 proc 2 procs 4 procs 8 procs T5.I2.D100K 20 17 12 10 T10.I4.D100K 96 70 51 39 T15.I4.D100K 236 168 111 78 T20.I6.D100K 513 360 238 166 T10.I6.D400K 372 261 165 105 T10.I6.D800K 637 435 267 163 T10.I6.D1600K 1272 860 529 307 Table 3 Naive Parallelization of Apriori seconds   0 2 4 6 8 10 12 0 2 4 6 8 10 12 Speedup Number of Processors CCPD Ideal  T5.I2.D100K.t2   T10.I4.D100K.t2   T15.I4.D100K.t2   T20.I6.D100K.t2   T10.I6.D400K.t2   T10.I6.D800K.t2   T10.I6.D1600K.t2    0 2 4 6 8 10 12 0 2 4 6 8 10 12 Speedup Number of Processors CCPD : With Reading Time Ideal  T5.I2.D100K.t2   T10.I4.D100K.t2   T15.I4.D100K.t2   T20.I6.D100K.t2   T10.I6.D400K.t2   T10.I6.D800K.t2   T10.I6.D1600K.t2  Figure 4 CCPD Speed-up a without reading time b with reading time 13 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


Reading  f Total Time Database Time P 000 1 P 000 2 P 000 4 P 000 8 P 000 12 T5.I2.D100K 9.1s 39.9 43.8 52.6 56.8 59.0 T10.I4.D100K 13.7s 15.6 22.2 29.3 36.6 39.8 T15.I4.D100K 18.9s 8.9 14.0 21.6 29.2 32.8 T20.I6.D100K 24.1s 4.9 8.1 12.8 18.6 22.4 T10.I6.D400K 55.2s 16.8 24.7 36.4 48.0 53.8 T10.I6.D800K 109.0s 19.0 29.8 43.0 56.0 62.9 T10.I6.D1600K 222.0s 19.4 28.6 44.9 59.4 66.4 Table 4 Database Reading Time in section 4 320 computation balancing hash tree balancing and short-circuited subset checking The 336gure on the left presents the speed-up without taking the initial database reading time into account We observe that as the number of transactions increase we get increasing speed-up with a speed-up of more than 8 n 2 processors for the largest database T10.I6.D1600K with 1.6 million transactions r if we were to account for the database reading time then we get speed-up of only 4 n 2 processors The lack of linear speedup can be attributed to false and true sharing for the heap nodes when updating the subset counts and to some extent during the heap generation phase Furthermore since variable length transactions are allowed and the data is distributed along transaction boundaries the workload is not be uniformly balanced Other factors like s contention and i/o contention further reduce the speedup Table 4 shows the total time spent reading the database and the percentage of total time this constitutes on different number of processors The results indicate that on 12 processors up to 60 of the time can be spent just on I/O This suggest a great need for parallel I/O techniques for effective parallelization of data mining applications since by its very nature data mining algorithms must operate on large amounts of data 5.3 Computation and Hash Tree Balancing Figure 5 shows the improvement in the performance obtained by applying the computation balancing optimization discussed in section 3.1.2 and the hash tree balancing optimization described in section 4.1 The 336gure shows the  improvement r a run on the same number of processors without any optimizations see Table 3 Results are presented for different databases and on different number of processors We 336rst consider only the computation balancing optimization COMP using the multiple equivalence classes algorithm As expected this doesn\325t improve the execution time for the uni-processor case as there is nothing to balance r it is very effective on multiple processors We get an improvement of around 20 on 8 processors The second column for all processors shows the bene\336t of just balancing the hash tree TREE using our bitonic hashing the unoptimized version uses the simple mod d hash function Hash tree balancing by itself is an extremely effective optimization It s the performance by about 30 n n uni-processors On smaller databases and 8 processors r t s not as 14 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 T5.I2.D100K T10.I4.D100K T15.I4.D100K T10.I6.D400K T10.I6.D800K T10.I6.D1600K Optimizations across Databases 5 0 5 10 15 20 25 30 35 40 45 Improvement COMP TREE COMP-TREE 1 2 4 8 1 2 4 8 1 2 4 8 2 4 8 2 4 8 1 2 4 8 Processors Databases Figure 5 Effect of Computation and Hash Tree Balancing good as the COMP optimization The reason that the hash tree balancing is not suf\336cient to offset inherent load imbalance in the candidate generation in this case The most effective approach is to apply both optimizations at the same time COMP-TREE The combined effect is suf\336cient to push the improvements in the 40 range in the multiple-processor case On 1 processor only hash tree balancing is bene\336cial since computation balancing only adds extra cost 5.4 Short-circuited Subset Checking Figure 6 shows the improvement due to the short-circuited subset checking optimization with respect to the unoptimized version The unoptimized version is the Apriori algorithm due to Agrawal et al 5 The results are presented for dif ferent number of processors across dif ferent databases The results indicate that while there is some improvement for databases with small transaction sizes the optimization is most effective when the transaction size is large In this case we get improvements of around 25 r the unoptimized version To gain further insight into this optimization consider 336gure 7 It shows the percentage improvement obtained per iteration on applying this optimization on the T20.I6.D100K database It shows results only for the uni-processor case r similar results were obtained on more processors We observe that as the iteration k increases there is more opportunity for shortcircuiting the subset checking and we get increasing bene\336ts of up to 60 The improvements start to fall off t the high end where the number of candidates becomes small resulting in a small hash tree and less opportunity for short-circuiting It becomes clear that is an extremely effective 15 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 T5.I2.D100K T10.I6.D800K T15.I4.D100K T20.I6.D100K procs across Databases 0 5 10 15 20 25 Improvement 1 2 4 8 Figure 6 Effect of Short-circuited Subset Checking 23456789101112 Iterations 0 10 20 30 40 50 60 improvement T20.I6.D100K Figure 7  Improvement per Iteration  proc   16 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


optimization for larger transaction sizes and in cases where there are large number of candidate k itemsets 6 Conclusions In this paper e presented a parallel implementation of the Apriori algorithm on the SGI Power Challenge shared memory multi-processor We also discussed a set of optimizations which include optimized join and pruning computation balancing for candidate generation hash tree balancing and short-circuited subset checking We then presented experimental results on each of these Improvements of more than 40 were obtained for the computation and hash tree balancing The short-circuiting optimization was found to be extremely effective for databases with large transaction sizes Finally we reported the parallel performance of the algorithm While we d good speed-up we observed a need for parallel I/O techniques for further performance gains References  R Agra wal T  Imielinski and A Swami Database mining A performance perspecti v e  I n IEEE Trans on Knowledge and Data Engg  pages 5\(6 1993  R Agra wal T  Imielinski and A Swami Mining association rules between sets of items in lar ge databases In Proc M SIGMOD Intl Conf Management of Data  May 1993  R Agra wal H Mannila R Srikant H T o i v onen and A I V erkamo F ast disco v ery of association rules In U F et al editor Advances in Knowledge Discovery and Data Mining  MIT Press 1996  R Agra wal and J Shafer  P arallel mining of association rules design implementation and e xperience Technical Report RJ10004 IBM Almaden Research Center San Jose CA 95120 Jan 1996  R Agra wal and R Srikant F ast algorithms for mining association rules In Proc 20th VLDB Conf  Sept 1994  M Cierniak W  Li and M J Zaki Loop scheduling for heterogeneity  I n 4th IEEE Intl Symposium on High-Performance Distributed Computing also as URCS-TR 540 CS Dept Univ f Rochester  Aug 1995  M Holsheimer  M  K ersten H Mannila and H T o i v onen A perspecti v e on databases and data mining In 1st Intl Conf Knowledge Discovery and Data Mining  Aug 1995  M Houtsma and A Swami Set-oriented mining of association rules In RJ 9567  IBM Almaden Oct 1993  H Mannila H T o i v onen and I V erkamo Ef 336cient algorithms for disco v ering association rules In AAAI Wkshp Knowledge Discovery in Databases  July 1994  J S P ark M Chen and P  S Y u  A n e f fecti v e hash based algorithm for mining association rules In Proc M SIGMOD Intl Conf Management of Data  May 1995 17 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 J S P ark M Chen and P  S Y u  E f 336cient parallel data mining for association rules T echnical Report RC20156 IBM T J Watson Research Center Aug 1995  G Piatetsk y-Shapiro Disco v ery  presentation and analysis of strong rules In G P S et al editor  KDD  AAAI Press 1991  A Sa v asere E Omiecinski and S Na v athe An ef 336cient algorithm for mining association rules in large databases In Proc 21st VLDB Conf  1995  M J Zaki M Ogihara S P arthasarathy  and W  Li P arallel data mining for association rules on shared-memory multi-processors Technical Report 618 Department of Computer Science University of Rochester 618 1996 18 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


