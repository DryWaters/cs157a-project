Data Mining for Path Traversal Patterns in a Web Environment Ming-Syan C:hen Jong So0 Park*anld Philip S Yu IBM Thomas J Watson Reisearch Ctr P.O.Box 704 Yorktown NY 10598 Abstract In this paper we explore a new data mining capa bility which involves mining path traversal patterns in a distributed information providing environment like world-wide-web First we convert th,e original se quence of 
log data into a set of maximaIfomard ref erences and filter out the eflect of some backward ref erences which are mainly made for eaSIe of iiraveling Second we derive algorithms to determine the frequent traversal patterns i.e large reference sequences from the maximal forward references obtained Two al gorithms are devised for determining large reference sequences one is based on some hashing and prun ing techniques and the other is further improved with the option of determining 
large reference seqaences in batch so as to reduce the number of database scans required Performance of these two method8 is com paratively analyzed 1 Introduction Due to the increasing use of computing for vari ous applications the importance of database mining is growing at a rapid pace recently Vairious data min ing capabilities have been explored in the literature One of the most important data mining problems is mining association 
rules 3 4 9 10 111 For exam ple given a database of sales transactions it is desir able to discover all associations among items such that the presence of some items in a transaction will imply the presence of other items in the same transaction Also mining classification is an approach of trying to develop rules to group data tuples together based  J S Park is partially supported by KOSEF Korea 
1063-6927196 5.00 0 1996 IEEE Proceedings of the 16th ZCDCS 385 Department of Computer Science Sungshin Women's University Seoul, Korea on certain common features This has been explored both in the AI domain 12 131 and in the context of databases 2 6 81 Another source of data mining is on ordereld data such as stock market and point of sales data Interesting aspects to explore from these ordered data include searching for similar sequences 
I 141 e.g stocks with similar movement in stock prices and sequential patterns 5 e.g grocery items bought over a set of visits in sequence It is noted that data mining is a very application-dependent issue and different applications explored will require differ ent mining techniques to cope with In this paper we shall explore a new data min ing capability which involves mining access patterns in a dist cibuted information providing environment where documents or objects are linked together to 
fa cilitate interactive access Examples for such informa tion providing environments include World Wide Web WWW 7 and on-line services where users when seeking fior information of interest travel from one object to another via the corresponding facilities i.e hyperlinks\provided Clearly understanding user ac cess patterns in such environments will not only help improving the system design e.g providing efficient access between highly correlated objects better au thoring design for pages etc but also be able to lead to better marketing decisions 
e.g putting ad vertisements in proper places better customer/user classification and behavior analysis etc Capturing user access patterns in such environments is referred to as mining traversal patterns in this paper Note that although some efforts have been elaborated upon ana lyzing the user behavior there is little result reported on dealing with the algorithmic aspects to improve the execution of traversal pattern mining In addition it is important to mention that since users are travel 


ing along the information providing services to search for the desired information some objects are visited because of their locations rather than their content This shows the very difference between the traversal pattern problem and others which are mainly based on customer transactions This unique feature of the traversal pattern problem unavoidably increases the difficulty of extracting meaningful information from a sequence of traversal data However as these infor mation providing services are becoming increasingly popular nowadays there is a growing demand for cap turing user behavior and improving the quality of such services Consequently we shall explore in this paper the problem of mining traversal patterns Our solution procedure consists of two steps First we derive an al gorithm called algorithm MF standing for maximal forward references to convert the original sequence of log data into a set of traversal subsequences Each tra versal subsequence represents a maximal forward ref erence from the starting point of a user access As will be explained later this step of converting the original log sequence into a set of maximal forward references will filter out the effect of backward references which are mainly made for ease of traveling and enable us to concentrate on mining meaningful user access se quences Second we derive algorithms to determine the frequent traversal patterns termed large TefeTence sequences from the maximal forward references ob tained above where a large reference sequence is a reference sequence that appeared in a sufficient num ber of times in the database Note that the problem of finding large reference sequences is similar to that of finding large itemsets for association rules 3 where a large itemset is a set of items appearing in a sufficient number of transactions However they are different from each other in that a reference sequence in min ing traversal patterns has to be consecutive references in a maximal forward reference whereas a large item set in mining association rules is just a combination of items in a transaction As a consequence although several schemes for mining association rules have been reported in the literature 3,4 lo the very difference between these two problems calls for the design of new algorithms for determining large reference sequences Explicitly we devise two algorithms for determining large reference sequences The first one referred to as full-scan FS algorithm essentially utilizes some tech niques on hashing and pruning while solving the dis crepancy between traversal patterns and association rules mentioned above Although trimming the trans action database as it proceeds to later passes algo rithm FS is required to scan the transaction database in each pass In contrast by properly utilizing the candidate reference sequences the second algorithm devised referred to as selective-scan SS algorithm is able to avoid database scans in some passes so as to reduce the disk 1/0 cost involved Specifically algo rithm SS has the option of using a candidate reference set to generate subsequent candidate reference sets and delaying the determination of large reference sets to a later pass when the database is scanned Since SS does not scan the database to obtain a large reference set in each pass some database scans are saved Ex perimental studies are conducted by using a synthetic workload that is generated based on referencing some logged traces and performance of these two methods FS and SS is comparatively analyzed It is shown that the option of selective scan is very advantageous and algorithm SS thereby outperforms algorithm FS in general Sensitivity analysis on various parameters is also conducted This paper is organized as follows Problem de scription is given in Section 2 Algorithm MF to iden tify maximal forward references is described in Section 3.1 and two algorithms FS and SS for determining large reference sequences are given in Section 3.2 Per formance results are presented in Section 4 Section 5 contains the summary 2 Problem description As pointed out earlier, in an information providing environment where objects are linked together users are apt to travel objects back and forth in accordance with the links and icons provided As a result some node might be revisited because of its location rather than its content For example in a WWW environ ment to reach a sibling node a user is usually inclined to use 223backward\224 icon and then a forward selection instead of opening a new URL Consequently to ex tract meaningful user access patterns from the original log database we naturally want to take into consider ation the effect of such backward traversals and dis cover the real access patterns of interest In view of this we assume in this paper that a backward ref erence is mainly made for ease of traveling but not for browsing and concentrate on the discovery of for ward reference patterns Specifically a backward ref erence means revisiting a previously visited object by the same user access When backward references oc 386 


cur a forward reference path terminates This re sulting forward reference path is termed a mazimal forward reference After a maximal forward ireference is obtained we back track to the starting point of the forward referencing and resume anotheic forward refer ence path In addition the occurrence of a null source node also indicates the termination of ongoing for ward reference path and the beginning of a new one While deferring the formal description of the algo rithm to determine maximal forward references i.e algorithm MF to Section 3.1 we give an illustra tive example for maximal forward references below Suppose the traversal log contains the following tra versal path for a user A B C D C B E G H G W A 0 U 0 V as shown in Figure 1 Then it can be verified by algorithm MF that the set of maximal forward references for this user is ABCD ABEGH ABEGW AOU AOV After maximal forward refer ences for all users are obtained we then map the prob lem of finding frequent traversal patterns into the one of finding frequent occurring consecutive subsequences among all maximal forward references A large refer ence sequence is a reference sequence that appeared in a sufficient number of times In a set of maximal forward references the number of times a reference sequence has to appear in order to be qualified as a large reference sequence is called the minimal support A large Ic-reference is a large reference sequence with k elements We denote the set of large k-references as Lk and its candidate set as ck As pointed out earlier, a very difference between mining traversal pastterns and mining association rules lies in the fact that a refer ence sequence in mining traversal patterns has to be consecutive references in a maximal forward reference whereas a large itemset in mining association rules is just a set of items in a transaction As a result it is necessary to devise new algorithms for determining large reference sequences It is worth mentioning that after lairge reference se quences are determined maximal reference sequences can then be obtained in a straightforward manner A maximal reference sequence is a large reference sequence that is not contained in any other maxi mal reference sequence For examplle suppose that AB BE AD CG GH BG is the set of large 2 references i.e L2 and ABE,CC:H is the set of large 3-references i.e L3 Then the resulting maximal reference sequences are AD, BG, ABE and CGH A maximal reference sequence corresponds to a 223hot\224 access pattern in an information providing ser vice In all the entire procedure for mining traversal Figure 1 An illustrative example for traversal pat terns patterns can be summarized as follows Procedure for mining traversal patterns Step 1 Determine maximal forward references from the original log data Step 2 Determine large reference sequences i.e Lk Ic 2 1 from the set of maximal forward refer ences Step 3 Determine maximal reference sequences from large reference sequences Since the extraction of maximal reference sequences from large reference sequences i.e Step 3 is straight forward we shall henceforth focus on Steps 1 and 2 and devise algorithms for the efficient determination of large reference sequences 3 Algorithm for traversal pattern We shall describe in Section 3.1 algorithm MF which converts the original traversal sequence into a set of maximal forward references Then by mapping the problem of finding frequent traversal patterns into the one of finding frequent consecutive subsequences we develop two algorithms called full-scan FS and selective-scan SS for mining traversal patterns 3.1 Finding maximal forward references In general a traversal log database contains for each Iinlk traversed a pair of source destination For 387 


the beginning of a new path which is not linked to the previous traversal, the source node is null Given a traversal sequence SI dl 32 d2  Sn dn of a user we shall map it into multiple subsequences each of which represents a maximal forward reference The algorithm for finding all maximal forward ref erences is given as follows First the traversal log database is sorted by user id\222s resulting in a traver sal path SI dl 52 dz  snl  for each user where pairs of si di are ordered by time Algorithm MF is then applied to each user path to determine all of its maximal forward references Let RF denote the database to store all the resulting maximal forward references obtained Algorithm MF Step 1 Set i  1 and string Y to null for initializa tion where string Y is used to store the current forward reference path Also set the flag F  1 to indicate a forward traversal Step 2 Let A  si and B  di If A is equal to null then  this is the beginning of a new traversal  begin to the database DF Write out the current string Y if not null Set string Y  B Go to Step 5 end Step 3 If B is equal to some reference say the j-th reference in string Y then  this is a cross-referencing back to a previous reference  begin database DF in string Y If F is equal to 1 then write out string Y to Discard all the references after the j-th one F=0 Go to Step 5 end move 1 2 3 4 5 6 Step 4 Otherwise append B to the end of string Y  we are continuing a forward traversal  If F is equal to 0 set F  1 Step 5 Set i  i+l If the sequence is not completed scanned then go to Step 2 Consider the traversal scenario in Figure 1 for ex ample It can be verified that the first backward ref erence is encountered in the 4-th move i.e., from D string Y output to DF AB  ABC  ABCD  ABC ABCD AB  ABE  Table 1 An example execution by algorithm MF 13 14 15 J AOU  A0 AOU AOV AOV end ABEGH 11 ABEGW 12 A0 ABEGW to C At that point the maximal forward reference ABCD is written to DF by Step 3 In the next move i.e from C to B although the first condi tional statement in Step 3 is again true nothing is written to RF since the flag F  0 meaning that it is in a reverse traversal The subsequent forward ref erences will put ABEGH into the string Y which is then written to DF when a reverse reference from H to G is encountered The execution scenario by algo rithm MF for the input in Figure 1 is given in Table 1 3.2 Finding large reference sequences Once the database containing all maximal forward references for all users DF is constructed we can derive the frequent traversal patterns by identifying the frequent occurring reference sequences in DF  A sequence 1   sn is said to contain TI  Tk as a consecutive subsequence if there exists an i such that si+j  T for 1 5 j 5 k A sequence of k references TI  Tk is called a large k-reference sequence if there are a sufficient number of users with maximal forward references in DF containing TI  Tk as a consecutive subsequence We shall describe below two algorithms for min ing traversal patterns The first one called full-scan FS algorithm essentially utilizes the concept of DHP i.e hashing and pruning while solving the discrep ancy between traversal patterns and association rules 388 


Although trimming the transaction database as it pro ceeds to later passes, FS is required to scan the trans action database in each pass In contrast by properly utilizing the candidate reference sequences tlhe second algorithm referred to as selective-scan SS algorithm is improved with the option of determining large ref erence sequences in batch so as to reduce tbe number of database scans required 3.2.1 To describe algorithm FS we shall first summarize the key ideas of the DHP algorithm The details of DHP can be found in lo Recall that DHP has two ma jor features in determining association rules one is efficient generation for large itemsets and the other is effective reduction on transaction dathtbase size after each scan As shown in lo by utilizing a hash tech nique DHP is very efficient for the generation of can didate itemsets, in particular for the large Litemsets thus greatly improving the performance bottleneck of the whole process In addition DHP employs effective pruning techniques to progressively reduce the trans action database size Recall that Lk represents the set of alll large k references and ck is a set of candidate k-references ck is in general a superset of Lk By scanning through DF FS gets L1 and makes a hash table i.e H2 to count the number of occurrences of each 2-reference Similarly to DHP starting with k  2 IFS generates ck based on the hash table count obtained in the pre vious pass determines the set of large k-references reduces the size of database for the next pass and makes a hash table to determine the candidate k  1 references Note that as in mining association rules a set of candidate references Ck can be generated fromjoining Lk-1 with itself denoted by Lk-1 I However due to the difference between traversal pat terns and association rules we modify this approach as follows For any two distinct reference sequences in Lk-1 say TI  rk-1 and SI  Sk-1 we join them together to form a k-reference sequence onlly if either r1  rk-1 contains SI  56-2 or SI lk-1 con tains rl  k-2 i.e after dropping the first element in one sequence and the last element in the other se quence the remaining two k  2 are iden tical We note that when k is small especially for the case of k  2 deriving ck by joining Lk-1 with itself will result in a very large number of candidate refer ences and the hashing technique is thus very helpful for such a case As k increases the size of Lk-1 Algorithm on full scan FS can decrease significantly Same as in lo we found that it is generally beneficial for FS to generate ck di rectly from Lk-1  Lk-1 i.e without using hashing after k 2 3 To count the occurrences of each A-reference in ck to determine Lkj we need to scan through a trimmed version of database DF From the set of maximal for ward references we determine, among k-references in Ck large k-references After the scan of the entire database those k-references in ck with count exceed ing the threshold become Lk If Lk is non-empty the iteration continues for the next pass i.e pass k  1 Same as in DHP every time when the database is scanned the database is trimmed by FS to improve the efficiency of future scans 3.2.2 Algorithm on selective scan SS Algorithm SS is similar to algorithm FS in that it also employs hashing and pruning techniques to re duce both CPU and 1/0 costs but is different from the latter in that algorithm SS by properly utilizing the information in candidate references in prior passes is able to avoid database scans in some passes thus further reducing the disk 1/0 cost The method for SS to avoid some database scans and reduce disk 1/0 cost is described below Recall that algorithm FS generates a small inumber of candidate 2-references by using a hashing technique In fact this small C2 can be used to generate the candidate 3-references Clearly a CA generated from Cz  C2 instead of from L2  L2 will have a size greater than IC31 where C3 is generated from Lz r L2 However if ICil is not much larger than IC31 and both C2 and Ci can be stored in the main memory we can find L2 and L3 together when the next scain of the database is performed thereby sav ing one iround of database scan It can be seen that using this concept one can determine all Lk\222S by as few as two scans of the database i.e one initial scan to determine L1 and a final scan to determine all other large reference sequences\assuming that CL for IC 2 3 is generated from CL-l and all CLs for k  2 can be kept in the memory Note that when the minimum support is relatively small or potentially large references are long ck and Lk could1 become large If IC;+,I  IcLl for k 2 2 then it may cost too much CPU time to generate all subsequent Ci j  k  1 from candidate sets of large references since the size of C may become huge quickly thus compromising all the benefit from sav ing disk 1/0 cost This fact suggests that a timely 389 


A Table 2 Results from an example run by FS and SS 1 Leaf node 25 go bad to parent node 75 jump io only niemal node k I 11 21 31 41 51 61 sec ck 121 84 58 22 3 Lk 94 91 84 58 21 3 19.48 Algorithm FS Dk MB 12.8 12.8 12.2 5.3 1.9 0.26 30.80 Algorithm SS ck 121 144 58 22 3 Lk 94 91 84 58 21 3 18.75 Dk MB 12.8  12.8   5.3 17.80 3 of all intemal nodes t parent node intemal jump to any node children nodes parent node jump to intemal node  Figure 2 A traversal tree to simulate WWW database scan to determine large reference sequences will in fact pay off After a database scan one can obtain the large reference sequences which are not de termined thus far say up to L and then construct the set of candidate m  1 Cm+l based on L from that point According to our experiments we found that if IC  CL1 for some 12 2 2 it is usually beneficial to have a database scan to obtain Lk+l before the set of candidate references becomes too big Same as in FS each time the database is scanned the database is trimmed by SS to improve the efficiency of future scans We then derive CL from Lk+1 We note that CL+z is in fact equal to ck+z here After that we again use c to derive Cj+l for j 2 L  2 The process continues until the set of candidate j  1 becomes empty Illustrative examples for FS and SS are given in Table 2 where the number of reference paths DI  200,000 and the minimum support s  0.75 In this example run FS performs a database scan in each pass to determine the corresponding large reference sequences resulting in six database scans On the other hand SS scans the database only three times skipping database scans in passes 2 4 and 5 and is able to obtain the same result The CPU and disk 1/0 times for FS are 19.48 seconds and 30.8 seconds respectively whereas those for SS are 18.75 seconds and 17.8 seconds respectively Considering both CPU and 1/0 times the execution time ratio for SS to FS is 0.73 showing a prominent advantage of SS 4 Performance results To assess the performance of FS and SS we con ducted several experiments to determine large refer ence sequences by using an RS/6000 workstation with model 560 In our experiment the browsing scenario in a World Wide Web WWW environment is simu lated To generate a synthetic workload and determine the values of parameters we referenced some logged traces which were collected from a gateway First a traversal tree is constructed to mimic WWW structure whose starting position is a root node of the tree The traversal tree consists of internal nodes and leaf nodes Figure 2a shows an example of the traversal tree The number of child nodes at each internal node referred to as fanod is determined from a uniform distribution within a given range The height of a subtree whose subroot is a child node of the root node is determined from a Poisson distribution with mean ph Then, the height of a subtree whose subroot is a child of an inter nal node Nj is determined from a Poisson distribution with mean equal to a fraction of the maximum height of the internal node Ni As such the height of a tree is controlled by the value of ph A traversal path consists of nodes accessed by a user The size of each traversal path is picked from a Poisson distribution with mean equal to JPI With the first node being the root node a traversal path is generated probabilistically within the traversal tree as follows For each internal node we determine which is the next hop according to some predetermined prob abilities Essentially each edge connecting to an in ternal node is assigned with a weight This weight corresponds to the probability that each edge will be next accessed by the user As shown in Figure 2b the weight to its parent node is assigned with PO which is generally  where n is the number of child nodes This probability of traveling to each child node pi is determined from an exponential distribution with 390 


Table 3 Meaning of various parameters The height of a traversal tree A varameter of a Zivf-like distribution unit mean and is so normalized that the sunn of the weights for all child nodes is equal to 1  po If this internal node has an internal jump and the weight for this jump is pj then po is changed to pol1  pj and the corresponding probability for each child node is changed to pi\(1  p3 such that the sum of all the probabilities associated with this node remains one When the path arrives at a leaf node the next move would be either to its parent node in backward with a probability 0.25 or to any internal node with an ag gregate probability 0.75 Some internal nodes in the tree have internal jumps which can go to any other nodes The number of internal nodes with internal jumps is denoted by NJ which is set to 3 of all the internal nodes in general cases Table 3 summarizes the meaning of various parameters used in our simu lations Figure 3 represents execution times of two meth ods, FS and SS when ID1  200,000 NJ  3 and pj  0.1 HzPy means that a is the height of a tree and y is the average size of the reference paths D200K means that the number of reference paths is 200,000 A tree for H10 was obtained when the height of a tree is 10 and the fanout at each internal node is between 4 and 7 The root node consists of 7 child nodes The number of internal nodes is 16,200 and the number of leaf nodes is 73,006 The number of internal nodes with internal jumps is thus 16200 XNJ 486 Note that the total number of nodes increases as the height of a tree increases To make the experiment tractable we reduced the fanout to 2  5 for the tree of H20 with the height of 20 This tree contained 616,595 in ternal nodes and 1,541,693 leaves In Figure 3 the left graph of each HaPy.D200K represents the CPU time to find all the large reference sequences and the right graph shows the 1/0 time to find them where the disk 1/0 time is set to 2 MB/sec and I M[B buffer CPU 6 Time sec 4 1.5 1.25 1.0 0.75 0.5 0.25 H 10P5.D2dJi!t Minimum su 1 ss x  4t 0 I I I I J 1.5 1.25 1.0 0.75 0.5 0.25 Minimum support Figure 3 Execution Times for FS and SS 391 


is used in main memory It can be seen from Fig ure 3 that algorithm SS in general outperforms FS and their performance difference becomes prominent when the 1/0 cost is taken into account From our ex periments it was shown that both the CPU and 1/0 times of each method increase linearly as the database size increases It can be seen that SS consistently out performs FS as the database size increases 5 Conclusion In this paper we have explored a new data min ing capability which involves mining traversal patterns in an information providing environment where doc uments or objects are linked together to facilitate in teractive access Our solution procedure consisted of two steps First we derived algorithm MF to convert the original sequence of log data into a set of maxi mal forward references By doing so we filtered out the effect of some backward references and concen trated on mining meaningful user access sequences Second we developed algorithms to determine large reference sequences from the maximal forward refer ences obtained Two algorithms were devised for de termining large reference sequences one was based on some hashing and pruning techniques and the other was further improved with the option of determining large reference sequences in batch so as to reduce the number of database scans required Performance of these two methods has been comparatively analyzed It is shown that the option of selective scan is very ad vantageous and algorithm SS thus in general outper formed algorithm FS Sensitivity analysis on various parameters was conducted References l R Agrawal C Faloutsos and A Swami Ef ficient Similarity Search in Sequence Databases Proceedings of the 4th Intl conf on Foundations of Data Organization and Algorithms October 1993 2 R Agrawal S Ghosh T Imielinski B Iyer and A Swami An Interval Classifier for Data base Mining Applications Proceedings of the 18th International Conference on Very Large Data Bases pages 560-573 August 1992 131 R Agrawal T Imielinski and A Swami Mining Association Rules between Sets of Items in Large Databases Proceedings of AGM SIGMOD pages 207-216 May 1993 4 R Agrawal and R Srikant Fast Algorithms for Mining Association Rules in Large Databases Proceedings of the 20th International Conference on Very Large Data Bases pages 478-499 Sep tember 1994 Mining Sequen tial Patterns Proceedings of the 11th Interna tional Conference on Data Engineering pages 3 14 March 1995 6 T.M Anwar H.W Beck and S.B Navathe Knowledge Mining by Imprecise Querying A Classification-Based Approach Proceedings of the 8th International Conference on Data Engi neering pages 622-630 February 1992 7 J December and N Randall The World Wide Web Unleashed SAMS Publishing 1994 8 J Han Y Cai  and N Cercone Knowledge Discovery in Databases An Attribute-Oriented Approach Proceedings of the 18th International Conference on Very Large Data Bases pages 9 J Han and Y Fu Discovery of Multiple-Level Association Rules from Large Databases Pro ceedings of the 21th International Conference on Very Large Data Bases pages 420-431 Septem ber 1995 lo J.-S Park M.-S Chen and P S Yu An Effec tive Hash Based Aleorithm for Minine Associa 5 R Agrawal and R Srikant 547-559 August 1992 tion Rules Proceediigs of ACM SIGMaD pages 175-186 May 1995 ll J.-S Park M.-S Chen and P S Yu Efficient Parallel Data Mining for Association Rules Pro ceedings of the 4th Intern Conf on Information and Knowledge Management Nov 29  Dec 3 1995 Discovery Analysis and Presentation of Strong Rules Knowledge Discov ery in Databases pages 229-248 1991 13 J.R Quinlan Induction of Decision Trees Ma chine Learning 1:81-106 1986 14 J T.-L Wang G,-W Chirn T.G Marr B Shapiro D Shasha and K Zhang Combina torial Pattern Discovery for Scientific Data Some Preliminary Results Proceedings of ACM SIG MOD Minneapolis MIV pages 115-125 May 1994 12 G Piatetsky-Shapiro 392 


Figure 8 Visual interface for Moridou system Search EngineTest Page 0 UI 0 5 5 Keyword plealet Figure 9 Prototype system in hcterogeneous environment 283 


6 Conclusions We presented MAFIA an algorithm for finding maximal frequent itemsets Our experimental results demonstrate that MAFIA consistently outperforms Depthproject by a factor of three to five on average The breakdown of the algorithmic components showed parent-equivalence pruning and dynamic reordering were quite beneficial in reducing the search space while relative compressiodprojection of the vertical bitmaps dramatically cuts the cost of counting supports of itemsets and increases the vertical scalability of MAFIA Acknowledgements We thank Ramesh Agarwal and Charu Aggarwal for discussing Depthproject and giving us advise on its implementation We also thank Jayant R Haritsa for his insightful comments on the MAFIA algorithm and Jiawei Han for providing us the executable of the FP-Tree algorithm This research was partly supported by an IBM Faculty Development Award and by a grant from Microsoft Research References I R Agarwal C Aggarwal and V V V Prasad A Tree Projection Algorithm for Generation of Frequent Itemsets Journal of Parallel and Distributed Computing special issue on high performance data mining to appear 2000 2 R Agrawal T Imielinski and R Srikant Mining association rules between sets of items in large databases SIGMOD May 1993  R Agrawal R Srikant Fast Algorithms for Mining Association Rules Proc of the 20th Int Conference on Very Large Databases Santiago Chile, Sept 1994  R Agrawal H Mannila R Srikant H Toivonen and A 1 Verkamo Fast Discovery of Association Rules Advances in Knowledge Discovery and Data Mining Chapter 12 AAAVMIT Press 1995 5 C C Aggarwal P S Yu Mining Large Itemsets for Association Rules Data Engineering Bulletin 21 1 23-31 1 998 6 C C Aggarwal P S Yu Online Generation of Association Rules. ICDE 1998: 402-41 1 7 R J Bayardo Efficiently mining long patterns from databases SICMOD 1998: 85-93 8 R J Bayardo and R Agrawal Mining the Most Interesting Rules SIGKDD 1999 145-154 9 S Brin R Motwani J D Ullman and S Tsur Dynamic itemset counting and implication rules for market basket data SIGMOD Record ACM Special Interest Group on Management of Data 26\(2\1997 IO B Dunkel and N Soparkar Data Organization and access for efficient data mining ICDE 1999 l 11 V Ganti J E Gehrke and R Ramakrishnan DEMON Mining and Monitoring Evolving Data. ICDE 2000: 439-448  121 D Gunopulos H Mannila and S Saluja Discovering All Most Specific Sentences by Randomized Algorithms ICDT 1997: 215-229 I31 J Han J Pei and Y Yin Mining Frequent Pattems without Candidate Generation SIGMOD Conference 2000 1  12 I41 M Holsheimer M L Kersten H Mannila and H.Toivonen A Perspective on Databases and Data Mining I51 W Lee and S J Stolfo Data mining approaches for intrusion detection Proceedings of the 7th USENIX Securiry Symposium 1998 I61 D I Lin and Z M Kedem Pincer search A new algorithm for discovering the maximum frequent sets Proc of the 6th Int Conference on Extending Database Technology EDBT Valencia Spain 1998 17 J.-L Lin M.H Dunham Mining Association Rules: Anti Skew Algorithms ICDE 1998 486-493 IS B Mobasher N Jain E H Han and J Srivastava Web mining Pattem discovery from world wide web transactions Technical Report TR-96050 Department of Computer Science University of Minnesota, Minneapolis, 1996 19 J S Park M.-S Chen P S Yu An Effective Hash Based Algorithm for Mining Association Rules SIGMOD Conference 20 N Pasquier Y Bastide R Taouil and L Lakhal Discovering frequent closed itemsets for association rules ICDT 99 398-416, Jerusalem Israel January 1999 21 J Pei J Han and R Mao CLOSET An efficient algorithm for mining frequent closed itemsets Proc of ACM SIGMOD DMKD Workshop Dallas TX May 2000 22 R Rastogi and K Shim Mining Optimized Association Rules with Categorical and Numeric Attributes ICDE 1998 Orlando, Florida, February 1998 23 L Rigoutsos and A Floratos Combinatorial pattem discovery in biological sequences The Teiresias algorithm Bioinfomatics 14 1 1998 55-67 24 R Rymon Search through Systematic Set Enumeration Proc Of Third Int'l Conf On Principles of Knowledge Representation and Reasoning 539 550 I992 25 A Savasere E Omiecinski and S Navathe An efficient algorithm for mining association rules in large databases 21st VLDB Conference 1995 26 P Shenoy J R Haritsa S Sudarshan G Bhalotia M Bawa and D Shah: Turbo-charging Vertical Mining of Large Databases SIGMOD Conference 2000: 22-33 27 R Srikant R Agrawal Mining Generalized Association Rules VLDB 1995 407-419 28 H Toivonen Sampling Large Databases for Association Rules VLDB 1996 134-145 29 K Wang Y He J Han Mining Frequent Itemsets Using Support Constraints VLDB 2000 43-52 30 G I Webb OPUS An efficient admissible algorithm for unordered search Journal of Artificial Intelligence Research 31 L Yip K K Loo B Kao D Cheung and C.K Cheng Lgen A Lattice-Based Candidate Set Generation Algorithm for I/O Efficient Association Rule Mining PAKDD 99 Beijing 1999 32 M J Zaki Scalable Algorithms for Association Mining IEEE Transactions on Knowledge and Data Engineering Vol 12 No 3 pp 372-390 May/June 2000 33 M. J. Zaki and C Hsiao CHARM An efficient algorithm for closed association rule mining RPI Technical Report 99-10 1999 KDD 1995: 150-155 1995 175-186 3~45-83 1996 452 


