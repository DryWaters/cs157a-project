html><head></head><body><pre style="word-wrap: break-word; white-space: pre-wrap;">2004 IEEE  International Conference on Systems, Man and Cybernetics Optimization of Association Rule Mining using Improved Genetic Algorithms Manish Saggar Ashish Kumar Agrawal Abhimanyu Lad Undergraduate Student Undergraduate Student Undergraduate Student 4* Year, B.TECH 4" Year, B.TECH 4" Year, B.TECH Indian Institute of Information Technology, Allahabad, India Indian Institute of Information Technology, Allahahad, India Indian Institute of Information Technology, Allahabad, India msaggar-01 @iiita.ac.in ashir.h-agr82@yahoo.co.in alad-01 @iiita.ac.in Abstract: In this paper, the main area of concenhution wos to optimize the rules generated by Association Rule Mining \(apriori metho4, using Genetic Algorithms. In general the rule generated by Association Rule Mining technique do not consider the negative occurrences of attributes in them, but by using Genetic Algorithms \(GAS over these rules the system can predict the rules which contains negative attributes. The main motivation for using GAS in the discovery of high-levelprediction rules is that they pe$orm a global search and cope better with ottribute interaction than the gree4  rule induction algorithms open used in data mining. The improvements opplied in GAS ore definitely going to kelp the rule bmed systems used for  classification as described in results and conclusions Keywords: Genetic Algorithms, Data Miring Association Rule Mining 1 Introduction In today's jargon, the amount of data storeti in databases continues to grow very fast. This large amount of data contains latent knowledge, which can be utilized to improve decision making process of an organization. This knowledge discovery can be done in various ways available today, like Decision Tree, Association Rule Mining, Bayesian Classifier and so on. The form of this latent knowledge also varies to a l'arge extent liom different kind of rules to prediction values. In this paper the authors have considered Association Rule Mining and tried to improve this technique by applying Genetic Algorithms on the rules generated by Association Rule Mining A brief introduction about Association Rule Mining and GA is given in the following sub-sections, followed by 0-7803-8566-7/04/$20.00 Q 2004 IEEE methodology in section 2, which will describe the basic implementation details of Association Rule Mining and GAS. In section 3 the authors will discuss the results followed by conclusion in the last section 1.1 Association Rules Introduced in 1993 [5], association rule mining has gained great deal of attention. Even today people use it for mining in KDD. In brief, an association rule is an expression X=&gt;Y, where X and Y are item sets The meaning of this kind of rule is : Given a database D containing say N tupples or transactions, where say T belongs to D is a transaction, then X=&gt;Y expresses that whenever a transaction T contains X than T probably also contains Y .  This probability or confidence is defined as the percentage of transactions containing Y in addition to X with regard to overall number of transactions containing X Thus the authors can represent can represent this probability as conditional probability p\(Y  T/X  T thrust behind introduction of these rules was there similarity with market-based data where rules like "A customer buys milk and Bread will also buy butter with a probability, say x % is a famous example. Also, their direct applicability to business problems together with their 


direct applicability to business problems together with their inherent understandability, even for non-experts, made them a popular mining method. Further, it was also determined that their applications can be further extended from general dependency based rules to a wide range of business applications Mining Association rules is not full of advantages; it has some limitations too, first of all the algorithmic complexity. The number of rules grows exponentially with the number of items. But this complexity is tackled with some latest algorithms which can efficiently prune the search space. Secondly, the problem of finding rules from rules, i.e. picking interesting rules from set of rules. The 3725 work tackling the second problem mainly support the user when browsing the rule set, e.g. [4] and the development of further useful quality measures on the rules, e.g. [2;6;7 Thirdly, the problem that is being discussed in this paper is that, association rules do not utter the rules in which the negation of attributes is there. Like, say there are three attributes in the datahase X1, X2, X3, than rules lie  If a customer takes X1 and not X 2  than he will take X3 with a confidence of say c % will not be provided by normal association rule mining. In order to generate these kinds of rules and also to tackle the second problem discussed above, i.e. to evolve quality rules, this paper is using Genetic Algorithms 1.2 Genetic Algorithms As discussed in [I], in general the main motivation for using GAS in the discovery of high-level prediction rules is that they perform a global search and cope better with attribute interaction than the greedy rule induction algorithms often used in data mining. This section of the paper discusses several aspects of GAS for rule discovery The main areas of discussion include individual representation of rules, Genetic Operators involved and the choice of Fimess function Representation of rules plays a major role in GAS broadly there are two approaches based on how rules are encoded in the population of individuals  Chromosomes   as discussed in [l] Michigan and Pittsburgh; The pros and cons as discussed in [ 11 is as follows, Pittsburgh approach leads to syntactically-longer individuals, which tends to make fitness computation more computationally expensive In addition, it may require some modifications to standard genetic operators to cope with relatively complex individuals. By contrast, in the Michigan approach the individuals are simpler and syntactically shorter. This tends to reduce the time taken to compute the fimess function and to simplify the design of genetic operators However, this advantage comes with a cost. First of all since the fitness function evaluates the quality of each rule separately, now it is not easy to compute the quality of the rule set as a whole - i.e. taking rule interactions into account. In this paper Michigan  s approach is opted i.e each individual encodes single rule. The encoding can be done in a number of ways like, binary encoding or expression encoding etc. For example let  s consider a rule  If a customer buys milk and bread then he will also buy butter  which can be simply written as If milk and bread then butter Now, following Michigan  s approach and binary encoding, for simplicity sake, this rule can be represented as 00 01 01 01 10 01 where, the bold di-digits are used as product id, like 00 for milk, 01 for bread and IO for butter and the normal di-digits are 00 or 01 which shows absence  3726 or presence respectively. Now this rule is ready for linther computations Second, area of concem is Genetic Operators. Mainly 


Second, area of concem is Genetic Operators. Mainly three operations are to be performed, selection, cross-over and mutation to robustly search the rule space for various options. Selection involves selecting two fit parents for evolving new children rules which are fit than the parents and in this manner the average fitness of the rules can be increased. Cross-over and mutation provides the ways to evolve new rules Third area of concem is fitness function. Since, the discovered rules should \(a accuracy; \(h c thus choice of this function is very important to get the desired results 2 Methodology In this paper the genetic algorithms are applied over the rules fetched from association rule mining. Now for demonstration its utility, the database is produced synthetically. This database contains the choice of electives by students during their 31d year of course studies at Indian Institute of Information Technology, Allahabad India. Students have to choose four subjects from eight based on their liking and area of interest. Now, the authors fustly implemented Association Rule mining \(using a priori technique  the GAS are applied to evolve the rules which contains the negations in attributes and are of richer quality. In this section the paper discusses each step in detail 2.1 Association Rule Mining \(a-priori The Algorithm for its implementation is same as described in section 1.1. The rules came out of it looks like IF NFC&amp;RIA THEN BI IF QC &amp;VLSI THEN IPR  Where NFC, RIA, QC, VLSI, etc. are of the eight subjects out of which student has to choose four. The rules above shows that if a student takes NFC and RIA then the probability is high that he will choose BI too, similarly if he chooses QC and VLSI then the probability is high that he will take IPR There is no boundation on the number of antecedents in the rules, but there is a constraint on the number of consequents, and i.e number of consequents = 1 This boundation doesn  t make any harm, because if in case the user wants to see the confidence value of ii rule that contains the more than one consequents can dii the same by taking two rules from our system and then by doing the intersection of it 2.2 Genetic Algorithms with Modificationis The GAS implemented over here involves the basics learnt from Goldenberg  s book on Genetic Algorithms The following subsection will tell in more detail various choices a The individuals are represented using the Michiran  s approach, i.e. each individual encodes single rule. As discussed in section 1.2, about its merits and de-merits  a conjunctian of conditions Here the authors have employed binary encoding, for the rules. An example encoding is as follows, since the antecedent can contain all the subjects, thus it needs to have space for all eight subjects. Thus in antecedent each subject has a predefined location and each subject needs two bits for representation, now the two bits can represent four different states, but in this paper the authors have used just three out of them 00 10 00 10 01 00 10 01 1 2 3  4 5 6 7 8 Where, the lower numbereing \(from 1 to 8 the slots for various subjects, like 1 is for NFC, 2 is: for 


the slots for various subjects, like 1 is for NFC, 2 is: for RIA etc. in this manner till eighth slot. The upper bold row gives the status of each subject defined by the student, like if a student chooses the subject than its particular slot will contain a di-digit of 01, similarly if he do not chooser, the subject than 00, and if the subject do not matter in this rule that 10 \(while the option of 11 is not used here For the consequent part the same encoding is used except that only one consequent is allowed c For selection the authors used Roullete Wheel Sampling procedure, in this procedure, the parents for crossover and mutations are selected based on their fitness i.e. if a candidate has more fitness function value more will be its chance to get selected. The implementation of Roullete Wheel Sampling is done by frst  normalizing the values of all candidates so that, there probabilities lie between 0 and 1 ,  and then by using Java  s random number function, a random number is evaluated, and then corresponding to this value and the fitness normalized value, the candidate is selected Mutation; This part of the genetic algorithms require great care, here there are two probabilities, one usually called as pm, this probability will be used to judge whether mntation has to be done or not, when the candidate fulfills this criterion it will be fed to another probability and that is, locus probability that is on which point of the candidate the mutation has to be done In the case of database provided, binary encoding is used thus simple toggling operator is requird for mntation i.e. mutate 0-21 and 1-&gt;0 Crossover ; Same as the case with Mutation here two probabilities are there, one for the whether crossover has to be performed or not, i.e. pc, and other for fmding the location, the point where, crossover must be done This paper bas used single point crossover technique for mutation as described above d A general problem of over-fitting is occurred if simple confidence factor is used as described in [l]. Thus the authors used the following method; described in [l Let a rule be of the form IF A THEN C where A is the antecedent \(a conjunction of conditions and C is the consequent \(predicted class performance of a rule can be snmmarized by a 2 x 2 matrix, sometimes called a confusion matrix, as illustrated in the following fig actual class predicted Class Fig 1 : Confusion Matrix for a classikation rule The labels in each quadrant of the matrix have the following meaning TP = True Positives = Number of examples satisfying A and C FP = False Positives = Number of examples satisfymg A but not C FN = False Negatives = Number of examples not satisfying A but satisfylng C TN = True Negatives =Number of examples not satisfying A nor C 3727 11 Clearly, the higher the values of TF  and TN, and the lower the values of FP and FN, the better the rule Confidence Factor, CF = TP / \(TP + FP 1 Now measure the predictive accuracy of a rule by taking into account not only its CF .hut also a measure of how  complete  the rule is, i.e. what is the proportion of examples having the predicted class C that is actually 


examples having the predicted class C that is actually covered by the d e  antecedent. The rule completeness measure, denoted Comp, is computed by the formula Comp = TP / \(TP + FN 2 In order to combine the CF and Comp measures one can define a fitness function such as Fitness = CF x Comp \(3 Although this fitness function does a good job in evaluating predictive performance, it has nothing to say about the comprehensibility of the rule. This fitness function can be extended \(or any other focusing only on the predictive accuracy of the rule Comprehensibility measure in several ways. A simple approach is to defme a fitness function such as Fitness = wl  x \(CF x Comp 4 where Simp is a measure of rule simplicity \(normalized to take on values in the range O.. l defined weights. The Simp measure can be defined in many different ways, depending on the application domain and on the user. In general, its value is inversely proportional to the number of conditions in the d e antecedent - i.e., the shorter the rule, the simpler it is 3 Results As described earlier, in this paper the implementation of GAS are applied to the rules obtained hy applying association rule mining on synthetic database which is based on the selection procedure of electives in 3  d year of B.Tech course. The database was made at random The columns in the datahase are the subjects and their value is either one or zero depending on whether they are selected or not. Following figure shows a database glimpse  0 8 . 8  0  Fig 2 : Glimpse of Database The parameters used for GAS in this paper are as follows Table 1 : GA parameters Sampling with DeJong  s Crowding Procedure Cross Over Probability I Mutation Probability I 0.005 Fitness Function 1 As described in section 2.2.4 Accuracv of the d e s  I 100 The rules evolved out of the system after application of apriori -association rule minimg and GAS in succesion contains some rules with negations in the attributes as predicted and desired The following rules were evolved from 100 rows of the synthetic datahase created 3726 I I I W J ~ ' E B J \( ~ I P R ~  I   X W O W UIJPC  BEI1\(!D~]IEI1J!II  OCJ\(!BJ\(EBIIIPR   0.21428571428S1161 l!sTil \(!.Ul\(O[ll!BIl \(!EBl\(!I?Rl J 1RSI] l!DQij I rib contidct 0.5306122#P919!92 r  Fig 3 : Showing Association rules and new Genetically evolved rules 4 Conclusions and Future Work Although a number of works are already published in this field, hut in this paper the authors have tried to USI: the enormous robustness of GAS in mining the Association Rules. The results generated when the technique applied 


on the synthetic database, includes the desired rules:. i.e rules containing the negation of the attributes as well ai; the general rules evolved from the Association Rule Minin,g The authors believe that the toolkit can also handle other databases, after minor modifications. As for future work, the authors are currently working on the complexity reduction of Genetic Algorithms by using distributed computing References I] Alex A. Freitas, "A Survey of Evolutionary Algorithms for Data Mining and Knowledge Discovi:ry Postgraduate Program in Computer Science, Pontilicia Universidade Catolica do Parana Rna Imaculada Conceicao, 1155. Curitiba ~ PR. 80215-901. Brazil 2] C. Silverstein, S. Brin, R. Motwani and J.D. Ullan Scalable techniques for mining causal structures. In the Proc. of 1998 ACM SIGMOD Int'l Conf. on Management of Data, Seattle, Washington, USA, June 1998 3] Manish Saggar, Ashish K. Aganval, Abhishek Aganval; Discovery- A Data Mining Tookit, Under graduate mini-project in 4th semester of 4 year B.TECH course from IIIT-A 4] M. Klemettinen, H. Mannila, P. Ronkainen, H Toivonen, and A.I. Verkamo. Finding interesting rules from large sets of discovered association rules. In Proc. of the 3" Int'l Cod. on Information and Knowledge Management, Gaithershurg, Maryland, 29. Nov - 2. Dec 1994 5] R.Agrawal, T. Imielinski, and A.Swami. Mining association rules between sets of items in large databases In the Proc. of the ACM SIGMOD Int'l Cod,  on Management of Data \(ACM SIGMOD '93 USA, May 1993 6] S. Brin, R. Motwani, and C. Silverstein. Beyond market baskets: Generalising association rules to correlations. In the Proc. of the ACM SIGMOD Int'l Conference on Management of Data \(ACM SIGMOD '97 7] S. Brin, R. Motwani, J.D. Ulhnan, and S. Tsur Dynamic itemset counting and implication rules for market basket data. In the Proc. of the ACM SIGMOD Int'l Conf on Management of Data, 1997 3729 pre></body></html 


A S 2005#219_81_01616731.pdf.t xt t e xt  pl a i n 1 1629 xt a ppl i c a t i on oc t e t s t re a m 17972 xt t e xt  pl a i n 22442 A S 2005#219_84_01434871.pdf.t xt t e xt  pl a i n 24210 xt n 12139 xt t e xt  pl a i n 1577 A S 2005#219_87_01562776.pdf.t xt a ppl i c a t i on oc t e t s t re a m 23184 xt a ppl i c a t i on oc t e t s t re a m 17875 xt t e xt  pl a i n 22796 A S 2005#219_90_01547368.pdf.t xt t e xt  pl a i n 29777 xt a ppl i c a t i on oc t e t s t re a m 19235 xt n 9995 xt t e xt  pl a i n 8512 A S 2005#219_94_01547343.pdf.t xt t e xt  pl a i n 14 A S 2005#219_95_0152731 1.pdf.t xt t e xt  pl a i n 28623 xt a ppl i c a t i on oc t e t s t re a m 21584 A S 2005#219_97_01529474.pdf.t xt t e xt  pl a i n 27494 xt n 31529 xt a ppl i c a t i on oc t e t s t re a m 150 A S 2005#219_100_01545181.pdf.t xt a ppl i c a t i on oc t e t s t re a m 28617 A S 2005#219_101_01565673.pdf.t xt t e xt  pl a i n 43389 xt n 10040 xt t e xt  pl a i n 28430 A S 2005#219_104_01467710.pdf.t xt t e xt  pl a i n 22267 xt a ppl i c a t i on oc t e t s t re a m 17799 xt t e xt  pl a i n 21355 A S 2005#219_107_01416460.pdf.t xt a ppl i c a t i on oc t e t s t re a m 15752 xt n 1 1281 xt n 17635 xt n 15958 A S 2005#219_1 1 1_01572320.pdf.t xt t e xt  pl a i n 18685 xt n 33715 xt n 36162 xt n 28692 xt n 27476 xt a ppl i c a t i on oc t e t s t re a m 34155 xt a ppl i c a t i on oc t e t s t re a m 31425 xt n 39506 xt n 19383 xt t e xt  pl a i n 18545 A S 2005#219_121_01684322.pdf.t xt t e xt  pl a i n 7990 xt n 30289 xt a ppl i c a t i on oc t e t s t re a m 18715 A S 2005#219_124_01565744.pdf.t xt t e xt  pl a i n 14055 xt a ppl i c a t i on oc t e t s t re a m 29423 xt a ppl i c a t i on oc t e t s t re a m 28950 A S 2005#219_127_01591957.pdf.t xt t e xt  pl a i n 28826 xt n 20054 xt t e xt  pl a i n 18194 A S 2005#219_130_01595839.pdf.t xt t e xt  pl a i n 19792 


xt n 19792 xt t e xt  pl a i n 13977 A S 2005#219_132_01562645.pdf.t xt a ppl i c a t i on oc t e t s t re a m 32966 xt n 7519 xt n 3981 xt t e xt  pl a i n 19758 A S 2005#219_136_01565764.pdf.t xt a ppl i c a t i on oc t e t s t re a m 20034 xt a ppl i c a t i on oc t e t s t re a m 21069 xt t e xt  pl a i n 31044 A S 2005#219_139_01428463.pdf.t xt a ppl i c a t i on oc t e t s t re a m 34618 xt a ppl i c a t i on oc t e t s t re a m 38682 xt t e xt  pl a i n 20529 A S 2005#219_142_01647787.pdf.t xt a ppl i c a t i on oc t e t s t re a m 34775 xt a ppl i c a t i on oc t e t s t re a m 18993 xt a ppl i c a t i on oc t e t s t re a m 18379 A S 2005#219_145_04085288.pdf.t xt a ppl i c a t i on oc t e t s t re a m 17000 xt n 24341 xt t e xt  pl a i n 20984 A S 2005#219_148_01571 139.pdf.t xt t e xt  pl a i n 25796 xt n 18836 xt a ppl i c a t i on oc t e t s t re a m 19592 A S 2005#219_151_01565794.pdf.t xt a ppl i c a t i on oc t e t s t re a m 19937 xt n 17383 xt t e xt  pl a i n 26283 A S 2005#219_154_01571713.pdf.t xt t e xt  pl a i n 30495 xt n 21627 xt t e xt  pl a i n 24023 A S 2005#219_157_01410188.pdf.t xt a ppl i c a t i on oc t e t s t re a m 73548 xt n 25661 xt t e xt  pl a i n 30801 A S 2005#219_160_01565675.pdf.t xt a ppl i c a t i on oc t e t s t re a m 36582 xt n 19335 xt a ppl i c a t i on oc t e t s t re a m 35925 A S 2005#219_163_01524032.pdf.t xt t e xt  pl a i n 33370 xt n 19704 xt t e xt  pl a i n 37045 A S 2005#219_166_01522861.pdf.t xt a ppl i c a t i on oc t e t s t re a m 21236 xt n 26842 xt a ppl i c a t i on oc t e t s t re a m 39012 A S 2005#219_169_01598834.pdf.t xt t e xt  pl a i n 18689 xt n 12319 xt t e xt  pl a i n 16947 A S 2005#219_172_04133499.pdf.t xt t e xt  pl a i n 23083 xt n 17758 xt t e xt  pl a i n 29325 A S 2005#219_175_01425248.pdf.t xt t e xt  pl a i n 1285 A S 2005#219_176_01452149.pdf.t xt t e xt  pl a i n 15656 xt t e xt  pl a i n 39326 A S 2005#219_178_01527272.pdf.t xt t e xt  pl a i n 28030 xt n 15029 xt t e xt  pl a i n 33284 


xt n 33284 xt n 20304 xt n 25016 xt t e xt  pl a i n 39404 A S 2005#219_184_01647786.pdf.t xt t e xt  pl a i n 32135 xt n 7439 xt t e xt  pl a i n 20831 A S 2005#219_187_01578757.pdf.t xt a ppl i c a t i on oc t e t s t re a m 29401 xt n 22909 xt t e xt  pl a i n 7901 A S 2005#219_190_01565747.pdf.t xt t e xt  pl a i n 18145 xt n 19319 xt a ppl i c a t i on oc t e t s t re a m 158 A S 2005#219_193_01565708.pdf.t xt a ppl i c a t i on oc t e t s t re a m 37537 A S 2005#219_194_01587556.pdf.t xt t e xt  pl a i n 22203 xt a ppl i c a t i on oc t e t s t re a m 34180 xt t e xt  pl a i n 14418 A S 2005#219_197_01616237.pdf.t xt t e xt  pl a i n 14621 xt n 23075 xt t e xt  pl a i n 28629 A S 2005#219_200_01607471.pdf.t xt t e xt  pl a i n 27671 xt a ppl i c a t i on oc t e t s t re a m 25191 xt t e xt  pl a i n 34132 A S 2005#219_203_01587551.pdf.t xt t e xt  pl a i n 24699 xt a ppl i c a t i on oc t e t s t re a m 24690 xt t e xt  pl a i n 27266 A S 2005#219_206_01662306.pdf.t xt t e xt  pl a i n 16968 xt n 29446 xt t e xt  pl a i n 24323 A S 2005#219_209_01461779.pdf.t xt t e xt  pl a i n 19792 xt n 28753 xt n 15442 xt a ppl i c a t i on oc t e t s t re a m 20877 A S 2005#219_213_01631278.pdf.t xt a ppl i c a t i on oc t e t s t re a m 29361 xt n 22678 A S 2005#219_215_015001 1 1.pdf.t xt t e xt  pl a i n 14579 xt t e xt  pl a i n 36462 A S 2005#219_217_01553005.pdf.t xt t e xt  pl a i n 24200 xt  33655 A S 2005#219_219_01562644.pdf.t xt a ppl i c a t i on oc t e t s t re a m 20212 xt n 27490 xt t e xt  pl a i n 25676 A S 2006#237_3_04216805.pdf.t xt t e xt  pl a i n 26780 xt n 24003 xt t e xt  pl a i n 25270 A S 2006#237_6_04052773.pdf.t xt t e xt  pl a i n 20034 xt a ppl i c a t i on oc t e t s t re a m 31 129 xt  34205 A S 2006#237_9_01684993.pdf.t xt t e xt  pl a i n 26787 xt n 28994 xt a ppl i c a t i on oc t e t s t re a m 25060 


A S 2006#237_1 1_04021078.pdf.t xt a ppl i c a t i on oc t e t s t re a m 25060 xt t e xt  pl a i n 17067 A S 2006#237_13_04085462.pdf.t xt a ppl i c a t i on oc t e t s t re a m 24865 xt n 16444 xt t e xt  pl a i n 29459 A S 2006#237_16_04030898.pdf.t xt a ppl i c a t i on oc t e t s t re a m 31967 xt n 44817 xt t e xt  pl a i n 30604 A S 2006#237_19_01692192.pdf.t xt t e xt  pl a i n 14301 xt n 47081 xt a ppl i c a t i on oc t e t s t re a m 21216 A S 2006#237_22_01651995.pdf.t xt t e xt  pl a i n 19500 xt n 24747 xt t e xt  pl a i n 21056 A S 2006#237_25_04072208.pdf.t xt t e xt  pl a i n 20440 xt n 26159 xt t e xt  pl a i n 51484 A S 2006#237_28_0404161 1.pdf.t xt t e xt  pl a i n 34488 xt n 36884 xt t e xt  pl a i n 15297 A S 2006#237_31_04028223.pdf.t xt t e xt  pl a i n 19681 xt n 29194 xt a ppl i c a t i on oc t e t s t re a m 25157 A S 2006#237_34_04061370.pdf.t xt a ppl i c a t i on oc t e t s t re a m 30602 xt a ppl i c a t i on oc t e t s t re a m 31343 xt t e xt  pl a i n 26734 A S 2006#237_37_01647707.pdf.t xt a ppl i c a t i on oc t e t s t re a m 55637 xt a ppl i c a t i on oc t e t s t re a m 50522 xt t e xt  pl a i n 32709 A S 2006#237_40_04104869.pdf.t xt t e xt  pl a i n 26395 xt a ppl i c a t i on oc t e t s t re a m 23362 xt a ppl i c a t i on oc t e t s t re a m 23314 A S 2006#237_43_04028215.pdf.t xt t e xt  pl a i n 23042 xt n 27599 xt a ppl i c a t i on oc t e t s t re a m 19 A S 2006#237_46_04155477.pdf.t xt t e xt  pl a i n 27219 A S 2006#237_47_04018542.pdf.t xt t e xt  pl a i n 30149 xt n 27958 xt t e xt  pl a i n 29943 A S 2006#237_50_04072193.pdf.t xt a ppl i c a t i on oc t e t s t re a m 26669 xt n 31 120 xt n 17300 xt a ppl i c a t i on oc t e t s t re a m 21930 A S 2006#237_54_04077818.pdf.t xt t e xt  pl a i n 20656 xt n 34280 xt t e xt  pl a i n 22732 A S 2006#237_57_04028269.pdf.t xt t e xt  pl a i n 21082 xt n 24550 xt t e xt  pl a i n 30583 A S 2006#237_60_04053125.pdf.t xt a ppl i c a t i on oc t e t s t re a m 22832 


xt a ppl i c a t i on oc t e t s t re a m 22832 xt t e xt  pl a i n 17993 


the initial global candidate set would be similar to the set of global MFIs. As a result, during the global mining phase the communication and synchronization overhead is low  0 2 4 6 8 1 0 Number of Nodes Figure 5. Speedup of DMM 4.4.2 Sizeup For the sizeup test, we fixed the system to the 8-node con figuration, and distributed each database listed in Table 2 to the 8 nodes. Then, we increased the local database sire at each node from 45 MB to 215 MB by duplicating the initial database partition allocated to the node. Thus, the data distribution characteristics remained the same as the local database size was increased. This is different from the speedup test, where the database repartitioning was per formed when the number of nodes was increased. The per formance of DMM is affected by the database repartitioning to some extent, although it is usually very small. During the sizeup test, the local mining result of DMM is not changed at all at each node The results shown in Figure 6 indicate that DMM has a very good sizeup property. Since increasing the size of local database did not affect the local mining result of DMM at each node, the total execution time increased just due to more disk U 0  and computation cost which scaled almost linearly with sizeup 5 Conclusions In this paper, we proposed a new parallel maximal fre quent itemset \(MFI Max-Miner \(DMM tems. DMM is a parallel version of Max-Miner, and it re quires low synchronization and communication overhead compared to other parallel algorithms. In DMM, Max Miner is applied on each database partition during the lo 0 45 90 135 180 225 270 Amwnt of Data per Node \(ME Figure 6. Sizeup of DMM cal mining phase. Only one synchronization is needed at thc end of this phase to construct thc initial global candi date set. In the global mining phase, a top-down search is performed on the candidate set, and a prefix tree is used to count the candidates with different length efficiently. Usu ally, just a few passes are needed to find all global maximal frequent itemsets. Thus, DMM largely reduces the number of synchronizations required between processing nodes Compared with Count Distribution, DMM shows a great improvement when some frequent itemscts are large \(i.e long patterns employed by DMM for efficient communication between nodes; and global support estimation, subset-infrequency based pruning, and superset-frequency based pruning are used to reduce the size of global candidate set. DMM has very good speedup and sizeup properties References I ]  R. Agrawal and R. Srikant  FdSt Algorithms for Mining As sociation Rules  Pmc. o f f h e  ZOrh VLDB Conf, 1994, pp 487499 2] R. Agrawal and I. C. Shafer  Parallel Mining of Association Rules  IEEE Trans. on Knowledge and Dura Engineering Vol. 8, No. 6, 1996, pp. 962-969 3] R. I. Bayardo  Efficient Mining Long Patlems from Databases  Proc. ofrhe ACM SIGMOD Inf  l Conf on Man ogemenr ofDara, 1998, pp. 85-91 4] S.  M. Chung and J. Yang  A Parallel Distributive Join Al gorithm for Cube-Connected Multiprocessors  IEEE Trans on Parallel and Disrribured Systems, Vol. 7, No. 2, 1996, pp 127-137 51 M. Snir, S. Otto. S. Huss-Lederman, D. Walker, and J. Don gana, MPI: The Complete Reference, The MIT Press, 1996 


gana, MPI: The Complete Reference, The MIT Press, 1996 6] R. Rymon  Search through Systematic Set Enumeralion   Pmc. of3rd Inr  l Con$ on Principles of Knowledge Repre sentation and Reasoning, 1992, pp. 539-550 507 pre></body></html 


sketch-index in answering aggregate queries. Then Section 5.2 studies the effect of approximating spatiotemporal data, while Section 5.3 presents preliminary results for mining association rules 5.1 Performance of sketch-indexes Due to the lack of real spatio-temporal datasets we generate synthetic data in a way similar to [SJLL00 TPS03] aiming at simulation of air traffic. We first adopt a real spatial dataset [Tiger] that contains 10k 2D points representing locations in the Long Beach county \(the data space is normalized to unit length on each dimension These points serve as the  airbases  At the initial timestamp 0, we generate 100k air planes, such that each plane \(i uniformly generated in [200,300], \(ii, iii destination that are two random different airbases, and iv  the velocity direction is determined by the orientation of the line segment connecting its source and destination airbases move continually according to their velocities. Once a plane reaches its destination, it flies towards another randomly selected also uniform in [0.02, 0.04 reports to its nearest airbase, or specifically, the database consists of tuples in the form &lt;time t, airbase b, plane p passenger # a&gt;, specifying that plane p with a passengers is closest to base b at time t A spatio-temporal count/sum query has two parameters the length qrlen of its query \(square number qtlen of timestamps covered by its interval. The actual extent of the window \(interval uniformly in the data space \(history, i.e., timestamps 0,100 air planes that report to airbases in qr during qt, while a sum query returns the sum of these planes  passengers. A workload consists of 100 queries with the same parameters qrlen and qtlen The disk page size is set to 1k in all cases \(the relatively small page size simulates situations where the database is much more voluminous specialized method for distinct spatio-temporal aggregation, we compare the sketch-index to the following relational approach that can be implemented in a DBMS. Specifically, we index the 4-tuple table lt;t,b,p,a&gt; using a B-tree on the time t column. Given a count query \(with window qr and interval qt SELECT distinct p FROM &lt;t,b,p,a&gt WHERE t?qt &amp; b contained in qr The performance of each method is measured as the average number of page accesses \(per query processing a workload. For the sketch-index, we also report the average \(relative Specifically, let acti and esti be the actual and estimated results of the i-th query in the workload; then the error equals \(1/100 set the number of bits in each sketch to 24, and vary the number of sketches The first experiment evaluates the space consumption Figure 5.1 shows the sketch index size as a function of the number of sketches used \(count- and sum-indexes have the same results more sketches are included, but is usually considerably smaller than the database size \(e.g., for 16 signatures, the size is only 40% the database size 0 20 40 60 80 


80 100 120 140 160 8 16 32 number of sketches size \(mega bytes database size Figure 5.1: Size comparison Next we demonstrate the superiority of the proposed sketch-pruning query algorithm, with respect to the na  ve one that applies only spatio-temporal predicates. Figure 5.2a illustrates the costs of both algorithms for countworkloads with qtlen=10 and various qrlen \(the index used in this case has 16 sketches also illustrate the performance of the relational method which, however, is clearly incomparable \(for qrlen?0.1, it is worse by an order of magnitude we omit this technique Sketch-pruning always outperforms na  ve \(e.g., eventually two times faster for qrlen=0.25 increases with qrlen, since queries returning larger results tend to set bits in the result sketch more quickly, thus enhancing the power of Heuristics 3.1 and 3.2. In Figure 5.2b, we compare the two methods by fixing qrlen to 0.15 and varying qtlen. Similar to the findings of [PTKZ02]4 both algorithms demonstrate  step-wise  growths in their costs, while sketch-pruning is again significantly faster The experiments with sum-workloads lead to the same observations, and therefore we evaluate sketch-indexes using sketch-pruning in the rest of the experiments 4 As explained in [PTKZ02], query processing accesses at most two paths from the root to the leaf level of each B-tree regardless the length of the query interval Proceedings of the 20th International Conference on Data Engineering \(ICDE  04 1063-6382/04 $ 20.00  2004 IEEE sketch-pruning naive relational 0 100 200 300 400 500 600 700 800 900 0.05 0.1 0.15 0.2 0.25 number of disk accesses query rectangle length 300 0 100 200 400 500 600 1 5 10 15 20 number of disk accesses query interval length a qtlen=10 b qrlen=0.15 Figure 5.2: Superiority of sketch-pruning \(count As discussed in Section 2, a large number of sketches reduces the variance in the resulting estimate. To verify this, Figure 5.3a plots the count-workload error of indexes 


using 8-, 16-, and 32- sketches, as a function of qrlen qtlen=10 error \(below 10 it increases slowly with qrlen used, however, the error rate is much higher \(up to 30 and has serious fluctuation, indicating the prediction is not robust. The performance of 16-sketch is in between these two extremes, or specifically, its accuracy is reasonably high \(average error around 15 much less fluctuation than 8-sketch 32-sketch 16-sketch 8-sketch relative error 0 5 10 15 20 25 30 35 0.05 0.1 0.15 0.2 0.25 query rectangle length relative error 0 5 10 15 20 25 30 35 1 5 10 15 20 query interval length a qtlen=10, count b qrlen=0.15, count relative error query rectangle length 0 5 10 15 20 25 0.05 0.1 0.15 0.2 0.25 relative error query interval length 0 5 10 15 20 25 30 1 5 10 15 20 c qtlen=10, sum d qrlen=0.15, sum Figure 5.3: Accuracy of the approximate results The same phenomena are confirmed in Figures 5.3b where we fix qrlen to 0.15 and vary qtlen 5.3d \(results for sum-workloads number of sketches improves the estimation accuracy, it also leads to higher space requirements \(as shown in Figure 5.1 Figures 5.4a and 5.4b show the number of disk accesses for the settings of Figures 5.3a and 5.3b. All indexes have almost the same behavior, while the 32-sketch is clearly more expensive than the other two indexes. The interesting observation is that 8- and 16-sketches have 


interesting observation is that 8- and 16-sketches have almost the same overhead due to the similar heights of their B-trees. Since the diagrams for sum-workloads illustrate \(almost avoid redundancy 32-sketch 16-sketch 8-sketch number of disk accesses query rectangle length 0 50 100 150 200 250 300 350 400 0.05 0.1 0.15 0.2 0.25 number of disk accesses query interval length 0 50 100 150 200 250 300 350 1 5 10 15 20 a qtlen=10 b qrlen=0.15 Figure 5.4: Costs of indexes with various signatures Summary: The sketch index constitutes an effective method for approximate spatio-temporal \(distinct aggregate processing. Particularly, the best tradeoff between space, query time, and estimation accuracy obtained by 16 sketches, which leads to size around 40 the database, fast response time \(an order of magnitude faster than the relational method average relative error 5.2 Approximating spatio-temporal data We proceed to study the efficiency of using sketches to approximate spatio-temporal data \(proposed in Section 4.1 as in the last section, except that at each timestamp all airplanes report their locations to a central server \(instead of their respective nearest bases maintains a table in the form &lt;time t, plane p, x, y&gt;, where x,y with parameters qrlen and qtlen distinct planes satisfying the spatial and temporal conditions. For comparison, we index the table using a 3D R*-tree on the columns time, x, and y. Given a query, this tree facilitates the retrieval of all qualifying tuples, after which a post-processing step is performed to obtain the Proceedings of the 20th International Conference on Data Engineering \(ICDE  04 1063-6382/04 $ 20.00  2004 IEEE number of distinct planes \(in the sequel, we refer to this method as 3DR method introduces a regular res  res grid of the data space, where the resolution res is a parameter. We adopt 16 sketches because, as mentioned earlier, this number gives the best overall performance Figure 5.5 compares the sizes of the resulting sketch indexes \(obtained with resolutions res=25, 50, 100 the database size. In all cases, we achieve high compression rate \(e.g., the rate is 25% for res=25 evaluate the query efficiency, we first set the resolution to the median value 50, and use the sketch index to answer workloads with various qrlen \(qtlen=10 


workloads with various qrlen \(qtlen=10 size \(mega bytes database size 0 20 40 60 80 100 120 140 160 25 50 100 resolution Figure 5.5: Size reduction Figure 5.6a shows the query costs \(together with the error in each case method. The sketch index is faster than 3DR by an order of magnitude \(note that the vertical axis is in logarithmic scale around 15% error observations using workloads with different qtlen Finally, we examine the effect of resolution res using a workload with qrlen=0.15 and qtlen=10. As shown in Figure 5.6c, larger res incurs higher query overhead, but improves the estimation accuracy Summary: The proposed sketch method can be used to efficiently approximate spatio-temporal data for aggregate processing. It consumes significantly smaller space, and answers a query almost in real-time with low error 3D Rsketch number of disk accesses query rectangle length 1 10 100 1k 10k 0.05 0.1 0.15 0.2 0.25 16 14% 15 15% 13 relative error number of disk accesses query interval length 1 10 100 1k 10k 1 5 10 15 20 16 15% 15% 12% 11 relative error a qtlen=10, res=25 b qrlen=0.15, res=25 0 500 1000 1500 2000 2500 25 50 100 number of disk accesses resolution 20% 15% 14 relative error c qrlen=0.15, qtlen=10 


c qrlen=0.15, qtlen=10 Figure 5.6: Query efficiency \(costs and error 5.3 Mining association rules To evaluate the proposed algorithm for mining spatiotemporal association rules, we first artificially formulate 1000 association rules in the form \(r1,T,90 with 90% confidence i randomly picked from 10k ones, \(ii in at most one rule, and \(iii Then, at each of the following 100 timestamps, we assign 100k objects to the 10k regions following these rules. We execute our algorithms \(using 16 sketches these rules, and measure \(i  correct  rules divided by the total number of discovered rules, and \(ii successfully mined Figures 5.7a and 5.7b illustrate the precision and recall as a function of T respectively. Our algorithm has good precision \(close to 90 majority of the rules discovered are correct. The recall however, is relatively low for short T, but gradually increases \(90% for T=25 evaluated in the previous sections, the estimation error decreases as the query result becomes larger \(i.e., the case for higher T 78 80 82 84 86 88 90 92 94 96 5 10 2015 25 precision HT 78 80 82 84 86 88 90 92 94 96 5 10 2015 25 recall HT a b Figure 5.7: Efficiency of the mining algorithm Summary: The preliminary results justify the usefulness of our mining algorithm, whose efficiency improves as T increases Proceedings of the 20th International Conference on Data Engineering \(ICDE  04 1063-6382/04 $ 20.00  2004 IEEE 6. Conclusions While efficient aggregation is the objective of most spatio-temporal applications in practice, the existing solutions either incur prohibitive space consumption and query time, or are not able to return useful aggregate results due to the distinct counting problem. In this paper we propose the sketch index that integrates traditional approximate counting techniques with spatio-temporal indexes. Sketch indexes use a highly optimized query algorithm resulting in both smaller database size and faster query time. Our experiments show that while a sketch index consumes only a fraction of the space required for a conventional database, it can process 


required for a conventional database, it can process queries an order of magnitude faster with average relative error less than 15 While we chose to use FM sketches, our methodology can leverage any sketches allowing union operations Comparing the efficiency of different sketches constitutes a direction for future work, as well as further investigation of more sophisticated algorithms for mining association rules. For example, heuristics similar to those used for searching sketch indexes may be applied to improve the brute-force implementation ACKNOWLEDGEMENTS Yufei Tao and Dimitris Papadias were supported by grant HKUST 6197/02E from Hong Kong RGC. George Kollios, Jeffrey Considine and were Feifei Li supported by NSF CAREER IIS-0133825 and NSF IIS-0308213 grants References BKSS90] Beckmann, N., Kriegel, H., Schneider, R Seeger, B. The R*-tree: An Efficient and Robust Access Method for Points and Rectangles. SIGMOD, 1990 CDD+01] Chaudhuri, S., Das, G., Datar, M., Motwani R., Narasayya, V. Overcoming Limitations of Sampling for Aggregation Queries. ICDE 2001 CLKB04] Jeffrey Considine, Feifei Li, George Kollios John Byers. Approximate aggregation techniques for sensor databases. ICDE, 2004 CR94] Chen, C., Roussopoulos, N. Adaptive Selectivity Estimation Using Query Feedback. SIGMOD, 1994 FM85] Flajolet, P., Martin, G. Probabilistic Counting Algorithms for Data Base Applications JCSS, 32\(2 G84] Guttman, A. R-Trees: A Dynamic Index Structure for Spatial Searching. SIGMOD 1984 GAA03] Govindarajan, S., Agarwal, P., Arge, L. CRBTree: An Efficient Indexing Scheme for Range Aggregate Queries. ICDT, 2003 GGR03] Ganguly, S., Garofalakis, M., Rastogi, R Processing Set Expressions Over Continuous Update Streams. SIGMOD, 2003 HHW97] Hellerstein, J., Haas, P., Wang, H. Online Aggregation. SIGMOD, 1997 JL99] Jurgens, M., Lenz, H. PISA: Performance Models for Index Structures with and without Aggregated Data. SSDBM, 1999 LM01] Lazaridis, I., Mehrotra, S. Progressive Approximate Aggregate Queries with a Multi-Resolution Tree Structure. SIGMOD 2001 PGF02] Palmer, C., Gibbons, P., Faloutsos, C. ANF A Fast and Scalable Tool for Data Mining in Massive Graphs. SIGKDD, 2002 PKZT01] Papadias,  D., Kalnis, P.,  Zhang, J., Tao, Y Efficient OLAP Operations in Spatial Data Warehouses. SSTD, 2001 PTKZ02] Papadias, D., Tao, Y., Kalnis, P., Zhang, J Indexing Spatio-Temporal Data Warehouses ICDE, 2002 SJLL00] Saltenis, S., Jensen, C., Leutenegger, S Lopez, M.A. Indexing the Positions of Continuously Moving Objects. SIGMOD 2000 SRF87] Sellis, T., Roussopoulos, N., Faloutsos, C The R+-tree: A Dynamic Index for MultiDimensional Objects. VLDB, 1987 TGIK02] Thaper, N., Guha, S., Indyk, P., Koudas, N Dynamic Multidimensional Histograms 


SIGMOD, 2002 Tiger] www.census.gov/geo/www/tiger TPS03] Tao, Y., Papadias, D., Sun, J. The TPR*Tree: An Optimized Spatio-Temporal Access Method for Predictive Queries. VLDB, 2003 TPZ02] Tao, Y., Papadias, D., Zhang, J. Aggregate Processing of Planar Points. EDBT, 2002 TSP03] Tao, Y., Sun, J., Papadias, D. Analysis of Predictive Spatio-Temporal Queries. TODS 28\(4 ZMT+01] Zhang, D., Markowetz, A., Tsotras, V Gunopulos, D., Seeger, B. Efficient Computation of Temporal Aggregates with Range Predicates. PODS, 2001 ZTG02] Zhang, D., Tsotras, V., Gunopulos, D Efficient Aggregation over Objects with Extent PODS, 2002 Proceedings of the 20th International Conference on Data Engineering \(ICDE  04 1063-6382/04 $ 20.00  2004 IEEE pre></body></html 


