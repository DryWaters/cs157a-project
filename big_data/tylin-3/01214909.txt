1 Bitmap Techniques for Optimizing Decision Support Queries and Association Rule Algorithms Xiaohua Hu                              T.Y.Lin                                 Eric Louie College of Info.  Science   Dept. of Computer Science        IBM Almaden Research Center Drexel University              San Jose State University          650 Harry Road Philadelphia, PA 19104   San Jose, California 95192        San Jose, CA 95120 thu@cis.drexel.edu tylin@cs.sjsu.edu ewlouie@almaden.ibm.com  Abstract In this paper, we discuss some new bitmap tech 
niques for optimizing decision support queries and association rule algorithm.  We first show how to use a new type of predefined bitmap join index \(prejoin_bitmap_index\ to efficiently execute complex decision support queries with multiple outer join operations involved and push the outer join operations from the data flow level to the bitmap level and achieve significant performance gain. Then we discuss a bitmap based association rule algorithm. Our bitmap based associa 
tion rule algorithm Bit-AssocRule doesnêt follow the generation-and-test strategy of Apriori algorithm and adopts the divide-and-conquer strategy, thus avoids the time-consuming table scan to find and prune the itemsets, all the operations of finding large itemsets from the datasets are the fast bit operations. The experimental results show Bit-AssocRule is 2 to 3 orders of magnitude faster than Apriori and AprioirHybrid algorithms. Our results indicate that bitmap techniques can greatly improve the performance of decision support queries and association rule algorithm, and bitmap techniques are 
very promising for the decision support query optimization and data mining applications 1. Introduction In this paper we present some novel bitmap techniques in two new areas. We first present a new method to use bitmap join indexes to efficiently execute complex DSS queries with multi-tables with outer join conditions, and then we discuss a bitmap-based algorithm in finding association rules from large databases. In DSS application for multi-table joins with outer join operations, no work is done to use the performance advantages of the bitmap 
indexes, all the execution of the complex queries with outer join operations are done in the data flow level in an ças writtené manner. With the outer join operations are becoming more and more frequent in the DSS and DM queries, it is very important to push down part of the join operations to the bitmap join indexes level to take the advantage of the efficiency of the bitmap join indexes to efficiently execute common multi-table joins with outer join operation involved.  In our method, a 
predefined join table \(prejoin table\ultitable join based on the full outer join conditions. A set of prejoin_bitmap_indexes is created corresponding to the full outer join conditions in the multi-table joins. An efficient method to calculate the foundset for the multi table outer joins by using prejoin_bitmap_indexes for multiple outer join operations is proposed. Our method uses prejoin_bitmap_indexes, which can resolve join predicates using the bitmap indexes to determine a found set very efficiently.  Next we present a bitmap 
based algorithm Bit-AssocRule for finding association rules from large databases. Traditional Apriori algorithms require multiple full table scans and generates and tests the itemsets in order to find association rules from large database. Our Bit-AssocRule avoids these time-consuming operations and relies on the fast bit operations to find the large itemsets.  With bitmap techniques, we can greatly improve the performance of the association rule algorithms The rest of the paper is organized as follows: we give an overview of bitmap indexes and introduce the 
new bitmap techniques in Section 2. In Section 3 we present the prejoin_bitmap_index based algorithm for outer join DSS queries optimization with some examples. In section 4 we present the bitmap-based associaProceedings of the Seventh International Database Engineering and Applications Symposium \(IDEASê03 1098-8068/03 $17.00 © 2003 IEEE 


2 tion algorithm Bit-AssocRule and the comparison results of Bit-AssocRule with Apriori and AprioriHybrid Section 5 concludes the paper with some discussions 2. Bitmap Indexes and New Bitmap Techniques Various bitmap techniques have been studied extensively and applied successfully in various application domains [5,12,14,15,16,19,20,22,23,27,28,30 In our study we noticed that there is a relationship between a columnês cardinality \(i.e., the number of distinct values\within the SQL language and the DSS & DM usage model. A column that has a low cardinality tends to be used most frequently in DSS within SQL WHERE clauses and GROUP BY clause. When use in SQL WHERE clause, a high cardinality column is usually a range predicate a sed  on this consideration we propose a hybrid bitmap technique which uses projection indexes, B-Tree indexes, traditional bitmap indexes, and advanced high-cardinality bitwise indexes to store and manipulate all data Our implementation of the low cardinality indexing technique differs from other implementation in several ways. Most implementations, including the one used by Oracle, are only useful at the very low end. This is because as the cardinality increases, so does the size of the index. What basically occurs is that the number of zero bits in the bitmaps increases with the cardinality. The number of 1 bits increases with the number of rows Hence, as the cardinality increases with the same number of rows, more and more zero bits occur with the same number of 1 bit. The increasing popular zero bits allow the compression to get better and better. Using this technique we have been able to extend the range of usable cardinality to a very large number A problem with using bitmap indexes for a column with high cardinality is its high storage costs and potentially high expression evaluation costs.  One method for dealing with the problem of using bitmap index on highcardinality attributes is to compress the bitmap. The form of compression is the most crucial aspect of such an implementation, since it must be designed both to save disk space for sparse bitmaps, and also to efficiently perform the operations AND, OR, NOT and  We have two types of bitmap indexes index for high cardinality column with symbolic values index for high cardinality column with numeric values  In this approach, the data column is broken up into N number of separate bitmaps. One bitmap for each bit of precision in the quantity being indexed.  Organizing the data in this way greatly reduces the size of the data. A considerable body of work has been devoted to the study of bitmap index compression. The use of bitmap compression has many potential performance advantages less disk space is required to store the indexes, the indexes can be read from disk into memory fast, and more indexes can be cached in memory.  A wide variety bitmap representations and compressions have been proposed, such as Verbatim, Run Length Encoding \(RLE  ap te chni que s extend the range of the unique value of a column to 10000, by combining bitmap and compression. As the number of values increases, the amount of compression increases. The bitwise index proposed  close to our High cardinality indexes 3. A Prejoin_Bitmap_Index Based Algorithm for Outer Join DSS Query Optimization In this section we will discuss our new prejoin_bitmap_index based algorithm for outer join DSS queries optimization and the integration of it into a commercial data flow based query engine. For explanation purpose, we use a Volcano style data flow based query engine underlying que ry e ngi ne to im plement our algorithm. Each query plan in the query engine is a tree of operators, all operators are implemented as iterators, i.e., they support a simple open-next-close protocol, but our algorithm is easily extended to any other data flow based query engine We have implemented various types of bitmap indexes based on the cardinality of the data columns described in Section 2.  Based on the query at hand, the best index can be chosen to run the query fast. The factors in choosing the proper bitmap index for attributes depend on the number of distinct values of the attribute, type of the queries the attributes will most likely to be involved  Optim iz er will choose the correct inde x when evaluating a query. The type of indexes chosen would be based on how a column will be used in general and not on specific queries 3.1 Some Limitations of the Current Database Systems for DSS Queries Optimization Currently there are two approaches to process complex decision support queries with multi-table joins to imProceedings of the Seventh International Database Engineering and Applications Symposium \(IDEASê03 1098-8068/03 $17.00 © 2003 IEEE 


3 prove query performance: \(1\n indexes or/and \(2\join result of two or more tables in advance which is often used in the queries. Join index 20,23 be use d to avoi d actual joins of tables or to greatly reduce the volume of the data. This join technique speeds join processing by processing multiple bit vector indexes and has been used in some commercial RDBMS. For example, Informix/Red Brick \(now part of IBM\S adopts the first approach to create STARindex [27 for m u lti table joi ns a nd dram atically accelerate join performance. These two approaches work very well in multi table joins without multi outer join operations because outer join operations need to reserve those rows even though they donêt satisfy the join conditions. If these tables are joined together through outer join conditions, then these methods will not generate the correct answers because all of them rely on AND or OR the bitmap indexes involved in the join conditions inner join, natural joins and so on\the semantic meaning of outer joins is so different, just ANDed or ORed these bitmap indexes is not enough to get the correct answer To enable the current RDBMS to support outer join operations through bitmap indexes, some modifications and extensions are needed because of the following limitations of the current data flow based query engine 1\engine; the execution order of the predicate is not exactly the same sequence as predicates appear in the query statement. The execution order of the predicates is determined by the cost of selectivity in most systems. This is fine and actually can improve query performance in a lot of circumstances without outer join involved because changing the execution orders of predicates would not affect the semantic meaning of the query, so the results are the same. But for multi table joins with outer join conditions, the story is totally different. It is essential to reserve the predicate orders in order to guarantee the correct results because outer joins are not commutative, so we need to find the found set for the outer joins based on the strictly order of the join conditions in the query plan tree. For multi table joins with outer join operations, the order of the join indexes access must have the same order as the outer joins in the original join sequences 2\For join conditions on an outer join, these will be bitmap join indexes, which are the bitmaps for that join conditions for inner, right outer and left outer. These are then ANDed and ORed with the current found set. The rules for ANDing and Oring these bitmap indexes for the leaf joins in the join tree and for higher level joins need to be different to not lose outers from earlier joins in the join sequences. This requires that a bitmap join index need to know whether its child at each side is another join or base table. But of the current bitmap indexes for join nodes, there is no mechanism to tell the difference and store the essential information. All current bitmap join indexes such as STARindex of Informix and bitmap join index of OêNeil [2  poi nt t o t w o  base tables only, thus could not deal with multiple outer join operations. For all commercial RDBMSs products complex queries with outer joins are executed by the query engine in an ças writtené manner. This requires that a bitmap join index needs to know whether its child at each side is another join or a base table 3.2 Predefined Join Table and Prejoin_Bitmap_Indexes A new type of bitmap join index called prejoin_bitmap_index is proposed to solve the problems discussed above. A predefined join table prejoin table for short\denormalized table of all columns from participating tables from full outer joins. A prejoin table can join more than two tables in a single operation so it overcomes the problems that plaque traditional OLTP RDBMS products. All the predicates local to the prejoin table can be solved using the prejoin_bitmap_indexes Definition 1: A Prejoin Table is a denormalized table storing and indexing the full denormalized result set of all columns from participating tables from full outer join The prejoin table has the following characteristics Join more than two tables Support full outer joins in a star relationship as well as linear join chain Multi-column join keys Multi-table join queries with more than one outer joins For each join relation in the prejoin table, a set of prejoin_bitmap_index is created. Since the results of a full outer join of two tables can be perceived as three parts INNER, LEFT and RIGHT. The INNER part is those rows from both tables which match the join conditions The LEFT part is those rows from the first table which fails the join conditions while the RIGHT part is those Proceedings of the Seventh International Database Engineering and Applications Symposium \(IDEASê03 1098-8068/03 $17.00 © 2003 IEEE 


4 rows from the second table. So it is natural to define three bitmap indexes for a full outer join relation. If there are multiple join relations, the join relation should tell whether the tables involved in the join relation are base tables or not because this information determines the semantic meaning of how the bitmap indexes of this join relation should be used. A prejoin_bitmap_index is able to point to the derived tables, not just the base table This is one of the advantages of our prejoin_bitmap_index over STARindex or the bitmap index proposed in [3,20,23,30,31, 32   Each prejoin_bitmap_index consists of three bitmaps as follow IJIndex The inner join of the result of the two tables with all conditions applied LJIndex All rows from the left table not included in the IJIndex, extended with NUL values for each column of the right table RJIndex All rows from the right table not included in the IJIndex, extended with NULL values for each column of the left table Suppose we have a Create Prejoin Table command as follow Create Prejoin Table FT 1 T 2 as \(\(F Full Outer Join T 1 On A 2 A 1 Full Outer Join T 2 on A 3 A 6  For this prejoin table FT 1 T 2 two prejoin_bitmap_indexes are created \(Table 3\index1 corresponds the join relation between base tables F and T 1 on join condition A 2 A 1 Jindex2 corresponds to the join relation between the derived table \(the result of F Full Outer Join T 1 on join condition A 2 A 1 se table T 2 on join condition A 3 A 6 For each type of outer join \(left, right, full\just put the proper çpiecesé together using UNION All by using the corresponding prejoin_bitmap_index Example 3.1 to compute the foundset FS of \(F Left Outer Join T 1 On A 2 A 1 bitmaps LJIndex of Jindex1: FS=LJIndex OR IJIndex = \(0 0 0 0 0 1 1 0 0\ OR \(1 1 1 1 1 0 0 0 0\ = \(1 1 1 1 1 1 1 0 0 For foundset of \(F Full Outer Join T 1 On A 2 A 1  ORed all the three bitmaps of Jindex1: FS=\(0 0 0 0 0 1 1 0 0\ OR \( 1 1 1 1 1 0 0 0 0\ OR \(0  0 0 0 0 0 0 1 0\=\(1 1 1 1 1 1 1 1 0 A 1 a b d e Table T1 A 6 A 7 2 4 3 2 3 5 8 1 Table T 2 A 8 u v w x TableT 3 A 2 A 3 A 4 A 5 a 1 u o b 2 v o d 3 w p d 4 x q f 5 z t g 7 z s Table F No A 2 A 3 A 4 A 5 A 1 A 6 A 7 1 a 1 u o a null null 2 b 2 v o b 2 4 3 d 3 w p d 3 2 4 d 3 w p d 3 5 5 d 4 x q d null null 6 f 5 z t null null null 7 g 7 z s null null null 8 null null null null e null null 9 null null null null null 8 1 Table 2  FT 1 T 2  0 0 0 0 0 1 1 0 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 1 1 0 0 1 1 1 0 0 0 0 0 Proceedings of the Seventh International Database Engineering and Applications Symposium \(IDEASê03 1098-8068/03 $17.00 © 2003 IEEE 


5 LJIndex     IJIndex       RJIndex       LJIndex    IJIndex  RJindex Table 3 Prejoin_bitmap_index Jindex1  Jindex2  3.3 Finding the Prejoin Table in the Query Execution Plan In order to use prejoin_bitmap_index in the data flow query engine, we simply add a new type of data flow node, called prejoin table node, which also follows the open-next-close interface of Volcano style engi In the query execution plan, a prejoin table is a subclass of the table node, but a table node only refers to one base table while a prejoin table can refers to two or more tables depending on the number of tables involved in the full outer join. Also there is an additional member for the prejoin table node Join_Relation_Tree Join_Relation_Tree is the join sequence tree, which matches the join order specified in the prejoin table command and is used to control the construction of the foundset bitmap \(FSBM\the prejoin table node. For each join node in the Join_Relation_Tree, there is a prejoin_bitmap_index, which consists of 3 parts IJIndex LJIndex and RJIndex Four different join results can be derived based on the different combinations of these three bitmap indexes. For example, the IJIndex is the inner join result of this join node, the union of LJIndex and IJIndex is the left outer join of this join node, the union of the IJIndex and RJIndex are the right outer join while the union of IJIndex, LJIndex and RJIndex are the full outer join of the join node For each join node in the query execution plan, we associate it with three members Join_Key_Type  Join_Predicate_Vector and Join_Operator which will help us to find whether the join node is part of a prejoin table or not. The Join_Key_Type is set to Table_Table if the join node links two base tables. It is set to Join-Table if the left child of the join node is a join node \(also called derived table\right child is a base table. If the left child is a Table node and the right child is a join node, the Join_Key_Type is set to TableJoin. The Join_Predicate_Vector is used to store the join predicates. A prejoin match is found if the Join_Key_Type, Join_Predicate_Vector of the join nodes matches with the prejoin table definition. The Join_Operator is set to Inner, LOuteror ROuter or FOuter if the join node type is inner join, left outer join and full outer join respectively Example 3.2 Suppose we have a query Select * from F Left Outer Join T 1 On A 2 A 1  2 On A 3 A 6 Full Outer Join T 3 On A 4 A 8  The query plan tree for this query is shown in Figure 4    Figure 1 Our optimizer can identify that part of the outer join operations \(F Left Outer Join T 1 On A 2 A 1 Outer Join T 2 On A 3 A 6 volved in the multi-table joins matches with our prejoin table FT 1 T 2 so we can replace that part in the plan tree with the prejoin table node FT 1 T 2 A modified plan tree is as follow \(Figure 2   Figure 2 Since the prejoin table is based on the full outer join condition, the prejoin table node FT1T2 contains more rows than \(F Left Outer Join T 1 On A 2  A1  Join T 2 On A 3 A 6 so we need to get rid of the extra rows introduced by the full outer join in order to get the correct answer. We can use the prejoin_bitmap_indexes associated with the Join_Relation_Tree of the prejoin  Join Join Table T 2 Join Table T 1 Table F Table T 3 Join-Table FOuter A 4 A 8 Join-Table ROuter A 3 A 6 TableTable LOuter A A   Join Table T 3 Prejoin Table FT 1 T 2 Table-Table FOuter A 4 A 8     Proceedings of the Seventh International Database Engineering and Applications Symposium \(IDEASê03 1098-8068/03 $17.00 © 2003 IEEE 


6 table, the Join_Operator of the join nodes in the Join_Relation_Tree and put the proper çPiecesé together to construct the correct foundset bitmap for the prejoin table node in the modified plan tree. These are then ANDed and ORed with the current foundset. The rules for ANDing and Oring these bitmaps for the leaf joins in the join tree and for higher level joins are different in order to reserve outers from earlier joins in the join sequence Algorithm 1: Executing the Prejoin Table Node in the Query Execution Plan traverse the Join_Relation_Tree of the prejoin table in breadth first order df_joinnode * current_node= node of the Join_Relation_Tree IF current_node is a join node Bitmap I_index = current_node IJIndex Bitmap L_index = current_node LJIndex Bitmap R_index = current_node RJIndex IF the current_node is the root of the Join_Relation_Tree Case \(Join_Operator Inner:     FSBM = I_index LOuter: FSBM = I_index OR L_index ROuter: FSBM = I_index OR R_index FOuter: FSBM = I_index OR L_index OR R_index Else Case \(Join_Operator Inner:   FSBM = FSBM AND \(NOT \(L_index OR R_index LOuter: FSBM = FSBM AND \(NOT R_index ROuter: FSBM = FSBM AND \(NOT L_index FOuter:  no change current_node = next node of the Join_Relation_Tree Example 3.3 For the modified plan tree in Figure 2, we compute the found set FSBM for prejoin table node FT1T2 starting form the top node of the Join_Relation_Tree \(the part inside the dash curve in Figure 1\The root join node is a right outer join \(the corresponding join index is Jindex2\hen we combine the two pieces IJIndex and RJIndex: FSBM 1 IJIndex OR RJIndex = \( 0 1 1 1 0 0 0 0 0\ OR \(0 0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 0 1\he next join node is a left outer join \(the corresponding join index Is Jindex1 should remove those extra rows introduced from the right side \(use the RJIndex of Jindex1 2  FSBM 1 AND \(NOT \(RJIndex  FSBM1 and \(NOT \(0 0 0 0 0 0 0 1 0\ = FSBM1 AND \( 1 1 1 1 1 1 1 0 1\ = \(0 1 1 1 0 0 0 0 1\ AND \( 1 1 1 1 1 1 1 0 1\= \( 0 1 1 1 0 0 0 0 1\o foundset bitmap corresponding to \(\(F Left Outer Join T1 On A 2 A 1 ht Outer Join T2 On A 3 A 6 0 1 1 1 0 0 0 0 1\then we can project out the corresponding rows of the foundset \(as shown in Table 4\pass the rows to the join node above A 2 A 3 A 4 A 5 A 1 A 6 A 7 b 2 v o b 2 4 d 3 w p d 3 2 d 3 w p d 3 5 null null null null null 8 1  Table 4 Rows of Prejoin Table Node We can choose any one of the join algorithms \(like nested-loop join, hash-join, sort-merge join and so on and apply it to the Table T 3 and then we obtain the final result Table 5 for the query The prejoin table match method and prejoin_bitmap_index based outer join optimization techniques have been implemented in a commercial databaseês query engine. It took only 6 man-months to have our techniques seamlessly integrated into the existing system. The initial test on TPCD benchmark data set using query Q5 and Q8  d an a v erage 30 times fast on scale 10 10 Gigabytes A 2 A 3 A 4 A 5 A 1 A 6 A 7 A 8 b 2 v o b 2 4 v d 3 w p d 3 2 w d 3 w p d 3 5 w null null null null null 8 1 null null null null null null null null u null null null null null null null x  Table 5 Result of the Query 4.  A Bitmap-Based Association Rule Algorithm Bit-AssocRule Though most of data mining algorithms assume all data are stored in a flat relation, in reality data are stored in various normal forms. So the techniques of previous sections are extremely important in supporting data mining; we rely on them to generate a virtual flat relation We have adopted the layered view, so in this section, we will only discuss the algorithms based on the flat relation without examining the detail interaction; we will defer it on later papers on data warehouse  Our focus in this section is to present a bitmap-based algorithm BitAssocRule to find association rule efficiently from large databases  Proceedings of the Seventh International Database Engineering and Applications Symposium \(IDEASê03 1098-8068/03 $17.00 © 2003 IEEE 


7 Given a set of transaction D, the problem of mining association rules is to generate all associations that meet certain user-specific minimum support and confidence The problem can be decomposed into two subproblems 1\combinations of items that have transaction support above the minimum support, \(2\use the large itemsets to generate the desired rules. The challenging issues of association rule algorithms are multiple scans of transaction databases and huge number of candidates. There have been many association rule algorithms [1,2,5,13,24,27 veloped t o re duce pas ses of transaction database scans and shrink number of candidates, which can be classified into two categories: \(1 candidate-generation-and-test approach such as Apriori  2 appr oach [24  most influential algorithm Apriori developed by Rakesh  nerates the k-c andidate by com bining two \(k1\sets. A new k-candidate becomes a k large itemset if every \(k-1\of the k-candidate is a large itemset otherwise it is removed, the process is very time consuming The use of bitmaps improves the performance to find association rules. The bit representation of bitmaps offers efficient storage while the intersection of bitmaps offers fast computation in finding association rules. The AND SHIFT, and COUNT operations among bitmaps are extremely fast. Unlike the traditional Apriori algorithm which generates k-candidate by combining two \(k-1 large itemset.  Our Bit-AssocRule algorithm generates k-candidate by intersecting the bitmap of 1 attribute value with bitmaps of other \(k-1\attribute values.  The algorithm starts with a list L 1 which contains attribute values \(also called 1-itemset, all the counts of the bitmaps of these 1-itemset are greater than the minimal counter number\he k-candidates consist of k attribute values \(X 1  t1 X 2,t2 X k-1,tk-1 X ij  from k attributes. Using bitmap techniques, the candidate is a large itemset if the bit count on the intersection of all the bitmaps B 1 B 2  B k suppose B j is the bitmap of the X k,tj  equal or greater than the minimal count. The bit count is the number of 1ês in the bitmap indexes from the result of the intersection of the bitmaps During each cycle, combinations of length k, or in short k-candidates are generated. When intersecting the bitmaps, the size of the bitmaps may be large. Thus, slices of the bitmaps are read and processed until all slices of the bitmaps are done. In the end, if the intersection of bitmaps in the k-candidate results in a count that meets or exceeds the minimal count, the candidate is a large itemset, and it is saved. At the end of the cycle, if any kcandidates are declared as large itemsets, new candidates of length k+1 are generated for the next cycle. The cycle stops when no k-candidates are found to be large itemset or if no new \(k+1\andidate can be generated from the discovered k large itemset. When making kcandidates, all the 1-itemsets in the list L 1 are verified if they exist as elements in any \(k-1\set.  If a 1itemset does not exist in any \(k-1\set, it is removed from the list L 1 Next, new k-candidates are created by joining a \(k-1\mset with 1-itemset in L 1 that has an attribute index greater than all attribute indexes of elements in that \(k-1\set. Only the new k large itemset are kept.  Below is the algorithm Algorithm 2: Bit-AssocRule L 1 bitmaps of large 1-itemset For k=2; L k-1 k Do Begin Remove those 1-itemsets in L 1 which are not included in any itemset of  L k-1 prune L 1 C k Join the 1-itemset in L 1 that is larger than any elements in the \(k-1\ set with the itemset in L k-1 new candidate L k c C k bitmap count of  c >= minsup End Answer k L k Theorem 1:  If the count of the intersection of the bitmap of 1-itemset X ij with the bitmap of  \(k-1 itemset \(X 1  t1 X 2,t2 X k-1,tk-1 large \(namely greater than or equal to the minimum support count C\then it is guaranteed that the newly k-candidate X 1  t1 X 2,t2 X k-1,tk-1 X ij is a large item Proof Suppose B k denotes the bitmap of the 1-itemset X ij and B 1 B 2 B k-1 bitmaps of X 1  t1 X 2,t2 X k-1,tk-1 respectively  If the count of the intersection of the bitmap  B k of 1-itemset X ij with the bitmaps B 1 B 2  B k-1 of  \(k-1\mset \(X 1  t1 X 2,t2 X k-1,tk1 namely greater than or equal to the minimum support count C\eans: Count\( B 1 B 2 B 3  B k1 B k Based on the logical bit And operations, it means that there must exists at least C positions \(suppose these positions are p 1 p 2 p 3 p C he bitmaps B 1  B 2 B k-1 B k such that B 1 p 1 B 2 p 1 B k-1 p 1 B k p 1   B 1 p 2 B 2 p 2 B k-1 p 2 B k p 2    Proceedings of the Seventh International Database Engineering and Applications Symposium \(IDEASê03 1098-8068/03 $17.00 © 2003 IEEE 


8 B 1 p C B 2 p C B k-1 p C B k p C   Then based on the bit And operation, for any \(k-1\ubset from the k-candidate \(X 1  t1 X 2,t2 X k-1,t-1 X ij  the count of their bitmap intersection must be also greater than or equal to C, thus any \(k-1\m set, so the newly k-candidate is a large item set This theorem says that Our Bit-AssocRule algorithm doesnêt need to check the \(k-1\ubset of the new kcandidate. If the count of the bitmap of  \(X 1  t1 X 2,t2  X k-1,tk-1 X ij is greater than C, there is no need to check whether any  \(k-1\subset of \(X 1  t1 X 2,t2 X k-1,tk-1 X ij  is also a large item set  because we are sure the newly kcandidate is an k large item set.  This property of our Bit-AssocRule algorithm is a significant improvement over the Aprior algorithm because the Apriori algorithm spends a huge amount of time to check all the  \(k-1 subsets of the newly k-candidate. Only after all the \(k1\of the k-candidate is checked then it can decide whether the new k-candidate is a large itemset or it should be removed. Our Bit-AssocRule eliminates this expensive step in the procedure, thus saves a lot of running time Four synthetic data sets are generated to compare the run time on these algorithms to find association rules The program for Apriori and AprioriHybrid are our honest implementations of the algorithms in implementation, we use some buffer scheme to speedup read/write for all algorithms. The tests were conducted using an IBM PC with 933Mhz CPU, 512MB memory under Window 2000. The program is coded in C Data set Rows Column of items Table size Bitmap size Min Sup DS1 400K 16 199 25.6M B 10.6MB 20K DS2 800K 20 247 64MB 25.0MB 40K DS3 1.6M 30 709 140M B 62MB 50K DS4 3.0M 30 303 361M B 91MB 80K Table 6 4 data sets Data set Length of candidate of candidates of itemsets Bit-AssocRule Apriori Hybrid Apriori DS1     1 199 188 3.966s 4.106s 4.105s 2 16333 103 18.426s 1402.977s 1403.438s 3 92 10 0.111s 1.833s 5.979s 4 0 0 0s 0s 0 Total time  22.503s 1408.916s 1413.522s DS2     1 247 235 10.375s 10.275s 10.786s 2 26033 88 56.371s 4496.245s 4496.405s 3 0 0 0s 0.01s 0s Total time  66.746s 4506.530s 4507.191s DS3     1 303 303 24.816s 9.894s 9.904s 2 43996 2681 99.162s 11245.120s 11231.390s 3 614 924 46.117s 5368.569s 9391.324s 4 0 0 0.03 25.487s 1658.455s Total time  171.401s 16649.070s 22291.073s DS4     1 244 244 49.021s 25.557s 20.059 2 28430 3920 153.080s 13979.431s 13682.575s 3 55467 2586 308.593s 28294.946s 45159.676s 4 3152 108 20.109s 455.155s 58274.374s 5 0 0 0 0.000s 180.209s Total time  530.803s 42755.089s 117316.893s Table 7 Experimental Run of 4 Data Sets Proceedings of the Seventh International Database Engineering and Applications Symposium \(IDEASê03 1098-8068/03 $17.00 © 2003 IEEE 


9 Here are some observations and explanations on the results 1\The total time of our comparison includes the time to write the association rules to a file; Bit-AssocRule is 2 to 3 orders of magnitude faster than the various Apriori algorithms \(64-221 times faster\he test data set, the big the time difference between the BitAssocRule and the various Apriori algorithms. We havenêt compared our algorithm with some of the other association rule algorithms such as VIPER  13,24] \(CHARM and CL OSE are base d on the closed frequent itemsets concept\d on their published comparison results with Apriori, our BitAssocRule is very competitive compared to them and a direct comparison will be conducted and reported in the near future 2\e or litter longer time than the various Apriori algorithms in constructing the 1-itemsets because of the extra cost of building the bitmaps for the 1-itemsets. But after the 1-itsemtset is done, Bit-AssocRule is significant faster than the Apriori algorithms in constructing large frequent itemsets because it only uses the fast bit operations \(AND COUNT and SHIFT\nd doesnêt need to test the subsets of the newly candidate 3\aps of the frequent items, and the bitmap storage \(uncompressed less than the original data set \(1/2 to 1/4 of the original data size The main reasons that Bit-AssocRule algorithm is significant faster than Apriori and its variations are 1\ocRule adopts the divide-and-conquer strategy, the transaction is decompose into vertical bitmap format and leads to focused search of smaller domain There is no repeated scan of entire database in BitAssocRule 2\snêt follow the traditional candidate-generate-and test approach, thus saves significant amount of time to test the candidates 3\basic operations are bit Count and bit And operations, which are extremely faster than the pattern search and matching operations used in Apriori and its variations 5. Conclusion The contributions of this paper are in two aspects:  we extend the application domains of bitmap techniques and introduce the bitmap techniques for complex DSS query optimization and association algorithm. We present a bitmap based query optimization algorithm to optimize complex query with multiple table join based on outer join operations and push the outer join operations from the data flow level to the bitmap level and achieve significant performance gain.   We introduce a novel algorithm to calculate the foundset for those tables involved in the prejoin table by using prejoin_bitmap_indexes and integrate this algorithm into the current commercial data flow based query engine seamlessly. Our query optimization can achieve an order of magnitude faster than conventional query engine Secondly we introduce the bitmap technique to the data mining procedure and develop a bitmap-based algorithm Bit-AssocRule to find association rules. Our BitAssocRule avoids the time-consuming table scan to find and prune the itemsets, all the operations of finding large itemsets from the datasets are the fast bit operations. The experimental result of our Bit-AssocRule algorithm with Apriori and AprioirHybrid algorithms shows Bit-AssocRule is2 to 3 orders of magnitude faster. This research indicates that bitmap technique can greatly enhance the performance for decision support queries and finding association rule, and bitmap techniques are very promising for the decision support query optimization and DM applications Bitmap technique is only one way to improve the performance of complex DSS queries and DM algorithm Parallelism is another crucial factor to improve the performance of DSS and data mining.  We are currently working on paralleling the bitmap-based algorithms and hope to report our findings in the near future 6. References  Agrawal R. Sri kant R., çFast al gorithm for mining association rulesé, Prod. of the 20 th VLDB Conf. 1994  Agrawal R., Mannila H., Sri kant R., Toivone n H., Verkamo A., çFast discovery of  association rulesé, in Advances in Knowledge Discovery and Data Mining, MIT 1996  AIP D Tec hnical P u blications In Syba se IQ Administration Guide, Sybase IQ Release  11.2 Collection, Sybase Inc Proceedings of the Seventh International Database Engineering and Applications Symposium \(IDEASê03 1098-8068/03 $17.00 © 2003 IEEE 


10  er-Yahia S., Johnson T., çOptimizing queries on compressed bitmapsé, Prod. of the 20 th VLDB  Conf  wa l, R., Gunopul os D  Constraint-based rule mining in large, dense databases Proc. of the 15th Int'l Conf. on Data Engineering \(ICDE1999 6] Bertino E., Ooi B.C., Sacks-Davis R. etc, çIndexing techniques for advanced database systems Kluwer Academic Publishers  n C Ioa nnidis Y B itm ap index design and evaluationé, Prod of the  SIGMOD-96  h atziant oni ou D Akinde  M, Johnson T Kim  S, çThe md-join: an operator for complex olapé. Prod of the 18 th Intêl Conference on Data Engineering \(ICDE2001  outer joiné, Prod of the 2nd International Conf. on Databases   Fre nch C  One size fits allê databa se arc hitecture do not work for dssé, Prof of the  SIGMOD-95  hal, A., çOute r join simplification and reordering for query optimizationé, ACM TODS, 22\(1\1997  G., çVolcano, an extensible and pa rallel query evaluation systemé, IEEE Transaction on Knowledge and Data Engineering, 6\(6  e i, J. Yin. Y  Mining fre quent patterns without candidate generation", Prod of the SIGMOD-2002    Hanusa R., çA lesso n in outer joins \(learned the hard way!\data Review, Spring 1998  aine C., Data A A novel inde x s u pporting high volume data warehouse insertioné Prod of the 25th VLDB Conf  on T , çPerform ance m easurem ents of compressed bitmap indicesé Prod. of the 25th VLDB conf   Y Data m i ni ng and m achine oriented modeling: a granular computing approaché, Journal of Applied Intelligence, Oct. 2000  Lin T.Y., çFi nding ass ociation rules using fast bit computation: machine-oriented modelingé ISMIS-2000  M., çGroup bit map index: a structure for association rules retrieval Prod. of the 4 th Intêl Conf. on Knowledge Discovery and Data Mining \(KDD-98  OêNeil P Graefe G., çM ulti-table joi ns  through bitmapped join indexesé, SIGMOD September 1995, 8-11   OêNeil P., Quass D., çIm prove d que ry pe rformance with variant indexesé, Prod of the SIGMOD-1997   Inform ix and inde xing s u pport for data warehouses,  Informix Whitepaper  a p join i n dex  http://technet.oracle.com/products/oracle9i/daily/a pr09.html  n, H. Lu, S. Ni shio, S. Ta ng, and D  Yang. "H-mine: hyper-structure mining of frequent patterns in large databases", Proc. The 2001 IEEE Intêl Conference on Data Mining  OêNeil P.,  OêNeil E.,  çBitSliced Index Arithmeticé, Prod of the SIGMOD2001  vase re , A Om iecinski E Na vat he S  An efficient algorithm for mining association rules in large databasesé, in Prod. of the 21 st VLDB conf  She noy P Bhal otia G Haritsa J B a wa M Sudarshan S., Shah D., çTurbo-charging vertical mining of large databaseé, Prod. of the SIGMOD2000  a processi ng for com plex queriesé, Red Brick/Informix White Paper  as and starjoi n technologyé Red Brick/Informix White Paper  P C be nchm ark d de cision s u pport  dard specification, Release 2.2. \(Transaction Processing Performance Council \(TPC  durie x P J oi n indexe s ACM TODS 12\(2\ 1987  W u M Buchm ann A  Encoding bitm ap indexing for data warehouseé, Proc. of the 14th  Intêl Conference on Data Engineering, 220-231, 1998   Gouda K., çF ast vertical usi ng diffsetsé, Tech report, Dept. of  computer science, RPI  Y., Des hpa nde P., Naughton J Shukla A.,  çSimultaneous optimization and evaluation of multiple dimensional queriesé, SIGMOD-98, 271282 Proceedings of the Seventh International Database Engineering and Applications Symposium \(IDEASê03 1098-8068/03 $17.00 © 2003 IEEE 


20% 4 4 4 12 12 30% 4 3 3 12 12 40% 3 3 3 12 11 50% 3 2 2 11 10 60% 2 1 2 11 10 70% 2 1 2 11 11 80% 2 2 2 10 11 90% 2 2 2 9 10 99% 0 1 1 6 10 Looking at Table 9, one may wonder why the representation determined for minSup = 70% has shorter longest elements in its Bd  GDFree \(here: length = 1 than the representation determined for minSup = 80 here: length = 2 border elements in Bd  GDFree, which are infrequent in the representation determined for minSup = 80 become frequent when lowering the support threshold to 70 7. Related work The most similar to the representations based on generalized disjunctive sets is the NDR representation which consists of all frequent non-derivable itemsets [7 8], and the representations based on ?-free sets [7, 9]. It was shown in [8], that for each non-empty itemset Z, one can derive the lower bound \(l\(Z u\(Z on sup\(Z from the fact that sup\(Z Non-derivable itemsets are those for which u\(Z Z gt; 0. If u\(Z Z sup\(Z supersets Y of a derivable itemset are also derivable and u\(Y Y Y such that neither sup\(Z Z Z Z It was proved in [7, 8] that u\(Z Z  u\(Z?{a Z?{a for |Z| ? 1 This important result was used in [7, 8] to determine the upper bound on the length of non-derivable itemsets namely: non-derivable itemsets are not longer than log2|D|? + 1 Hence, the bound on the length of non-derivable itemsets is identical to the bound on the length of generalized disjunction-free sets \(please see Theorem 3.2 It has been proved in [7] that ?-free sets are a subset of non-derivable itemsets, so their length is also bounded by ?log2|D|? + 1 There is a claim in [7, 9] that the generalized disjunction-free sets equal the ?-free sets. This claim however, is not correct, which we will prove by the example beneath. Table 4 contains all generalized disjunction-free sets. Among them, there is {fh}, the support of which equals 0. The support bounds for {fh are found as follows \(please, see [7] for the details  sup\({fh f h   sup\({fh f  sup\({fh h  sup\({fh Proceedings of the 16th International Conference on Scientific and Statistical Database  Management \(SSDBM  04 1099-3371/04 $ 20.00  2004 IEEE Hence, l\({fh fh fh sup\({fh free, is not a ?-free set Since the families of the generalized disjunction-free sets and ?-free sets may differ, finding the relationship between them or between the generalized disjunction-free sets and non-derivable itemsets remains a challenge 8. Conclusions The representations based on generalized disjunctionfree sets belong to the most concise ones among all lossless frequent patterns representations with borders. In 


lossless frequent patterns representations with borders. In practice, they are also much more concise than representations based on closed itemsets and approximate representations. In this paper, we offered three methods of deriving an upper bound on the length of sets in such representations. We proved that the upper bound on the length of a longest generalized disjunction-free set depends logarithmically on the number of records in the database. The obtained result is of high importance as it guarantees that any generalized disjunction-free set representation for all patterns \(both frequent and infrequent scans, where n is the number of records in the database irrespectively how strong or weak correlations among items in the database are and irrespectively of the lengths of records and number of distinct items The modifications of the basic estimation take into account the support threshold of the representation to be found or, additionally, the information on the length of longest sets of the representation already calculated for a higher support threshold. Though these estimations are more accurate than the basic one, they are still quite rough. Further improvements of the quality of estimating the length of longest itemsets in generalized disjunctionfree representations is subject to further research References 1] R. Agrawal, H. Mannila, R. Srikant, H. Toivonen, A.I Verkamo  Fast Discovery of Association Rules   Advances in Knowledge Discovery and Data Mining AAAI, CA, 1996 2] J. Baptiste, J.-F. Boulicaut  Constraint-Based Discovery and Inductive Queries: Application to Association Rule Mining  Pattern Detection and Discovery, Springer London, UK, September 2002, pp. 110-124 3] E. Baralis, S. Chiusano, P. Garza  On Support Thresholds in Associative Classification  SAC, ACM, Taipei Taiwan, March 2004, pp. 553-558 4] Y. Bastide, N. Pasquier, R. Taouil, G. Stumme, L. Lakhal  Mining Minimal Non-redundant Association Rules Using Frequent Closed Itemsets  Computational Logic, 2000 pp. 972  986 5] J.-F. Boulicaut, A. Bykowski, C. Rigotti  Approximation of Frequency Queries by Means of Free-Sets  PKDD Springer, Lyon, France, September 2000, pp. 75-85 6] A. Bykowski, C. Rigotti  A Condensed Representation to Find Frequent Patterns  PODS, ACM, Santa Barbara USA, May 2001, pp. 267-273 7] T. Calders, Axiomatization and Deduction Rules for the Frequency of Itemsets, Ph.D. Thesis, University of Antwerp, 2003 8] T. Calders, B. Goethals  Mining All Non-derivable Frequent Itemsets  PKDD, Springer, Helsinki, Finland August 2002, pp. 74?85 9] T. Calders, B. Goethals  Minimal k-free Representations of Frequent Sets  ECML/PKDD, Springer, CavtatDubrovnik, Croatia, September 2003, pp. 71-82 10] J. Han, M. Kamber, Data Mining: Concepts and Techniques, Morgan Kaufmann Publishers, 2000 11] S.K. Harms, J. Deogun, J. Saquer, T. Tadesse  Discovering Representative Episodal Association Rules from Event Sequences Using Frequent Closed Episode Sets and Event Constraints  ICDM, IEEE Computer Society, San Jose, California, USA, November-December 2001, pp. 603  606 12] M. Kryszkiewicz  Closed Set Based Discovery of Representative Association Rules  IDA, Springer Cascais, Portugal, September 2001, pp. 350-359 13] M. Kryszkiewicz  Concise Representation of Frequent Patterns based on Disjunction  free Generators  ICDM IEEE Computer Society, San Jose, California, USA 


IEEE Computer Society, San Jose, California, USA November-December 2001, pp. 305  312 14] M. Kryszkiewicz M  Inferring Knowledge from Frequent Patterns  Soft-Ware, Springer, Belfast, Northern Ireland April 2002, pp. 247  262 15] M. Kryszkiewicz  Concise Representations of Association Rules  Pattern Detection and Discovery, Springer London, UK, September 2002, pp. 92-109 16] M. Kryszkiewicz, Concise Representation of Frequent Patterns and Association Rules, Habilitation Thesis Publishing House of Warsaw University of Technology 2002 Proceedings of the 16th International Conference on Scientific and Statistical Database  Management \(SSDBM  04 1099-3371/04 $ 20.00  2004 IEEE 17] M. Kryszkiewicz  Reducing Infrequent Borders of Downward Complete Representations of Frequent Patterns  Proc. of The First Symposium on Databases Data Warehousing and Knowledge Discovery, Scientific Publishers OWN, Baden-Baden, Germany, July, 2003, pp 29-42 18] M. Kryszkiewicz  Closed Set Based Discovery of Maximal Covering Rules  International Journal of Uncertainty, Fuzziness and Knowledge-Based Systems Vol. 11. World Scientific Publishing Company, Singapore September 2003, pp. 15-29 19] M. Kryszkiewicz  Reducing Borders of k-Disjunction Free Representations of Frequent Patterns  SAC, ACM Taipei, Taiwan, March 2004, pp. 559  563 20] M. Kryszkiewicz  Reducing Main Components of k-Disjunction Free Representations of Frequent Patterns   Proc. of IPMU  2004 \(in print 21] M. Kryszkiewicz, M. Gajek  Concise Representation of Frequent Patterns based on Generalized Disjunction  Free Generators  PAKDD, Springer, Taipei, Taiwan, May 2002, pp. 159-171 22] M. Kryszkiewicz, M. Gajek  Why to Apply Generalized Disjunction-Free Generators Representation of Frequent Patterns  ISMIS, Springer, Lyon, France, June 2002, pp 383  392 23] M. Kryszkiewicz, H. Rybi?ski, M. Gajek  Dataless Transitions between Concise Representations of Frequent Patterns  Journal of Intelligent Information Systems JIIS Netherlands, 2004, pp. 41-70 24] N. Pasquier, Data mining: Algorithmes d  extraction et de R  duction des R  gles d  association dans les Bases de Donn  es, Th  se de Doctorat, Universit  Blaise Pascal   Clermont  Ferrand II, 2000 25] N. Pasquier, Y. Bastide, R. Taouil, L. Lakhal  Efficient Mining of Association Rules Using Closed Itemset Lattices  Journal of Information Systems, Vol. 24, No. 1 1999, pp. 25  46 26] N. Pasquier, Y. Bastide, R. Taouil, L. Lakhal  Discovering Frequent Closed Itemsets for Association Rules  ICDT, Springer, Jerusalem, Israel, January 1999 pp. 398  416 27] J. Pei, G. Dong, W. Zou, J. Han  On Computing Condensed Frequent Pattern Bases  ICDM, IEEE Computer Society, Maebashi City, Japan, December 2002 pp. 378-385 28] V. Phan-Luong V  Representative Bases of Association Rules  ICDM, IEEE Computer Society, San Jose California, USA, November-December 2001, pp. 639-640 29] A. Savinov  Mining Dependence Rules by Finding Largest Itemset Support Quota  SAC, ACM, Taipei Taiwan, March 2004, pp. 525-529 30] M.J. Zaki, C.J. Hsiao  CHARM: An Efficient Algorithm for Closed Itemset Mining  SIAM, Arlington, 2002 


for Closed Itemset Mining  SIAM, Arlington, 2002 Proceedings of the 16th International Conference on Scientific and Statistical Database  Management \(SSDBM  04 1099-3371/04 $ 20.00  2004 IEEE pre></body></html 


                                                  S J       


                                                      


                         L A                                        


          L A  Table 7. Table of Granules at left-hand-side is isomorphic to  at right- hand-side: By Theorem  3.1 one can ?nd patterns in either table as a single generalized concept  Internal points  are:[4]\(1, 1, 0, 0 tions; [5]\(0, 1, 1, 0  0, 1, 0, 1  0, 1, 1, 1  1, 1 1, 0  1, 1, 0, 1  1, 0, 1, 1 11]\(1, 1, 1, 1 form and simplify them into disjoint normal forms 1  T E N    S J    T E N    S J 2  T W E N T Y    L A    T H I R T Y   A 3  T W E N T Y      T H I R T Y   A 4  T W E N T Y            L A 5  T E N      T W E N T Y    L A    T E N    T W E N T Y   A   S J    T W E N T Y   A      T H I R T Y    L A     Y 7  T E N      T W E N T Y      T H I R T Y   L A    T E N   L A    S  J   A 8  T W E N T Y      T E N      T W E N T Y    L A    T E N   T W E N T Y      T H I R T Y 9  T W E N T Y    N Y    T E N    S J    T H I R T Y    L A      T W E N T Y    L A  1 0  T W E N T Y    N Y    T W E N T Y    L A    T H I R T Y   A    J 1 1  T W E N T Y          T W E N T Y    L A   T H I R T Y    L A    a l l If the simpli?ed expression is a single clause \(in the original symbols non-generalized the following associations 1   T E N     S J    T E N    S J  2. SJ   J 4   L A    T W E N T Y    L A    T H I R T Y    6 Conclusions Data, patterns, method of derivations, and useful-ness are key ingredients in AM. In this paper, we formalize the current state of AM: Data are a table of symbols. The patterns are the formulas of input symbols that repeat. The method of derivations is the most conservative and reliable one, namely, mathematical deductions. The results are somewhat surprising 1. Patterns are properties of the isomorphic class, not an individual relation - This implies that the notion of patterns may not mature yet and explains why there are so many extracted association rules 2. Un-interpreted attributes \(features can be enumerated 3. Generalized associations can be found by solving integral linear inequalities. Unfortunately, the number is enormous. This signi?es the current notion of data and patterns \(implied by the algorithms 4. Real world modeling may be needed to create a much more meaningful notion of patterns. In the current state of AM, a pattern is simply a repeated data that may have no real world meaning. So we may need to introduce some semantics into the data model [12],[10],[11 Proceedings of the Fourth IEEE International Conference on Data Mining \(ICDM  04 0-7695-2142-8/04 $ 20.00 IEEE References 1] R. Agrawal, T. Imielinski, and A. Swami  Mining Association Rules Between Sets of Items in Large Databases  in Proceeding of ACM-SIGMOD international Conference on Management of Data, pp. 207216, Washington, DC, June, 1993 


216, Washington, DC, June, 1993 2] Richard A. Brualdi, Introductory Combinatorics, Prentice Hall, 1992 3] A. Barr and E.A. Feigenbaum, The handbook of Arti?cial Intelligence, Willam Kaufmann 1981 4] Margaret H. Dunham, Data Mining Introduction and Advanced Topics Prentice Hall, 2003, ISBN 0-13088892-3 5] Fayad U. M., Piatetsky-Sjapiro, G. Smyth, P. \(1996 From Data Mining to Knowledge Discovery: An overview. In Fayard, Piatetsky-Sjapiro, Smyth, and Uthurusamy eds., Knowledge Discovery in Databases AAAI/MIT Press, 1996 6] H Gracia-Molina, J. Ullman. &amp; J. Windin, J, Database Systems The Complete Book, Prentice Hall, 2002 7] T. T. Lee  Algebraic Theory of Relational Databases  The Bell System Technical Journal Vol 62, No 10, December, 1983, pp.3159-3204 8] T. Y. Lin  Deductive Data Mining: Mathematical Foundation of Database Mining  in: the Proceedings of 9th International Conference, RSFDGrC 2003 Chongqing, China, May 2003, Lecture Notes on Arti?cial Intelligence LNAI 2639, Springer-Verlag, 403-405 9] T. Y. Lin  Attribute \(Feature  The Theory of Attributes from Data Mining Prospect  in: Proceeding of IEEE international Conference on Data Mining, Maebashi, Japan, Dec 9-12, 2002, pp. pp.282-289 10] T. Y. Lin  Data Mining and Machine Oriented Modeling: A Granular Computing Approach  Journal of Applied Intelligence, Kluwer, Vol. 13, No 2, September/October,2000, pp.113-124 11] T. Y. Lin, N. Zhong, J. Duong, S. Ohsuga  Frameworks for Mining Binary Relations in Data  In: Rough sets and Current Trends in Computing, Lecture Notes on Arti?cial Intelligence 1424, A. Skoworn and L Polkowski \(eds 12] E. Louie,T. Y. Lin  Semantics Oriented Association Rules  In: 2002 World Congress of Computational Intelligence, Honolulu, Hawaii, May 12-17, 2002, 956961 \(paper # 5702 13  The Power and Limit of Neural Networks  Proceedings of the 1996 EngineeringSystems Design and Analysis Conference, Montpellier, France, July 1-4, 1996 Vol. 7, 49-53 14] Morel, Jean-Michel and Sergio Solimini, Variational methods in image segmentation : with seven image processing experiments Boston : Birkhuser, 1995 15] H. Liu and H. Motoda  Feature Transformation and Subset Selection  IEEE Intelligent Systems, Vol. 13 No. 2, March/April, pp.26-28 \(1998 16] Z. Pawlak, Rough sets. Theoretical Aspects of Reasoning about Data, Kluwer Academic Publishers, 1991 Proceedings of the Fourth IEEE International Conference on Data Mining \(ICDM  04 0-7695-2142-8/04 $ 20.00 IEEE pre></body></html 


than that of MAFIA and the runtime of MHP can be significantly less than that of MAFIA 5.3. The Effect of the MHP Algorithm on Finding Maximal Hyperclique Patterns Figure 8 and Figure 9 show the number of maximal patterns identi?ed byMHP andMAFIA on Pumsb* and Pumsb data sets respectively. As can be seen, the number of maximal hyperclique patterns identi?ed by MHP can be orders of magnitude smaller than the number of maximal frequent patterns identi?ed by MAFIA. In other words, the number Proceedings of the 16th IEEE International Conference on Tools with Artificial Intelligence \(ICTAI 2004 1082-3409/04 $20.00 © 2004 IEEE 100 1000 10000 100000 1e+06 1e+07 1e+08 1e+09 0.02 0.025 0.03 0.035 0.04 0.045 0.05 0.055 0.06 N um be r o f C ou nt ed P at te rn s Support Threshold Mafia Min_Conf=0 Min_Conf=0.1 Min_Conf=0.3 Min_Conf=0.5 Min_Conf=0.7 Min_Conf=0.9 Figure 8. The Number of MFI/MHP Patterns in the Pumsb* Data Set 100 1000 10000 100000 1e+06 


1e+07 1e+08 0.1 0.2 0.3 0.4 0.5 0.6 0.7 N um be r o f C ou nt ed P at te rn s Support Threshold Mafia Min_Conf=0.5 Min_Conf=0.7 Min_Conf=0.9 Figure 9. The number of MFI/MHP Patterns in the Pumsb Data Set of maximal hyperclique patterns is much easier to manage than that of maximal frequent patterns. Indeed, in realworld applications, it is dif?cult to interpret several million maximal frequent patterns. However, it is possible to interpret the results of maximal hyperclique pattern mining In addition, due to the memory limitation, we cannot extract maximal frequent patterns with MAFIA on the Pumsb data set if the support threshold is less than 0.4, as shown in Figure 7. In contrast, MHP can identify maximal hyperclique patterns when the support threshold is 0.1, if we set the h-con?dence threshold to 0.5. In other words, MHP has the ability to identify patterns which can be dif?cult to identify for MAFIA. Hence, MHP can better explore the pattern space and ?nd interesting patterns at low levels of support 6. Conclusions and Future Work In this paper, we present a two-phase Maximal Hyperclique Pattern \(MHP best features of both the BFS strategy and the DFS strategy. More speci?cally, we adapted DFS pruning methods such as equivalence pruning, to an apriori-like approach In addition, we proved the correctness and completeness of the MHP algorithm. Finally, our experimental results show that the MHP algorithm can be several orders of magnitude faster than standard maximal frequent pattern mining algorithms and has the ability to identify patterns at extremely low levels of support in dense data sets There are several directions for future work. First, in 


this paper, we only generate the size-2 patterns in the BFS phase. It will be interesting to investigate the impact on the performance if the ?rst phase is stopped at a deeper level Also, the projection is a very ef?cient method for ?nding patterns, especially for parallel implementation of pattern mining algorithms [1]. We plan to adapt the projection ideas into our algorithm and design an ef?cient parallel algorithm for mining maximal hyperclique patterns References 1] R. Agarwal, C. Aggarwal, and V. Prasad. A Tree Projection Algorithm For Generation of Frequent Itemsets. pages 350 371, Feb 2001 2] R. Agrawal, T. Imielinski, and A. Swami. Mining Association Rules between Sets of Items in Large Databases. In Proc. of the ACM SIGMOD Conference on Management of Data, pages 207ñ216,May 1993 3] R. Agrawal and R. Srikant. Fast Algorithms for Mining Association Rules. In Proc. of the 20th Intíl Conference on Very LargeData Bases, 1994 4] R. Bayardo. Ef?ciently mining long patterns from databases In Proc. of the ACM SIGMOD Conference, 1998 5] R. Bayardo and R. Agrawal. Mining the Most Interesting Rules. In Proc. of the ACM SIGKDD Conference, 1999 6] D. Burdick, M. Calimlim, and J. Gehrke. Ma?a: AMaximal Frequent Itemset Algorithm for Transactional Databases. In Proc. of IEEE Conf. on Data Engineering, 2001 7] Y. Huang, H. Xiong, W. Wu, and Z. Zhang. A Hybrid Approach for Mining Maximal Hyperclique Patterns. In In Technical Report UTDCS-34-04, Department of computer science, University of Texas - Dallas, 2004 8] J.Han, J.Pei, and Y. Yin. Mining Frequent Patterns without Candidate Generation. In Proc. of the ACM SIGMOD International Conference on Management of Data, 2000 9] M.J.Zaki and C.Hsiao. ChARM: An ef?cient algorithm for closed itemset mining. In Proc. of 2nd SIAM International Conference on Data Mining, 2002 10] R.Rymon. Search through Systematic Set Enumeration. In Proc. Third Intíl Conference on Principles of Knowledge Representation and Reasoning, 1992 11] H. Xiong, M. Steinbach, P.-N. Tan, and V. Kumar. HICAP: Hierarchial Clustering with Pattern Preservation. In Proc. of 2004 SIAM International Conference on Data Mining \(SDM 12] H. Xiong, P.-N. Tan, and V. Kumar. Mining Strong Af?nity Association Patterns in Data Set with Skewed Support. In Proc. of the Third IEEE International Conference on Data Mining \(ICDM Proceedings of the 16th IEEE International Conference on Tools with Artificial Intelligence \(ICTAI 2004 1082-3409/04 $20.00 © 2004 IEEE 





