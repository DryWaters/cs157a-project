 Abstract  Association rule mining in real-time is of increasing thrust in many business applications. Applications such as e-commerce, recommender systems, supply-chain management and group decision support systems are to name a few. Finding frequent patterns from databases has been the most time consuming process of the association rule mining. Till date, a large number of algorithms have been proposed in the area of frequent pattern generation. However, all of these algorithms produce output only at the completion and are not amenable to the real-time need. The need for real-time frequent pattern mining for online tasks and real-time 
decision-making is increasingl y being felt. In this paper we describe BDFS\(b\, an algorithm to perform real-time frequent pattern mining using limited computer memory Empirical evaluations show that our algorithm can make a fair estimation of the probable frequent patterns and reaches some of the longest frequent patterns much faster than the existing algorithms  1  Introduction   Since its inception in 1993 by Agarwal et al., association rule mining for large databases of business data, such as transaction records, is of great interest in data mining and knowledge discovery as s o ciat ion ru le is a n  
expression of the form XY where X and Y are sets of items. Such a rule reveals that the transactions in the database, containing items in X tend to contain items in Y  and the probability, measured as the fractions of the transactions containing X also containing Y is called the confidence of the rule. The support of the rule, is the fraction of the total transactions that contain all items both in X 
and Y  For an association rule to hold, the support and the confidence of the rule should satisfy a user-specified  minimum support and minimum confidence. The problem of mining association rules is to discover all rules that satisfy this user-specified minimum support and minimum confidence. In this paper, we assume that the reader knows the basic assumptions and terminologies of association mining However, it is noteworthy at this point that the work of association rule mining can be decomposed into two phases 1  
Frequent itemsets generation: Find out all itemsets \(or group of parameters\at exceed the given minimum support 2  Rules construction: From the frequent itemsets generated in step 1 above, generate all association rules having confidence higher than the given minimum confidence As the second phase mentioned above is straightforward and less-expensive, researchers have generally focused on the first phase itself. The search space needed for finding all frequent itemsets is undoubtedly huge A num ber o f e f f i cie n t al g o rithm s  
have been proposed in the last few years to make this search fast and accu w e v e r m o s t of th e  algorithms stop only after finding the exhaustive optimal\set of frequent itemsets. These algorithms have been very efficient and scalable for many real-life applications and are based on the çcollect-store-analyze model. In all these, data mining is typically considered to be an offline analytical task. These algorithms do not have the ability to run under user defined real-time constraints and produce some satisficing \(interesting suboptimal\utions. With the increasing demand of real 
time applications in various fields of business today development of real-time data mining algorithms demand attention adopted from  realti m e  f r equ e n t pat tern  m i n i ng alg orit hm We also show its edge over existing efficient association mining algorithms such as FP-Growth, when it runs to completion and outputs exhaustive set of frequent patterns The rest of the paper is organized as follows. In the next section we discuss on the importance of real-time frequent pattern mining in businesses. In Section 3, we 
present a review of the previous work in association rule mining.  In Section 4, we introduce algorithm BDFS\(b Section 5 contains the empirical evaluation of our algorithm. Finally, we conclude the paper in Section 6  An Efficient Technique for Frequent Pattern Mining in Real-Time Business Applications  Rajanish Dass Indian Institute of Management Calcutta email: rajanish@iimcal.ac.in  Ambuj Mahanti Indian Institute of Management Calcutta email: am@iimcal.ac.in    0-7695-2268-8/05/$20.00 \(C Proceedings of the 38th Hawaii International Conference on System Sciences - 2005 1 


 2 Business Issues of Real-Time Frequent Pattern Mining  In recent years, business intelligence systems are playing pivotal roles in fine-tuning business goals such as improving customer retention, market penetration profitability and efficiency. In most cases, these insights are driven by analyses of historic data. Now the issue is if the historic data can help us make better decisions, how real-time data can improve the decision making process 4  An offline approach to data mining reflects sound practice because the data have to be cleaned checked for accuracy, etc. However, in a scenario of cutthroat competition, the organizations cannot afford to show the attitude of not keeping abreast with the latest changing demands and trends of their customers and get satisfied with periodical data. They have to act on the latest data that is available to them to react not only to the fierce global competition, but also market products keeping in mind of the latest customer wishes. In such a scenario, the concept of a real-time enterprise has creped into the corporate boardrooms of a number of organizations. Using up-to-date information, getting rid of delays, and using speed for competitive advantage is what the real-time enterprise is abou  In the following sub-sections, we discuss the importance of real-time frequent pattern mining in some common business applications  2.1 Real-Time CRM  Due to the change in the focus of marketing from mass marketing to more of relationship marketing, Customer Relationship Management \(CRM\ has become a major focus and thrust area for most of the companies, both online and offline. It costs five to seven times more to find new customers than to retain current customers. A 5% reduction in customer defection can result in profit increases from 30% to 85%. If companies increase their customer retention by 2%, it is the equivalent of cutting their operating expenses by 10 In this context, the extraction of hidden patterns from large databases help the organizations to identify customers, predict their future behaviors and enable firms to take proactive and knowledge-driven decisions However, one important thing to be noted is that the companies do not have infinite time to run data mining tools on huge transactional databases and data warehouses to look into the patterns or come up with offers for the customers who come to visit their stores This applies to both online and offline business outlets Companies have understood the need for real-time CRM and that real-time analysis of the buying habits is desperately needed to make relevant offers to a particular concerned customer, before the customer leaves the outlet and ends the transaction. Researchers e that real-time personalization technology will proactively offer a particular customer products and services that will fit into her needs exactly. A real-time analytical engine will work in real-time, analyzing web clicks or sales rep interactions and matching them with the past purchasing history to make the offerings  2.2 Real-Time Recommender Systems  The explosive growth of the world-wide-web and the emergence of e-commerce have led to the development of recommender systems  w h ich is a v ariant of realtime CRM. Recommender systems are personalized information filtering technology used to either predict if a particular user will like a particular item prediction problem or to identify a set of N-items that will be of interest to a particular user top-N recommendation system 29 In recent years, recommender systems have been used in a number of different applications Recommending products that a customer is most likely to buy such as movies, books, music, TV programs, and restaurant recommendations, demonstrating the wide range of application domains of existing recommender systems a user will find enjoyable, identifying the web pages that will be of interest, or even suggesting alternate ways of searching for information particu lar Schaf m a de an eleg ant s u rv e y on  m a j o r  existing systems and approaches to e-commerce recommendation Despite the popularity of the recommender systems, they have a number of limitations related to their scalability and real-time performance. As a typical example, the SmartPad system dev  makes recommendations using a model of association rules. The model is built on the past eight weeks of data from Safeway Stores and is updated weekly or quarterly to reflect seasonal differences. Hence, Shen  observes that most existing data mining approaches to ecommerce recommendation are past data model-based in the sense that they first build a preference model from a past dataset and then apply the model to current customer situations. Such approaches are not suitable for applications where fresh data should be collected and processed instantly since it reflects changes to customer preferences over some products  2.3 Real-Time Supply Chain Management Systems  Supply Chain Optimization traditionally has been done in a static way. Production-Distribution-Inventory Systems that are now being used in manufacturing companies are 0-7695-2268-8/05/$20.00 \(C Proceedings of the 38th Hawaii International Conference on System Sciences - 2005 2 


 static information systems. Periodically \(typically weekly or monthly\, all data \(demand forecasts, available machine capacity, current inventory levels, desired inventory levels, etc.\lected and fed into a huge Optimization System \(typically some type of Linear Programming system\. After many hours of computation a big company-wide plan is obt ained: this plan represents next week's \(or months\ production schedule, the inventory levels at the various facilities and the distribution of the final goods. However, due to demand fluctuations or other unpredictable situations, the plan does not exactly meet the company's best course of action in light of changing conditions and data. So, production and plant managers adjust the plan to the best of their possibilities, given the frequent lack of data and their inability to compute the ``best'' course of action. Needless to say, there is room for improvement in the process of making these real-time adjustments. Until now, no serious effort has been made to optimize the Supply Chain operations in real-time. The inability to access upto-date information and/or the inability to properly process it in real time were impediments to use any Analytic or Optimization tool. Consequently, all optimization systems for Supply Chain models that are described in the literature are static. Real-time adjustments in view of changing data are made manually and ad ho It has been estimated that companies, which generally spend about 10% of revenue on logistics and inventory overhead, could halve that by taking full advantage of effective supply chain management planning. Quite simply, 'increased information used effectively equals increased profits In such a dynamic environment, it is required that the software agents incorporate decision logic. It is not enough that they just gather data and monitor events but that they can heuristically take corrective action Indeed, it is not at all possible to re-run the overall planning model over and over as soon as something does not go according to plan. First of all, the optimization takes a long time to complete; and secondly, even if it were possible to do so, th e current situation cannot always be altered from one moment to the next, which puts additional constraints on the real-time model as compared to the planning m Besides this there are numerous areas where real-time decision making plays a crucial role. These include areas like real-time enterprise risk and vulnerability management ti m e stock management and vendor inventory [15  r e a l t i m e  operational management with special applications in mission critical real-time information as is used in the airlines industry, real-time intrusion and real-time fraud detection realti m e n e g o tiation s a n d oth er areas lik e real-time dynamic pricing and discount offering to customers in real-time. More than that, real-time data mining will have tremendous importance in areas where a real-time decision can make the difference between life and death Ö mining patterns in medical systems  3. Previous Work  Association rule mining were independently introduced by Hajek d b y  Agra w a l et al. [18]. A detailed discussion about the various algorithms of frequent pattern mining and their performance can be found in the literature surveys of frequent pattern mining It is noteworthy at this point that the total search space for all frequent itemsets is huge. Instead of generating and counting the supports of all possible itemsets at once, which is obviously infeasible, several solutions have been proposed to perform a more directed search by iteratively generating and counting sets of candidate itemsets The most well known and influential algorithm is Ap h ic h us es  an apriori k n o w l ed g e of  frequent kitemsets to generate candidate itemsets of length k+1 and employs an innovative technique for pruning non-promising candidates. However, the most discussed drawback of this algorithm is that when the cardinality of the longest frequent itemsets is k Apriori needs k passes of database scans. Many variants of this algorithm have been designed. Other ways of solving the problem were using various partitioning methods and sampling methods. These implementations included algorithms like Apriori-TID A p rioriH y brid[20  Partition Sam pli n g 22], CARM A 23], ECL A T   TopDo w n 24], F P G row t h 25] am o n g ot h e rs  Majority of the algorithms in this area have been classified according to their strategy to traverse the search space and by their strategy to determine the support values of the itemsets w e v e r, Su    L i n   h a s con clu ded th at t h e m o s t s a lien t f eat u r es of th e s e algorithms are their counting strategy  search direction  and search strategy Horizontal counting or vertical intersections are used for counting the occurrences of candidate itemsets. Most of the algorithms have generally used a bottom up approach in the search strategy. While applying the search strategy, the algorithms have used a breadth first or a depth first search. The above points may be summarized in the following table           Figure 1 Classification of prevailing algorithms Search Direction Bottom-up Top-Down Search Strategy Search Strategy Counting Strategy Depthfirst Breadthfirst Depthfirst Breadthfirst Counting FPGrowth Apriori TopDown Intersection ECLAT Partition   0-7695-2268-8/05/$20.00 \(C Proceedings of the 38th Hawaii International Conference on System Sciences - 2005 3 


 4. BDFS\(b\ Efficient Technique for Frequent Pattern Mining in Real-Time 4.1 Algorithm Basics   In this study, we propose a brute force algorithm which is a variant of the Block Depth First Search e  call the algorithm as BDFS\(b\DFS\(b\plores the given search space in stages. The search is conducted in a depth first manner, which ensures that patterns of greater length will be preferred over those of comparatively shorter lengths We assume that a lower triangular frequency matrix M is created in a pre-processing step, which stores the support independent frequencies of all 1-length and 2length patterns. Once the user specifies a desired support value, all frequent patterns of length 1 and 2 \(meaning F\(1\d F\(2\here F\(n\means frequent pattern of length-n\ed from M. Then BDFS\(b\tarts its search for frequent patterns of higher lengths from this point forward The most salient features of BDFS\(b a\onducts search in stages and uses backtracking strategy to run to completion and ensure optimal solution b\es a block of candidate patterns b from a global pool, conducts the search by checking the frequency of these patterns in the database. It generates the possible candidate patterns \(explained later with an example\ of the next higher length from the currently known frequent patterns. These candidate patterns are continued to be explored in a systematic manner until all frequent patterns are generated A possible state space diagram of BDFS\(b\ shown in figure 2   Figure 2 State Space Diagram for BDFS\(b The initial state \(or the root node\ the state-space is denoted by S 0 which contains the complete set of  2length frequent patterns F\(2\ S 0 the set of all candidate patterns of length 3 or more are set to  In general, by the expansion of a node \(which is a block of candidate patterns in this case\ we mean i  Counting the support frequency of all candidate patterns in the state from the database ii  Generating the candidate patterns or patterns of border set of next higher level \(explained later in the algorithm and its working through example iii  Arranging the candidate patterns according to their merits \(explained later\d group them into blocks containing b-patterns each. If the block has empty space, it gets candidate patterns from the previous level. This can be handled using a global pool of candidate patterns that has been sorted in descending order of length. We resolve ties arbitrarily  4.2 Algorithm Details  Algorithm BDFS\(b  Initialize the allowable execution time   Let the initial search frontier contain all 3-length candidate patterns. Let this search frontier be stored as a global pool of candidate patterns. Initialize a set called Border Set to null Order the candidate patterns of the global pool according to their decreasing length \(resolve ties arbitrarily\. Take a group of most promising candidate patterns and put them in a block b of predefined size  Expand \(b Expand \(b: block of candidate patterns If not last_level then begin Expand 1 b end Expand 1 b 1  Count support for each candidate pattern in the block b by intersecting the t-id list of the items in the database 2  When a pattern becomes frequent, remove it from the block b and put it in the list of frequent patterns along with its support value. If the pattern is present in the Border Set increase its subitemset counter. If the subitemset counter of the pattern in Border Set is equal to its length move it to the global pool of candidate patterns 3  Prune all patterns whose support values < given minimum support Remove  all supersets of these patterns  from Border Set 4  Generate all patterns of next higher length from the newly obtained frequent patterns at step 3. If all immediate subsets of the newly generated pattern are frequent then put the pattern in the global pool of candidate patterns else put it in the Border Set if the pattern length is 3 5  Take a block of most promising b candidate patterns from the global pool 6  If block b is empty and no more candidate patterns left, output frequent patterns and exit  7  Call  Expand\(b\ if enough time is left in  to expand a new block of patterns, ,else output frequent patterns and exit  Figure 3 Algorithm BDFS\(b Let us consider the following example to show how BDFS\(b\works. Let us consider some market basket data to illustrate its working, which has been a conventional 0-7695-2268-8/05/$20.00 \(C Proceedings of the 38th Hawaii International Conference on System Sciences - 2005 4 


 technique in describing many frequent pattern mining algorithms Let the following table represent a set of 12 transactions, where the items are represented by a, b, c  1.   a b c d e 2.   a c d e 3.   a d e 4.   b c d e 5.   b d e 6.   a b d 7.   a b d 8.   a b c d 9.   d e 10. a c d e 11. a b c d e 12. ace Figure 4 An example of transaction data Now we proceed as follows Step I Given this set of transactions D, we create a two dimensional lower triangular matrix M using procedure Create_Matrix and the transaction id lists  I. Create a lower triangular adjacency matrix, M, for nitems \(Total storage required: n*\(n+1\/2\. M stores the frequencies of 1-at-a-time and 2-at-a-time combinations of all items II. In M, M\(i,j\ represents the number of occurrences of the item-pair i and j  i = 1,2Én and  j = 1,2,3Éi and M\(i,i\ represents the total number of occurrences of item i  Figure 5 Procedure Create_Matrix  The created matrix M is depicted in figure 6. This step of creating the matrix M and the tid-list \(figure 7\ a support independent step and we refer this step through out this paper as a pre-processing step  Step II Let the absolute support abs\iven for running BDFS\(b\his means that we are interested only in patterns, which have frequency greater than or equal to 3. Cells of Matrix M are visited to find F\(1\d F\(2\here F\(n\ is frequent pattern of length n Thus we have F\(1  9 1 F\(2  ab\(5\, ac\(6\, ad\(8\, ae\(6\, bc\(4\, bd\(7\, be\(4 cd\(6\ ce\(6\,  de\(8 2 Frequency of each pattern is shown within parentheses Thus the pattern e of F\(1\ has frequency 9 and bd of F\(2 has frequency 7 Step III Two 2-length patterns are merged if their first elements match Thus newly merged patterns  abc, abd, abe, acd, ace ade, bcd, bce, bde, cde 3 Step IV Find if all the subsets of new merged patterns are frequent. For any 3-lemgth newly merged pattern, if all its 2-length subsets are not present, then the pattern is pruned \(using the support monotonicity property[18 e r w ise if all its 2 le n g t h  su b s e t s are present the pattern becomes a candidate-pattern and it is  moved to the global-pool of candidate patterns C The global-pool of candidate patterns is sorted on length and any tie between two same length patterns is resolved arbitrarily C  abc, abd, abe, acd, ace, ade, bcd bce, bde, cde 4   Figure 6 Matrix M  Item Transaction Ids A 1 2 3 6 7 8 10  11  12  B 1 4 5 6 7 8 11    C 1 2 4 8 10 11 12    D 1 2 3 4 5 6 7 8 9 10 11 E 1 2 3 4 5 10 11 12   Figure 7 The tid-list of the items Step V  Let us assume that the block size b is 4 which means that we can take at most 4 patterns into a block for checking their frequency. This means as the 3length candidate patterns are pushed into the global pool 4 of these patterns namely abc, abd, abe and acd will be put in the next block b Step VI We now check the frequency of these patterns by intersecting the tid-lists of the items b = {abc \(3\, abd \(5\, abe \(2\, acd \(5 5 As frequency of abe is less than the support threshold, it gets pruned F \(3\ = {abc \(3\, abd \(5\, acd \(5 6 Step VII We now merge the newly found frequent patterns in F\(3 and test these newly merged patterns generated for the presence of their immediate subsets Newly merged patterns  abcd  7 We now find that all immediate subsets of the pattern abcd are not present in F\(3 But only three immediate subsets are present. Hence we move the pattern abcd to border set of length 4 BS \(4 with a subitemset counter of 3 BS \(4\ = { abcd \(sub-itemset = 3 8  Patterns ace, ade, bcd, bce are taken in the next block b from the globalpool of candidate patterns b={ace\(5\,ade\(5\,bcd\(4\,bce\(3 9 We find that all these items have frequency greater than abs\ and are hence frequent.  Thus from the new block F\(3\={ ace\(5\ ,ade\(5\, bcd\(4\, bce\(3 10 For each pattern in the current F\(3 we search BS \(4 to see if any of the immediate supersets are waiting in the border set. We find that the pattern abcd is in BS \(4 with sub-itemset counter = 3. Hence we increase the sub-itemset counter of abcd and make it 4 The pattern abcd is of the highest length among the 0-7695-2268-8/05/$20.00 \(C Proceedings of the 38th Hawaii International Conference on System Sciences - 2005 5 


 candidate patterns in the global-pool and is put in the next block b  Newly merged patterns \(4  acde ,bcde 11 The number of frequent immediate subsets of acde and bcde are 3 and 2 respectively. Hence they are moved to BS \(4  BS \(4\ = { acde \(sub-itemset = 3\, bcde \(sub-itemset 2 12 The patterns abcd, bde and cde go to the current block b. After intersecting the tid-list of these patterns we find that F \(4\ {abcd \(3 13 F \(3\ {bde \(3\cde \(5 14 Similarly we search the BS \(4\ith newly found F\(3\s and merge the patterns in the newly found F\(3\s with previous F\(3\s to generate higher length patterns. We find that acde and bcde move from BS \(4\o global pool of patterns and moves into the block b. By intersecting the tid-lists of the items, we find that F\(4\={acde \(4\, bcde \(3 15 As no higher length patterns can be generated and the number of patterns in block b becomes zero and also the number of candidate patterns in the global pool of candidate patterns becomes zero, the algorithm stops executing here. Thus, the set of all frequent patterns are F\(1  9  F\(2  ab\(5\, ac\(6\, ad\(8\, ae\(6\, bc\(4\, bd\(7\, be\(4 cd\(6\ ce\(6\,  de\(8  F\(3  abc \(3\, abd \(5\, acd \(5\, ace\(5\ ,ade\(5\, bcd\(4 bce\(3\, bde \(3\,cde \(5  F\(4  abcd \(3\, acde \(4\, bcde \(3  The block size b can now be varied to show how it affects the execution time of the algorithm. In the next section, we show and discuss this effect. BDFS\(b\as the capability to run in real-time. Whenever it is stopped before its natural completion, it outputs frequent patterns of various lengths it had obtained up to that point of execution time  5. Empirical Evaluations  Legend T= Average size of transaction; I= Average size of the maximal potentially large itemset; D= No. of transactions in the database; N= Number of items  To evaluate the performance of BDFS\(b\we have tested it on various datasets. This includes real-life datasets like BMS-WebView-1[27 an d sev e ral sy n t h e tic  datasets like: T10I8D100K, T10I8D10K, T10I8D1K T10I2D100K, T6I5D10K, T5I4D1K, T5I4D10K T5I4D100K \(all these datasets have 1K number of items T5I4N500D1K, T5I4N500D10K, T5I4N500D100K \(with number of items being 500\T5I4N100D1K T5I4N100D10K, T5I4N100D100K where the number of items is 100\These datasets were generated using the IBM synthetic data generator 1  T h e ex peri m e n t s  w e re  performed on a Linux machine with 1GB RAM and 20 GB HD  5.1 Comparison of BDFS\(b\ with Existing Algorithms  In order to show how BDFS\(b\orms, when it is run to generate all frequent patterns, we have chosen to compare it with FP-growth and Apriori. Since FP-growth is known to be an order faster and scales better than Apriori[25  w e  ha ve  ta ke n F P gr o w th  a s the  b e nc h m a r k and compared its execution time with that of  BDFS\(b For the sake of curiosity we have also compared Apriori and BDFS\(b\t for their number of patterns checked In figures 8, 9 and 10 we have compared the run-time of FP-growth 2 and BDFS\(b\or three different datasets and found that BDFS\(b\ignificantly outperforms FP-growth in all the cases. In figure 11, we have tested the scalability of FP-growth and BDFS\(b We have observed that both the algorithms are scalable with time and number of transactions in the database, but BDFS\(b\es strikingly much less time than FP-growth over the same databases Comparing the number of patterns being checked by Apriori 3 and BDFS\(b\ shown in figure 12 it is found that BDFS\(b\ecks much lesser number of patterns than Apriori  5.2 Real-Time Performance of BDFS\(b  Performance of BDFS\(b\ for varying values of block size b is shown in figure 13. We find that for b=1K, 10K and 100K BDFS\(b\ scalable. When the block size is too small, say b= 1K, then it takes more time for completion compared to b= 10K or 100K. For b= 10K or above it gives similar performance \(as normally a successor block can then accommodate all the candidate patterns of a parent block Scalability test with increasing number of items fig. 14\hows that the time decreases with the increase in the number of items. Because, with fixed number of transactions, the increase in the number of items decreases the average number of occurrences per item which in turn decreases the search space for higher order patterns    1  The data generator is available from http://www.almaden.ibm.com/cs/quest//syndata.html#assocSyn Data  2  The FP-growth code used for comparison is publicly available at www.cse.cuhk.edu.hk/~kdd/program.html  3  Apriori code used for comparison is publicly available at www.cs.helsinki.fi/u/goethals/software/index.html   0-7695-2268-8/05/$20.00 \(C Proceedings of the 38th Hawaii International Conference on System Sciences - 2005 6 


  0 5 10 15 20 25 30 35 40 45 0.33 1.00 3 5 Support Time\(s FP-Growth BDFS\(b   Figure 8  Time comparison of FP-Growth and BDFS\(b T10I8D100K,b =100K  0 0.2 0.4 0.6 0.8 1 1.2 0.4 0.7 1.0 Support Time \(s FP-Growth BDFS\(b  Figure 9 Time comparison of FP-Growth and BDFS\(b T10I8D10K, b =100K Figures 15 and 16 summarize the real-time behavior of BDFS\(b\ depicting the percentage of frequent patterns generated with the percentage of total execution time. These include F\(1\d F\(2\ed from the frequency matrix. Figure 16 particularly shows that the efficiency enhances with increasing values of support. Next three figures namely, 17,18 and 19, present over all scenarios of real-time outputs by showing the number of patterns of different lengths obtained at different time slices \(expressed as % of total execution time\or three different block sizes In figures 20 and 21, we observe that our proposed algorithm perform quite well on real-life data BMS-WebView I. Figure 20 makes a tabular presentation of real-time outputs showing length-wise frequent patterns, border sets, and candidate sets, at different  time slices \(expressed as % of total execution time\may be seen from the output that all the F\(7\d F\(8\s which are of maximal length in this case\were outputted only in 4.18% time. Figure 21  shows percentage of frequent patterns generated with percentage execution time having F\(1\ & F\(2\ included and excluded in two respective curves.  It may be noted that the over all percentage of output is almost always ahead of percentage execution time  0 20 40 60 80 100 120 0.25 0.75 1.50 3 4.50 7 Support Time\(s FP-Growth BDFS\(b  Figure 10 Time comparison of FP-Growth and BDFS\(b T10I2D100K, b =100K  0 5 10 15 20 25 30 35 40 0 20406080100 No. of Transactions \(x 1000 Time \(s FP-Growth BDFS\(b\100K  Figure 11 Scalability evaluation of FP-Growth and b=100K\with number of transactions for T10I8 Support=0.5  6. Conclusion  Traditionally, the frequent pattern mining has been kept as an offline analytical task, where the frequent patterns are found on the data captured for a specific time period few weeks, months or even years. But with the changing scenario in the business environment and with improvement in the communications technology and the Internet, and with the more and more business processes going online, frequent pattern mining for real-time decision making has become a thrust area of research Real-time frequent pattern mining will have great impact on the way knowledge is gathered from patterns from the databases. It has the capability to affect all aspects of doing business in todayês world 0-7695-2268-8/05/$20.00 \(C Proceedings of the 38th Hawaii International Conference on System Sciences - 2005 7 


  0 1000 2000 3000 4000 0.00 0.50 1.00 1.50 2.00 Support No. of Patterns Checked Apriori BDFS\(b Figure 12 Number of patterns checked by Apriori and BDFS\(b\or T10I28D100K with varying supports   0 10 20 30 40 50 050100150 No. of Transactions \(x 1000 Time \(s b=100K b=10K b=1K  Figure 13 Time scalability of BDFS\(b\with increasing no. of transactions for T5I4D1K,10K,100K and b=1K,10K and 100K, support 0.5  0 0.2 0.4 0.6 0.8 1 0 200 400 600 800 1000 1200 No. of Items Time \(s b=100K b=10K b=1K  Figure 14 Scalability Test of BDFS\(b\with number of items for T5I4, support 0.5 It will provide decision makers with more accuracy and reduced time lag and help in real-time decision-making In this paper, we have proposed an algorithm BDFS\(b\which is a brute force version of the Block Depth First Search\(BDFS w e  h a v e co m p ared the performance of BDFS\(b\ith FP-Growth and Apriori and shown that it does significantly better than both Moreover, by adjusting its block size properly BDFS\(b\as the extra ability to run with limited available memory, which often becomes a point of concern in other algorithms. We have then shown that while running under real-time constraints it outputs large chunks of frequent patterns with fractional execution times. We have made detailed performance evaluation based on empirical analysis using several commonly used synthetic datasets and one real-life dataset          93 94 95 96 97 98 99 10 0 0 20 4060 80100 Tim e Patterns  Figure 15 Time-patterns % of BDFS\(b\or 0.05 support of  T6I5D10K 50.00 60.00 70.00 80.00 90.00 100.00 0.00 20.00 40.00 60.00 80.00 100.00 time pattern 0.03% supp 0.04% supp 0.05% supp 0.06% supp 0.07% supp 0.08% supp 0.09% supp 0.1% supp  Figure 16 Time-patterns % of BDFS\(b\or varying support for T6I5D10K Thus, we have demonstrated that real-time frequent pattern mining can be done successfully using BDFS\(b This algorithm may be modified for matching the memory and time constraints dynamically. It may be worthwhile to generalize this algorithm for other application domains having specialties such as sequential or temporal data This proposed brute force version of BDFS\(b expected to handle well problems of moderate to large size. For very large databases it may be beneficial to design domain specific heuristics for enhanced efficiency We believe this study will encourage use of AI search techniques in real-time frequent pattern mining 0-7695-2268-8/05/$20.00 \(C Proceedings of the 38th Hawaii International Conference on System Sciences - 2005 8 


  0 50 100 150 200 250 N o  o f P a tte r n s  F[4 F[5 F[6 F  7 16 45 75 95 Frequent Pattern Length Time 15.67 25.60 45.44 65.28 75.20 85.12 95.04 100.00  Figure 17 Real-time output of frequent patterns of T6I5D10K, support 0.05%, b =1K 0 50 100 150 200 250 No. of Patterns F F  4 F  5 F  6 F  7 8.97 25.00 50.64 76.28 100.00 Frequent Pattern Length Time 8.97 12.18 25.00 37.82 50.64 63.46 76.28 89.10 100.00  Figure 18 Real-time output of frequent patterns of T6I5D10K support 0.05%, b =10K 0 50 100 150 200 250 No. of Patterns F[3 F[4 F[5 F[6 F[7 8.64 24.07 54.94 85.80 Frequent Pattern Length Time 8.64 17.90 24.07 39.51 54.94 70.37 85.80 100.00  Figure 19 Real-time output of frequent patterns of T6I5D10K support 0.05%, b=100K      Tim e 1.72 4.18 14.01 23.83 38.58 48.41 63.15 97.55 100.00     350    350    350    350    350    350    350    350 F  350     2319    2319    2319    2319    2319    2319    2319    2319    2319     612    1028    1542    1488    1783    1935    2078    2695    3049     488    607    953    944    1070    1163    1250    1456    1790     299    301    347    331    363    376    390    445 F  508     134    134    134    134    134    136    136    137 F  141     1    31    31    31    31    31    31    31 F  31   F F  8 3 F  8 3 F  8] : 3 F  8] : 3 F  8 3 F  8 3 F  8 3  Bor der Sets BS[4 524 BS[4 879 BS[4 2469 BS[4 2446 BS[4 2890 BS[4 3159 BS[4 3676 BS[4 4820 BS[4 8127  BS[5 285 BS[5 310 BS[5 625 BS[5 625 BS[5 697 BS[5 747 BS[5 771 BS[5 927 BS[5 1865  BS[6 90 BS[6   90 BS[6 106 BS[6 101 BS[6 110 BS[6 118 BS[6 118 BS[6 136 BS[6 170  BS[7 21 BS[7 21 BS[7 21 BS[7 21 BS[7 21 BS[7 21 BS[7 21 BS[7 21 BS[7 21  Can dida te Sets C   17180 C   14570 C   10755 C   11698 C   9632 C   8504 C   7345   Figure 20 Frequent pattern output along with border sets and candidates patterns of BDFS\(b\or BMS-Web View-1 with support 0.08%. N= 497, T=2.5, D=59602, b = 497 0.00 20.00 40.00 60.00 80.00 100.00 0 20406080100 Time Patterns Output patterns including F\(1\ & F\(2 Output patterns excluding F\(1\ & F\(2  Figure 21 Time Ö patterns% comparison of BDFS\(b\or BMS-WebView-1 with support 0.08% and b = 497    0-7695-2268-8/05/$20.00 \(C Proceedings of the 38th Hawaii International Conference on System Sciences - 2005 9 


 7. Reference  1 B. G o e t ha ls  M em or y Is s u e s  in Fre q ue nt P a tte r n  Mining," in Proceedings of SAC'04 Nicosia, Cyprus ACM, 2004 2 B. G o e t ha ls  S urv e y on Fre que nt P a tte rn Mi ning   vol. 2004, 2003 3 A  Ma ha nti, S. G hos h  a nd A  K   P a l A H i g h  Performance Limited-Memory Admissible and Real Time Search Algorithm for Networks," University of Maryland at College Park, MD 20742, Maryland College Park, Computer Science Technical Report Series CS-TR-2858 UMIACS-TR-92-34, March 1992 1992  M  L  G o n zales Un earth BI in Real-tim e vo l  2004: Teradata, 2004 5 G a rtn er T h e RealT i m e En terp rise v o l. 2 0 0 4   2004 6 K  R  B hote  B ey ond C u s t o m e r Sa tisf a c tion to  Customer Loyalty," in Proceedings of the American Management Association New York, NY, 1996  S  L a n g en f e ld  CRM an d t h e Cu sto m er Driven  Demand Chain," vol. 2004, 2004 8 W  L i n, "A ssoc ia tion Rule  Min i n g f o r Colla b o ra tiv e  Recommender Systems," in Computer Science  Worcester Polytechnique Institute www.wpi.edu/Pubs/ETD/Available/etd-0515100145926 unrestricted/wlin.pdf, 2000, pp. 64 9 J  Sc ha f e r, J   K ons ta n, a nd J  Rie d l E le c t ronic  Commerce Recommender Applications Journal of Data Mining and Knowledge Discovery vol. 5, pp 115-152, 2001 1 R L a w r en ce  G   A l masi V  Ko tlyar M  V i vero s an d S. Duri, "Personalization of Supermarket Product Recommendations Journal of Data Mining and Knowledge Discovery vol. 5, pp. 11-32, 2001 1 Y. D. S h en  Q. Ya n g Z Zh a n g an d H L u  M i n in g  the Customer's Up-To-Moment Preferences for Ecommerce Recommendation," in Proceedings of the Advances in Knowledge Discovery and Data Mining 7th Pacific-Asia Conference, PAKDD 2003, Seoul Korea, April 30 - May 2 vol. 2637 / 2003 Lecture Notes in Computer Science K.-Y. Whang, J. Jeon, K Shim, and J. Srivastava, Eds. Heidelberg: SpringerVerlag, 2003, pp. 166-177 12 R. Ka la k o ta J. Sta lla e r t, a n d A  C. W h inston   Implementing Real time Supply Chain Optimization Systems," presented at Supply Chain Management Hong Kong, 1995 1 J D y ch e  Real T i me o r Righ t T i m e E x p l ain i n g T h e Real Time Enterprise," vol. 2004: CRM Guru, 2003 1 Op en S e rviceIn c  Real-T i m e En terp rise Risk an d Vulnerability Management," vol. 2004: Open Service Incorporation, 2004 15  Se e B ey ond R e a l T i m e Stoc k Ma na g e m e nt a n d  VMI," vol. 2004, 2004 16 W   L e e  S. J  Stolf o, P  K  Cha n E. Es k i n, W  Fa n, M  Miller, S. Hershkop, and J. Zhang, "Real time data mining-based intrusion detection," presented at DARPA Information Survivability Conference Exposition II, Anaheim, CA , USA, 2001 17 P. Ha je k  I. Ha v e l, a nd M. Chy til T he  G uha Me thod  of Automatic Hypotheses Generation Computing  vol. 1, pp. 293-308, 1966 18 R. Ag a r wa l, T  I m ie lin sk i, a nd A  S w a m i M ining  Association Rules Between Sets of Items in Large Datasets," in Proceedings of the ACM SIGMOD Conference on Management of Data  Washington,D.C.: ACM, 1993, pp. 207-216 1 J Hip p  U G u n t zer an d  G  Na kh aeizad e h   Algorithms for Association Rule Mining -- A general Survey and Comparision," in Proceedings of ACM SIGKDD vol. 2: ACM, 2000, pp. 58-64 20 R. Ag ra w a l a nd R. Srik a n t M ining Se que n tia l  Patterns," in Proceedings of the 11th IEEE International Conference on Data Engineering  Taipei, Taiwan: IEEE, 1995 2 A  S a vaser e E  O m i eci n s ki  an d S  B Navat h e   A n  Efficient Algorithm for Mining Association Rules in Large Databases," in Proceedings of the 21nd International Conference on Very Large Databases  Zurich, Swizerland, 1995, pp. 432-444 22  H  T o iv one n S a m pling L a r g e D a ta ba se s  f o r Association Rules," in Proceedings of the 22nd International Conference on Very Large Databases  Mumbai, India, 1996, pp. 134-145 23  C. H i dbe r O nline A s s o c i a tion Rule Mini ng  in Proceedings ACM SIGMOD International Conference on Management of Data Philadephia Pennsylvania: ACM, 1999, pp. 145-156 2 M  J Z aki  S cal ab l e A l go ri t h ms f o r A sso ci at i o n  Mining IEEE Transactions on Knowledge and Data Engineering vol. 12, pp. 372-390, 2000 25  J  H a n, J   P e i, a nd Y  Y i n M i n i n g Fre que nt P a tte rns  Without Candidate Generation," in Proceedings of the 2000 ACM SIGMOD International Conference on Management of Data Dallas,TX: ACM, 2000, pp. 112 26  J  H Su a nd W  Y  L i n CBW  A n Eff i c i e n t Algorithm for Frequent Itmeset Mining," in Proceedings of the 37th Hawaii International Conference on System Sciences Hawaii: IEEE, 2004 27  R  K oha v i a nd F P r ov os t A pplic a t i ons of D a ta  Mining to Electronic Commerce Journal of Data Mining and Knowledge Discovery vol. 5, pp. 5-10 2001 28  M. S Ra hm a n N  L  Ma rti n  a nd S   P a ul D a t a  Mining, Group Memory, Group Decision Making: A Theoretical Framework," presented at Ninth Americas Conference on Information Systems, 2003 29  Deshpande, M. and G. Karypis Item Based Top-N Recommendation Algorithms 2003     0-7695-2268-8/05/$20.00 \(C Proceedings of the 38th Hawaii International Conference on System Sciences - 2005 10 


xt a ppl i c a t i on oc t e t s t re a m 22832 xt t e xt  pl a i n 17993 


the initial global candidate set would be similar to the set of global MFIs. As a result, during the global mining phase the communication and synchronization overhead is low  0 2 4 6 8 1 0 Number of Nodes Figure 5. Speedup of DMM 4.4.2 Sizeup For the sizeup test, we fixed the system to the 8-node con figuration, and distributed each database listed in Table 2 to the 8 nodes. Then, we increased the local database sire at each node from 45 MB to 215 MB by duplicating the initial database partition allocated to the node. Thus, the data distribution characteristics remained the same as the local database size was increased. This is different from the speedup test, where the database repartitioning was per formed when the number of nodes was increased. The per formance of DMM is affected by the database repartitioning to some extent, although it is usually very small. During the sizeup test, the local mining result of DMM is not changed at all at each node The results shown in Figure 6 indicate that DMM has a very good sizeup property. Since increasing the size of local database did not affect the local mining result of DMM at each node, the total execution time increased just due to more disk U 0  and computation cost which scaled almost linearly with sizeup 5 Conclusions In this paper, we proposed a new parallel maximal fre quent itemset \(MFI Max-Miner \(DMM tems. DMM is a parallel version of Max-Miner, and it re quires low synchronization and communication overhead compared to other parallel algorithms. In DMM, Max Miner is applied on each database partition during the lo 0 45 90 135 180 225 270 Amwnt of Data per Node \(ME Figure 6. Sizeup of DMM cal mining phase. Only one synchronization is needed at thc end of this phase to construct thc initial global candi date set. In the global mining phase, a top-down search is performed on the candidate set, and a prefix tree is used to count the candidates with different length efficiently. Usu ally, just a few passes are needed to find all global maximal frequent itemsets. Thus, DMM largely reduces the number of synchronizations required between processing nodes Compared with Count Distribution, DMM shows a great improvement when some frequent itemscts are large \(i.e long patterns employed by DMM for efficient communication between nodes; and global support estimation, subset-infrequency based pruning, and superset-frequency based pruning are used to reduce the size of global candidate set. DMM has very good speedup and sizeup properties References I ]  R. Agrawal and R. Srikant  FdSt Algorithms for Mining As sociation Rules  Pmc. o f f h e  ZOrh VLDB Conf, 1994, pp 487499 2] R. Agrawal and I. C. Shafer  Parallel Mining of Association Rules  IEEE Trans. on Knowledge and Dura Engineering Vol. 8, No. 6, 1996, pp. 962-969 3] R. I. Bayardo  Efficient Mining Long Patlems from Databases  Proc. ofrhe ACM SIGMOD Inf  l Conf on Man ogemenr ofDara, 1998, pp. 85-91 4] S.  M. Chung and J. Yang  A Parallel Distributive Join Al gorithm for Cube-Connected Multiprocessors  IEEE Trans on Parallel and Disrribured Systems, Vol. 7, No. 2, 1996, pp 127-137 51 M. Snir, S. Otto. S. Huss-Lederman, D. Walker, and J. Don gana, MPI: The Complete Reference, The MIT Press, 1996 


gana, MPI: The Complete Reference, The MIT Press, 1996 6] R. Rymon  Search through Systematic Set Enumeralion   Pmc. of3rd Inr  l Con$ on Principles of Knowledge Repre sentation and Reasoning, 1992, pp. 539-550 507 pre></body></html 


sketch-index in answering aggregate queries. Then Section 5.2 studies the effect of approximating spatiotemporal data, while Section 5.3 presents preliminary results for mining association rules 5.1 Performance of sketch-indexes Due to the lack of real spatio-temporal datasets we generate synthetic data in a way similar to [SJLL00 TPS03] aiming at simulation of air traffic. We first adopt a real spatial dataset [Tiger] that contains 10k 2D points representing locations in the Long Beach county \(the data space is normalized to unit length on each dimension These points serve as the  airbases  At the initial timestamp 0, we generate 100k air planes, such that each plane \(i uniformly generated in [200,300], \(ii, iii destination that are two random different airbases, and iv  the velocity direction is determined by the orientation of the line segment connecting its source and destination airbases move continually according to their velocities. Once a plane reaches its destination, it flies towards another randomly selected also uniform in [0.02, 0.04 reports to its nearest airbase, or specifically, the database consists of tuples in the form &lt;time t, airbase b, plane p passenger # a&gt;, specifying that plane p with a passengers is closest to base b at time t A spatio-temporal count/sum query has two parameters the length qrlen of its query \(square number qtlen of timestamps covered by its interval. The actual extent of the window \(interval uniformly in the data space \(history, i.e., timestamps 0,100 air planes that report to airbases in qr during qt, while a sum query returns the sum of these planes  passengers. A workload consists of 100 queries with the same parameters qrlen and qtlen The disk page size is set to 1k in all cases \(the relatively small page size simulates situations where the database is much more voluminous specialized method for distinct spatio-temporal aggregation, we compare the sketch-index to the following relational approach that can be implemented in a DBMS. Specifically, we index the 4-tuple table lt;t,b,p,a&gt; using a B-tree on the time t column. Given a count query \(with window qr and interval qt SELECT distinct p FROM &lt;t,b,p,a&gt WHERE t?qt &amp; b contained in qr The performance of each method is measured as the average number of page accesses \(per query processing a workload. For the sketch-index, we also report the average \(relative Specifically, let acti and esti be the actual and estimated results of the i-th query in the workload; then the error equals \(1/100 set the number of bits in each sketch to 24, and vary the number of sketches The first experiment evaluates the space consumption Figure 5.1 shows the sketch index size as a function of the number of sketches used \(count- and sum-indexes have the same results more sketches are included, but is usually considerably smaller than the database size \(e.g., for 16 signatures, the size is only 40% the database size 0 20 40 60 80 


80 100 120 140 160 8 16 32 number of sketches size \(mega bytes database size Figure 5.1: Size comparison Next we demonstrate the superiority of the proposed sketch-pruning query algorithm, with respect to the na  ve one that applies only spatio-temporal predicates. Figure 5.2a illustrates the costs of both algorithms for countworkloads with qtlen=10 and various qrlen \(the index used in this case has 16 sketches also illustrate the performance of the relational method which, however, is clearly incomparable \(for qrlen?0.1, it is worse by an order of magnitude we omit this technique Sketch-pruning always outperforms na  ve \(e.g., eventually two times faster for qrlen=0.25 increases with qrlen, since queries returning larger results tend to set bits in the result sketch more quickly, thus enhancing the power of Heuristics 3.1 and 3.2. In Figure 5.2b, we compare the two methods by fixing qrlen to 0.15 and varying qtlen. Similar to the findings of [PTKZ02]4 both algorithms demonstrate  step-wise  growths in their costs, while sketch-pruning is again significantly faster The experiments with sum-workloads lead to the same observations, and therefore we evaluate sketch-indexes using sketch-pruning in the rest of the experiments 4 As explained in [PTKZ02], query processing accesses at most two paths from the root to the leaf level of each B-tree regardless the length of the query interval Proceedings of the 20th International Conference on Data Engineering \(ICDE  04 1063-6382/04 $ 20.00  2004 IEEE sketch-pruning naive relational 0 100 200 300 400 500 600 700 800 900 0.05 0.1 0.15 0.2 0.25 number of disk accesses query rectangle length 300 0 100 200 400 500 600 1 5 10 15 20 number of disk accesses query interval length a qtlen=10 b qrlen=0.15 Figure 5.2: Superiority of sketch-pruning \(count As discussed in Section 2, a large number of sketches reduces the variance in the resulting estimate. To verify this, Figure 5.3a plots the count-workload error of indexes 


using 8-, 16-, and 32- sketches, as a function of qrlen qtlen=10 error \(below 10 it increases slowly with qrlen used, however, the error rate is much higher \(up to 30 and has serious fluctuation, indicating the prediction is not robust. The performance of 16-sketch is in between these two extremes, or specifically, its accuracy is reasonably high \(average error around 15 much less fluctuation than 8-sketch 32-sketch 16-sketch 8-sketch relative error 0 5 10 15 20 25 30 35 0.05 0.1 0.15 0.2 0.25 query rectangle length relative error 0 5 10 15 20 25 30 35 1 5 10 15 20 query interval length a qtlen=10, count b qrlen=0.15, count relative error query rectangle length 0 5 10 15 20 25 0.05 0.1 0.15 0.2 0.25 relative error query interval length 0 5 10 15 20 25 30 1 5 10 15 20 c qtlen=10, sum d qrlen=0.15, sum Figure 5.3: Accuracy of the approximate results The same phenomena are confirmed in Figures 5.3b where we fix qrlen to 0.15 and vary qtlen 5.3d \(results for sum-workloads number of sketches improves the estimation accuracy, it also leads to higher space requirements \(as shown in Figure 5.1 Figures 5.4a and 5.4b show the number of disk accesses for the settings of Figures 5.3a and 5.3b. All indexes have almost the same behavior, while the 32-sketch is clearly more expensive than the other two indexes. The interesting observation is that 8- and 16-sketches have 


interesting observation is that 8- and 16-sketches have almost the same overhead due to the similar heights of their B-trees. Since the diagrams for sum-workloads illustrate \(almost avoid redundancy 32-sketch 16-sketch 8-sketch number of disk accesses query rectangle length 0 50 100 150 200 250 300 350 400 0.05 0.1 0.15 0.2 0.25 number of disk accesses query interval length 0 50 100 150 200 250 300 350 1 5 10 15 20 a qtlen=10 b qrlen=0.15 Figure 5.4: Costs of indexes with various signatures Summary: The sketch index constitutes an effective method for approximate spatio-temporal \(distinct aggregate processing. Particularly, the best tradeoff between space, query time, and estimation accuracy obtained by 16 sketches, which leads to size around 40 the database, fast response time \(an order of magnitude faster than the relational method average relative error 5.2 Approximating spatio-temporal data We proceed to study the efficiency of using sketches to approximate spatio-temporal data \(proposed in Section 4.1 as in the last section, except that at each timestamp all airplanes report their locations to a central server \(instead of their respective nearest bases maintains a table in the form &lt;time t, plane p, x, y&gt;, where x,y with parameters qrlen and qtlen distinct planes satisfying the spatial and temporal conditions. For comparison, we index the table using a 3D R*-tree on the columns time, x, and y. Given a query, this tree facilitates the retrieval of all qualifying tuples, after which a post-processing step is performed to obtain the Proceedings of the 20th International Conference on Data Engineering \(ICDE  04 1063-6382/04 $ 20.00  2004 IEEE number of distinct planes \(in the sequel, we refer to this method as 3DR method introduces a regular res  res grid of the data space, where the resolution res is a parameter. We adopt 16 sketches because, as mentioned earlier, this number gives the best overall performance Figure 5.5 compares the sizes of the resulting sketch indexes \(obtained with resolutions res=25, 50, 100 the database size. In all cases, we achieve high compression rate \(e.g., the rate is 25% for res=25 evaluate the query efficiency, we first set the resolution to the median value 50, and use the sketch index to answer workloads with various qrlen \(qtlen=10 


workloads with various qrlen \(qtlen=10 size \(mega bytes database size 0 20 40 60 80 100 120 140 160 25 50 100 resolution Figure 5.5: Size reduction Figure 5.6a shows the query costs \(together with the error in each case method. The sketch index is faster than 3DR by an order of magnitude \(note that the vertical axis is in logarithmic scale around 15% error observations using workloads with different qtlen Finally, we examine the effect of resolution res using a workload with qrlen=0.15 and qtlen=10. As shown in Figure 5.6c, larger res incurs higher query overhead, but improves the estimation accuracy Summary: The proposed sketch method can be used to efficiently approximate spatio-temporal data for aggregate processing. It consumes significantly smaller space, and answers a query almost in real-time with low error 3D Rsketch number of disk accesses query rectangle length 1 10 100 1k 10k 0.05 0.1 0.15 0.2 0.25 16 14% 15 15% 13 relative error number of disk accesses query interval length 1 10 100 1k 10k 1 5 10 15 20 16 15% 15% 12% 11 relative error a qtlen=10, res=25 b qrlen=0.15, res=25 0 500 1000 1500 2000 2500 25 50 100 number of disk accesses resolution 20% 15% 14 relative error c qrlen=0.15, qtlen=10 


c qrlen=0.15, qtlen=10 Figure 5.6: Query efficiency \(costs and error 5.3 Mining association rules To evaluate the proposed algorithm for mining spatiotemporal association rules, we first artificially formulate 1000 association rules in the form \(r1,T,90 with 90% confidence i randomly picked from 10k ones, \(ii in at most one rule, and \(iii Then, at each of the following 100 timestamps, we assign 100k objects to the 10k regions following these rules. We execute our algorithms \(using 16 sketches these rules, and measure \(i  correct  rules divided by the total number of discovered rules, and \(ii successfully mined Figures 5.7a and 5.7b illustrate the precision and recall as a function of T respectively. Our algorithm has good precision \(close to 90 majority of the rules discovered are correct. The recall however, is relatively low for short T, but gradually increases \(90% for T=25 evaluated in the previous sections, the estimation error decreases as the query result becomes larger \(i.e., the case for higher T 78 80 82 84 86 88 90 92 94 96 5 10 2015 25 precision HT 78 80 82 84 86 88 90 92 94 96 5 10 2015 25 recall HT a b Figure 5.7: Efficiency of the mining algorithm Summary: The preliminary results justify the usefulness of our mining algorithm, whose efficiency improves as T increases Proceedings of the 20th International Conference on Data Engineering \(ICDE  04 1063-6382/04 $ 20.00  2004 IEEE 6. Conclusions While efficient aggregation is the objective of most spatio-temporal applications in practice, the existing solutions either incur prohibitive space consumption and query time, or are not able to return useful aggregate results due to the distinct counting problem. In this paper we propose the sketch index that integrates traditional approximate counting techniques with spatio-temporal indexes. Sketch indexes use a highly optimized query algorithm resulting in both smaller database size and faster query time. Our experiments show that while a sketch index consumes only a fraction of the space required for a conventional database, it can process 


required for a conventional database, it can process queries an order of magnitude faster with average relative error less than 15 While we chose to use FM sketches, our methodology can leverage any sketches allowing union operations Comparing the efficiency of different sketches constitutes a direction for future work, as well as further investigation of more sophisticated algorithms for mining association rules. For example, heuristics similar to those used for searching sketch indexes may be applied to improve the brute-force implementation ACKNOWLEDGEMENTS Yufei Tao and Dimitris Papadias were supported by grant HKUST 6197/02E from Hong Kong RGC. George Kollios, Jeffrey Considine and were Feifei Li supported by NSF CAREER IIS-0133825 and NSF IIS-0308213 grants References BKSS90] Beckmann, N., Kriegel, H., Schneider, R Seeger, B. The R*-tree: An Efficient and Robust Access Method for Points and Rectangles. SIGMOD, 1990 CDD+01] Chaudhuri, S., Das, G., Datar, M., Motwani R., Narasayya, V. Overcoming Limitations of Sampling for Aggregation Queries. ICDE 2001 CLKB04] Jeffrey Considine, Feifei Li, George Kollios John Byers. Approximate aggregation techniques for sensor databases. ICDE, 2004 CR94] Chen, C., Roussopoulos, N. Adaptive Selectivity Estimation Using Query Feedback. SIGMOD, 1994 FM85] Flajolet, P., Martin, G. Probabilistic Counting Algorithms for Data Base Applications JCSS, 32\(2 G84] Guttman, A. R-Trees: A Dynamic Index Structure for Spatial Searching. SIGMOD 1984 GAA03] Govindarajan, S., Agarwal, P., Arge, L. CRBTree: An Efficient Indexing Scheme for Range Aggregate Queries. ICDT, 2003 GGR03] Ganguly, S., Garofalakis, M., Rastogi, R Processing Set Expressions Over Continuous Update Streams. SIGMOD, 2003 HHW97] Hellerstein, J., Haas, P., Wang, H. Online Aggregation. SIGMOD, 1997 JL99] Jurgens, M., Lenz, H. PISA: Performance Models for Index Structures with and without Aggregated Data. SSDBM, 1999 LM01] Lazaridis, I., Mehrotra, S. Progressive Approximate Aggregate Queries with a Multi-Resolution Tree Structure. SIGMOD 2001 PGF02] Palmer, C., Gibbons, P., Faloutsos, C. ANF A Fast and Scalable Tool for Data Mining in Massive Graphs. SIGKDD, 2002 PKZT01] Papadias,  D., Kalnis, P.,  Zhang, J., Tao, Y Efficient OLAP Operations in Spatial Data Warehouses. SSTD, 2001 PTKZ02] Papadias, D., Tao, Y., Kalnis, P., Zhang, J Indexing Spatio-Temporal Data Warehouses ICDE, 2002 SJLL00] Saltenis, S., Jensen, C., Leutenegger, S Lopez, M.A. Indexing the Positions of Continuously Moving Objects. SIGMOD 2000 SRF87] Sellis, T., Roussopoulos, N., Faloutsos, C The R+-tree: A Dynamic Index for MultiDimensional Objects. VLDB, 1987 TGIK02] Thaper, N., Guha, S., Indyk, P., Koudas, N Dynamic Multidimensional Histograms 


SIGMOD, 2002 Tiger] www.census.gov/geo/www/tiger TPS03] Tao, Y., Papadias, D., Sun, J. The TPR*Tree: An Optimized Spatio-Temporal Access Method for Predictive Queries. VLDB, 2003 TPZ02] Tao, Y., Papadias, D., Zhang, J. Aggregate Processing of Planar Points. EDBT, 2002 TSP03] Tao, Y., Sun, J., Papadias, D. Analysis of Predictive Spatio-Temporal Queries. TODS 28\(4 ZMT+01] Zhang, D., Markowetz, A., Tsotras, V Gunopulos, D., Seeger, B. Efficient Computation of Temporal Aggregates with Range Predicates. PODS, 2001 ZTG02] Zhang, D., Tsotras, V., Gunopulos, D Efficient Aggregation over Objects with Extent PODS, 2002 Proceedings of the 20th International Conference on Data Engineering \(ICDE  04 1063-6382/04 $ 20.00  2004 IEEE pre></body></html 


