Mining Sequential Patterns Using Graph Search Techniques  Yin-Fu Huang and Shao-Yuan Lin Institute of Electronic and Information Engineering National Yunlin University of Science and Technology huangyf@el.yuntech.edu.tw  This work was supported by National Science Council of R.O.C. under Grant NSC91-2213-E-224-017 Absrtact Sequential patterns discovery has emerged as an important problem in data mi ning. In this paper, we propose an effective GST al gorithm for mining sequential 
patterns in a large transaction database. Different from the Apriori-like algorithms, the GST algorithm can out of order find large k-sequences \(k >= 3\; i.e., we can find large k-sequences not directly through large k-1\-sequences. This leads to that our algorithm has much better performance than the Apriori-like algorithms so propose the method to find new sequential patterns by scanning only new transactions since the database was increased. Through several comprehensive experiments, the GST algorithm gains a 
significant performance imp rovement over the Apriori-like algorithms. Also we found as lo ng as the ratio of the items purchased in new transactions is not close to 100 scanning only new transactions is always much better than scanning the entire database 1. Introduction Recently data mining has been recognized as a new area and been growing at a rapid pace. It extracts desirable knowledge with useful patterns for some purposes from the existing large databases. Due to the rapid growth in the size and number of databases, the new 
techniques of data mining is urgently requested and developed in the recent years. Data mining is a very applicationdependent issue and different applications might require di fferent mining techniques to deal with. Especially, data mining has high applicability in retail organizations that collect and store mass amounts of sales data Analysis of mass amounts of sales data can provide very valuable information on customer purchasing behaviors with which we can improve the qua lity of business decisions, such as catalog design, store layout customer segmentation, cross 
marketing strategies across products, effectiveness of promotional campaigns, she d light on more effective management of workgroup communication and organization infrastructure, and so on Many kinds of knowledge could be mined from a database such as association rules [1, 5, 6 8, 10 2, 3, 7, 11 and et al T h e association rules show that attribute-value conditions occur fre quently together in a given set of data. For example, when customers purchase some items how will they tend to purchase some other items too? The sequential patterns proposed by R. Agrawal and R. Srikant [2 
are another useful knowledge that refer to frequently occurring patterns related to time or ot her sequences. For example, a customer who bought the book \215The basic C language\216 six months ago is likely to buy the book \215The reference dictionary of C language\216 next month. Thus the major difference between association rules and sequential patterns is the temporal relationship; i.e., temporal re lationships do not exist in association rules, but exist in seque ntial patterns. In this paper we will focus on how to find sequential patterns Most of the previous researches such as AprioriAll and AprioriSom thm 1 1 fuzz y algorithm 7  
and the algorithm mining path traversal patterns [3], adopted an Apriori-like method to find sequential patterns. However it is very costly to generate candidate sets since it tediously and repeatedly scans the database. Ma ny discussions have shown that the bottleneck of the Apriori-like method is the generation of candidate sets and the scan of th e database. Rather than generating a huge set of can didates and re-scanning the database, must improve the performance of mining sequential patterns, we propose a novel algorithm using graph search techniques \(GST\uential patterns. The GST 
algorithm can out of order find large k sequences k 3  k rectly through large  k 1\quences. This leads to that our algorithm has much Proceedings of the 27th Annual International Computer Software and Applications Conference \(COMPSAC\22203 0730-3157/03 $ 17.00 \251 2003 IEEE 


better performance than the Apriori-like algorithm [2, 11 Besides the GST algorithm is very suitable for mining new sequential patterns since the database was increased. We merely process those new trans actions occurring after mining to find out new sequential patterns The remainder of the paper is organized as follows. In Section 2, the mining prob lem for sequential patterns is defined. We propose a GST algorithm using graph search techniques to find seque ntial patterns in Section 3. In Section 4, several experiments are undertaken and the results show the superiority of the GST algorithm over the Apriori-like algorithm. Finally, we make a conclusion in Section 5 2. Problem descriptions The problem of discovering sequential patterns is to find inter-transaction patterns such that the presence of a set of items is followed by another item in the time-stamp ordered transaction set. Let i 1 i 2 i 3 203, i m be an itemset i where an itemset is a non-empty set of items and i k is an item. A sequence s is denoted as s 1 s 2 s 3 203, s n where s is an order list of itemsets and s j is an itemset whose items are purchased by a customer at the same transaction-time. For an item i k it can appear only once in s j but can appear multiple times in s i and s j with different transaction-time. A sequence s is maximal if s is not contained in any other sequence. A sequence a 1 a 2  a 3 203, a n is contained in another sequence b 1 b 2 b 3 203 b m if there exist integers i 1  i 2 203 i n 1 000d i k 000d m such that a 1 000\216 b i1  a 2 000\216 b i2 203 a n 000\216 b in For example, sequence <\(A BC\ contained in sequence <\(A\ \(BC\\(D\ but sequence <\(A\, \(B\, \(C\> is not since B and C must be bought together. Sequence <\(A\\(D\ is also contained in sequence D\ven though there exists an itemset \(BC between \(A\nd \(D\ A sequence with k items is called a k sequence, and it may have three types, such as ordered non-ordered, and hybrid. For example, <\(A\, \(B\ a 2-sequence of ordered, <\(AB a 2-sequence of non-ordered and <\(AB\\(C\> a 3-sequence of hybrid. Besides we do not consider the relative order of th e items in an itemset; we pre-sorted them alphabetically. All the transactions of a customer, ordered by increasing transaction-time, is a customer-sequence. The support count for a customer-sequence is defined as the fraction of total customers who support this sequence. Each sequence satisfying a certain minimum support threshold \(user-specified\ is called a large sequence Given a transaction database D and a minimum support threshold 000H we can define the problem of mining sequential sequences among all the sequences with support count greater than or equal to 000H Each found maximal large sequence represents a sequential pattern In addition, we will consider ti me constraints when finding sequential patterns and this makes th e found sequence patterns more useful. Finally, we also propose the method to find new sequential patterns by scanning only new transactions since the database was increased 1 When time constraints are considered If a sequential pattern is found, but the time in terval of sequential pattern may be so long, for example over one month, the information will be not so useful. Most previous researches did not consider the time interval, so they could fi nd some garbage information Thus in our paper we take care of time constraints when finding the sequential patterns. Time constraints restrict the time interval among a set of transactions for a custom. Given the specified maximal interval, a sequence s  s 1 s 2 203, s n is hold for a customer sequence d  d 1 d 2 203, d m where n 000d m such that a s is the subsequence of d and b\me s i e s i-1  000d max-interval where 1 000\037 i 000d n  For the transaction database sh own in Figure 1, a sequence I\s in customer 1 and customer 4. If max-interval 10 \(days\ given, respectively, then the time interval of the sequence in customer 4 is greater than max-interval, we will prune the sequence from customer 4 Customer ID Transaction Time Items Bought 1 1 1   3/1 C I A, B 2 2 2    A, B C D, F, G 3 3 3    C, G F E 4 4 4 4     C D, F, G I A, B 5 5 5  3/2 3/3 I A B  Figure 1. The transaction database 2 Since the database was increased Since the size of the database can be huge, if we scan the database to find new sequential patterns each time when the database is increased it will be costly. Thus the key issue to improve the performance of finding new sequential pattern s is to just scan the new transactions since last time, in stead of scanning the entire database once more. Doing so, we not only reduce the times to scan the database, but also reduce the size of data required to process Proceedings of the 27th Annual International Computer Software and Applications Conference \(COMPSAC\22203 0730-3157/03 $ 17.00 \251 2003 IEEE 


3. Mining sequential patterns 3.1. The GST algorithm In the section, we propose a novel algorithm using graph search techniques \(GST\o find sequential patterns. At first 2-sequences L 2 nd then employs L 2 to construct the item relation graph \(IRG\. Afterwards, through searching the graph, we can find all other large k sequences  k 3\relation information about items are all in the graph. Different from th e Apriori-like algorithms, it can  k sequences k 3\.e., we can find large k sequences not directly through large k 1\quences This leads to that our algorithm has much better performance than the Apriori-like algorithms. The GST al gorithm has four phases to mine the sequential patterns as follows 1 Scan the database to produce large 1-sequences  L 1  First we scan the database to construct table C 1 that will be also used in the postprocess inng discussed in Section 3.2 The only one scan throughout the database in our algorithm is executed here. For each 1-sequence in table C 1 calculate its support count. If its support count is greater than or equal to the minimum suppo rt, we insert it into L 1 otherwise discard it. The associated structure of C 1 and L 1 is shown in Figure 2 Item CID Time  Figure 2. The structure of C 1 and  L 1 2 Join L 1 with itself to produce large 2-sequences  L 2  Then we join L 1 with itself by CID and Time to produce L 2  The join performed here can be classified into two types. The first type is denoted as \(AB ch that item A and B are purchased by the same CID at the same Time. The second type B\such that item A and B are purchased by the same CID, but item A occurs before item B. For example if we have three large 1-sequences A, B, and C, after the join C  B\s shown in Figure 3. Then calculate their su pport counts and discard the sequences with the sup port counts less th an the minimum support. The associated structure of L 2 is shown in Figure 4 In this phase, we also check time constraints that prune the sequences with long time interval. The proce dure in term of SQL statements can be specified as follows INSERT INTO L 2 SELECT p Item q Item p CID p Time q Time FROM L 1 p, L 1 q WHERE p CID q CID AND p Time q Time AND p Item q Item UNION SELECT p Item q Item p CID p Time q Time FROM L 1 p, L 1 q WHERE p CID q CID AND p Time q Time AND q Time \205 p Time 000d max-interval Next, discard all 2-sequences w ith the support counts less than the minimum support. The corresponding SQL is specified as follows DELETE * FROM L 2 WHERE Sequence NOT IN SELECT Sequence FROM L 2 GROUP BY Sequence HAVING COUNT 000t the minimum support A B C B AB AC C BC B\\(C B\\(A A B Figure 3. Join results Sequence CID STime ETime Figure 4. The structure of L 2 3 Construct an IRG \(Item Relation Graph Next, we use table L 2 to construct an IRG as follows. The nodes in an IRG are the items appearing in the 2-sequence in table L 2 The two different edge types in an IRG represent different relationships between the items. If a 2-sequence is equal to B\ we draw the directional edge from A to B, such as A 001 B. If a 2-sequence is equal to <\(AB\draw the dotted edge between A and B, such as A-\000 B. Besides, an edge is labeled with a group of associating \(CID, STime, ETime\s An IRG example and the structure of an IRG edge are shown in Figure 5 and Figure 6, re spectively. The procedure to construct an IRG is described as follows where two functions can be applied to the 2-sequences in table L 2 i.e Tail\(Sequence\returns the last item appearing in the Sequence and Type\(Sequence\dge type For each distinct large 2-sequence l 2 000\217 L 2 Create a new edge e for l 2 such that e To_vertex = Tail l 2 Sequence e Edge_type = Type l 2 Sequence\nd e CID, STime, ETime\'s  l 2 CID l 2 STime l 2 ETime\s A B C Proceedings of the 27th Annual International Computer Software and Applications Conference \(COMPSAC\22203 0730-3157/03 $ 17.00 \251 2003 IEEE 


 Figure 5. An IRG with \(AB\, \(A\\(C\, and \(B\\(C To_vertex Edge_type \(CID, STime, ETime\s Figure 6. The structure of an IRG edge 4 Search the IRG to produce the large sequences and sequential patterns For each vertex in the IRG, we search sequences rooted from it, and then find the maximal large sequences. When going forward, we check the concatenation cond itions of neighboring edges as well. In other words, following an edge e to the next edge w we compare their CIDs, STime, and ETime. If e CID is equal to w CID e ETime is equal to w STime, and the support count 000t the minimum support, then we go forward; otherwise, go back. Thus, each path is a large n-sequence if n vertices are successfully visited. The procedure to search the IRG is described as follows 1. LS 000\207 initialize the set of large sequences and one working stack LS_Stack 000\207  2. For each vertex v in the IRG Push v to LS_Stack Search_Sequence v  000\207  3 Find the maximal large sequences from LS Search_Sequence v result  ever_output: local va riable indicating whether a distinct path ending at v is got ever_output = no For each outgoing edge e from v If \(result 000\207  result e CID, STime, ETime\s else result = { \(cid, stime, etime cid=result.CID e CID 000\232 stime=result.STime 000\232 result.ETime e Stime 000\232 etime e ETime If \(count\(result 000t the minimum support Push e To_vertex to LS_Stack ever_output = yes Search_Sequence e To_vertex, result else If \(ever_output = no ever_output = yes Copy the path in LS_Stack to LS If \(ever_output = no Copy the path in LS_Stack to LS Pop one vertex from LS_Stack  3.2. Postprocessing since the database was increased If the database is increased after mining, we do not need to re-scan the database to find all the sequential patterns. We merely process those new trans actions occurring after mining to find out new sequential patterns. The procedure works as follows 1 Insert all new transactions into C 1  2 For each item i purchased by new transactions If its support count 000t the minimum support Search all the customers who ever purchased i from C 1 and then insert the transactions made by those customers into another partial table C 1  3 For each item i in the partial table C 1 If its support count 000\037 the minimum support prune i to get the partial table L 1  4 Do the same procedure from phase 2 to phase 4 4. Performance evaluations 4.1. Simulation model To evaluate the performance of the GST algorithm, we undertake several experiments on a PC with AMD Athlon 750MHz, 128M PC-133 SDRAM, 40G IBM HD \(Ultra 100 to compare the GST algorithm with the Apriori algorithm and the DSG algorithm. The generati on of the synthetic data in the transaction database is based on a normal distribution; i.e., the purchases made by customers are concentrated on some items In these experiments, we have 1000 items to be purchased by customers, and use the notations C for average number of transactions per customer, T for average number of items per transaction, and D for number of transactions. For example the experiment labeled with C10.T5.D6000 represents the simulation environment with 10 transactions on the average per customer, 5 items on the average per transaction, and 6000 transactions in total 4.2. Experimental results Experiment 1 In the experiment, we explore the execution time of the Apriori algorithm the DSG algorithm, and the GST algorithm under different si mulation environments and minimum supports, as shown in Figure 7. As a result, we found that the GST algorithm always rev eals its superiority over the other two algorithms, regardless of what simulation environment. The inefficiency of the Apriori algorithm is resulted from generating candidate itemsets and checking whether they are really large itemsets each pass, especially when there are a huge amount of candidate 2-itemsets generated in the second pass. Although the DSG algorithm like the Apriori algorithm, generates large itemsets step-by-step, it uses the as sociation graph to find large sequences directly, instead of generating candidate sequences Thus the DSG algorithm outperfo rms the Apriori algorithm Proceedings of the 27th Annual International Computer Software and Applications Conference \(COMPSAC\22203 0730-3157/03 $ 17.00 \251 2003 IEEE 


Besides we observed that the GST algorithm is less sensitive to the variance of the minimum support under the environments of more data, such as C10.T10.D6000 and C10.T5.D6000. Finally, we also found that the curves of all three algorithms become smooth for the lower minimum support under the environments of less data, such as C10.T2.D6000 and C5.T5.D6000. The reason is that the number of generated candidate sequences is always not beyond some threshold  0 2000 4000 6000 8000 15 12.5 0 5 5 minimum support ex ecu t i o n t i m e   s ec o n d  Apriori DSG GST Figure 7.\(a\ The environment C10.T10.D6000 0 1000 2000 3000 4000 5000 6000 15 12.5 10 7.5 5 minimum support ex ec u t i o n t i m e  s e c o n d  Apriori DSG GST Figure 7.\(b\ The environment C10.T5.D6000 0 200 400 600 800 1000 1200 1400 1600 1800 15 12.5 0 7.5 5 minimum support execution time \(second Apriori DSG GST Figure 7.\(c\ The environment C10.T2.D6000 0 500 1000 1500 2000 15 12.5 10 7.5 5 minimum support ex ecu t i o n t i m e   s e c o n d  Apriori DSG GST Figure 7.\(d\ The environment C5.T5.D6000 Experiment 2 In the experiment, we explore the scalability of the GST algorithm under different simulation environments as shown in Figure 8. Here the number of transactions is varied from 60000 to 350000 and the minimum support = 10%. When the number of transactions \(or the average number of items per transaction\reases, the execution time increases as well 0 100 200 300 400 500 600 700 6 0000 100000 125000 250000 350000 number of transactions execution time \(minute C 10.T 5 C 10.T 2 C5.T5 Figure 8. The scalability of the GST algorithm Experiment 3 In the experiment, we explore the execution time of the same GST algorithm under different scanning methods since the database was increased, as shown in Figure 9; i.e., scanning only new transactions and the entire database Here the experiment is under the environment C10.T5.D6000 and the minimum support = 5%. As shown in Figure 9.\(a\, the rates of the items purchased in the new transactions \(i.e., total items purchased in the new tran sactions over total items ever purchased in the original datab ase\re varied with 0%, 20 40%, 60%, 80%, and 100%. Here we found as long as the ratio is not close to 100%, scanning only new transactions is always much better than scanning the entire database. Besides, as shown in Figure 9.\(b\e rate of the items purchased in the new transactions is fixed at 50% and the growth rates of the transactions are varied with 25%, 50%, 75%, and 100%. We found that scanning only new transactions is still better than scanning the entire database Proceedings of the 27th Annual International Computer Software and Applications Conference \(COMPSAC\22203 0730-3157/03 $ 17.00 \251 2003 IEEE 


 0 200 400 600 800 0 20 40 0 80 100 s of purchased items execution time \(second the entire database new transactions Figure 9.\(a\ Postprocessing with the rates of purchased items 0 500 1000 1500 25 50 75 100 growth rates of transactions e x e c ut i on t i m e  s e c ond  e entire database sactions Figure 9.\(b\ Postprocessing with the growth rates of transactions 5. Conclusions and future works In the paper, we propose the GST algorithm to find sequential patterns from a transaction database. Through the experiments, we find that the GST algorithm is superior to the Apriori-like algorithms. The advantage of the GST algorithm over the Apriori-like algorithms is th at it can 1\generate large sequences without constructing candidate sequences and 2 generate large k sequences without following from large  k-1 quences step-by-step. Besides, we consider time constraints as well when finding sequential patterns, and this makes the found sequence patterns more useful. Finally, we also propose the method to fi nd new sequential patterns by scanning only new transactions since the database was increased, and compare it with the rough method of scanning the entire database In the GST algorithm, we search the IRG to find the large sequences rooted from each node. Since some redundant paths might be generated, the GST algorithm can be tried to avoid the sub-path generation when a path is found. Besides, in the future, we shall extend our algorithm to Web usage mining to mine the Web access logs [4 ich can b e  u s ed t o  pred ict user visit patterns and then help in targeting the advertisements at groups of users based on these patterns 6. References  R Agrawal and R. Srik ant, \215Fast algorithms f o r mining association rules,\216 Proc. 20 th International Conference on Very Large Data Bases, 1994, pp. 487-499  R. Agr a wal and  R. Srik ant, \215Mining sequen tial patterns,\216 Proc 11 th International Conference on Data Engineering, 1995, pp. 3-14  Ming-S y a n Chen Jong-Soo Park  and P  S Y u 215Ef f icien t d a ta  mining for path traversal patterns,\216 IEEE Transactions on Knowledge and Data Engineering, Vol. 10, No. 2, 1998, pp. 209-221  R. Cooley B  Mo basher and J  Srivastava, \215Grouping web p a ge references into transactions for mining world wide web browsing patterns,\216 Proc. IEEE Knowledge and Data Engineering Exchange Workshop, 1997, pp. 2-9  Jian-lin Feng and Y u cai Feng 215Binar y  par tition based  algorithms for mining association rules,\216 Proc. IEEE Forum on Research and Technology Advances in Digital Libraries, 1998, pp 30-34  Jia-W ei H a n, Ji an Pei and Y i W en Y i n, \215Mining frequen t  patterns without candidate generation,\216 Proc. ACM International Conference on Management of Data, 2000, pp. 1-12  Tzung-pei Hon g, Chan-Sheng  Kuo, and Shen g-chai Chi 215Mining fuzzy sequential patterns from quantitative data,\216 Proc IEEE International Conference on System, Man, and Cybernetics 1999, pp. 962-966  J. S. Park, M  S. C h en and P  S. Y u  215Using a hash-based method with transaction trimming for mining association rules,\216 IEEE ansactions on Knowledge and Data Engineering, Vol. 9, No. 5 1997, pp. 813-825  R Srik a nt and Y  Y a ng 215Mining web logs to improve website organization,\216 Proc. ACM World Wide Web 10, 2001, pp. 430-437  Suh-Y ing W ur and Y ung-ho Leus, \215An ef fective boo lean algorithm for mining association rules in large databases,\216 Proc. 6 th IEEE International Conference on Database Systems for Advanced Applications, 1999, pp. 179-186  Show-Jane Y e n and Arbee L. P  C h en, \215An ef fici en t approac h  for discovering knowledge from large databases,\216 Proc. 4 th IEEE International Conference on Parallel and Distributed Information Systems, 1996, pp. 8-18  M. J Zaki, \215Scalable algor ithm s for association m i n ing,\216 IEEE Transactions on Knowledge and Data Engineering, Vol. 12, No 3 2000, pp. 372-390 Proceedings of the 27th Annual International Computer Software and Applications Conference \(COMPSAC\22203 0730-3157/03 $ 17.00 \251 2003 IEEE 


pro cedure optConfNaiv e\(curSet curLo c 1 for i  curLo c to n do f 2 S  curSet f instArra y[i g 3 if sup S 025 minSup and conf S  conf optSet 4 optSet  S 5 if numI nst S k 6 optConfNaiv e\(S i 1 7 g Figure 1 Naiv e Alg for Optimized Con\014dence Set 4.2 Naiv e Algorithm Optimized Con\014dence Set W e b egin b y presen ting a naiv e algorithm for determining the optimized con\014dence set of instan tiations see Figure 1 In a n utshell the algorithm emplo ys depth 014rst se ar ch to en umerate all p ossible sets con taining k or less instantiations and returns the set with the maxim um con\014dence and supp ort at least mi nSup  The algorithm assumes that instan tiations are stored in the arra y instArra y  The n um b er of instantiations is n  n 1 003 n 2 003 001\001\001\003 n m  where n i is the n umber of v alues in the domain of A i  The algorithm is initially in v ok ed with argumen ts curSet   and curLo c=1 The v ariable optSet is used to k eep trac k of the optimized set of instan tiations encoun tered during the execution of the algorithm The algorithm en umerates all p ossible subsets of size k or less b y recursiv ely in v oking itself Step 6 and sets optSet to a set with a greater con\014dence than the curren t optimized set steps 3 and 4 Eac hin v o cation accepts as input curSet the set of instan tiations to b e further extended and curLo c the index of the 014rst instan tiation in instArra ytobe considered for extending curSet all instan tiations b et w een curLo c and n are considered The extended state is stored in S and if the n um b er of instan tiations in S is less than k  the algorithm calls itself recursiv ely to further extend S with instan tiations whose index is greater than the index of all the instan tiations in S The complexit y of the naiv e algorithm is 006 k i 1 nC i  When k 034 n  the complexit y of the algorithm b ecomes O  n k  Ho w ev er as w e sho w ed earlier if there is no restriction on the size of the optimized set that is k  n  the problem is NP-hard Optimized Supp ort Set The naiv e algorithm for computing the optimized supp ort set is similar to optConfNaiv e except that the condition in Step 3 whic h tries to maxim ize con\014dence is replaced with the follo wing condition if conf S 025 minCo nf and sup S  sup optSet 4.3 Pruning Using the Curren t Optimized Set The naiv e algorithm exhaustiv ely en umerates all p ossible sets with at most k instan tiations  this results in high complexit y Ho w ev er in the naiv e algorithm illustrated in Figure 1 if w e kno w that the con\014dence of an y set satisfying minim um supp ort and obtained as a result of extending curSet cannot exceed the con\014dence of the curren t optimized set that is optSet then w e can stop extending curSet immedia tely and reduce the searc h space signi\014can tly  In this section w e dev elop br anch and b ound pruning tec hniques that with the aid of the curren t optimized set considerably reduce the o v erhead of exploring the en tire searc h space F or our pruning tec hniques to b e e\013ectiv e it is imp erativ e that w e 014nd a set close to the optimized set early  since it can then b e used to eliminate a larger n um b er of sub-optimal sets It ma y seem logical that for the optimized con\014dence problem since w e are trying to maxim ize con\014dence considering instan tiations with high con\014dences 014rst ma y cause the searc h to conv erge on the optimized set more rapidly Ho w ev er this ma y not b e the case since the supp ort of the optimized con\014dence set has to b e at least minSup F or a high minim um supp ort it ma y b e b etter to explore instan tiations in the decreasing order of their supp orts Th us the order in whic h instan tiations m ust b e considered b y the searc h algorithm is a non-trivial problem In order to in v estigate this idea of pruning curSet early w e in tro duce the notion of the w eigh t of an instan tiation I denoted b y w  I  and de\014ne it b elo w w  I  w 1 003 conf  I  w 2 003 sup  I  In the de\014nition w 1 and w 2 are p ositiv e real constan ts Th us the w eigh t of an instan tiation is the w eigh ted sum of b oth its con\014dence and supp ort Our searc h algorithms can then consider instan tiations with higher w eigh ts 014rst and b y using di\013eren tv alues of w 1 and w 2 v ary the strategy for en umerating sets In the remainder of this section w e prop ose algorithms that store instan tiations in instArra y in the decreasing order of their w eigh ts and explore instan tiations with higher w eigh ts 014rst W e also presen t tec hniques that exploit the sort order of instan tiations to prune the searc h space The v ariables maxC onf and maxSup are used to store the maxim um con\014dence and maxim um supp ort of all the instan tiations in instArra y  resp ectiv ely  Optimized Con\014dence Set Supp ose the curren t set of instan tiations curSet is only extended with instan tiations b elonging to the set comprising of instArra y i  for some i  and instan tiations follo wing it in instArra y  The k ey idea is that w e can stop extending curSet if among instan tiations b eing considered to extend curSet there do es not exist a set of instan tiations S suc h that 1 sup curSet  S  025 minSup  and 2 conf curSet  S  025 conf optSet In order to determine whether a set S satisfying the ab o v e conditions 1 and 2 exists w e 014rst deriv e the constrain ts that suc h a set S m ust satisfy If the constrain ts are unsatis\014able with the remaining instan tiations that are candidates for extension a set S satisfying the conditions 1 and 2 do es not exist and w e can stop extending curSet immediately  Let v ariables s and c denote sup  S  and conf  S  resp ectiv ely  and l  k 000 numI nst curSet In the follo wing w e deriv e the constrain ts on s that m ust b e satis\014ed b yan y 


A tomic conditions can b e com bined using op erators  or _ to yield more complex conditions Instan tiated asso ciation rules that w e study in this pap er ha v e the form C 1  C 2  where C 1 and C 2 are arbitrary instan tiated conditions Let the supp ort for an instan tiated condition C  denoted b y sup  C  b e the ratio of the n um b er of tuples satisfying the condition C and the total n um b er of tuples in the relation Then for the asso ciation rule R  C 1  C 2  sup  R  is de\014ned as sup  C 1  and conf  R  is de\014ned as sup  C 1  C 2  sup  C 1   Note that our de\014nition of sup  R  is di\013eren t from the de\014nition in 1  where sup  R  as de\014ned to b e sup  C 1  C 2  Instead w eha v e adopted the de\014nition used in 5  and 4 Also let minSup and minConf denote the user-sp eci\014ed minim um supp ort and minim um con\014dence resp ectiv ely  The optimized asso ciation rule problem requires optimal instan tiations to b e computed for an uninstan tiated asso ciation rule whic h has the form U  C 1  C 2  where U is a conjunction of m uninstan tiated atomic conditions o v er m distinct attributes and C 1 and C 2 are arbitrary instan tiated conditions Let U i denote an instantiation of U th us U i is obtained b y replacing v ariables in U with v alues An instan tiation U i can b e mapp ed to a rectangle in m dimensional space  there is a dimension for eac h attribute and the co-ordinates for the rectangle in a dimension are iden tical to the v alues for the corresp onding attribute in U i Tw o instan tiations U 1 and U 2 are said to b e non-overlapping if the t w o m dimensional rectangles de\014ned b y them do not o v erlap that is the in tersection of the t w o rectangles is empt y Ha ving de\014ned the ab o v e notation for asso ciation rules w e presen t b elo w the form ulations of the optimized asso ciation rule problems 017 Optimized Con\014dence Problem Giv en k and an uninstan tiated rule U  C 1  C 2  determine non-o v erlapping instan tiations U 1 U l of U with l 024 k suc h that sup  R  025 minSup and conf  R  is maximi zed  where R is the rule  U 1 _ 001\001\001 _ U l   C 1  C 2  017 Optimized Supp ort Problem Giv en k and an uninstan tiated rule U  C 1  C 2  determine non-o v erlapping instan tiations U 1 U l of U with l 024 k suc h that conf  R  025 minConf and sup  R  is maxim ized  where R is the rule  U 1 _ 001\001\001 _ U l   C 1  C 2  The problem of computing optimized asso ciation rules required instan tiations U 1 U l to b e determined suc h that the rule R  U 1 _\001\001\001_ U l   C 1  C 2 satis\014es user-sp eci\014ed constrain ts Supp ose for an instan tiation U i of U  I i is the instan tiated rule U i  C 1  C 2  and for a set S  f I 1 I j g of instan tiated rules sup  S  and conf  S  are de\014ned as follo ws sup  S   sup  I 1  001\001\001  sup  I j  conf  S   sup  I 1  001 conf  I 1  001\001\001  sup  I j  001 conf  I j  sup  I 1  001\001\001  sup  I j  Then w eha v e sup  S  sup  R  and conf  S  conf  R  Th us since 1 for ev ery instan tiated rule or alternativ ely  instan tiation I i  sup  I i  and conf  I i  can b e computed b y p erforming a single pass o v er the relation and 2 these in turn can b e used to compute supp orts and con\014dences for sets of instan tiations the optimized asso ciation rule problem reduces to the follo wing 017 Optimized Con\014dence Problem Giv en k  and sup  I i  and conf  I i  for ev ery instantiation I i  determine a set S con taining at most k non-o v erlapping instan tiations suc h that sup  S  025 minSup and conf  S  is maxim ized 017 Optimized Supp ort Problem Giv en k  and sup  I i  and conf  I i  for ev ery instan tiation I i  determine a set S con taining at most k nono v erlapping instan tiations suc h that conf  S  025 minConf and sup  S  is maximi zed In the remainder of the pap er w e use the ab o v e form ulations instead to dev elop algorithms for the optimized asso ciation rule problems 4 Categorical A ttributes In this section w e presen t algorithms for computing optimized supp ort and con\014dence sets when rules con tain only uninstan tiated conditions of the form A i  v  Th us the results of this section are only applicable to categorical attributes and n umeric attributes restricted to A i  v 1 conditions of the form A i 2  l i u i  where A i is a n umeric attribute are dealt with in the next section An example of suc h a rule is  date  v   src cit y  NY  dst country  F rance in the rule date isan umeric attribute while src cit y is categorical Due to the ab o v e restriction an yt w o arbitrary instan tiations are alw a ys non-o v erlapping This prop ert y is essen tial for the correctness of the pruning tec hnique used b y the graph searc h algorithm presen ted in Section 4.4 4.1 NP-Hardness Result The problem of computing optimized sets giv en sup  I i  and conf  I i  for ev ery instan tiation I i  can b e sho wn to b e in tractable and follo ws from the follo wing theorem Theorem 4.1  Given sup  I i  and conf  I i  for every instantiation I i  determining if ther eisa set S c ontaining an arbitr ary numb er of instantiations such that conf  S  025 mi nConf and sup  S  025 minSup is NP-har d In the follo wing subsections w e presen tsc hemes for computing optimized sets that emplo y tec hniques for pruning the searc h space in order to o v ercome the complexit y of the problem In eac h subsection w e 014rst presen t the sc heme for computing optimized con\014dence sets and then brie\015y describ e the mo di\014cations to the sc heme in order to compute optimized supp ort sets 1 Note that if the domain of the n umeric attribute A i is large then it can b e partitioned in to a sequence of n i in terv als and successiv ein terv als can b e mapp ed to consecutiv ein tegers in the in terv al b et w een 1 and n i  


a minim um supp ort of 0.03 the optimized con\014dence rule results in the p erio d for whic h calls from NY in the p erio d are at least 3 of the total n um b er of calls and the p ercen tage of calls from NY that are directed to F rance is maxim um  With a minim um con\014dence of 0.5 the optimized supp ort rule results in the p erio d during whic h at least 50 of the calls from NY are to F rance  and the n um b er of calls originating in NY is maxim um  A limitatio n of the optimized asso ciation rules dealt with in is that only a single optimal in terv al for a single n umeric attribute can b e determined Ho wev er in a n um b er of applications a single in terv al ma y b e an inadequate description of lo cal trends in the underlying data F or example supp ose the telecom service pro vider is in terested in doing upto k promotions for customers in NY calling F rance F or this purp ose w e need a mec hanism to iden tify upto k p erio ds during whic h a sizable n um b er of calls from NY to F rance are made If asso ciation rules w ere p ermitted to con tain disjunctions of uninstan tiated conditions then w e could determine the optimal k or few er p erio ds b y 014nding optimal instan tiations for the rule  date 2  l 1 u 1  _\001\001\001 _  date 2  l k u k   src cit y  NY  dst country  F rance  The ab o v e framew ork can b e further strengthened b y enric hing asso ciation rules to con tain more than one uninstan tiated attribute and p ermitting attributes to b e b oth n umeric e.g date and duration sw ell as categorical e.g src cit y  dst country  Th us optimal instan tiations for the rule  src cit y  v 1  date 2  l 1 u 1  _ 001\001\001 _  src cit y  v k  date 2  l k u k   dst country  F rance w ould yield v aluable information ab out cities and p erio ds with a fairly high out w ard call v olume a substan tial p ortion of whic h is directed to F rance  Alternately  information ab out cities and sp e ci\014c dates can b e obtained from the rule  src cit y  v 1  date  u 1  _ 001\001\001 _  src cit y  v k  date  u k   dst country  F rance  This information can b e used b y the telecom service pro vider to determine the most suitable geographical regions and dates for o\013ering discoun ts on in ternational long distance calls to F rance  In this pap er w e generalize the optimized asso ciation rules problem describ ed in 5  in three w a ys{1 asso ciation rules are p ermitted to con tain disjunctions o v er uninstan tiated attributes 2 asso ciation rules are allo w ed to con tain an arbitrary n um b er of uninstan tiated attributes and 3 uninstan tiated attributes can b e either categorical or n umeric W e 014rst sho w that the problem of computing optimized supp ort and optimized con\014dence asso ciation rules in our framew ork is NP-hard W e then presen t a general depth 014rst se ar ch algorithm for exploring the searc h space The algorithm searc hes through the space of instan tiated rules in the decreasing order of the w eigh ted sums of their con\014dences and supp orts and uses br anch and b ound tec hniques to prune the searc h space e\013ectiv ely F or categorical attributes w e also presen ta gr aph se ar ch algorithm that in addition uses in termediate results to reduce the searc h Finally  for n umeric attributes w e dev elop tec hniques to eliminate certain instan tiated rules prior to searc hing through them Exp erimental results indicate that our sc hemes p erform w ell for a large n um b er of uninstan tiated attributes disjunctions and v alues in the domain of the uninstan tiated attributes Pro ofs of theorems presen ted in the pap er can b e found in 9  2 Related W ork Asso ciation rules for a set of transactions in whic h eac h transaction is a set of items b ough tb y a customer w ere 014rst studied in 1  These asso ciation rules for sales transaction data ha v e the form X  Y  where X and Y are disjoin t sets of items E\016cien t algorithms for computing them can b e found in 2 7  6 10 11 In 10 6  the generalization of asso ciation rules to m ultiple lev els of taxonomies o v er items is studied Asso ciation rules con taining quantitative and c ate goric al attributes are studied in and 11  The w ork in 8  restricts asso ciation rules to b e of the form A 1  v 1  A 2  v 2 only  They suggest w a ys to extend their framew ork to ha v e a range that is A 1 2  l 1 u 1  rather than a single v alue in the left hand side of a rule T oac hiev e this they partition n umeric attributes in to in terv als Ho w ev er they do not consider merging neigh b oring in terv als to generate a larger in terv al In 11  the authors use a p artial c ompleteness measure in order to determine the partitioning of n umeric attributes in to in terv als The optimized asso ciation rule problem w as in troduced in 5  The authors p ermit asso ciation rules to con tain a single uninstan tiated condition A 1 2  l 1 u 1  on the left hand side and prop ose sc hemes to determine v alues for v ariables l 1 and u 1 suc h that the con\014dence or supp ort of the rule is maximi zed In the authors extend the results in 5  t o the case in whic h rules con tain t w o uninstan tiated n umeric attributes on the left hand side They prop ose algorithms that disco v er optimized gain supp ort and con\014dence asso ciation rules for t w o classes of regions  rectangles and admissible regions for admissible regions the algorithms compute appro ximate not optimized supp ort and con\014dence rules Ho w ev er their sc hemes only compute a single optimal region In con trast our algorithms are general enough to handle more than t w o uninstan tiated attributes whic h could b e either categorical or n umeric F urthermore our algorithms can generate an optimal set of rectangles rather than just a single optimal rectangle note that w e do not consider admissible regions or the notion of gain in this pap er This enables us to 014nd more in teresting patterns 3 Preliminaries In this section w e de\014ne the optimized asso ciation rule problem addressed in the pap er The data is assumed to b e stored in a relation de\014ned o v er categorical and n umeric attributes Asso ciation rules are built from atomic conditions eac h of whic h has the form A i  v i  A i could b e either categorical or n umeric and A i 2  l i u i  only if A i is n umeric F or the atomic condition A i  v i if v i isav alue from the domain of A i  the condition is referred to as instantiate d  else if v i isav ariable w e refer to the condition as uninstantiate d  Lik ewise the condition A i 2  l i u i  s referred to as instan tiated or uninstan tiated dep ending on whether l i and u i are v alues or v ariables 


Mining Optimize d Asso ciation Rules with Categorical and Numeric A ttributes Ra jeev Rastogi Kyuseok Shim Bell Lab oratories Bell Lab oratories Murra y Hill NJ 07974 Murra y Hill NJ 07974 rastogi@researc h.b ell-labs.com shim@researc h.b ell-labs.com Abstract Asso ciation rules ar e useful for determining c orr elations b etwe en attributes of a r elation and have applic ations in marketing 014nancial and r etail se ctors F urthermor e optimized asso ciation rules ar e an e\013e ctive way to fo cus on the most inter esting char acteristics involving c ertain attributes Optimize d asso ciation rules ar ep ermitte dto c ontain uninstantiate d attributes and the pr oblem is to determine instantiations such that either the supp ort or c on\014denc e of the rule is maximize d In this p ap er we gener alize the optimize d asso ciation rules pr oblem in thr e e ways  1 asso ciation rules ar e al lowe dtoc ontain disjunctions over uninstantiate d attributes 2 asso ciation rules ar ep ermitte dtoc ontain an arbitr ary numb er of uninstantiate d attributes and 3 uninstantiate d attributes c an b e either c ate goric al or numeric Our gener alize d asso ciation rules enable us to extr act mor e useful information ab out se asonal and lo c al p atterns involving multiple attributes We pr esent e\013e ctive te chniques for pruning the se ar ch sp ac e when c omputing optimize d asso ciation rules for b oth c ate goric al and numeric attributes Final ly we r ep ort the r esults of our exp eriments that indic ate that our pruning algorithms ar e e\016cient for a lar ge numb er of uninstantiate d attributes disjunctions and values in the domain of the attributes 1 In tro duction Asso ciation rules in tro duced in 1  pro vide a useful mec hanism for disco v ering correlations among the underlying data In its most general form an asso ciation rule can b e view ed as b eing de\014ned o v er attributes of a relation and has the form C 1  C 2  where C 1 and C 2 are conjunctions of conditions and eac h condition is either A i  v i or A i 2  l i u i  v i  l i and u i are v alues from the domain of the attribute A i  Eac h rule has an asso ciated supp ort and c on\014denc e  Let the supp ort of a condition C i b e the ratio of the n um b er of tuples satisfying C i and the n um b er of tuples in the relation The supp ort of a rule of the form C 1  C 2 is then the same as the supp ort of C 1  C 2  while its con\014dence is the ratio of the supp orts of conditions C 1  C 2 and C 1  The asso ciation rules problem is that of computing all asso ciation rules that satisfy user-sp eci\014ed minim um supp ort and minim um con\014dence constrain ts and sc hemes for this can b e found in 1  2 6 10 11  F or example consider a relation in a telecom service pro vider database that con tains call detail information The attributes of the relation are date  time  src cit y  src country  dst cit y  dst country and duration  A single tuple in the relation th us captures information ab out the t w o endp oin ts of eac h call as w ell as the temp oral elemen ts of the call The asso ciation rule  src cit y  NY    dst country  F rance  ould satisfy the user-sp eci\014ed minim um supp ort and minim um con\014dence of 0.05 and 0.3 resp ectiv ely  if at least 5 of total calls are from NY to F rance  and at least 30 of the calls that originated from NY are to F rance  The optimize d asso ciation rules problem motiv ated b y applications in mark eting and adv ertising w as intro duced in 5  An asso ciation rule R has the form  A 1 2  l 1 u 1   C 1  C 2  where A 1 is a n umeric attribute l 1 and u 1 are uninstan tiated v ariables and C 1 and C 2 con tain only instan tiated conditions that is the conditions do not con tain uninstan tiated v ariables The authors prop ose algorithms for determining v alues for the uninstan tiated v ariables l 1 and u 1 for eac h of the follo wing cases 017 Con\014dence of R is maxim ized and supp ort of the condition  A 1 2  l 1 u 1   C 1 is at least the usersp eci\014ed supp ort referred to as the optimize dc on\014denc e rule 017 Supp ort of the condition  A 1 2  l 1 u 1   C 1 is maximi zed and con\014dence of R is at least the usersp eci\014ed con\014dence referred to as the optimize d supp ort rule Optimized asso ciation rules are useful for unra v eling ranges for n umeric attributes where certain trends or correlations are strong that is ha v e high supp ort or con\014dence F or example supp ose the telecom service pro vider men tioned earlier w as in terested in offering a promotion to NY customers who mak e calls to F rance  In this case the timing of the promotion ma y b e critical  for its success it w ould b e adv an tageous to o\013er it close to a p erio d of consecutiv eda ys in whic h at least a certain minim um n um b er of calls from NY are made and the p ercen tage of calls from NY to F rance is maxim um  The framew ork dev elop ed in 5  can b e used to determine suc h p erio ds Consider for example the asso ciation rule  date 2  l 1 u 1   src cit y  NY  dst country  F rance  With 


It can also be added to cell CrossSales.3\(PC, printer one_year,\205 5  Distributed and Incremental Rule Mining There exist two ways to deal with association rules 267  Static that is, to extract a group of rules from a snapshot, or a history, of data and use "as is 267  Dynamic that is, to evolve rules from time to time using newly available data We mine association rules from an e-commerce data warehouse holding transaction data. The data flows in continuously and is processed daily Mining association rules dynamically has the following benefits 267  223Real-time\224 data mining, that is, the rules are drawn from the latest transactions for reflecting the current commercial trends 267  Multilevel knowledge abstraction, which requires summarizing multiple partial results. For example association rules on the month or year basis cannot be concluded from daily mining results. In fact multilevel mining is incremental in nature 267  For scalability, incremental and distributed mining has become a practical choice Figure 3: Distributed rule mining Incremental association rule mining requires combining partial results. It is easy to see that the confidence and support of multiple rules may not be combined directly. This is why we treat them as \223views\224 and only maintain the association cube, the population cube and the base cube that can be updated from each new copy of volume cube. Below, we discuss several cases to show how a GDOS can mine association rules by incorporating the partial results computed at LDOSs 267  The first case is to sum up volume-cubes generated at multiple LDOSs. Let C v,i be the volume-cube generated at LDOS i The volume-cube generated at the GDOS by combining the volume-cubes fed from these LDOSs is 345   n i i v v C C 1  The association rules are then generated at the GDOS from the centralized C v  214  The second case is to mine local rules with distinct bases at participating LDOSs, resulting in a local association cube C a,I a local population cube C p,I  and a local base cube C b,i at each LDOS. At the GDOS, multiple association cubes, population cubes and base cubes sent from the LDOSs are simply combined, resulting in a summarized association cube and a summarized population cube, as 345   n i i a a C C 1   345   n i i p p C C 1  and 345   n i i b b C C 1  The corresponding confidence cube and support cube can then be derived as described earlier. Cross-sale association rules generated from distinct customers belong to this case In general, it is inappropriate to directly combine association cubes that cover areas a 1 205, a k to cover a larger area a In the given example, this is because association cubes record counts of customers that satisfy   customer product merchant time area Doe TV Dept Store 98Q1 California Doe VCR Dept Store 98Q1 California customer product merchant time area Doe VCR Sears 5-Feb-98 San Francisco Joe PC OfficeMax 7-Feb-98 San Francisco customer product merchant time area Doe TV Fry's 3-Jan-98 San Jose Smith Radio Kmart 14-Jan-98 San Jose Association   population      base          confidence      support cube               cube                cube         cube                cube LDOS LDOS GDOS 


the association condition, and the sets of customers contained in a 1 205, a k are not mutually disjoint. This can be seen in the following examples 214  A customer who bought A and B in both San Jose and San Francisco which are covered by different LDOSs , contributes a count to the rule covering each city, but has only one count, not two, for the rule A  336  B covering California 214  A customer \(e.g. Doe in Figure 3\who bought a TV in San Jose, but a VCR in San Francisco, is not countable for the cross-sale association rule TV  336 VCR covering any of these cities, but countable for the rule covering California. This is illustrated in Figure 3 6  Conclusions In order to scale-up association rule mining in ecommerce, we have developed a distributed and cooperative data-warehouse/OLAP infrastructure. This infrastructure allows us to generate association rules with enhanced expressive power, by combining information of discrete commercial activities from different geographic areas, different merchants and over different time periods. In this paper we have introduced scoped association rules  association rules with conjoint items and functional association rules as useful extensions to association rules The proposed infrastructure has been designed and prototyped at HP Labs to support business intelligence applications in e-commerce. Our preliminary results validate the scalability and maintainability of this infrastructure, and the power of the enhanced multilevel and multidimensional association rules. In this paper we did not discuss privacy control in customer profiling However, we did address this issue in our design by incorporating support for the P3P protocol [1 i n  ou r data warehouse. We plan to integrate this framework with a commercial e-commerce system References 1  Sameet Agarwal, Rakesh Agrawal, Prasad Deshpande Ashish Gupta, Jeffrey F. Naughton, Raghu Ramakrishnan, Sunita Sarawagi, "On the Computation of Multidimensional Aggregates", 506-521, Proc. VLDB'96 1996 2  Surajit Chaudhuri and Umesh Dayal, \223An Overview of Data Warehousing and OLAP Technology\224, SIGMOD Record Vol \(26\ No \(1\ 1996 3  Qiming Chen, Umesh Dayal, Meichun Hsu 223 OLAPbased Scalable Profiling of Customer Behavior\224, Proc. Of 1 st International Conference on Data Warehousing and Knowledge Discovery \(DAWAK99\, 1999, Italy 4  Hector Garcia-Molina, Wilburt Labio, Jun Yang Expiring Data in a Warehouse", Proc. VLDB'98, 1998 5  J. Han, S. Chee, and J. Y. Chiang, "Issues for On-Line Analytical Mining of Data Warehouses", SIGMOD'98 Workshop on Research Issues on Data Mining and Knowledge Discovery \(DMKD'98\ , USA, 1998 6  J. Han, "OLAP Mining: An Integration of OLAP with Data Mining", Proc. IFIP Conference on Data Semantics DS-7\, Switzerland, 1997 7  Raymond T. Ng, Laks V.S. Lakshmanan, Jiawei Han Alex Pang, "Exploratory Mining and Pruning Optimizations of Constrained Associations Rules", Proc ACM-SIGMOD'98, 1998 8  Torben Bach Pedersen, Christian S. Jensen Multidimensional Data Modeling for Complex Data Proc. ICDE'99, 1999 9  Sunita Sarawagi, Shiby Thomas, Rakesh Agrawal Integrating Association Rule Mining with Relational Database Systems: Alternatives and Implications", Proc ACM-SIGMOD'98, 1998   Hannu Toivonen, "Sampling Large Databases for Association Rules", 134-145, Proc. VLDB'96, 1996   Dick Tsur, Jeffrey D. Ullman, Serge Abiteboul, Chris Clifton, Rajeev Motwani, Svetlozar Nestorov, Arnon Rosenthal, "Query Flocks: A Generalization of Association-Rule Mining" Proc. ACM-SIGMOD'98 1998   P3P Architecture Working Group, \223General Overview of the P3P Architecture\224, P3P-arch-971022 http://www.w3.org/TR/WD-P3P.arch.html 1997 


Plenary Panel Session 30 XML Databases   Moderator: Michael Carey, IBM Almaden Research Center USA Panelists Adam Bosworth, Microsoft Corporation USA David De Witt University of Wisconsin-Madison, USA Alon Levy University of Washington USA Bruce Lindsay IBM Almaden Research Center USA Jennifer Widom Stanford University USA Demo Session 1 Web Query Optimizer  661 V Zadorozhny L Bright L Raschid T Urhan and M Vidal ReQueSS: Relational Querying of Semi-structured Data  664 R Sunderraman The IDEAL Approach to Internet-Based Negotiation for E-Business  666 J Hammer C Huang Y Huang C Pluempitiwiriyawej M Lee H Li L Wang Y Liu and S Su READY A High Performance Event Notification Service  668 R Gruber B Krishnamurthy, and E Panagos A Multimedia Information Server with Mixed Workload Scheduling  670 G Nerjes DISIMA An Object-Oriented Approach to Developing an Image Database System  672 V Oria T Ozsu P Iglinski B Xu and L Cheng Demo Session 2 The Collaboration Management Infrastructure  677 H Schuster D Baker A Cichocki D Georgakopoulos and M Rusinkiewicz Assisting the Integration of Taxonomic Data The LITCHI Toolkit  679 I Sutherland J Robinson S Brandt A Jones S Embury W Gray R White and F Bisby TheaterLoc: Using Information Integration Technology to Rapidly Build Virtual Applications  681 G. Barish Y.4 Chen D Dipasquo, C Knoblock S Minton I Muslea and C Shahabi Lineage Tracing in a Data Warehousing System  683 Y Cui and J Widom xiii 


The Mentor-Lite Prototype A Light-Weight Workflow Management System  685 J Weissenfels M Gillmann 0 Roth, G Shegalov and W Wonner Location Prediction and Queries for Tracking Moving Objects  687 0 Wolfson B Xu and S Chamberlain Semiorder Database for Complex Activity Recognition in Multi-Sensory Environments  689 S Bhonsle A Gupta S Santini and R Jain Tutorial 1 Web Information Retrieval  693 M Henzinger Tutorial 2 Mobile and Wireless Database Access for Pervasive Computing  694 P Chrysanthis and E Pitoura Tutorial 3 Data Mining with Decision Trees  696 J Gehrke Tutorial 4 Directories Managing Data for Networked Applications  697 D Srivastava Tutorial 5 Indexing High-Dimensional Spaces Database Support for Next Decade\222s Applications  698 S Berchtold and D Keim xiv 


 T5.I2.D100K T10.I4.D100K T15.I4.D100K T10.I6.D400K T10.I6.D800K T10.I6.D1600K Optimizations across Databases 5 0 5 10 15 20 25 30 35 40 45 Improvement COMP TREE COMP-TREE 1 2 4 8 1 2 4 8 1 2 4 8 2 4 8 2 4 8 1 2 4 8 Processors Databases Figure 5 Effect of Computation and Hash Tree Balancing good as the COMP optimization The reason that the hash tree balancing is not suf\336cient to offset inherent load imbalance in the candidate generation in this case The most effective approach is to apply both optimizations at the same time COMP-TREE The combined effect is suf\336cient to push the improvements in the 40 range in the multiple-processor case On 1 processor only hash tree balancing is bene\336cial since computation balancing only adds extra cost 5.4 Short-circuited Subset Checking Figure 6 shows the improvement due to the short-circuited subset checking optimization with respect to the unoptimized version The unoptimized version is the Apriori algorithm due to Agrawal et al 5 The results are presented for dif ferent number of processors across dif ferent databases The results indicate that while there is some improvement for databases with small transaction sizes the optimization is most effective when the transaction size is large In this case we get improvements of around 25 r the unoptimized version To gain further insight into this optimization consider 336gure 7 It shows the percentage improvement obtained per iteration on applying this optimization on the T20.I6.D100K database It shows results only for the uni-processor case r similar results were obtained on more processors We observe that as the iteration k increases there is more opportunity for shortcircuiting the subset checking and we get increasing bene\336ts of up to 60 The improvements start to fall off t the high end where the number of candidates becomes small resulting in a small hash tree and less opportunity for short-circuiting It becomes clear that is an extremely effective 15 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 T5.I2.D100K T10.I6.D800K T15.I4.D100K T20.I6.D100K procs across Databases 0 5 10 15 20 25 Improvement 1 2 4 8 Figure 6 Effect of Short-circuited Subset Checking 23456789101112 Iterations 0 10 20 30 40 50 60 improvement T20.I6.D100K Figure 7  Improvement per Iteration  proc   16 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


optimization for larger transaction sizes and in cases where there are large number of candidate k itemsets 6 Conclusions In this paper e presented a parallel implementation of the Apriori algorithm on the SGI Power Challenge shared memory multi-processor We also discussed a set of optimizations which include optimized join and pruning computation balancing for candidate generation hash tree balancing and short-circuited subset checking We then presented experimental results on each of these Improvements of more than 40 were obtained for the computation and hash tree balancing The short-circuiting optimization was found to be extremely effective for databases with large transaction sizes Finally we reported the parallel performance of the algorithm While we d good speed-up we observed a need for parallel I/O techniques for further performance gains References  R Agra wal T  Imielinski and A Swami Database mining A performance perspecti v e  I n IEEE Trans on Knowledge and Data Engg  pages 5\(6 1993  R Agra wal T  Imielinski and A Swami Mining association rules between sets of items in lar ge databases In Proc M SIGMOD Intl Conf Management of Data  May 1993  R Agra wal H Mannila R Srikant H T o i v onen and A I V erkamo F ast disco v ery of association rules In U F et al editor Advances in Knowledge Discovery and Data Mining  MIT Press 1996  R Agra wal and J Shafer  P arallel mining of association rules design implementation and e xperience Technical Report RJ10004 IBM Almaden Research Center San Jose CA 95120 Jan 1996  R Agra wal and R Srikant F ast algorithms for mining association rules In Proc 20th VLDB Conf  Sept 1994  M Cierniak W  Li and M J Zaki Loop scheduling for heterogeneity  I n 4th IEEE Intl Symposium on High-Performance Distributed Computing also as URCS-TR 540 CS Dept Univ f Rochester  Aug 1995  M Holsheimer  M  K ersten H Mannila and H T o i v onen A perspecti v e on databases and data mining In 1st Intl Conf Knowledge Discovery and Data Mining  Aug 1995  M Houtsma and A Swami Set-oriented mining of association rules In RJ 9567  IBM Almaden Oct 1993  H Mannila H T o i v onen and I V erkamo Ef 336cient algorithms for disco v ering association rules In AAAI Wkshp Knowledge Discovery in Databases  July 1994  J S P ark M Chen and P  S Y u  A n e f fecti v e hash based algorithm for mining association rules In Proc M SIGMOD Intl Conf Management of Data  May 1995 17 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 J S P ark M Chen and P  S Y u  E f 336cient parallel data mining for association rules T echnical Report RC20156 IBM T J Watson Research Center Aug 1995  G Piatetsk y-Shapiro Disco v ery  presentation and analysis of strong rules In G P S et al editor  KDD  AAAI Press 1991  A Sa v asere E Omiecinski and S Na v athe An ef 336cient algorithm for mining association rules in large databases In Proc 21st VLDB Conf  1995  M J Zaki M Ogihara S P arthasarathy  and W  Li P arallel data mining for association rules on shared-memory multi-processors Technical Report 618 Department of Computer Science University of Rochester 618 1996 18 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


