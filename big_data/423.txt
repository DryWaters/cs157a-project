193 An Enhanced A Priori Algorithm for Mining Multidimensional Association Rules Jurgen M Jams Fakultat fur Wirtschafts irnd Orgarzisatioriswissenschaften Universitat der Bideswehr Munchen Werner-Heisenberg Wey 39 0-85577 Neubiberg, Bundesrepublik Deutschlancl juergen.janas  urzihw-inuenchen.de Abstract In this pciper two concepts from different research arem are brought together ricimely functional dependencies which are a clms of 
integrity constraints that have gained fundamental importcince for releitiorin1 database design and association rules which are a class of patterns which has been studied rigorously in data mining It will be shown that functional dependencies may be used to logically infer new association rules from given ones This observation will then be employed to propose a new variant of the besr known algorithm for association rule mining the so-called A Priori algorithm Keywords data 
mining association rules A Priori algorithm relational databases functional dependencies 1 Introduction Data mining is the analysis of typically very large sets of data in order to discover yet unknown relationships among the data and aggregate them in ways which are novel, useful and understandable to the users of the data Data mining is a still young and due to its different ancestors namely statistics databases and artificial intelligence heterogeneous discipline Among its subdisciplines association rule mining is probably the one which is most 
independent from these ancestors Association rule mining is usually explained in the context of the market-basket problem which is the task of identifying sets of items which frequently occur together in supermarket transaction data. Technically spoken the rules to be mined in this scenario are single-ditnensioiial association rules i.e both sides of these rules are sets of values which come from the same domain in this case the items that may be purchased in the supermarket Single dimensional association rules may be 
generalized quite naturally to multidimensional association rules which are better tailored to data according to the relational model of data Association rule mining is done today by means of numerous variants of an algorithm which is known as A Priori and which extracts all association rules that are regarded as significant according to some simple statistical criteria during a number of sequential scans of the data In this paper we will propose an improvement of the A 
Priori algorithm that uses knowledge about the functional dependencies that are contained in the data to be mined Functional dependencies are patterns in data according to the relational model of data that may be observed due to corresponding regularities among the real world objects which are to be modeled by the data they are commonly employed in the database design process In combination with multidimensional association rules functional dependencies allow us to logically infer the validity of other 
association rules and thereby to simplify the A Priori algorithm The remainder of this paper is organized as follows Section 2 serves to introduce the concepts and the notation used within this paper this comprises concepts both from relational database theory and from data mining In section 3 an adaptation of the A Priori algorithm to multidimensional association rules is presented The similarities the differences and the interactions between functional dependencies on the one hand and association rules 
on the other will be investigated in section 4 This lays the foundation of the enhanced A Priori algorithm which will be proposed in section 5 In section 6 we shall discuss in how far the prerequisite of the proposed algorithm namely that there are functional depe6dencies in the data to be mined 25th Int Conf Information Technology Interfaces IT1 2003 June 16-1 9 2003 Cavtat, Croatia 


194 is justified The final section is then used to substantiate the advantages of the proposed algorithm over the classical A Priori algorithm 2 Basic concepts and notation 2.1 Relations and functional dependencies We assume that the reader is familiar with the basic concepts of the relational model of data e.g on the basis of 5 and restrict ourselves to informally introducing the concepts we are using in the rest of this paper When talking about a relation we distinguish between the relation schema denoted by R which describes the structure of the relation and the relation instance denoted by r which conforms to that structure and in which data are stored A relation schema R comprises the set of attributes denoted by atts\(R on which R is defined and a set of integrity constraints which have to be satisfied by the conforming relation instances We will use letters X and Y for sets of attributes and letters A and B for individual attributes A relation instance may be thought of as a set of tuples each of which consists of a set of values such that for each of the attributes in atts\(R\there is exactly one corresponding value individual such values will be referred to as attribute values and denoted by A:a where a stands for the value corresponding to A Sets of attribute values that consist of one attribute value per attribute from some X c atts\(R are called X values and will be designated by X:x We shall not distinguish between an attribute value and an X-value which contains only this attribute value The notation CJ x\(r stands for the relation instance which is obtained by selecting those tuples from r that contain the X-value X:x Finally, card\(r is used to designate the number of tuples contained in the relation instance r As far as the integrity constraints of a relation schema are concerned we restrict our considerations to functional dependencies within this paper A functional dependency is an expression of the form X A We say X  A is satisfied by a relation instance r if and only if every two tuples from r which agree with respect to their X-values also agree with respect to their A-values moreover we say that X  A holds in a relation schema R if and only if X  A is satisfied by every relation instance conforming to R The set of all functional dependencies that hold in relation schema R will be denoted by r A key of a relation schema R is a minimal set X c atts\(R such that the functional dependency X A holds in R for each A E atts\(R The closure of a set of attributes X with respect to r is the set of all attributes A such that X  A is contained in r the closure of X with respect to r will be denoted by Xr A linear time algorithm for computing the closure of a set of attributes may be found in 3 2.2 Association rules Suppose R is a relation schema A E atts\(R and X c atts\(R then an expression of the form X:x 3 A:a s c where s and c are real numbers from the interval between 0 and 1 is called a multidimensional association rule If r is a relation instance conforming to R we say that a multidiniensional association rule X:x 5 A:a s c is satisfied by r if card\(oA  a\(o  Jr  card\(r 2 s and Both s and c are measures for the interestingness of a multidimensional association rule s is called the support threshold and it prescribes a lower bound for the fraction of the tuples of r that have to contain both X:x and A:a for the rule to be satisfied by r. The confidence level c prescribes what fraction at least of the tuples of r that contain X:x have to contain A:a as well for the rule to be satisfied by r Multidimensional association rules are particularly appropriate for mining data according to the relational model of data For reasons of brevity multidimensional association rules will be referred to as association rules throughout this paper card\(o  doX  x\(r card\(ox  Ar 3 c 3 The classical A Priori algorithm The best known algorithm for mining association rules is the so-called A Priori algorithm which was originally introduced in I As a matter of fact the A Priori algorithm does not actually compute association rules but rather generates the set of all frequent X-values i.e X-values which appear in at least a fraction s of the tuples of the given relation instance Obviously for each frequent X-value an association rule containing all the attribute values 


195  Input r relation instance s support threshold Output L set of all frequent X-values of the frequent X-value inay be chosen e.g based on the confidence levels of the resulting rules subsequently The A Priori algorithm is based on the observation that if an X-value appears in a fraction s of the tuples, then any subset of the X value appears in at least fraction s of the tuples or  to put it the other way round  an X-value inay appear in a fraction s of the tuples only if each of its subsets does so This property is sometiiiies referred to as A Priori trick In the relevant literature the A Priori algorithm is usually explained in the context of the market-basket problem which implies a restriction to single-dimensional association rules However, as observed in 6 the algorithm inay easily be adapted to multi-dimensional association rules In the following the classical A Priori algorithm is restated in such a way that it applies to multi-dimensional association rules thus we make it directly comparable to the algorithm which will be proposed in section 5 of this paper and which is applicable to multi dimensional association rules only I Algorithm: Classical A Priori I The algorithm proceeds levelwise and requires one pass per level through the given relation instance On level k the set Lk of all frequent X-values of size k is computed this is done in two steps During the first step a set Ck of candidate X-values is constructed from Lk-1 by applying the A Priori trick In the second step the occurrences of the candidate X-values in the relation instance are counted and thus the actually frequent ones are identified For further details and a discussion of how to compute the candidate sets Ck efficiently the reader is referred to 6 4 Interactions between association rules and functional dependencies At first sight, association rules and functional dependencies seem to show a good deal of similarities As a matter of fact, both of them are meant to characterize situations in which the values with respect to one or more attributes of a relation determine the values with regard to some other attribute of that relation However there are three aspects in which association rules and functional dependencies differ from each other considerably Firstly functional dependencies have a coarser granularity than association rules This means while a functional dependency X 4 A is a statement which refers to all the X-values and all the A-values in a relation instance an association rule X:x 3 A:a s c is a statement which relates to the combination of only one particular X-value and one particular A-value Secondly functional dependencies are more stringent than association rules that is while a functional dependency enforces that all of the tuples which contain a certain X-value have to agree with respect to their A-value an  association rule requires only that a certain percentage expressed by means of the confidence level c of the tuples which contain the X-value have the same A-value Finally functional dependencies relate to the relation schema whereas association rules relate to a specific relation instance This implies that a functional dependency will be satisfied by every relation instance which belongs to the respective relation schema; thus the validity of a functional dependency cannot be affected by changes to the relation instance An association rule by way of contrast is a statement about one particular relation instance only and therefore such a statement may become invalid due to a chlinge to the respective instance It is an immediate consequence of the latter of these differences between association rules and functional dependencies that the existence of one or more association rules will by no means have 


196 any effect on the set of functional dependencies which hold in the respective relation schema On the other hand a functional dependency X  A which holds in a relation schema implies the validity of all association rules X:x 3 A:a s c for those X-values and A-values which occur in combination in the respective relation instance this implication is independent of the respective relation instance and the confidence level of each of the implied association rules is equal to 1 Of course this kind of relationship is owed to the different granularity of functional dependencies and association rules and it is of a rather trivial nature The following lemma will show however that there is another more useful kind of interaction between functional dependencies and association rules Lemma Let R be a relation schema r a conforming relation instance A B E atts\(R\and X c atts\(R if i X:x 3 A:a s c is satisfied by r and ii Y  B holds in R with Y c X U A then X:x U A:aa B:b s 1 is also satisfied by r with B:b being the uniquely determined attribute value which is contained in all tuples of r which contain both X x and A:a Proof obvious 0 5 An enhanced A Priori algorithm The above lemma has some interesting 222 implications for generating frequent X-values according to the A Priori algorithm Suppose, at some time during the execution of the algorithm we know that X:x is contained in the set Lk.1 and we also know that there is a functional dependency Y  B with Y c X that holds in R according to the above lemma we may then conclude that X:x U B:b is an element of Lk where B:b is the uniquely determined attribute value which is contained in all tuples of r which contain X:x The important point about that is the fact that we can make this conclusion without verifying that all subsets of size k-1 of the set X:x U B:b are elements of Lk-1 and without counting the occurrences of X:x U B:b in r either Instead we may immediately assign such an X-value to Lk without making it a member of the candidate set However, there is still another way in which we can make use of this situation Once we have ck concluded that X:x U B:b is contained in Lk due to the existence of some functional dependency as described above it is apparent that any X value X:x u B:b\222 with b\222  b cannot be an element of Lk even if all subsets of size k  1 of X:x U B:b\222 were elements of Lk.1 and again we may make this inference without counting the occurrence of X:x U B:b\222 in r This implies a further reduction of the size of the candidate sets ck In order to illustrate these effects the following example is provided Example Suppose at the beginning of the A Priori algorithm we have established the set L1   A:al A:ar},\(B:bl},\(B:b2},{B:b3 If we may assume that the functional dependency A  B holds in R and that according to this functional dependency the value a uniquely determines the value b for 1 5 i 5 2 then we may conclude that Axl B:bl A:a2 B:b2 E LZ and consequently that A:al, B:br\{A:al B:b3 A:az B:b A:a2, B:b3 E Lt Note that the classical A Priori algorithm would instead include all six possible pairs of attribute values in the candidate set Cl and count their occurrences in r in order to finally end up with the same result 0 Given a frequent X-value X:x from Lk-1 and a functional dependency Y  B with Y c X there seems to remain the problem of finding the attribute value B:b which corresponds to X:x according to the functional dependency Of course this attribute value may be found in any tuple which contains X:x but we certainly would not like to make an additional scan of the relation instance in order to find such a tuple It turns out however that this is not really a problem Since B:b is functionally dependent on some of the attribute values in X:x it is guaranteed that there is only one such value Hence whenever during subsequent traversals of the loop of the A Priori algorithm we have to count the occurrences of an X-value which contains one or more such unknown attribute values we may increment the respective count without checking the value of these particular attributes Obviously such missing values may be added either during the next counting of the occurrences of candidate X values or at the end of the algorithm after all frequent X-values have been found In the enhanced A Priori algorithm given below these unknown values are taken into 


197 account by using the symbol 223*\224 which may be understood as some kind of wildcard for an unknown yet uniquely determined value Algorithm Enhanced A Priori Input r relation instance s support threshold Output L set of all frequent X-values begin CI    A:a I r contains dn occurrence of A:a 1 Ll   A:a I Ax E Cl A card\(oA,\(r s  L  0 k 1 while Lk  0 do begin k:=k I L  L U Lk ck   c I c  Al:al  Ak:ak r\\A,#A,for 1 i<j<k A A E AI  A!.J\\\(A,J A C\\\(A,:a E Lk.1 for 1 5 i 5 k for 1 lisk Lk   x:X I x:X E Ck A card\(ox x\(r 2 S  U  C I31 E 1  k C  Al:al  AI  Ak:ak AA,#A,for 1 li<j<k A C\\\(AI:al E Lk.1 A AI E AI 224 ALl\\~All I end end It should be mentioned that the coinputation of the closures of sets of attributes  contrary to what the above algorithm may suggest at first sight  need not be done anew for each possible element of Ck or Lk respectively As closures are defined in term of attributes rather than in term of attribute values it is sufficient to compute all the closures which are needed during a traversal of the while-loop only once when the loop is entered Moreover one can easily see from the above algorithm that the closure of an attribute set X is required for the coinputation of Ck and Lk only if Lk.1 contains some element x:x 6 Applicability of the enhanced A Priori algorithm The enhanced A Priori algorithm makes use of certain regularities in the data that have the form of functional dependencies a concept which is commonly used in the design of relational databases. Therefore it is legitimate to ask whether we may reasonably expect that functional dependencies will be present at all in sets of data to be mined for association rules It may at first glance seem as if the answer to this question is completely dependant on the respective data set however a closer look reveals that there is an easy way to decide whether the enhanced A Priori algorithm inay benefit from the presence of functional dependencies or not Functional dependencies are used in relational database design to define certain I normal forms of relation schemes that are considered desirable because they avoid redundancy in the conforming relation instances The best normal form which may be achieved  as long as only functional dependencies are regarded  is the so-called BoyceKodd normal form BCNF according to the definition of BCNF if X  A is a non-trivial functional dependency that holds in a relation schema which is in BCNF then X has to contain a key of that relation schema It is easy to see that any such functional dependency X  A will be of hardly any help for the enhanced A Priori algorithm this is because any X-value which coinprises all of the attributes from X will occur at most once in a conforming relation instance and therefore will hardly ever be considered frequent As a consequence the enhanced A Priori algorithm is not appropriate for mining associations between multiple attribute values which are contained in the same relation particularly if the relation schema is in BCNF The situation is different however as soon as associations between attribute values from multiple relations are considered In this case the relations which contain the attribute values have to be joined as a prerequisite to counting the co occurrences of the attribute values For reasons of brevity we restrict ourselves to the case where only two relation schemes RI and R2 have to be joined The attribute\(s on which the join of RI and RI is performed must be a key in at least one of the relation schemes RI and R2 because otherwise the join would be 223lossy\224 i.e the relation resulting from the join would not comprise the same information as RI and R2 On the other hand if the join attribute\(s constitute a key in RI it IS very unlikely that they are a key of 


198 Rz as well because in that case there would have been no need to separate the information contained in the two relations during database design As a consequence the left-hand-side of any functional dependency which holds in RI will not contain a key of the joined relation even if it contains a key of RI and therefore an X value with X c atts\(Rl may be contained in the joined relation an arbitrary number of times and in particular may be frequent So all the functional dependencies that hold in R may be useful for the enhanced A Priori algorithm even if their left-hand-sides contain a key of RI It is obvious that the number of functional dependencies in the data to be mined increases with the number of joins that are required to build the relation in which the occurrences of the X-values may be counted Apart from that we would like to point out that the data to be mined may also contain functional dependencies for other reasons we only mention dimension tables in data warehouses which are deliberately denormalized cf 7 7 Conclusions When comparing the enhanced and the classical A Priori algorithm with regard to runtime there is not much difference The enhanced A Priori algorithm will occasionally require one scan less of the relation instance r but the gains during counting due to smaller candidate sets will be moderate at best Actually the main advantage of the enhanced A Priori algorithm is the fact that it avoids to include candidates into the sets Ck unnecessarily This is very important because according to  223the number of candidates must be sufficiently small that a count for each can fit in main memory\224 For that reason enhanced A Priori will be able to cope with larger sets of data than classical A Priori As a matter of fact there have been numerous other proposals on how to improve the classical A Priori algorithm with respect to this vulnerable spot We only mention hash-based techniques such as SI transaction reduction techniques as described in 2 the partitioning technique cf and the dynamic itemset counting approach described in 4 It seems worth mentioning that almost all of such attempts to improve the efficiency of the classical A Priori algorithm may be applied in combination with the enhancement proposed in this paper 8 References  11 Agrawal R Imielinski T., Swami T Mining Association Rules between Sets of Items in Large Databases Proc ACM SIGMOD Int Conf on Management of Data 1993. p 207  216  Agrawal R Srikant R Fast Algorithms for Mining Association Rules Proc Int Conf Very Large Data Bases 1994 p 487  499  Beeri C Bernstein P.A Computational Problems Related to the Design of Normal Form Relation Schemas ACM Trans on Database Systems 1979 4 1  30  59 4 Brin S Motwani R Ullman J.D Tsur S Dynamic Itemset Counting and Implication Rules for Market Basket Analysis Proc ACM SIGMOD Int Conf on Management of Data 1997 p 255  264 SI Garcia-Molina H Ullman J.D Widom J Database Systems The Complete Book Upper Saddle River, NJ. Prentice Hall 2002 6 Han J Kamber M Data Mining Concepts and Techniques San Francisco Morgan Kaufinann Publishers 2001 7 Kimball R The Data Warehouse Toolkit  Practical Techniques for Building Dimensional Data Warehouses New York Wiley 1996 8 Park J.S Chen M.S Yu P.S An Effective Hash-Based Algorithm for Mining Association Rules PI-oc ACM SIGMOD Int Conf on Management of Data 1995. p 175  186  Savasere A Omiecinski E Navathe S An Efficient Algorithm for Mining Association Rules in Large Databases Proc Int Conf Very Large Data Bases 1995. p 432  443 IO Ullman J.D Data Mining Lecture Notes httD://www-db.stanford.edu/-ull man/mini ng mining html 03/06/2003 r 


in Btree storage structure respectively The schemas of the relations are STUDENT logname c8 regno int advisor int, entry int year c2 scheme c6 uccacode c6 status cl examno int school c4 HOUSEHOLD hserno int persno int region c10 npersons int typaccm c10 bedrooms int centheat c4 ncars int ownrent c5 mortgage c4, cost int loan int The machine used was a 33Mhz SPARC-ELC with Ingres files held on a 2GB Fujitsu SCSI running synchronously Both relations are based on actual data used within the University Rules in our rules set were derived from the system by 12 91 The rule sets for each relation contained 50 rules The experiment was done for several thousand queries on both relations which was based on many observations using different featured rules in order to analyse the time saving using SQO For example if the rules contain any index attribute or not From our tests the following results were observed a For the both relations if the original query is refuted by any rule, the saving on average was 99.15 If the answer to the original query was found by one of the matching rules alone the saving on average was 99.53 b If the rule contained an indexed attribute the savings on average were up to 86.40 for 221STUDENT\222 and 83.52 for 221HOUSEHOLD\222 c In queries for which no indexed condition could be found, the saving on average was 6.39 for the relation 221STUDENT\222 and 1.94 for the relation 221HOUSEHOLD\222 The poorer result from the 221HOUSEHOLD\222 data was due to the lower number of instances per block compared with the 221STUDENT\222 relation 5 Conclusions This paper has described a fast query transformation process in SQO which constructs a near optimum query taking into account all matching rules The results are encouraging and promise large savings even when the rule set is large since transformation time is in linear function of rule set cardinality We are now extending our current work in statistics and knowledge discovery to address the issue of complex queries such as join queries and maintaining rules set 13 181 Acknowledgement We would like to thank John Ford  Tony Lawson in Computer Science Dept and Ken Miller  other personnel in the ESRC Data Archive at University of Essex Thanks also to Prof Tahir Sisman at Yildiz University for all his support during this research References I S Chakravarthy J Grant and J Minker 223Logic-based approach to semantic query optimisation\224 ACM on Database Systems Vol 15 No 2, 1990, pp. 162-207 2 K.C Chan and A.K.C Wong 223A statistical test for extracting classificatory knowledge form databases\224 Knowledge Discovery in Databases Ed The AAA1 Press 1991 pp 107-123 3 G Graefe and D Dewitt 223The EXODUS optimiser generator\224 In Proc of the 1987 ACM-SIGMOD Conf on Management of Data May 1987 pp 160-1711 4 J Han Y Cai and N Cercone 223Data-driven discovery of quantitative rules in relational databases\224 IEEE on Knowledge and Data Eng Vol5 no 1 Feb 1993 pp 29-40 5 C Hsu and C.A Knoblock, \223Rule induction for semantic query optimisation\224 In Proceedings of the Eleventh International Conf on Machine Learning 1994  I F Imam R S Michalski and L. Kerschberg 223Discovering attribute dependence in database by integrating symbolic learning and statistical analysis tests\224 Knowledge Discovery in Databases Workshop 1993 pp 264-275 7 J J King 223QUIST A system for semantic query optimisation in relational databases\224 In Proceeding of the 7 th VLDB Conference, Sept. 1981 pp 510-517 8 B G T Lowden 223An Approach to Multikey Sequencing in an equiprobable keyterm retrieval situation\224 Proceedings of the Eighth Annual International ACM SIGIR Conference on Research and Development in Information Retrieval, 1985 pp 92-96 9 B G T Lowden J Robinson and K Y Lim 223A semantic query optimiser using automatic rule derivation\224, Proc Fifth Annual Workshop on Information Technologies and Systems Netherlands, 68-76 December 1995 pp 68-76 lo L F Mackert and G M Lohman 223R optimizer validation and performance evaluation for local queries\224, Proc ACM-SIGMOD 1986 pp 84-95  111 G.Piatetsky-Shapiro and C Matheus 223Measuring data dependencies in large databases\224 Knowledge Discovery in Databases Workshop 1993 pp 162-173 12 A Sayli and B G T Lowden 223The use of statistics in semantic query optimisation\224, Thirteenth European Meeting on Cybernetics and Systems Research Vienna April 1996 pp 991-996 325 


 131 M SCHKOLNICK and P TIBERIO 223Estimating the cost of updates in a relational database\224 ACM Trans Database Systems 10,2 June 1985 pp 163-179  141 S Shekhar J Srivastava and S Dutta 223A formal model of trade-off between optimisation and execution costs in semantic query optimization\224 Proceedings of the 14th VLDB Conference Los Angeles, California, 1988 pp 457-467 15 S Shekhar B Hamidzadeh and A Kohli Learning transformation rules for semantic query optimisation a data driven approach. IEEE, 1993 pp 949-964 16 S.T Shenoy and Z.M Ozsoyoglu 223Design and implementation of semantic query optimiser\224 IEEE Transactions on Knowledge and Data Engineering Vol 1 No 3 Sept. 1989 pp 344-361 17 M.D Siegel E Sciore and S Salveter 223A method for automatic rule derivation to support semantic query optimisation\224 ACM Transactions on Database Systems Vol 17 No 4 Dec 1992, pp 563-600  181 C Yu and W Sun 223Automatic knowledge acquisition and maintenance for semantic query optimisation\224 IEEE Trans Knowl. Data Eng 1 3 Sept. 1989, pp 362-375 326 


of the query expression without ha ving the global view of the in ten tion There is a big c hance that the enco ded pro cedure ma y not b e the b est w a y to compute the rules dep ending on the database instance F urthermore as w e understand it their prop osals require p oten tially large n um ber of name generation for relations and attributes The names that are needed are usually database dep enden t and th us p ossibly cannot b e gathered at query time An additional pro cess needs to b e completed to gather those v ariables b efore actual computations can b egin 5  9 Optimization Issues While it w as in tellectually c hallenging to dev elop a declarativ e expression for asso ciation rule mining from deductiv e databases there are sev eral op en issues with great promises for resolution In the w orst case the least xp oin tneedsto generate n 2 tuples in the rst pass alone when the database size is n  Theoretically  this can happ en only when eac h transaction in the database pro duces an in tersection no de and when they are not related b y subset-sup erset relationship In the second pass w e need to do n 4 computations and so on The question no w is can w e a v oid generating and p erhaps scanning some of these com binations as they will not lead to useful in tersections F or example the no de b 0 3 in gure 11 is redundan t A signican t dierence with apriori lik e systems is that our system generates all the item sets top do wn in the lattice without taking their candidacy as a large item set in to consideration Apriori on the other hand do es not generate an y no de if their subsets are not large item sets themselv es and thereb y prunes a large set of no des Optimization tec hniques that exploit this so called an ti-monotonicit y prop ert y of item set lattices similar to apriori could mak e all the dierence in our setup The k ey issue w ould b e ho ww e push the selection threshold minim um supp ort inside the top do wn computation of the no des in the lattice in our metho d F or the momen t and for the sak e of this discussion let us consider a higher supp ort threshold of 60 for the database T of gure 9 No w the l-en v elop e will b e the one sho wn in ligh ter dashed lines in gure 11 and the no des under this line will b e the large item sets Notice that no ww eha v eto discard no des ad 2 0 and d 0 2 to o This raises the question is it p ossible to utilize the supp ort and condence thresholds pro vided in the query and prune candidates for in tersection an y further Ideas similar to magic sets transformation 3  24 ma y be b orro w ed to address this issue The only problem is that pruning of an y no de dep ends on its supp ort coun t whic h ma y come at a later stage By then all no des ma y already ha v e b een computed and th us pushing selection conditions inside aggregate op erator ma y b ecome non-trivial Sp ecial data structures and indexes ma y also aid in dev eloping faster metho ds to compute ecien t interse ction joins that w e ha v e utilized in this pap er W e lea v e these questions as op en issues that should be tak en up in the future F ortunately though there has been a v ast b o dy of researc h in optimizing Datalog programs including recursiv e programs suc h as the one w e ha v e used in this pap er and hence the new questions and researc h 5 Recall that their prop osal requires one to express the mining problem to the system using sev eral queries and up date statemen ts that utilizes information ab out the database con ten ts to ac hiev e its functionalit y  c hallenges that this prop osal raises for declarativ e mining ma y exploit some of these adv ances Needless to emphasize a declarativ e metho d preferably a formal one is desirable b ecause once w e understand the functioning of the system w e will then be able to select appropriate pro cedures dep ending on the instances to compute the seman tics of the program whic hw e kno wis in tended once w e establish the equiv alence of declarativ e and pro cedural seman tics of the system F ortunately  w e ha v e n umerous pro cedural metho ds for computing asso ciation rules whic h complemen t eac h other in terms of sp eed and database instances In fact that is what declarativ e systems or declarativit y buy us  a c hoice for the most ecien t and accurate pro cessing p ossible 10 Conclusion Our primary goal for this pap er has b een to demonstrate that mining asso ciation rules from an y rst-order kno wledge base is p ossible in a declarativ ew a y  without help from an y sp ecial to ols or mac hinery  and that w e can no wha v ea v ery in tuitiv e and simple program to do so W eha v esho wn that it is indeed p ossible to mine declarativ ekno wledge b y exploiting the existing mac hinery supp orted b ycon temp orary inference engines in programming languages e.g Prolog or kno wledge base systems e.g RelationLog XSB LD L  CORAL All w e require is that the engine b e able to supp ort set v alued terms grouping aggregate functions and set relational op erators for comparison functionalities whic hmostofthesesystemscurren tly supp ort W e ha v e also demonstrated that our formalism is grounded on a more mathematical foundation with formal prop erties on whic h the seman tics of the R ULES system rely  W e ha v e also raised sev eral op en issues related to eciency and query optimization whic h should b e our next order of business As future researc h w e plan to dev elop optimization tec hniques for mining queries that require non-trivial lo ok ahead and pruning tec hniques in aggregate functions The dev elopmen ts presen ted here also ha v e other signican t implications F or example it is no w p ossible to compute c hi square rules 4 using the building blo c ks pro vided b y our system Declarativ e computation of c hi square rules to our kno wledge has nev er b een attempted for the man y pro cedural concepts the computation of c hi square metho d relies on In a separate w ork 2 w e sho w that the coun ting metho d prop osed in this pap er can be eectiv ely utilized to generate the exp ectations needed in order to compute suc h rules rather easily  These are some of the issues w e plan to address in the near future The motiv ation imp ortance and the need for in tegrating data mining tec hnology with relational databases has b een addressed in sev eral articles suc h as 12  13 They con vincingly argue that without suc h in tegration data mining tec hnology ma y not nd itself in a viable p osition in the y ears to come T o b e a successful and feasible to ol for the analysis of business data in relational databases suc htec hnology m ust b e made a v ailable as part of database engines and as part of its declarativ e query language Our prop osal for declarativ e mining bears merit since it sheds ligh t on ho w rst order databases can be mined in a declarativ e and pro cedure indep enden t w a y so that the optimization issues can b e delegated to the underlying database engine Once suc h argumen ts are accepted sev eral systems 9 


related issues b ecome prime candidates for immediate atten tion F or example traditionally database systems supp orted declarativ e querying without the necessit y to care ab out the pro ceduralit y of the queries In this pap er w eha v e actually demonstrated that asso ciation rule mining can b e view ed as a Datalog query  It is immediate that a direct mapping from the Datalog expressions presen ted in this pap er to SQL can be dev elop ed with no problem at all W e can then rely on ecien t database pro cessing of the query in an optimized fashion Hence w ecomeclose to the essence of the visions expressed b y the leading database researc hers and practioners 12  References 1 Rak esh Agra w al and Ramakrishnan Srik an t F ast algorithms for mining asso ciation rules in large databases In VLDB  pages 487{499 1994 2 Anon ymous A declarativ e metho d for mining c hisquare rules from deductiv e databases T ec hnical rep ort Departmen t of Computer Science Anon ymous Univ ersit y USA F ebruary 2001 3 C Beeri and R Ramakrishnan On the po w er of magic In Pr o c e e dings of the 6th A CM Symp osium on Principles of Datab ase Systems  pages 269{283 1987 4 Sergey Brin Ra jeev Mot w ani and Craig Silv erstein Bey ond mark et bask ets Generalizing asso ciation rules to correlations In Pr o c A CM SIGMOD  pages 265 276 1997 5 D Chimen ti et al The LD L system protot yp e IEEE Journal on Data and Know le dge Engine ering  2\(1 90 1990 6 Jia w ei Han Jian P ei and Yiw en Yin Mining frequen t patterns without candidate generation In Pr o c A CM SIGMOD  pages 1{12 2000 7 Marcel Holsheimer Martin L Kersten Heikki Mannila and Hann uT oiv onen A p ersp ectiv e on databases and data mining In Pr o c of the sixth A CM SIGKDD Intl Conf  pages 150{155 Mon treal Queb ec 1995 8 Flip Korn Alexandros Labrinidis Y annis Kotidis and Christos F aloutsos Ratio rules A new paradigm for fast quan tiable data mining In Pr o c of 24th VLDB  pages 582{593 1998 9 Brian Len t Arun N Sw ami and Jennifer Widom Clustering asso ciation rules In Pr o c of the 3th ICDE  pages 220{231 1997 10 Mengc hi Liu Relationlog At yp ed extension to datalog with sets and tuples In John Llo yd editor Pr oc e e dings of the 12th International L o gic Pr o gr amming Symp osium  pages 83{97 P ortland Oregon Decem ber 1995 MIT Press 11 Rosa Meo Giusepp e Psaila and Stefano Ceri An extension to SQL for mining asso ciation rules Data Mining and Know le dge Disc overy  2\(2 1998 12 Amir Netz Sura jit Chaudh uri Je Bernhardt and Usama M F a yy ad In tegration of data mining with database tec hnology  In Pr o c e e dings of 26th VLDB  pages 719{722 2000 13 Amir Netz Sura jit Chaudh uri Usama M F a yy ad and Je Bernhardt In tegrating data mining with SQL databases In IEEE ICDE  2001 14 Ra ymond T Ng Laks V S Lakshmanan Jia w ei Han and Alex P ang Exploratory mining and pruning optimizations of constrained asso ciation rules In Pr o c A CM SIGMOD  pages 13{24 1998 15 Jong So o P ark Ming-Sy an Chen and Philip S Y u An eectiv e hash based algorithm for mining asso ciation rules In Pr o c A CM SIGMOD  pages 175{186 1995 16 Karthic k Ra jamani Alan Co x Bala Iy er and A tul Chadha Ecien t mining for asso ciation rules with relational database systems In Pr o c e e dings of the International Datab ase Engine ering and Applic ations Symp osium  pages 148{155 1999 17 R Ramakrishnan D Sriv asta v a and S Sudarshan CORAL  Con trol Relations and Logic In Pr o c of 18th VLDB Confer enc e  pages 238{250 1992 18 Konstan tinos F Sagonas T errance Swift and Da vid Scott W arren XSB as an ecien t deductiv e database engine In Pr o c of the A CM SIGMOD Intl Conf  pages 442{453 1994 19 Sunita Sara w agi Shib y Thomas and Rak esh Agra w al In tegrating mining with relational database systems Alternativ es and implications In Pr o c A CM SIGMOD  pages 343{354 1998 20 Ashok a Sa v asere Edw ard Omiecinski and Shamk an tB Nav athe An ecien t algorithm for mining asso ciation rules in large databases In Pr o c of 21th VLDB  pages 432{444 1995 21 Pradeep Sheno y  Ja y an t R Haritsa S Sudarshan Gaura v Bhalotia Ma y ank Ba w a and Dev a vrat Shah T urb o-c harging v ertical mining of large databases In A CM SIGMOD  pages 22{33 2000 22 Abraham Silb ersc hatz Henry F Korth and S Sudarshan Datab ase System Conc epts  McGra w-Hill third edition 1996 23 Shib y Thomas and Sunita Sara w agi Mining generalized asso ciation rules and sequen tial patterns using SQL queries In KDD  pages 344{348 1998 24 J D Ullman Principles of Datab ase and Know le dgeb ase Systems Part I II  Computer Science Press 1988 25 Mohammed J Zaki Generating non-redundan t association rules In Pr o c of the 6th A CM SIGKDD Intl Conf  Boston MA August 2000 1 0 


OM OM 006 OD8 01 012 014 016 018 02 022 False alarm demity Figure 9 Percentage of tracks lost within 200 seconds using three-scan assignment with PD  0.9 TI  O.ls Figure 11 T2  1.9s and T  Is ij  20 and 0  0.1 24 1 22  20  E fls 0  8l 16 0 n 14  12  0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 T1/12 PD Average track life of three-scan assignment with PD varying TI  0-ls T2  1.9s T  Is X  0.02 ij LO and   0.1 mareuvenng index Figure 12 Percentage of lost tracks of 4-D assipment in 200 seconds with maneuvering index varying X  0.01 Ti  0.1 T2  1.9s and T  IS PD  0.98 Figure 10 Percentage of lost tracks of 4-D assignment in 200 SeoDllCls with TI and T2 varying PD  0.98 X  0.02 q 20 and 0  0.1 4-1607 


Figure 13 Average gate size for Kalman filter Figure is relative as compared to nq and curves are parametrized by ij/r with unit-time between each pair of samples 1.2 Iy I 1.1 0.5 I A CRLB for he unifm samiina I  0.4 0.35 d 3 03 i7 3 0.25 0 0.M 0.04 0.06 008 0.1 0.12 0.14 0.16 0.18 0.2 False A!am DemW V I    Figure 14 CramerRao Lower Boundfor Mean Square Error of uniform and nonuniform sampling schemes with Ti  O.ls T2  1.9s T  IS PD  0.9 ij  5 and U  0.25 1 unifon sampling r-ls ked i non-uniform sampling loge inlewi I ti non-uniform sampling shod interva I 0.9 0.8 I Figure 15 MSE comparison of three-scan assignment with Ti and T2 varying I'D  1 X  0.01 ij  20 and U  0.1 4-1608 


Plenary Panel Session 30 XML Databases   Moderator: Michael Carey, IBM Almaden Research Center USA Panelists Adam Bosworth, Microsoft Corporation USA David De Witt University of Wisconsin-Madison, USA Alon Levy University of Washington USA Bruce Lindsay IBM Almaden Research Center USA Jennifer Widom Stanford University USA Demo Session 1 Web Query Optimizer  661 V Zadorozhny L Bright L Raschid T Urhan and M Vidal ReQueSS: Relational Querying of Semi-structured Data  664 R Sunderraman The IDEAL Approach to Internet-Based Negotiation for E-Business  666 J Hammer C Huang Y Huang C Pluempitiwiriyawej M Lee H Li L Wang Y Liu and S Su READY A High Performance Event Notification Service  668 R Gruber B Krishnamurthy, and E Panagos A Multimedia Information Server with Mixed Workload Scheduling  670 G Nerjes DISIMA An Object-Oriented Approach to Developing an Image Database System  672 V Oria T Ozsu P Iglinski B Xu and L Cheng Demo Session 2 The Collaboration Management Infrastructure  677 H Schuster D Baker A Cichocki D Georgakopoulos and M Rusinkiewicz Assisting the Integration of Taxonomic Data The LITCHI Toolkit  679 I Sutherland J Robinson S Brandt A Jones S Embury W Gray R White and F Bisby TheaterLoc: Using Information Integration Technology to Rapidly Build Virtual Applications  681 G. Barish Y.4 Chen D Dipasquo, C Knoblock S Minton I Muslea and C Shahabi Lineage Tracing in a Data Warehousing System  683 Y Cui and J Widom xiii 


The Mentor-Lite Prototype A Light-Weight Workflow Management System  685 J Weissenfels M Gillmann 0 Roth, G Shegalov and W Wonner Location Prediction and Queries for Tracking Moving Objects  687 0 Wolfson B Xu and S Chamberlain Semiorder Database for Complex Activity Recognition in Multi-Sensory Environments  689 S Bhonsle A Gupta S Santini and R Jain Tutorial 1 Web Information Retrieval  693 M Henzinger Tutorial 2 Mobile and Wireless Database Access for Pervasive Computing  694 P Chrysanthis and E Pitoura Tutorial 3 Data Mining with Decision Trees  696 J Gehrke Tutorial 4 Directories Managing Data for Networked Applications  697 D Srivastava Tutorial 5 Indexing High-Dimensional Spaces Database Support for Next Decade\222s Applications  698 S Berchtold and D Keim xiv 


 T5.I2.D100K T10.I4.D100K T15.I4.D100K T10.I6.D400K T10.I6.D800K T10.I6.D1600K Optimizations across Databases 5 0 5 10 15 20 25 30 35 40 45 Improvement COMP TREE COMP-TREE 1 2 4 8 1 2 4 8 1 2 4 8 2 4 8 2 4 8 1 2 4 8 Processors Databases Figure 5 Effect of Computation and Hash Tree Balancing good as the COMP optimization The reason that the hash tree balancing is not suf\336cient to offset inherent load imbalance in the candidate generation in this case The most effective approach is to apply both optimizations at the same time COMP-TREE The combined effect is suf\336cient to push the improvements in the 40 range in the multiple-processor case On 1 processor only hash tree balancing is bene\336cial since computation balancing only adds extra cost 5.4 Short-circuited Subset Checking Figure 6 shows the improvement due to the short-circuited subset checking optimization with respect to the unoptimized version The unoptimized version is the Apriori algorithm due to Agrawal et al 5 The results are presented for dif ferent number of processors across dif ferent databases The results indicate that while there is some improvement for databases with small transaction sizes the optimization is most effective when the transaction size is large In this case we get improvements of around 25 r the unoptimized version To gain further insight into this optimization consider 336gure 7 It shows the percentage improvement obtained per iteration on applying this optimization on the T20.I6.D100K database It shows results only for the uni-processor case r similar results were obtained on more processors We observe that as the iteration k increases there is more opportunity for shortcircuiting the subset checking and we get increasing bene\336ts of up to 60 The improvements start to fall off t the high end where the number of candidates becomes small resulting in a small hash tree and less opportunity for short-circuiting It becomes clear that is an extremely effective 15 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 T5.I2.D100K T10.I6.D800K T15.I4.D100K T20.I6.D100K procs across Databases 0 5 10 15 20 25 Improvement 1 2 4 8 Figure 6 Effect of Short-circuited Subset Checking 23456789101112 Iterations 0 10 20 30 40 50 60 improvement T20.I6.D100K Figure 7  Improvement per Iteration  proc   16 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


optimization for larger transaction sizes and in cases where there are large number of candidate k itemsets 6 Conclusions In this paper e presented a parallel implementation of the Apriori algorithm on the SGI Power Challenge shared memory multi-processor We also discussed a set of optimizations which include optimized join and pruning computation balancing for candidate generation hash tree balancing and short-circuited subset checking We then presented experimental results on each of these Improvements of more than 40 were obtained for the computation and hash tree balancing The short-circuiting optimization was found to be extremely effective for databases with large transaction sizes Finally we reported the parallel performance of the algorithm While we d good speed-up we observed a need for parallel I/O techniques for further performance gains References  R Agra wal T  Imielinski and A Swami Database mining A performance perspecti v e  I n IEEE Trans on Knowledge and Data Engg  pages 5\(6 1993  R Agra wal T  Imielinski and A Swami Mining association rules between sets of items in lar ge databases In Proc M SIGMOD Intl Conf Management of Data  May 1993  R Agra wal H Mannila R Srikant H T o i v onen and A I V erkamo F ast disco v ery of association rules In U F et al editor Advances in Knowledge Discovery and Data Mining  MIT Press 1996  R Agra wal and J Shafer  P arallel mining of association rules design implementation and e xperience Technical Report RJ10004 IBM Almaden Research Center San Jose CA 95120 Jan 1996  R Agra wal and R Srikant F ast algorithms for mining association rules In Proc 20th VLDB Conf  Sept 1994  M Cierniak W  Li and M J Zaki Loop scheduling for heterogeneity  I n 4th IEEE Intl Symposium on High-Performance Distributed Computing also as URCS-TR 540 CS Dept Univ f Rochester  Aug 1995  M Holsheimer  M  K ersten H Mannila and H T o i v onen A perspecti v e on databases and data mining In 1st Intl Conf Knowledge Discovery and Data Mining  Aug 1995  M Houtsma and A Swami Set-oriented mining of association rules In RJ 9567  IBM Almaden Oct 1993  H Mannila H T o i v onen and I V erkamo Ef 336cient algorithms for disco v ering association rules In AAAI Wkshp Knowledge Discovery in Databases  July 1994  J S P ark M Chen and P  S Y u  A n e f fecti v e hash based algorithm for mining association rules In Proc M SIGMOD Intl Conf Management of Data  May 1995 17 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 J S P ark M Chen and P  S Y u  E f 336cient parallel data mining for association rules T echnical Report RC20156 IBM T J Watson Research Center Aug 1995  G Piatetsk y-Shapiro Disco v ery  presentation and analysis of strong rules In G P S et al editor  KDD  AAAI Press 1991  A Sa v asere E Omiecinski and S Na v athe An ef 336cient algorithm for mining association rules in large databases In Proc 21st VLDB Conf  1995  M J Zaki M Ogihara S P arthasarathy  and W  Li P arallel data mining for association rules on shared-memory multi-processors Technical Report 618 Department of Computer Science University of Rochester 618 1996 18 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


