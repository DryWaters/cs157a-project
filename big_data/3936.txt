Considering RFM-Values of Frequent Patterns in Transactional Databases Ya-Han Hu Department of Information Management National Chung Cheng University Chia-Yi, Taiwan, R.O.C yahan.hu@mis.ccu.edu.tw Fan Wu Department of Information Management National Chung Cheng University Chia-Yi, Taiwan, R.O.C kfwu@mis.ccu.edu.tw Tzu-Wei Yeh Department of Information Management National Chung Cheng University Chia-Yi, Taiwan, R.O.C jimwayne@mis.ccu.edu.tw Abstract  Market basket analysis is an important data mining application for finding correlations between purchasing items in transactional databases. Previous works show that considering constraints which users may concerned with into the mining process can effectively reduce the number of patterns and get more promising information. In this study, we extend the RFM analysis into the mining process to measure the importance of frequent patterns. In RFM analysis, a customer to be recognized as valuable if his/her purchasing records are recent, frequent and having high amount of money. Follow the same concept of RFM analysis, we first define the RFM-patterns. The RFMpatterns we discovered are not only frequently occurred but also recently bought and having a higher percentage of revenue. After that, we propose a tree structure, named RFMP-tree, to compress and store entire transactional database, and a pattern growthbased algorithm, called RFMP-growth, is developed to discover all RFM-patterns from RFMP-tree. In experimental evaluation the results show that the algorithm can both significantly reduce the number of discovered patterns and efficiently find the RFMpatterns Keywords: market basket analysis, frequent pattern mining RFM analysis, constraint-based mining I I NTRODUCTION Association rule mining is one of the most prominent research topics in data mining. It can be used in discovering relationships among items or events in various application domains By given a user-specified threshold, also known as minimum support, the mining of association rules can discover the complete set of frequent patterns. That is, once the minimum support is given, the complete set of frequent patterns is determined. In order to retrieve more correlations among items, users may specify a relatively lower minimum support. Such a lower support often generates a huge amount of frequent patterns; but most of the patterns are already known or not interested to users. It is a tedious task for users to filter out these valueless patterns Previous works [1-2 s h o w e d th at  pu sh in g c o n s tr ain t s  which users concerned with into the mining algorithm can effectively reduce the number of patterns and get more promising information. Furthermore, instead of filtering patterns after the completion of the mining process, pushing additional constraints directly into the mining procedure can allow more efficient algorithm. For example, users may want such patterns that occur only in a specific period of time contained specific itemsets, or follow some regular expressions   Su ch c o n s t r aints m a y  m e et th e u s e r s  need and provide an effective and efficient way to gain more meaningful information In this study, we consider constraints developed from the RFM analysis to examine the interestingness of frequent patterns into the mining algorithm RFM Recency, Frequency and Monetary analysis 3  is a w ellk n o w n  and p o w e rf u l  to o l  in database marketing and is widely used in measuring the values of customers according to their prior purchasing history Valuable customers can be defined as those whose purchasing behaviors occur frequently and recently and whose purchasing records show high consumption ability, i.e. high total transaction amount. The same concepts can be used to evaluate the value of frequent patterns. That is, a frequent pattern is treated as valuable if it occurs frequently in both the whole database and the recent period, and the pattern can provide higher revenue for business. According to the description above, we develop a scoring-based method from RFM to evaluate the interestingness of patterns. Recency score denotes the number of a pattern  s occurrences in recent period. The more recent occurrences of a pattern does, the higher recency score it will get. Frequency score denotes the support count of the pattern. Monetary score denotes the amount of money that all customers spent on this pattern. A pattern with high recency and frequency scores implies that the pattern is important recently and over the long periods of time, while a pattern with high monetary score is important since it contributes higher revenue to business Follow the concepts of scoring method described above, we call a pattern is a RFM-pattern if its recency score, frequency score, and monetary score satisfies user-specified minimum recency, frequency, and monetary thresholds in this paper respectively Then, we design a compact tree structure, called RFMP-tree RFM-pattern tree which compresses and stores the necessary information of the entire transaction database within it. Based on the tree, we developed a pattern growth algorithm, called RFMP-growth to discover complete set of RFM-patterns The rest of our study is organized as follows: Section 2 shows the literatures relevant to this paper. Section 3 gives the definitions and notations used in the study. Section 4 describes the algorithm and gives some examples to illustrate it. The 422 


experiment result is shown in section 5, and Section 6 concludes the study II R ELATED W ORK There are some studies dealing with the concept of recency or monetary in frequent pattern mining. For example, Wu et al 4  discuss e d th e r e cen c y p r ob lem a b ou t th e chang e  of d ata  distribution between the past data and the new data Emerging patterns  introduced by Dong and Li [5 d i s c o v er t h e significant change in the same dataset but with different time periods. For another example, the utility mining [6-7 is a ty pe  of data mining considering the monetary that measure the importance of frequent pattern according to their monetary value \(i.e. profit Although several existing researches [8 use co nce p t s  similar to RFM in measuring the importance of frequent patterns, they still fail to fully reflect the requirement of RFM in the mining process. For example, RFM-Apriori [9  def i n e d recency constraint that the occurring time of the last transaction of a pattern should satisfy the recency threshold. Similarly to recency, monetary is defined as that the total amount of money spent by all customers in a pattern should fall into the range between the maximum and minimum monetary thresholds. The paper in [9  pr o p o se d an algo r ith m f o r m i n i n g pat t e r n s  satisfying RFM constraints; they used a fixed time gap that every occurrence of patterns within the given recent time period will have the same influence regardless of the occurring time. However, their approach cannot reflect the different length of stripes of recency in measuring the importance of transactions To the best of our knowledge, there exist no comprehensive studies concerning all the three concepts of RFM analysis on frequent pattern mining simultaneously. In this study, the proposed scoring-based method not only gives a more reasonable approach, but also performs the complete concept of RFM on measuring the importance of patterns III P ROBLEM D EFINITION In traditional association rule mining, a customer transaction only contains a set of items. With the information frequent patterns can be got. For a set I of items in a database to measure the scores of RFM of itemsets, the database should contain the more information of a transaction X like t x   1 a  1 a q   2 a  2 a q   m a  m a q where t x stands for the transaction time when transaction X occurs, the m pairs a i  i a q where 1 i m and a i  I denotes that there are m different items are purchased in the transaction and for item a i  the purchased quantity is i a q  Given an itemset Y  Y  I  Y is said to be contained in X if all items in Y also occur in X  Definition 1 Assume that an itemset Y is contained in transaction X  Y s transaction recency score gained from X  denoted by trscore  Y  X is defined as trscore  Y  X 1 tcurrent tx where  is a user-specified decay speed   0, 1 t current denotes the current timestamp Decay speed is a parameter used to control the output of the transaction recency score. A larger decay speed represents that the recency of transaction X shrinks fast as t x decrease and will lead to a smaller trscore On the contrary, a smaller decay speed will result in a higher trscore Given two transactions X i and X j containing itemset Y the relationship trscore  Y  X i  trscore  Y  X j will always hold when t i t j 0  1 Definition 2 Following Definition 1, the recency score of itemset Y denoted by Rscore  Y is defined as the sum of transaction recency score gained from all of the transactions containing it    DB X s DB s X Y trscore Y Rscore       Given a user-specified recency minimum support  an itemset Y is called a R-pattern if Rscore  Y    Example 1 Consider the transaction database DB shown in Fig. 1\(a\. Assume that the current time stamp t current 115 and let the decay speed  0.01. Given an itemset {CE}, its transaction recency score in X 5 \(e.g trscore CE X 5\s equal to \(1-0.1 1 15 45 0.495 Moreover, {CE}ês recency score Rscore DB CE trscore CE X 1  trscore CE X 2  trscore CE X 1 1.273. If  1 is set, we call an itemset {CE} is a R-pattern The concept of frequency is completely the same as the definition in traditional frequent pattern mining. We simply give the following definition Definition 3 The frequency score of itemset Y in DB  denoted by Fscore  y is the number of transactions containing itemset Y  Fscore DB  Y  X s  X s  DB 012 Y is contained in X s  2 Given a user-specified minimum frequency support  an itemset Y is called a RF-pattern if \(1\itemset Y is an R-pattern  and \(2 Fscore DB Y   DB    Example 2 Following Example 1, itemset {CE} is a Rpattern. And the Fscore of itemset {CE} is equal to 2 since it is contained in transaction 5 and 7. If  10% is set, then {CE} is called a RF-pattern because Fscore DB CE}\  1 0◊10 1 TID transaction 1 F, 1 2 F, 2 3 C, 1 4 E, 3 5 45, \(C, 1\\(E, 7 6 E, 5 7 E, 10 8 F, 5 9 G, 1 10 E, 10 a\ansactional database Item Price A 10 B 150 C 25 D 45 E 7 F 2 G 80 b\ unit price list Figure 1 An example of transactional database and item unit price list 423 


Monetary stands for the value \(amount of money\ a specific itemset can provide from historical transactions. In this study the definitions related to the monetary is similar to those in the mining of high utility patterns [6-7  Definition 4 Let p  a i denotes the unit price of item a i  Assume that an itemset Y is contained in transaction X An itemset Y s transaction monetary score gained from X  denoted by tmscore  Y  X is defined as  i i a Y a i q a p X Y tmscore           Definition 5 Following Definition 4, the monetary score of itemset Y in DB denoted by Mscore DB  Y is the sum of monetary score gained from transactions containing itemset y      DB X s DB s X Y tmscore y Mscore      015 Given a user-specified minimum monetary threshold  an itemset Y is called a RFM-pattern if \(1 Y is a RF-pattern and 2 Mscore DB  Y    Example 3 Following Example 2, itemset {CE} is a RFpattern. Consider the item unit price list shown in Fig. 1\(b\, for items C and E, their unit price is 25 and 7 respectively. Then CE}ês transaction monetary score from X 5 is tmscore CE X 5 1◊25 10◊7 95. Moreover, the monetary score of {CE gained from all transactions in DB is Mscore DB CE tmscore CE X 1  tmscore CE X 2  tmscore CE X 15 194. If  100 is set, then we call {CE} is a RFMpattern since Mscore DB CE}\  1 00 and it is also a RF-pattern In summary, given a transaction database and userspecified minimum thresholds    and , the goal of this study is to determine all RFM-patterns which the user interests in Although the concept of RFM-pattern is simple, to simultaneously consider all three constraints into the mining process is not straightforward The main problem is that monetary score doesnêt hold the downward closure property i.e. a subset of a RFM-pattern may not be a RFM-pattern Follow the parameter settings in Example 3 Mscore DB F 18 doesnêt satisfy  and {F} will never be a RFM-pattern. But its superset {BF} could be a RFM-pattern since Mscore DB BF}\ = 45 6   In other words, the Mscore of an itemsetês superset is possible to be higher than that of an itemset itself. To effectively prune the search space, we adopt the concepts proposed in [6 t o g i v e  th e f o ll ow in g def i n iti on s Definition 5 Following the Definition 4, the transaction amount for transaction X denoted by ta  X is the sum of all itemsê monetary score in transaction X s  i i a X a i q a p X ta          Definition 6 Based on definition 5, the total transaction amount of an itemset Y denoted by Tta  Y is defined as       012   s s X Y DB X s X ta Y Tta  Given a user-specified minimum monetary threshold  an itemset Y is called a RFT-pattern if \(1 Y is a RF-pattern and 2 Tta DB  Y    Example 4 Following Example 3, itemset {CE} is a RFpattern and is contained in transaction 5 and 7. Then its total transaction amount is Tta CE ta 5 ta 7\239 We call CE} is a RFT-pattern since {CE} is a RF-pattern and Tta CE   100 IV R FMP TREE AND R FMP GROWTH A LGORITHM In this section, we introduce the RFMP-tree structure and the RFMP-growth algorithm, which are modified from the well-known FP-tree structure and FP-growth algorithm [1 A RFMP-tree construction A complete RFMP-tree contains a list, called RFM-header  and a RFMP-tree A RFM-header is a list containing all the 1RFT-patterns \(i.e. a RFT-pattern containing one item only which are sorted according to their Fscore in descending order Each entry in RFM-header consists five fields item-name  Rscore  Fscore  Tta and head of node-link where item-name registers which item this entry presents Rscore  Fscore and Tta record the recency score, frequency score, and total transaction amount of this item, respectively, and head of nodelink points to the first node in RFMP-tree carrying the same item-name  Each node in RFMP-tree consists of five fields item-name  Rscore  Fscore  Tta  parent-link  child-link and sibling-link  where item-name registers which item this node represents Rscore  Fscore and Tta register the recency score, frequency score, and total transaction amount from all the transactions that have the corresponding patterns represented at this node and parent-link  child-link and sibling-link register the addresses of the parent node, child nodes, and the next node carrying the same item-name in the RFMP-tree, respectively While constructing RFMP-tree, we need two database scans \(briefly called DB scan in the following sections\ to build the complete tree. We first collect information to compact the tree size, and then build the complete RFMP-tree, as shown in Fig. 2. In the first DB scan, we collect all items Rscore  Fscore  and Tta to get all 1-RFT-patterns and store them in the RFMheader. After that, we sort all 1-RFT-patterns in RFM-header according to their Fscore in descending order. In the second DB scan, we create the root node of the tree and label it as null  For each transaction, we prune items not contained in RFMheader, i.e. non-1-RFT-patterns, and sort the remaining items according to the order of items in RFM-header. The sorted items are then inserted one by one into the RFMP-tree. Each transaction in this case leads to be a branch in RFMP-tree 424 


 root root A A F F B B 0.315, 1, 312 0.315, 1, 312 0.315, 1, 312 root root A A F F B B 0.692, 2, 476 0.692, 2, 476 0.692, 2, 476 root root A A F F B B 1.085, 3, 521 0.692, 2, 476 0.692, 2, 476 C C 0.393, 1, 45 a b\                                       \(c root root A A E E F F C C E E C C B B F F D D D D B B F F 300 2 1.778 D 667 3 1.158 B 679 4 2.494 F 329 4 2.525 C 768 6 4.304 E 1059 8 4.976 A link Tta Fscore Rscore item 300 2 1.778 D 667 3 1.158 B 679 4 2.494 F 329 4 2.525 C 768 6 4.304 E 1059 8 4.976 A link Tta Fscore Rscore item  Figure 2 RFMP-tree construction algorithm  While inserting each transaction into RFMP-tree, two possible cases may occur. If there already exists a branch representing the transaction, we simply update all scores related to the transaction into the corresponding nodes. On the contrary, if there exists no corresponding branch, one may have to create all necessary node\(s\ and calculate initial scores for it/them. Once a new node is created, all the links related to this node have to be built up, including parent-link and node-links The procedure insert_node, as shown in Fig. 3, is used to perform the functions describe above Since the basic concept of the RFMP-tree construction is the same as the FP-tree, we only use examples to illustrate dissimilar parts as follows. Consider the transaction database DB and item unit price list shown in Fig. 1, let  1  10  100  0.01, and the current time stamp t current 115 After the first DB scan, the RFM-header retain all 1-RFT-patterns and their Rscore  Fscore and Tta in Fig 4. All items are already sorted in Fscore descending order. Below, we give the steps of inserting transaction 1, 2, and 3 into the RFMP-tree while the second DB scan performs. We first sort transaction 1 follow the order of items in RFM-header to form <0, \(A, 1\\(F 1\\(B, 2\>. The three nodes with item-name equal to A, F, and B are created respectively, as shown in Fig. 5\(a\. Notice that while creating each new node, all of its scores and node-links have to be built up immediately For nodes A, F, and B transaction 1ês Rscore 0.315 Fscore 1, and Tta 10◊1+150◊2 2◊1=312 are stored in the nodes. For the next ordered transaction <18, \(A, 1\\(F, 2\\(B, 1\>, it shares the same prefix F\\(B\ with the existing branch So, we update node Aês node Fês, and node B s information based on transaction 2 After calculation, its Rscore 0.377 Fscore 1, and Tta 10◊1+150◊1+2◊2=164 is accumulated into the nodes as shown in Fig. 5\(b\. For the third ordered transaction <22, \(A 2\\(C, 1\>, we first update node A  s information Rscore 0.393 Fscore 1, and Tta 10◊2+25 1=45 in the same way since it shares the same prefix \(A For the remaining 1 item, we insert a new node C as a child of node A and transaction 3ês Rscore  Procedure insert_node p  P   T  X s  Rscore  X s T ta  if T has a child node N such that N  item-name  p  item-name then update N s Rscore  Fscore and Tta  else create a new node N with N  Fscore 1 N  Rscore  X s  Rscore and N  Tta  X s T ta let N s parent link be linked to T let N s node link be linked to the nodes with the same itemname via the node link structure if P is nonempty then call insert_node P  N  X s  Rscore  X s T ta   Figure 3 Procedure insert_node  Figure 4 The complete RFMP-tree Figure 5 An example of inserting transactions into RFMP-tree Fscore and Tta is then stored in the nodes as shown in Fig 5\(c\. Follow the same steps in the remaining transactions in DB  at last, the complete RFMP-tree is shown in Fig. 4 B RFMP-growth algorithm The RFMP- growth algorithm can be divided into two steps In the first step we perform the pattern growth recursively and find all RFT-patterns from the RFMP-tree, as shown in Fig. 7 The second step scans database once to compute the Mscore of all RFT-patterns and finally discover all RFM-patterns In the pattern growth procedure, we search the RFM-header and traverse the RFMPtree from the itemês node link in RFMheader The itemês Rscore, Fscore, and Tta value can be collected by traversing nodes with the same item-name through the node-link structure. The item then will be outputted as a RFT-pattern if it satisfies the thresholds. After that, a conditional pattern base is generated for the following procedure. The conditional pattern base is a sub dataset which each pattern in it contains the item we just traversed from RFM-header. It can be generated by the RFMPtreeês branches which are from the root node to the traversed nodes. After acquiring the complete conditional pattern base, the conditional Algorithm RFMP-tree Construction Input a set of all transactions in DB  min_rscore   min_fscore   min_mscore  decay speed  Output RFMP-tree Method Initial the header table RFM-header  foreach transaction X s in DB do foreach item a i  X s do if a i is not in RFM-header then add a new entry with item-name a i in RFM header  update a i s Rscore  Frscore and Tta value in RFM-header  remove items not satisfying minimum thresholds    or  in RFM-header  sort items in RFM-header by their Fscore in descending order Create the root node of a RFMP tree T label it as null  foreach transaction X s in DB do remove items not exist in RFM-header  calculate and record X s s Rscore and Tta  sort the remaining items in the order of items in RFM-header  let the sorted items in X s be p  P   w h er e p is the first element and P is the remaining list call insert_node  p  P   T  X s Rscore  X s tta  425 


Input RFMP-tree RT       Output a complete set of RFM-patterns Method Call RFMP-growth\(RFMP-tree null  Procedure RFMP-growth  RT  call tree-growth  RT  null and get all RFT-patterns scan DB once to get Mscores of RFT-patterns output all RFM-patterns with their Mscores satisfying    Procedure tree-growth\(RT   foreach item a i in RFM-header do let a i s node link is b i  if b i  null then get b i s Rscore  Fscore and Tta by b i s node link structure if b i  Rscore   b i  Fscore  and b i  Tta  then output b i  generate pattern  a i   where Rscore  Fscore and   Tta are equal to a i s Rscore  Frscore and Tta recorded in RFMheader respectively construct  s conditional pattern base and  s conditional RFMP tree RT   if RT    then call tree-growth  RT      Figure 6 The RFMP-growth algorithm RFMP-tree can be constructed using the same steps of constructing RFMP-tree. We can perform the mining procedure recursively with the conditional RFMP-tree and get all of the RFT-patterns Here we give an example to show the tree growth procedure with considering only patterns with item D. Initially the input itemset  is null that we can traverse the RFMP-tree and generate all of the 1-patterns, including pattern {D By traversing the node-link structure, we can collect all the information of pattern {D}, and pattern {D} will be outputted since it satisfies the thresholds. The conditional pattern base of each 1-pattern is then constructed recursively. In this example we only show item D  s conditional pattern base in Fig. 7 While the complete pattern base of item D is constructed, we then construct Dês conditional RFMP tree based on its conditional pattern base, as shown in Fig. 8\(a\ In the conditional tree construction step, item B and C will be removed from conditional RFMP-tree since they do not satisfy the thresholds as shown in Fig. 8\(b\. After the tree growth complete, we can have all RFT-patterns which contain item D The RFT-patterns outputted from D  s conditional RFMP-tree are {D}, {DE}, {AD}, and {ADE To find out all of the RFM-patterns from RFT-patterns, we use the hash-tree structure, which is a widely used tree structure in Apriori-based algorithms, to store the RFT-patterns After inserting all RFT-patterns in the hash-tree, we scan the database and traverse the hash-tree for each transaction to check if the RFT-pattern is contained in the transaction. Each RFT-pattern  s Mscore value will be collected after the scan item conditional pattern base Conditional RFMP-tree D A: 0.456, 1, 236\\(E: 0.456, 1 236\\(B: 0.456, 1, 236 C: 0.778, 1 165 A: 1, 1, 135\\(E: 1, 1, 135 E: 0.778, 1, 165\}|D A: 1, 1 135\}|D Figure 7 Item Dês conditional pattern base and conditional RFMP tree  a\                                         \(b Figure 8 Item D s conditional RFMP-tree completes. For item D  s RFT-patterns as example, pattern {D and {AD} will be pruned since Mscore D 90   Mscore AD 65  Therefore, the RFM-patterns containing item D are {DE and {ADE V E XPERIMENTAL E VALUATION In this section, we perform a simulation study to empirically compare the proposed algorithm with traditional association rule method \(FP-growth\ All the algorithms are implemented in Java language and tested on a DualCore Pentium E2180-2.0 GHz Windows XP system with 2 gigabyte of main memory. The three synthetic datasets are generated by IBM Quest Data Generator. Table I lists the parameters used in the data generation algorithm and Table II shows the parameter settings in our experiments. Since the synthetic datasets does not contain purchase quantity, item price, and transaction time we generate all necessary information in the following way The quantity of each item in the transaction is randomly generated from 1 to 10. Each item  s price is randomly generated in log-normal distribution, ranging from 1 to 50,000 The transaction time interval is drawn from a uniform distribution raging from 1 to 24, i.e. each transaction time will be later than that of prior transaction at most 24 time units We also investigate a real-life dataset in our experiments This real-life dataset contained all sales data of a supermarket in Taiwan from 2002/7/31 to 2002/11/28. Each row in this dataset records item ID, item quantity, and item price. After we perform all necessary data preprocessing tasks, the dataset contains 108,162 transactions and 9,943 items As shown in table III, we have designed three threshold settings. The decay speed  is set to be 0.001 in all tests Besides, since t current can significantly influence the Rscore of each pattern, we set t current to be the same as the latest transaction time to enhance the influence of recency constraint Moreover, since the FP-growth considers frequency constraint only, the recency and monetary thresholds will be discarded TABLE I P ARAMETERS  D  Number of transactions  T  Average size of the transactions  I  Average size of the maximal potentially large itemsets N Number of items N p Number of patterns L p Average length of maximal pattern C Correlation between patterns 426 


TABLE II P ARAMETER S ETTINGS OF S YNTHETIC D ATASETS Name  D   T   I  N N p L p C SYN-1 100K 25 20 1K 10K 4 0.25 SYN-2 150K 25 20 1K 10K 4 0.25 SYN-3 150K 25 20 4K 10K 4 0.25 TABLE III P ARAMETER S ETTINGS OF T HRESHOLDS    S1 3.5 3 100K S2 4 3.5 120K S3 4.5 4 150K The first test we compare the total execution time with FPgrowth. For each threshold setting, the proposed algorithm spends 1.42 times more than FP-growth on average. This is a reasonable result since we need three database scans whereas FP-growth needs only two database scans to find complete set of patterns Next, we compare the number of patterns generated from RFMP-growth and FP-growth. All three threshold settings are considered here. As shown in table IV, we find that the number of patterns significantly decrease when three constraints are added. On average, our method prunes more than 55 percent of patterns. We further examine the revenues both two kinds of patterns can represent, and the result is promising. Although RFM-patterns retain less than 45 percent of patterns, the proportion of the revenue of RFM-patterns to that of traditional patterns is more than 64 percents. Moreover, we conduct the same test using real-life dataset. In Table V, the result show that our method outputs only 7 percent of traditional patterns but the revenue of these patterns is over 12 percents. In TABLE IV T HE P ROPORTION OF THE R EVENUE OF R FM PATTERNS TO THAT OF T RADITIONAL P ATTERNS S YNTHETIC D ATASETS   patterns  al tradition of   patterns RFM  of     patterns  aditional Revenue\(tr patterns M Revenue\(RF  S1 S2 S3 S1 S2 S3 SYN-1 47.21 42.96 39.34 74.99 71.31 64.62 SYN-2 55.13 55.33 52.23 77.42 80.46 77.21 SYN-3 35.16 35.90 32.91 62.12 43.52 28.93 TABLE V T HE P ROPORTION OF THE R EVENUE OF R FM PATTERNS TO THAT OF T RADITIONAL P ATTERNS R EAL LIFE D ATASETS   patterns  al tradition of   patterns RFM  of     patterns  aditional Revenue\(tr patterns M Revenue\(RF  R0.05-F1%-M10k 6.90 14.68 R0.05-F0.5%-M10k 6.69 10.26 R0.005-F0.5%-M10k 7.62 11.49 R0.005-F0.6%-M12k 6.98 11.39 summary, through setting recency, frequency, and monetary thresholds simultaneously, we can get more compact representative and useful patterns VI CONCLUSION In this study, we consider the concept of RFM analysis into frequent pattern mining. To truly reflect the spirit of RFM in the mining process, we first define RFM-patterns, which can dynamically give recency score to each transaction, and perform the concept of monetary similar to utility mining. To efficiently discover RFM-patterns, we propose a tree structure RFMP-tree\as well as the pattern growth method \(RFMPgrowth\o discover complete set of RFM-patterns Three synthetic datasets and a real-life dataset are used in experimental evaluation. The experimental results show that the proposed method can not only significantly reduce the size of outputted patterns, but also retain more meaningful results to users R EFERENCES 1 F Bo nc hi an d C L u cche s e   E x t e n di ng t h e s t ate o f t he a r t o f co ns tr a i n t based pattern discovery Data & Knowledge Engineering vol. 60, pp 377-399, 2007 2 J  Pei  J  Ha n and W  W a n g  Con s t rai n t ba s e d s e qu en ti a l pa tt ern mining: The pattern-growth methods Journal of Intelligent Information Systems vol. 28, pp. 133-160, 2007 3 A H u g h e s Strategic database marketing 3 ed.: McGraw-Hill Companies, 2005 4 F W u Y  S L e e  an d J N Y u   A n ad ap tiv e a p pr o ach f o r mo de l  selection with high stability," in Proceedings of International Joint Conference on e-Commerce, e-Administration, e-Society, and eEducation Bangkok, Thailand, 2008 5 G D o ng and J  L i  E f f icie n t m i ni ng o f e m e r g i ng pat t e r ns  D i s c o v e r i ng  trends and differences," in Proceedings of the 5th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining  San Diego, California, United States, 1999, pp. 43-52 6 Y L i u, W  k L i ao an d A  C h o u d h a r y  A t w o phase al g o r ithm f o r f a s t  discovery of high utility itemsets," in The 9th Pacific-Asia Conference on Knowledge Discovery and Data Mining Hanoi, Vietnam, 2005, pp 689-695 7 C F  A h me d, S  K  T a nbe e r B S J e o n g  and Y  K  L e e   A n e f f i cie n t  candidate pruning technique for high utility pattern mining," in 13th Pacific-Asia Conference on Knowledge and Data Mining Bangkok THAILAND, 2009, pp. 749-756 8 Y L  Che n a nd Y  H H u  C o n s t r a i n t bas e d s e q u e n t i al p a t t e r n m i ni ng   The consideration of recency and compactness Decision Support Systems vol. 42, pp. 1203-1215, 2006 9 Y L  Che n  M  H K u o  S  Y W u a nd K  T a ng  D is co v e r i ng r e ce ncy   frequency, and monetary \(RFM\ sequential patterns from customers purchasing data Electronic Commerce Research and Applications vol 8, pp. 241-251, 2009 10 J  H a n, J  P e i, Y  Y i n an d R Mao    M i n i n g f r e que n t p a t t e r ns w itho u t  candidate generation: A frequent-pattern tree approach Data Mining and Knowledge Discovery vol. 8, pp. 53-87, 2004 42 7 


   


 990 978-1-4244-6571-2/10/$26.00 ©2010 IEEE  IEEE EDUCON Education Engineering 2010 Ö The Future of Global Learning Engineering Education A pril 14-16, 2010, Madrid, SPAIN 


              


   


                        





