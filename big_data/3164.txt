An Integrated OWL Data Mining and Query System Tzung-Pei Hong Dept. of Comp. Sci. & Info. Eng National University of Kaohsiung Dept. of Com. Sci. and Eng National Sun Yat-sen University Kaohsiung, Taiwan tphong@nuk.edu.tw Jun-Song Dong Dept. of Electrical Engineering National University of Kaohsiung Kaohsiung, Taiwan m0945120@mail.nuk.edu.tw Wen-Yang Lin Dept. of Comp. Sci. & Info. Eng National University of Kaohsiung Kaohsiung, Taiwan wylin@nuk.edu.tw Abstract In this paper, we propose an integrated OWL data mining and query system architecture for expressing the mined knowledge in the OWL format and for effectively answering users’ queries. The proposed system consists of five sub-systems query parser, rule inference system, ontology management system, knowledge generation system, and knowledge management system. We expect the architecture can provide users to query mined knowledge through the internet and with a more machine-understandable format Keywords—association rules, data mining, ontology, OWL language, semantic web I I NTRODUCTION Data mining involves the application of specific algorithms for extracting patterns or rules from data sets in a particular representation [7  8   1 6  A ccor d in g  to th e c l as s e s  of  knowledge derived, the mining approaches may be classified as finding association rules, classification rules, clustering rules and sequential patterns, among others. Among them, finding association rules in transaction databases is most commonly seen in data mining [1    I t i s used t o di sco v er  t h e relationships or information among the transaction items Besides, the concept of semantic web [2 s a t t r a c t ed much interest in recent years. It is proposed by Lee in 1998 and a method to effectively express materials on WWW. It provides a common framework that allows data to be shared and reused across applications and enterprises. There are many languages designed to implement semantic web. The Web Ontology Language \(OWL\ is the most popular among them. It can easily express the ontology needed in a particular domain In this paper, we try to use the OWL to represent the association rules. When association rules are mined out from a certain data source, they may need to be widely utilized through the internet environments. Appropriate semantic interpretation may expand the usage of the association rules An integrated semantic-web rule system architecture based on the OWL language is thus proposed for expressing the mined knowledge. The system consists of five sub-systems. They are query parser, rule inference system, ontology management system, knowledge generation system, and knowledge management system. We expect the architecture can provide users to query mined knowledge effectively and flexibly through the internet and with a more machine-understandable format. Besides, the system can be examined from the viewpoints of two different types of actors: the end user and the system administrator. From the viewpoint of end users, the system functions on dealing with user’s query and generating answers. From the viewpoint of system administrators, the system acts as a back end to support the query processing These will be illustrated in the paper The remaining parts of this paper are organized as follows Related work is first reviewed in Section 2. The integrated system framework is proposed in Section 3. Each component in the framework is described in details in Section 4. Conclusions are stated in Section 5 II R EVIEW OF R ELATED W ORK Agrawal and his co-workers proposed several mining algorithms based on the concept of large itemsets to find association rules in transaction data 2 3 4 18 T h e y  divided the mining process into two phases. In the first phase frequent itemsets were generated by scanning the transaction data. In the second phase, association rules were induced from the large itemsets found in the first phase. There are many other approaches proposed for finding association rules as well As to semantic web, many approaches and applications have also been proposed. For example, Fang et al proposed a search engine that can properly interpret the meaning of a user’s query and the inherent relation among terms [9  I n  t h e i r framework, a query request may be a keyword list as in traditional search methods or may be one in a complex form with various restrictions. Besides, the Web Ontology Language OWL\24 2 5  is th e  m o st p opu la r f o r im plem en tin g  sem a n tic  web applications. It is a makeup language for sharing and publishing data using ontology on the World Wide Web WWW\. OWL is developed based on DAML \(DARPA Agent Markup Language\ and OIL \(Ontology Inference Layer\ [19 and is now a W3C [2 r e c o m m e n dati on   T h e O W L in c l u d e s  class, property, object, some logics, and among others In this paper, we take the OWL Query Language \(OWLQL\ as the query language OW L-Q L i s  a for m a l la ngua ge and protocol for querying answers represented in OWL. It is an updated version of the DAML Query Language \(DQL query request is parsed into three parts that are subject property and object. These components are then filled in the OWL-QL query patterns that are a set of triples with the form  property> <subject> <object where any item in the triple 251 1-4244-2384-2/08/$20.00 c  2008 IEEE 


can be a variable. The patterns formed are then used to retrieve appropriate results III T HE F RAMEWORK OF THE I NTEGRATED OWL D ATA M INING AND Q UERY S YSTEM In this section, we describe the framework of the proposed integrated OWL data mining and query system. It consists of five sub-systems, including query parser, rule inference system ontology management system, knowledge generation system and knowledge management system. The framework of the proposed system architecture is shown in Fig. 1 Fig. 1 will be examined from the viewpoints of two different types of actors: the end user and the system administrator. From the viewpoint of end users, the system functions on dealing with user’s query and generating answers From the viewpoint of system administrators, the system acts as a back end to support the query processing IV M ODULE D ESIGN IN THE I NTEGRATED S YSTEM In this section, the functions of every sub-system and its components are described as follows A Query Parser Keywords usually have to be extracted to reflect the real request of a sentence or a query. The Query Parser is thus designed to achieve this purpose. For matching the OWL patterns, it recognizes subjects, properties and objects in a sentence or a query as keywords. There are two kinds of queries usually appearing. The first one is the data query which is a simple one and is the most commonly used in past applications. For example, assume we give the query Who owns the car It is first parsed to get the unknown subject  who e exact property owns and the known object car  according to the format of the OWL-QL Patterns [5  T h e second one belongs to rule queries, which has still seldom been seen in the current applications. For example, assume the query related to the association rule If beverage is an antecedent and snack is a consequent, what confidence is the rule is to be parsed. In the example, the words beverage  snack and rule are set as subjects antecedent  consequent and confidence are set as objects; and is is set as a property \(type\ These items extracted are thus stored as the OWL query pattern and used for inference B The Rule Inference System The work of this sub-system is to infer appropriate answers according to user queries. It is based on the OWL Query Language. It consists of the two components: the OWL query patterns and the inference engine. The functions of each component are described as follows 1 The OWL query patterns The component is implemented by the OWL Query Language \(OWL-QL  which is a formal language and protocol for querying answers and represented in OWL. An OWL-QL query pattern is a set of triples of the form  property> <subject> <object  Items in the triple may be constants or variables \(with their names beginning with the character “?”\. For the above example, the OWL query pattern receives the three keywords owns property who subject\ and car object\ from the query parser. It then judges that the word who represents an unknown subject and replaces it with the variable “?”. The following triple is then formed  owns> <?p> <car  2 The inference engine The main function of the inference engine is to infer appropriate answers through the integrated knowledge base according to the OWL query pattern. Continuing the above example, assume the fact about Tom owns a car” stored in the integrated knowledge base is expressed in the OWL form as follows  user Query Parser OWL Query Pattern Inference Engine query response  Rule Inference System   Rule Conversion Engine Rule Editor Rule Mining Engine Integrated Knowledge Base Domain Ontology  Ontology Management System  Object-Oriented Transaction Database Data Manager Insert / delete System Administrator Knowledge Management System Association Rules Ontology Editor OWL Rule Base  Knowledge Generation System form  user System Administrator Knowledge Integration System Administrator user Query Parser OWL Query Pattern Inference Engine query response  Rule Inference System   Rule Conversion Engine Rule Editor Rule Mining Engine Integrated Knowledge Base Domain Ontology  Ontology Management System  Object-Oriented Transaction Database Data Manager Insert / delete System Administrator Knowledge Management System Association Rules Ontology Editor OWL Rule Base  Knowledge Generation System form  user System Administrator Knowledge Integration System Administrator Figure 1 The proposed system framework 252 2008 IEEE International Conference on Systems Man and Cybernetics SMC 2008 


owl-ql:premise rdf:RDF rdf:Description rdf:about="#Tom owns rdf:resource="#car rdf:Description rdf:RDF owl-ql:premise The inference engine will derive the answer as Tom in the following process Query Who owns the car Query Pattern owns ?p car Must-Bind Variable List p Answer Tom There have been several products in the market which can be used to achieve the inference function. In our system, we use the OWL-QL Server to implement the functions C The Ontology Management System The Ontology Management System is responsible for the building and management of the domain ontology that is related to the transaction data stored in the object-oriented transaction database. It includes two modules, the ontology editor and the domain ontology. They are described as follows 1 The domain ontology The term Ontology     15 17 w a s pro pos ed i n t h e f i el d of  philosophy at the earliest. It is now commonly used for the research of semantic web. Ontology mainly presents the entries or things in the world, and relationships between the entries. An example of ontology regarding food is shown in Fig. 2, which describes the concept hierarchy of food and its relationships among the concepts \(classes In this paper, the domain ontology is represented in the OWL format. The domain ontology in Fig. 2 is thus transformed into the representation depicted in Fig. 3 through the ontology editor In Fig. 3, each node is a concept and each link is a property Some original attributes of an item are also represented as concepts in the OWL representation. For example, the class wine has an attribute age which is also thought of as a class in the OWL representation. In the context of the OWL syntax, a class is defined by owl:Class The semantic relationships among classes are represented by the properties and are specified through the OWL syntax of owl:OjectProperty  Besides, classes may have their subclasses. For the above example beverage  snack and fruit are the subclasses of the class food and the property hasCost connects the two classes of beverage and cost In the representation of the RDF format beverage is the subject cost is the object, and hasCost is the property. Each subject should have its domains and each object have ranges. The link of has hasCost thus connects the domain of beverage and the range of cost That is, it relates instances of the class beverage to instances of the class cost  2 The Ontology editor The ontology editor allows the system administrator to edit the domain ontology in the OWL format. The module can utilize an existing ontology editing tool, such as protégé, to achieve this purpose. If the system administrator has known that some classes or relationships about the data items need to be added, deleted or updated he/she can directly edit the domain ontology through the ontology editor. In this paper, the ontology editor, Protég  is used. It can allow users to build ontology for semantic web functions, in particular in the W3C's Web Ontology Language OWL D The Knowledge Generation System The function of this sub-system is to generate association rules from an object-oriented transaction database. It includes the four modules: data manager, object-oriented transaction database, rule mining engine and association rules. They are introduced below 1 The data manager The data manager stores the data in a particular domain into the object-oriented transaction database. It can use operations such as insertion, deletion and update to handle the data. Any object-oriented database management system \(DBMS\ can play the role  food beverage snack fruit wine tea milk cookie chocolate bread watermelon apple banana cost expiration alcohol age category color fat flavor cost calorie cookie category shape sugar color vegetarian bread category country of origin ripe weight size apple category apple grade color banana category IS-A Property food beverage snack fruit wine tea milk cookie chocolate bread watermelon apple banana cost expiration alcohol age category color fat flavor cost calorie cookie category shape sugar color vegetarian bread category country of origin ripe weight size apple category apple grade color banana category IS-A Property Figure 2 An example of ontology regarding food 2008 IEEE International Conference on Systems Man and Cybernetics SMC 2008 253 


 food beverage snack wine tea milk cookie chocolate bread cost expiration alcohol age category fat flavor calorie cookie category shape sugar color vegetarian bread category hasCost hasExpiration hasCost hasCalorie hasAge hasAlcohol hasCategory hasFat hasFlavor hasSugar hasCookie_Category hasShape hasColor hasBread_Category hasVegetarian objectProperty subClassOf hasColor food beverage snack wine tea milk cookie chocolate bread cost expiration alcohol age category fat flavor calorie cookie category shape sugar color vegetarian bread category hasCost hasExpiration hasCost hasCalorie hasAge hasAlcohol hasCategory hasFat hasFlavor hasSugar hasCookie_Category hasShape hasColor hasBread_Category hasVegetarian objectProperty subClassOf hasColor Figure 3 The OWL representation of the ontology in Fig 2  2 The object-oriented transaction database An objectoriented transaction includes one or more purchased items each of which is represented as an object or an instance. Each instance inherits its characteristics from a superior object called class, which defines the basic structure of objects with common properties, including attributes, default values, and methods. In this system, each item itself \(or item name\s thought of as a class and each item instance appearing in a transaction is thought of as an object. Objects with the same class \(item name\ may have different attribute values since they may appear in different transactions. These data are stored in the object-oriented transaction database. The administrator can manage the database through the data manager 3 The rule mining engine This component aims at finding relationships among data items. It extracts the data stored in the object-oriented transaction database to generate inter- and intra-class association rules. Our previously proposed approach for mining rules from object-oriented transactions u s ed h e re T h ere are th ree k i n d s of  knowledge to be discovered: inter-class association rules intra-class association rules and inter-intra class association rules. Objects and attributes are assumed to be binary, with the number 1 representing that the objects and the desired attributes appear. If they are not binary, they can be preprocessed by transforming an attribute with n values into n new binary attributes 4 The association rules The module of association rules store the knowledge mined from the data by the rule mining engine. As mention before, there are three kinds of knowledge to be discovered: inter-class association rules, intra-class association rules and inter-intra class association rules. Some examples of the three kinds are shown below The inter-class association rules  If the subclass watermelon then the subclass apple with a confidence factor of 0.8  If the subclass watermelon then the subclass apple with a support factor of 0.6 The intra-class association rules  If the cookie  cost 1\ then cookie  category 1\ with a confidence factor of 1  If the cookie  cost 1\ then cookie  category 1\ with a support factor of 0.7 The inter-intra association rules  If the watermelon  ripe 1\hen apple  grade 2 with a confidence factor of 0.9  If the watermelon ripe 1\, then apple  grade 2 with a support factor of 0.5 E The Knowledge Management System The subsystem mainly manages the association rules and transforms them into the OWL format. It includes rule conversion engine, rule editor, OWL rule base, knowledge integration and integrated knowledge base. They are described as follows 1 The rule conversion engine The function of the rule conversion engine is to automatically transform the association rules mined from the rule mining engine into the OWL format In the system, Jena s ed to im ple m e n t t h e eng i n e Jen a  is an open software developed by the HP Semantic Web Labs It is a Java API for manipulating RDF, RDFS, OWL SPARQL and is thus suitable as a tool to implement the engine. Besides, it includes a rule-based inference engine. This part is still under implementation 2 The rule editor In addition to automatic conversion from mined rules to OWL rules by the conversion engine, the rule editor allows the system administrator to manually transform the mined rules into the OWL format. The module 254 2008 IEEE International Conference on Systems Man and Cybernetics SMC 2008 


can utilize an existing ontology editing tool, such as protég to achieve this purpose because the OWL rules are also expressed in the OWL syntax. If the system administrator has known that some rules about the data items need to be added deleted or updated, He/She can directly edit the rules through the rule editor into the OWL rule base In this paper, the ontology editor, Protégé [21 is u s e d  as  the rule editor. The administrator can easily edit classes and relationships about classes through it. The class edition includes class descriptions, properties and their instances 3 The OWL rule base The OWL rule base stores the OWL rules both from the conversion engine and from the rule editor. All the rules stored in it are represented in the OWL format 4 The knowledge integration module The knowledge integration module integrates together the OWL rules stored in the OWL rule base and the relevant part of the domain ontology stored in the ontology management system. The integrated knowledge base can then support the inference engine in the rule inference systems to answer users’ queries in a semantic and flexible way. Users can thus easily find the super-classes of purchased items, their attributes, and other interesting information V C ONCLUSIONS In this paper, we have used the OWL language to represent the association rules for wide and flexible usage through the internet environments. We have also proposed an integrated OWL data mining and query system architecture for expressing the mined knowledge in the OWL format and for effectively answering users’ queries. We expect the architecture can provide users to query mined knowledge through the internet and with a more machine-understandable format R EFERENCES 1 R. A g r a w a l  T   I m ie l i nksi an d A  S w am i M in i n g asso ci at io n r u l e s  between sets of items in large database,” in Proc 1993 ACM SIGMOD Conference 1993, pp. 207–216 2 R. A g r a w a l  T   I m ie l i nksi a n d  A  S w am i D at ab ase m i ni ng  a  performance perspective IEEE Transactions on Knowledge and Data Engineering vol. 5, no. 6, 1993, pp. 914–925 3 R. A g r a w a l and R  S r ik an t F ast al g o r ithm f o r m i n i ng asso c i a t io n  rules,” in Proc. Int. Conf. Very Large Databases 1994, pp. 487–499 4 R. A g r a w a l and R. S r i k an t M i n i n g  s e que nt ial  pa tte r n s   in  Proc. 11th Int. Conf. on Data Engineering 1995, pp. 3–14 5 N Be n n a c e r Y  Bo ur d a  an d B. L  D o an F o r m a l i z i ng f o r que r y ing  learning objects using OWL,” in Proc IEEE Int. Conf. on Advanced Learning Technology 2004, pp. 321–325 6 C   C l a i r  C  L i u  and N P i s s i n ou   A t t ri bu t e w e i g h t in g: a m e t h od of applying domain knowledge in the decision tree process,” in Proc. 7th Int. Conf. on Information and Knowledge Management 1998, pp. 259 266 7 W  J  F r a w l e y   G  P i a t et sk y S h a p i r o an d C J  Ma th eu s  K n o w l e d g e  discovery in databases: an overview,” in Proc AAAI Workshop on Knowledge Discovery in Databases 1991, pp. 1–27 8 A F a m i l i W   M S h e n  R W e be r  a n d E S i m o ud is   D ata  pr e p r o ce s s i ng  and intelligent data analysis Intelligent Data Analysis vol. 1, 1997, pp 3–23 9 W D   F a ng  L  Y  Z h ang  X  W a ng  S  B. D o ng  T ow ar d a s e m a nt ic  search engine based on ontology,” in The Machine Learning and Cybernetics 2005, pp. 18–21 10 R. F ike s  P  H a y e s  and I  H o r r o c ks  OWL-QL: a language for deductive query answering on the semantic web Available http://ksl.standord.edu/KSL_Abstracts/ KSL-03-14.html 11 A   G  m e z P  r e z and O  Co r c ho  O nto l o g y l a ng uag e s f o r the s e m a nti c  web IEEE Intelligent Systems vol. 17, 2002, pp. 54–60 12 M. G r n ing e r an d M. S  F o x  Me t ho do l o gy fo r the de s i g n a n d  evaluation of ontologies,” in Proc. Workshop on Basic Ontological Issues in Knowledge Sharing 1995  N G u a r in o an d R Poli T h e rol e of form a l on t o log y i n th e in form a t i on technology International Journal of Human-Computer Studies vol. 43 1995, pp. 623–624 14 W  K i m   O bje c to r ie nte d  da ta bas e s  de f i ni tio n a n d r e s e ar ch dir e c t io ns    IEEE Transactions on Knowledge and Data Engineering vol. 2, no. 3 1990, pp. 327–341  Y F   K a o Y H K u o C  S. L ee a n d I  H M e n g   A d o m a in on t o logy learning approach based on soft-computing techniques,” in Proc National Computer Symposium 2003 16 H  Ma n n il a M e t ho ds  an d pr o b l e m s in da ta m i n i ng   i n  Proc. Int. Conf on Database Theory 1997, pp. 41–55 17 N  F  N o y and D  L  McG u in ne s s   O nto l o g y de ve l o pm e n t 10 1 A g u ide  to creating your first ontology,” Technical Report, Knowledge Systems Laboratory, Standford University, 2001  R  Srik an t Q V u an d  R  A g ra w a l  M in in g a s s o ci at i o n ru les w i t h  i t e m  constraints,” in Proc 3rd Int. Conf. on Knowledge Discovery in Databases and Data Mining 1997, pp.67–73  DARPA Markup Language \(DAML+OIL Available http://www.daml.org  Jena -- A Semantic Web Framework for Java Available http://jena.sourceforge.net/ index.html  Protég Available: http://protege.stanford.edu  Resource Description Framework \(RDF Available http://www.w3.org/RDF  Semantic Web technology Available: http://www.w3.org/2001/sw  World Wide Web Consortium \(W3C  Available: http://www.w3.org  Web Ontology Language \(OWL  Available http://www.w3.org/2004/OWL 2008 IEEE International Conference on Systems Man and Cybernetics SMC 2008 255 


1990 19 20 T Fawcett An introduction to ROC analysis thesis PhD 2005 18 K Fukunaga Journal of Atmospheric and SolarTerrestrial Physics Journal of Geophysical Research Pattern Recognition Letters vol 91 pp 169-180 1984 6 D F Webb Understanding CMEs and their source regions vol 27 pp 861-874,2006 S ROping mySVM-Manual University of Dortmund Lehrstuhl Informatik 8 http://www-aLcs unidortmund.de/SOFTW ARE/MYSVMI 2000 15 NGDC The National Geophysical Data Centre ftp://ftp.ngdc.noaa.gov/STP/SOLAR_ DATA 2007 16 SOHO/LASCO SOHO LASCO CME Catalogue http://cdaw.gsfc.nasa.gov/CME _list 2007 17 1 ling Dynamics of Filaments Flares and Coronal Mass Ejections CMEs in vol 62 pp 1415\255 1426,2000 7 R H Munro 1 T iosling E Hildner R M MacQueen A I Poland and C L Ross The association of coronal mass ejection transients with other forms of solar activity vol 69 pp 169-175 1981 9 S Yashiro N Gopalswamy S Akiyama G Michalek and R  Howard Visibility of Coronal Mass Ejections as a Function of Flare Location and Intensity vol 110 2005 10 G Yang and H Wang Statistical Studies of Filament Disappearances and CMEs in vol 397 pp 1057-1067,2003 12 T Colak and R Qahwaji Automated McIntosh-Based Classification of Sunspot Groups Using MDl Images vol 241 pp 195-211 2007 14 R Qahwaji T Colak M AI-Omari and S Ipson Prediction ofCMEs Using Automated Machine Learning of CME-Flare Associations AU 2007 13 R Qahwaji and T Colak Automatic Short\255 Term Solar Flare Prediction Using Machine Learning and Sunspot Associations SolarTerrestrial Magnetic Activity and Space Environment Proceedings of the COSPAR Colloquium held in the NAOC 1  Beijing China 2002 p 113 11 G Zhou 1 Wang and Z Cao Correlation Between Halo Coronal Mass Ejections and Solar Surface Activity Solar Physics Solar Physics Astronomy and Astrophysics vol 61 pp 201-215,1979 8 A I Poland R A Howard M 1 Koomen D 1 Michels and N R Sheeley Coronal transients near sunspot maximum New York Academic Solar Physics Solar Physics Solar Physics Solar Physics 2008 Introduction to Statistical Pattern Recognition http://archives njit edu/volO 1/etd/2000s/2005 njit-etd2005-07 3/njit-etd2005-07 3.pdf 2008 5th International Multi-Conference on Systems Signals and Devices 5 R M Wilson and E Hildner Are interplanetary magnetic clouds manifestations of coronal transients at 


 Kluwer Academic Publishers Springer, New York 1st edition, 2001 14  S c h e f f e r   T   F i n d i n g  A s s o c i a t i o n  Ru l e s  t h a t  T r a de Support Optimally Against Confidence th The Elements of Statistical Learning self_care_guide/Urogenital/Postate%20Cancer.pdf  Accessed, 25 August, 2008 11  A g r a w a l   R  T   I m i e l i n s k i     A   S w a m i   M i n i n g  association rules between sets of items in large databases, In Proceedings of the 1993 ACM SIGMOD international conference on Management of data  The Netherlands 42 2001 61-95  Ordonez C Association rule discovery with the train and test approach for heart disease predictio n 207\226 216 12 001 13  H a s t i e   T    R  T i b s h i r a n i     J  H   F r i e d m a n   Proceedings of the 5th European Conference on Principles and Practice of Knowlege Discovery in Databases\(PKDD'01 IEEE Transactions on Information Technology in Biomedicine, 10\(2\, 2006. 334 \226 343 001 Freiburg, Germany : SpringerVerlag, 2001. 424-435 15  F l a c h   P  A     L a c h i c h e   N   Co n f i r m a t i o n g u i d e d  discovery of first-order rules with Tertius 10  P h a r m a c y   h t t p    w w w  p h a r m a c y  g o v  m y    


 7. Conclusions  In this paper we have proposed an intelligent and efficient technique to reassess the distances between dynamic XML documents when one or all of the initially clustered documents have changed. After the changes, the initial clustering solution might become obsolete - the distances between clustered XML documents might have changed more or less depending on the degree of modifications \(insert update, delete\hich have been applied. Re-running full pair-wise comparisons on the entire set of modified documents is not a viable option, because of the large number of redundant operations involved Our proposed technique allows the user to reassess the pair-wise XML document distances, not by fully comparing each new pair of versions in the clustering solution, but by determining the effect of the temporal changes on the previously known distances between them. This approach is both time and I/O effective, as the number of operations involved in distance reassessing is greatly reduced  References  1  Beringer, J. and H\374llermeier, E., Online clustering of parallel data streams Data and Knowledge Engineering 58\(2\,  2006, 180-204 2  Catania, B. and Maddalena A., A Clustering Approach for XML Linked Documents, Proceedings of the 13th International Workshop on Database and Expert Systems Applications \(DEXA\22202\, IEEE 2002 3  Chen, M.S., Han, J. and Yu, P., Data Mining: An Overview from Database Perspective, IEEE Transactions on Knowledge and Data Engineering vol. 8, 1996, 866-883 4  Cormen, T., Leiserson, C. and Rivest, R Introduction to algorithms, MIT Press, 1990 5  Costa, G., Manco, G., Ortale, R. and Tagarelli, A., A tree-based Approach to Clustering XML documents by Structure, PAKDD 2004, LNAI 3202, 137-148 Springer 2004 6  Dalamagas, T., Cheng, T., Winkel, K.J. and Sellis, T 2004, Clustering XML documents by Structure SETN 2004, LNAI 3025, 112-121, Springer 2004 7  Ester, M., Kriegel, H.P., Sander, J., Wimmer,M. and Xu, X., Incremental Clustering for Mining in a Data Warehousing Environment, Proc.of the 24 th VLDB Conference, New York, USA, 1998 8  Garofalakis, M., Rastogi, R., Seshadri, S. And Shim K., Data Mining and the Web: Past, Present and Future Proceedings of WIDM 99 Kansas, US, ACM 1999 9  Mignet, L., Barbosa, D. and Veltri, P., The XML web : a first study, In Proceedings of the 12 th  International Conference on WWW, 500-510 2003   Nayak, R., Xu, S., XCLS: A Fast and Effective Clustering Algorithm for Heterogeneous XML Documents, In Proceedings of the 10 th Pacific-Asia Conference on Advances in Knowledge Discovery and Data Mining, Singapore, LNCS 3918, 2006   Rusu, L.I., Rahayu, W. and Taniar, D., A methodology for Building XML Data Warehouses International Journal of Data warehousing Mining, 1\(2 67-92, 2005   Rusu, L.I., Rahayu, W. and Taniar D.,  Maintaining Versions of Dynamic XML Documents, In Proceedings of the 6th International Conference on Web Information Systems Engineering, New York NY, USA, November 20-22, 2005, LNCS 3806   Rusu, L.I., Rahayu, W. and Taniar, D., Warehousing Dynamic XML Documents, In Proceedings of the 8 th  International Conference on Data Warehousing and Knowledge Discovery \(DaWaK 2006 LNCS 4081 Springer, 175-184, 2006   Shen, Y. and Wang, B., Clustering Schemaless XML documents, CoopIS / DOA/ODBASE 2003, LNCS 2888, 767-784, Springer 2003   Yoon, J. P., Raghavan, V., Chakilam, V., and Kerschberg, L., BitCube: A Three-Dimensional Bitmap Indexing for XML Documents J. Intel. Inf Syst 17, 2-3 \(Dec. 2001\, 241-254   XML data repository, online at http www.cs.washington.edu / research / projects / xmltk xmldata  
456 
456 


5 Related Work There exists extensive previous work on both the mining of software repositories and on the use of clustering algorithms in software engineering This discussion focuses on the most similar and recent work in the area of software evolution Mining Software Repositories Our technique was partially inspired by the work of Zimmermann et al and Y ing et al 17 on the mining of association rules in change history As described in Section 1 we sought to expand the technique to be able to recommend larger but less precise clusters of elements to guide program navigation Bouktif et al also investigated how to recommend cochanges in software development As opposed to the work cited above Bouktif et al used change patterns instead of association rules Also their approach does not attempt to reconstruct transactions and can consider associated 002les that were changed in different transactions ChangeDistiller is a tool to classify changes in a transaction into 002ne-grained operations e.g addition of a method declaration and determines how strongly the change impacts other source code entities Our approach uses similar repository analysis techniques but is focused on providing task-related information as opposed to an overall assessment of a system's evolution Finally repository mining can also be used to detect aspects in the code In this conte xt aspects are recurring sets of changed elements that exhibit a regular structure Aspects differ from the clusters we detect in the regular structure they exhibit which may not necessarily align with the code that is investigated as part of change tasks Clustering Analysis The classical application of clustering for reverse engineering involves grouping software entities based on an analysis of various relations between pairs of entities of a given version of the system Despite its long and rich history  e xperimentation with this approach continues to this day For example Andreopoulos et al combined static and dynamic information K uhn et al used a te xtual similarity measure as the clustering relation and Christl et al used clustering to assist iterative semi-automated reverse engineering The main dif ferences b e tween most clusteringbased reverse engineering techniques and the subject of our investigation is that the entities we cluster are transactions rather than software entities in a single version of a system For this reason our analysis is based strictly on the evolving parts of the system Both Kothari et al and V an ya et al 15 recently reported on their use of clustering to study the evolution of software systems The idea of using change clusters is the same in both works and ours but the purpose of the work is different Kothari et al use change clusters to uncover the types of changes that happened e.g feature addition maintenance etc during the history of a software system Vanya et al use change clusters which they call evolutionary clusters to guide the partitioning of a system that would increase the likelihood that the parts of the system would evolve independently In contrast we cluster transactions based on overlapping elements not 002les to recommend clusters to support program navigation as opposed to architectural-level assessment of the system Finally Hassan and Holt evaluated on 002ve open source systems the performance of several methods to indicate elements that should be modi\002ed together This study found that using historical co-change information as opposed to using simple static analysis or code layout offered the best results in terms of recall and precision The authors then tried to improve the results using 002ltering heuristics and found that keeping only the most frequently cochanged entities yielded the best results As opposed to our approach the evaluated 002ltering heuristics were only applied on entities recovered using association rules and not using clustering techniques The focus of their study was also more speci\002c as they recommend program elements that were strictly changed  as opposed to recommending elements that might be inspected by developers 6 Conclusion Developers often need to discover code that has been navigated in the past We investigated to what extent we can bene\002t from change clusters to guide program navigation We de\002ned change clusters as groups of elements that were part of transactions or change sets that had elements in common Our analysis of close to 12 years of software change data for a total of seven different open-source systems revealed that less than 12 of the changes we studied could have bene\002ted from change clusters We conclude that further efforts should thus focus on maximizing the quality of the match between the current task and past transactions rather than 002nding many potential matches Our study has already helped us in this goal by providing reliable evidence of the effectiveness of some 002ltering heuristics and useful insights for the development of additional heuristics Acknowledgments The authors thank Emily Hill and Jos  e Correa for their advice on the statistical tests and the anonymous reviewers for their helpful suggestions This work was supported by NSERC 
25 
25 
25 
25 
25 


References  B Andreopoulos A An V  Tzerpos and X W ang Multiple layer clustering of large software systems In Proc 12th Working Conf on Reverse Engineering  pages 79–88 2005  S Bouktif Y G Gu  eh  eneuc and G Antoniol Extracting change-patterns from cvs repositories In Proc 13th Working Conf on Reverse Engineering  pages 221–230 2006  S Breu and T  Zimmermann Mining aspects from v ersion history In Proc 21st IEEE/ACM Int'l Conf on Automated Software Engineering  pages 221–230 2006  A Christl R K oschk e and M.-A Store y  Equipping the re\003exion method with automated clustering In Proc 12th Working Conf on Reverse Engineering  pages 89–98 2005  D 020 Cubrani  c G C Murphy J Singer and K S Booth Hipikat A project memory for software development IEEE Transactions on Software Engineering  31\(6 465 2005  B Fluri and H C Gall Classifyi ng change types for qualifying change couplings In Proc 14th IEEE Int'l Conf on Program Comprehension  pages 35–45 2006  A E Hassan and R C Holt Replaying de v elopment history to assess the effectiveness of change propagation tools Empirical Software Engineering  11\(3 2006  D H Hutchens and V  R Basili System s tructure analysis Clustering with data bindings IEEE Transactions on Software Engineering  11\(8 1985  D Janzen and K De V older Na vig ating and querying code without getting lost In Proc 2nd Int'l Conf on AspectOriented Software Development  pages 178–187 2003  J K ot hari T  Denton A Shok ouf andeh S Mancoridis and A E Hassan Studying the evolution of software systems using change clusters In Proc 14th IEEE Int'l Conf on Program Comprehension  pages 46–55 2006  A K uhn S Ducasse and T  G  021rba Enriching reverse engineering with semantic clustering In Proc 12th Working Conf on Reverse Engineering  pages 133–142 2005  M P  Robillard T opology analysis of softw are dependencies ACM Transactions on Software Engineering and Methodology  2008 To appear  M P  Robillard and P  Mangg ala Reusing program in v estigation knowledge for code understanding In Proc 16th IEEE Int'l Conf on Program Comprehension  pages 202 211 2008  J Sillito G Murph y  and K De V older Questions programmers ask during software evolution tasks In Proc 14th ACM SIGSOFT Int'l Symposium on the Foundations of Software Engineering  pages 23–34 2006  A V an ya L Ho\003and S Klusener  P  v an de Laar and H van Vliet Assessing software archives with evolutionary clusters In Proc 16th IEEE Int'l Conf on Program Comprehension  pages 192–201 2008  N W ilde and M C Scully  Softw are reconnaissance Mapping program features to code Software Maintenance Research and Practice  7:49–62 1995  A T  Y ing G C Murph y  R Ng and M C Chu-Carroll Predicting source code changes by mining change history IEEE Transactions on Software Engineering  30\(9 586 2004  A Zeller  The future of programming en vironments Integration synergy and assistance In Proceedings of the 29th International Conference on Software Engineering The Future of Software Engineering  pages 316–325 2007  T  Zimmermann and P  W eißgerber  Preprocessing C VS data for 002ne-grained analysis In Proc 1st Int'l Workshop on Mining Software Repositories  pages 2–6 May 2004  T  Zimmermann P  W eißgerber  S Diehl and A Zeller  Mining version histories to guide software changes In Proc 26th ACM/IEEE Int'l Conf on Software Engineering  pages 563–572 2004 A Clustering Algorithm This algorithm is not sensitive to whether a given program element exists or not in a given version of a program For example if method m exists in one version it is considered a valid program element even if it is removed in a later version In the rest of this section we use the term program element to refer to the uniquely identifying representation of the element e.g a Java fully-quali\002ed name Let T be a transaction modeled as a set of program elements changed together during the history of a software system Let T be a sequence of transactions In this algorithm a cluster is also modeled as a set of elements 1 Input  T  A sequence of transactions 2 Parameter  M IN O VERLAP  A positive non-zero value indicating the minimum overlap between two transactions in a cluster 3 Var  C  A set of clusters initially empty 4 for all T i 2 T do 5 MaxOverlap  0 6 MaxIndex  000 1 7 for all C j 2 C do 8 if j C j  T i j  MaxOverlap then 9 MaxOverlap  j C j  T i j 10 MaxIndex  j 11 end if 12 end for 13 if MaxIndex   0  MaxOverlap 025 M IN O VERLAP  then 14 C MaxIndex   C MaxIndex  T i  15 else 16 NewCluster  T i 17 C  C  f NewCluster g 18 end if 19 end for 20 return C B Systems Analyzed System home pages last veri\002ed 7 May 2008 Ant ant.apache.org Azureus azureus.sourceforge.net Hibernate www.hibernate.org JDT-Core www.eclipse.org/jdt/core JDT-UI www.eclipse.org/jdt/ui Spring springframework.org Xerces xerces.apache.org 
26 
26 
26 
26 
26 


