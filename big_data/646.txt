Discovering Temporal Association Rules: Algorithms, Language and System Xiaodong Chen Department of Computing and Mathematics Manchester Metropolitan University, U.K e-mail: x.chen@doc.mmu.ac.uk Ilias Petrounias Department of Computation UMIST, U.K e-mail: ilias@co.umist.ac.uk Abstract Most previous work on association rule discovery [1 overlooks time components, which are usually attached to transactions in databases. This results in the loss of the chance to discover some meaningful time-related rules This work addresses temporal issues of association rules with the corresponding algorithms, language and system for discovering temporal association rules 1. Temporal association rule discovery A temporal pair  AR, TF  where AR is an implication of the form X 336 
Y and TF is a temporal feature \(e.g., a valid period, a periodicity or a specific calendar\ possesses. In the task of temporal association rule discovery, both association rules and temporal features are expected to be extracted from the database. From a practical point of view, it is too expensive to find all possibly hidden temporal association rules from large databases without any limitation, due to the two-dimensional solution space The methodology adopted in this paper is eventually discovering potential temporal rules by alternatively using special search techniques for various restricted problems in an interactive and iterative process Three forms of interesting mining tasks for temporal association rules with certain constraints are identified These tasks are the discovery of valid time periods during which association rules hold, the discovery of possible periodicities that association rules have, and the discovery of association rules with temporal features. The search techniques and algorithms  hos e i ndi vi dual 
tasks have been developed and implemented in a temporal mining system The results of experiments with synthetic datasets show that many time-related association rules that would have been missed with traditional approaches can be discovered with the techniques and approaches presented in this paper 2. Temporal mining language and system The integrated query and mining system \(IQMS\s a prototype system with an integrated query and mining interface \(IQMI\upporting the discovery of temporal association rules. The kernel of the system is a temporal mining language \(TML\ntegrated with Oracle SQL. By using this system, data miners can explore temporal association rules from databases in an iterative process, as shown in Figure 1. With the query function, the data in any Oracle database can firstly be analysed, according to the business requirements, in order to get some useful information \(e.g., summary information about the data for designing mining tasks. The mining task can then be 
designed and expressed in the TML language and fulfilled by the ad hoc mining function of the system. The mining results need to be further analysed to judge if the expected knowledge has been found or whether the mining task should be adjusted to make another mining effort  Data Understanding Task Design Mining Task Ad hoc Mining Mining Result Result Analysis Business Requirement Knowledge 
DBMS 
Figure 1: IQMI-based mining process The significance of such an integrated system has been shown in three aspects in the dynamic data mining efforts Firstly data selection and sampling for different data mining tasks are easy to achieve with the query function 
that is integrated in the system. Secondly ad-hoc mining for different application requirements is possible to fulfil with the mining language supported by the system Finally, all data mining activities can be undertaken in a more flexible data mining process based on IQMI 3. References 1 R Ag rawal T Im ielin sk i, an d A. Swam i, Min i n g Associations between Sets of Items in Massive Databases Proc. of SIGMOD\22293 Washington D.C., USA, pp.207216  h en, I. P e t r ouni as  and H Heat hfi e l d  Di s c overi ng Temporal Association Rules in Temporal Databases Proc. of IADT\22298 Berlin, Germany, pp.312-319  h en and I. P e t r ouni as Mi ni ng Temporal  F eat ures in Association Rules Proc. of PKDD\22299 Prague, Czech Republic, pp.295-300 


library reuse patterns in existing applications in a way that takes into account inheritance relationships Section 4 shows how browsing such reuse patterns for the KDE application framework can illustrate characteristic reuse in existing ap plications Section 5 discusses related work Section 6 sum marizes the paper, concluding with future work 2 DATAMINING Data mining may be defined as follows The process of nontrivial extraction of implicit previously unknown and potentially useful infor mation such as knowledge rules, constraints reg ularities from data 9 Data mining is widely used in business to gain a competi tive edge An effective data mining application in the retail environment is shopping basket analysis Progress in bar code technology has made it possible to store busker dura that contains items purchased on a per-transaction basis By using data mining technology one can find patterns in items that are bought in combination Association Rules Shopping basket analysis can be done by mining associa tion rules l Let I  il iz     im be a set of literals called items An association rule is an implication of the form AzEx z  AgEy y which we write more com pactly as X  Y where X c I Y c I and X n Y  8 Throughout this paper we shall distinguish sets of items from individual items by using upper and lower case letters respectively For example, suppose that people who purchase bread and butter also tend to purchase milk In that case the corre sponding association rule is 223breadAbutter*milk\224 The an tecedent of the rule X consists of bread and butter and the consequent Y consists of milk Such rules are useful for analyzing data For example to determine how one might boost the sales of milk, one could look for rules that have 223milk\224 in the consequent To deter mine the impact of discontinuing the sale of butter one could find all rules that have \223butter\224 in the antecedent Incidently observe that as we are using sets throughout, an item that occurs multiple times in a transaction is not treated any differently from one that occurs only once Confidence and Support Let D be a set of transactions where each transaction T is a set of items iremser such that T 5 I We say that a rule X  Y holds in transaction set D with confidence c if c of transactions in D that contain X also contain Y We say that itemset 2 has support s in transaction set D ifs of transactions in D contain 2 Support is also defined for rules X  Y has supporr s if itemset X U Y has support s For brevity we may at times write 223supp\(Q\to indicate the support of an itelnset or rule Q in D Returning to our example, suppose we find that in 90 of transactions in which customers purchase bread and butter they also purchase milk Moreover, say that 5 of trans actions include all three items bread butter and milk In that case the confidence of the rule 223breadAbutter=+milk\224 is 90 while its support is 5 Support should not be confused with confidence. While con fidence is a measure of the rule\222s strength support corre sponds to its statistical significance For example, a rule a A b  c may have much higher confi dence than a  c which means that whenever we encounter a in a transaction it is more likely we find c if b is also present So in that sense a A b  c is stronger than a sj c and we should take it more seriously in our analysis of the data As a side note this notion of rule strength is differ ent from logical implication in which case a  c would be considered stronger because it implies a A b 3 c Now support is a measure of statistical significance in the following sense if supp\(X  Y x supp\(X x supp\(Y then it is likely that X and Y are independent and co-occur in transactions by chance however if supp\(X  Y  supp\(X x supp\(Y then this is not likely to be the case 7 We make this argument more precise in Section 3 Retum ing to our example it may be that a  c is more statistically significant although a A b 9 c has higher confidence Association Rule Mining Problem Given a set of transactions D the problem of mining associ ation rules is the following Generate all association rules that have support s at least as great as some user-specified mini mum support smin and confidence c at least as great as some user-specified minimum confidence in Several algorithms have been presented in the literature for finding all such association rules Many of them are vari ations on the Apriori algorithm l which works in two phases 1 it finds all itemsets that have support above the minimum support and 2 it uses these itemsets to generate all rules whose confidence is above the minimum confidence In such an algorithm larger values of smin can reduce the running time significantly but larger values of Cmin have little effect on the running time \(although they do yield fewer rules of course Taxonomies In this paper we shall be concerned with generalized asso ciation rules which take into account the presence of tax onomies ll By taxonomies we mean 223is-a hierarchies\224 where a node\222s descendents represent specializations of that 168 


node For example, a taxonomy may indicate that white bread is a kind of bread and that skim milk is a kind of milk In that case, the taxonomy would have white bread as a descendent of bread and skim milk as a descendent of milk. As we shall see in Section 3 such taxonomies allow us to take into ac count the class inheritance hierarchy when mining for library reuse patterns Taxonomies allow us to mine for rules at different levels of abstraction This is important since interesting associations among data items often occur with more abstract concepts In particular, purchase patterns may not show any substantial regularities at the primitive data level but may show some interesting regularities at higher levels of abstraction For example, the rule \223white breadAbutter+skim milk\224 may have insufficient support using standard association rule min ing but 223breadAbutter+milk\224 may pass the support require ment using generalized association rules That is because additional transactions may support other kinds of bread and milk Formally speaking we model one or more taxonomies as a directed acyclic graph 7 on the items I  il i2     im Edges in the 7 denote is-a relationships among items Specifically an edge from c to p in 7 indicates that p is the parent of c and means that c is a particular kind of p or in other words that p is a generalization of c Generalized Association Rules Generalized association rules improve upon standard asso ciation rules by incorporating a taxonomy 7 In particular a generalized association rule is an implication of the form AzEx x  AyEY y  which we write as X  Y where X c I Y c I X n Y  0 and no item in Y is an ances tor of any item in X The reason for this latter requirement is that any rule of the form 223x ancestor\(x is true with 100 confidence and consequently redundant Before proceeding further we first define a partial order on itemsets using the taxonomy 7 In particular X  Y if and only if we can get from itemset Y to itemset X by replacing one or more items in Y with some ancestor\(s in 7 Observe that X may have fewer or greater items than Y for exam ple food  bread, butter and dairy product liquid  milk If X  Y then itemset X is an ancestor of Y or equivalently Y is a descendent of X Now we say that a generalized association rule X  Y holds in transaction set D with conjidence c if c of trans actions in D that contain X or a descendent of X also con tain Y or a descendent of Y Moreover itemset 2 has sup port s in transaction set D if s of transactions in D con tain 2 or a descendent of 2 Support for rules is defined as follows X  Y has support s if the itemset X U Y has 0 support s Our earlier observations with respect to confidence and sup port still apply in this more general context Moreover if a rule X  Y has minimum support and confidence then the rule X  ancestor\(Y is guaranteed to have both minimum support and confidence also However the rules ancestor\(X  Y and ancestor\(X  ancestor\(Y have minimum support but not necessarily minimum confidence To support taxonomies, one can use algorithms for mining standard association rules by considering \223extended transac tions\222\222 that contain not only the items in transactions but also their ancestors To make this process efficient certain op timizations are done to restrict the number of itemsets that need to be counted at various stages in the algorithm and the number of ancestors added to form extended transac tions  113 Finally there is also the problem that taxonomies tend to yield more rules many of which are redundant Conse quently pruning the output to show only 223interesting rules\224 is essential We shall describe our pruning technique in Sec tion 3 3 MINING REUSE PATTERNS Now that we have introduced generalized association rule mining in Section 2 we demonstrate how to apply this tech nology to discover library reuse patterns in existing appli cations We do this in a way analogous to that for discov ering items that are typically purchased together in basket data Specifically we identify library classes and member functions that are often reused in combination by application classes For example we may find that application classes that inherit from the library class Widget usually override its member function Widget::paint In that case we would generate the generalized association rule class-inheritswidget  class-overrides Widget::paint Of course, one might question the utility of such a rule It may be obvious from the library source that paint could be overridden in application classes \(perhaps because it is declared virtual in a language like C However, not all virtual functions are overridden with equal frequency If a member function is overridden most of the time  or under certain circumstances  then the developer should consider overriding the function in his own application under similar circumstances Applying Generalized Association Rule Mining Conceptually, our application of generalized association rule mining in the manner described above is simple However in practice, there are many issues to consider For exam ple what kinds of reuse relationships do we want to in clude How do we take advantage of the inheritance hier archy How do we prune the resulting rules 169 


In what follows we present a fairly detailed account of ap plying our approach to C software libraries and appli cations In particular we define our notion of items I  il iz     zm explain how to construct the set of transac tions D and present a taxonomy 7 over items I based on the class inheritance hierarchy While existing data mining algorithms can be used ll there are issues to consider while pruning the resulting gen eralized association rules Thus we conclude our discussion by describing the pruning process Items In our use of generalized association rules items indicate reuse relationships involving classes or member functions For example, a typical item might be class-inherits:Widget where the reuse relationship is inheritance and the class reused is Widget As another example the item class-ove rrides  W id get paint  indicates an overriding relationship with Widget\222s member function paint We associate with every application class A 221the set of all items I\(A that are involved in a reuse relationship with class A Returning to our example if a class mywidget only inherits from Widget and overrides paint then I\(myWidget class-inherits:Widget class-0verrides:Widget paint 1 Also the reuse relationship need not involve a library class For example if myDialog instantiates myButton then class-instantiates:myButtone I\(myDia1og The complete set of items I is defined as I  UA I\(A where the union is over all application classes A The set I contains items with reuse relationships that involve both application and library classes In what follows we shall expand on the various reuse rela tionships Before doing so we extend our notation to in clude library and application names as prefixes of classes and their member functions For example we shall write app\222myDialog to indicate that myDialog is defined in appli cation app Similarly we shall write lib\222Widget::paint to indicate that member function Widget::paint is defined, or at least declared as an abstract member in library lib Global functions such as main are represented by omitting the class name as with app\222maino There are five reuse relationships that we have considered in our research class inheritance, class instantiation function invocation, function overriding and implicit invocation. Al though our approach can be applied to any object-oriented programming language, we shall, for concreteness base our presentation on C For the reuse relationships mentioned we present the corresponding item types below  class-inherits:p\222class This item expresses a standard inheritance relationship Both single and multiple in heritance are allowed class-instantiates:p\222class We say that class or mem ber function A instantiates class B if and only if 1 A allocates an instance of B on the stack by way of a non-pointer variable of type B or 2 A allocates an instance of B on the heap using new or malloc Ei ther way A instantiates a new instance of B We only generate instantiation items for classes So if A is ac tually a member function of some class C then we say that C instantiates B and write this as the item class-instantiates:p\222B class-calls:p\222class::func If a function p\222A::f calls a function q\222B::g then we construct an item indicating a call made by class A class-calls:q\222B::g I\(p\222A class-overrides:p\222class::func If a class p\222A inherits from q\222B and overrides its member function q\222B::f then we construct the item class-overrides:q\222B::f class-receives-signaI:p\222class::signal If implicit invocation is used in the libraries and applications at hand we assume there is some way to easily identify how this is done through simple lexical analysis of the source If an object of type A broadcasts 223signal that is received by an object of type B then we construct an item class-receives-signaI:p\222A::signal I\(q\222B Moreover, we also include a class-calls item for the emission by A For each of the items defined above, there is also a corre sponding version with a 221-\222 symbol appended to the item class Such items are used whenever the corresponding ap plication class may reuse a descendent of the class in the item. For example if an application class is associated with class-instantiates:lib\222PushButton then we also associate the item class-instantiates:lib\222Button since PushButton inherits from Button 222hamactions We could simply define each transaction T\(A as equal to I\(A for each A That is simply include all items associated with each application class We could then prune uninterest ing rules after the data mining is complete However this would be very inefficient It pays to reduce the number of items in transactions as early as possible to reduce computa tional blowup in the mining process Recall that our goal is to identify how library classes are typ ically reused in existing applications Moreover we do not care so much about how library classes reuse other library classes nor how application classes reuse other application classes Rather we are interested in how application classes reuse library classes 170 


One might try to construct transactions consisting of those items associated with application classes that refer to library classes and functions. For example we could include an item like c1assjnherits:lib\222Widget in a transaction for applica tion class app\222mywidget but exclude any items referring to application classes or functions However there is a problem in doing this Con sider a class app\222myDialog that inherits from Iib\222Dialog and instantiates app\222myPushButton that in turn inher its from Iib\222PushButton In such a case we would like to include class-instantiates:app\222myPushButton in app\222my Dialog\222s transaction so that we may indirectly sup port the following generalized association rule class-inherits:lib\222Dialog  class,instantiates:lib\222Pus hButton Also suppose app\222myDialog makes a call to app\222myPushButton::show where show is defined in PushButton\222s ancestor Widget In that case we would like to include class-calls:app\222myPushButton::show in app\222myDialog\222s transaction so that we may indirectly support the following generalized association rule class-inherits:lib\222Dialog  class-calls:lib\222PushButton^::show Consequently we include additional items in transactions to make this possible In particular given the items I\(A for an application class A we include in T\(A only the following items in I\(A 1 all items involving a library class Iib\222A or member function lib\222A::f 2 those items involving appli cation classes app\222A that inherit directly or indirectly from a library class Iib\222B and 3 those items involving application member functions app\222A::f where class app\222A inherits di rectly or indirectly from a library class Iib\222B that defines or overrides member function f Taxonomy We define a taxonomy 7 in a way that mirrors the inher itance hierarchy Consider the set of all transaction items Itrans defined as Itrans  UA T\(A where the union is over all application classes A and T\(A denotes the items in the transaction for A For efficiency we construct a taxonomy that is induced by only those items in Itrans  First we consider items in Itrans that do not involve member functions These denote inheritance or instan tiation Without loss of generality we consider instan tiation inheritance is handled similarly For an item c1assJnstantiates:p\222Cc we consider all ancestors AI     Ak of C in the inheritance hierarchy The item class-instantiates:p\222C contributes the following to the taxonomy I 1 nodes class-instantiates:p\222C class-instantiates:p\222C class-instantiates:pl\222Al   class-instantiates:pk\222AkA 2 an edge from class-inhe ts:Widget i c1assinherits:lib\222Dialog pp\222myPushButtorP class-instantiates:lib\222PushButton class-instantiates:app\222my PushButton Figure 1 Items not involving member functions in taxon omy class-instantiates:p\222C to class-instantiates:p\222C 3 edges from class-instantiates:p\222C to class-instantiates:pi\222Ai where C inherits from Ai and 4 edges from class-instantiates:pi\222A to class-instantiates:pj\222Aj where A inherits from Aj  By distinguishing items using 221*\222 a user can tell whether a rule involves only the items mentioned or possibly their descendents For example a rule involving item class-instantiates:p,\222Ai makes it very clear that some application classes that support the rule may instanti ate a descendent of Ai However if the rule had class-instantiates:p,\222Ai then all application classes that support this rule instantiate Ai Finally observe that the min ing algorithm may generate both kinds of rules with differ ent confidence and support. Browsing both can be helpful in learning to use the library Let us again consider a class app\222myDialog that inher its from Iib\222Dialog and instantiates app\222myPushButton that in turn inherits from Iib\222PushButton The transaction for app\222myDialog contains items class-inherits:lib\222Dialog and class-instantiates:app\222myPushButton Figure 1 shows the contributions made by these two items to the taxonomy 7 Observe that another transaction has contributed the node class-instantiates:lib\222PushButton and the edge from class-instantiates:lib\222PushButton to class-instantiates:lib\222PushButton Next we consider items in Itran that do involve member functions. These denote function invocation, function over riding or implicit invocation We handle such items in much thesame way as those not involving member functions ex cept that we only consider ancestor classes that inherit or define the member function in question 171 


class-calls:lib\222PushButton::show class_calls:app\222myDialog::accepl class-callsapp\224yPush1utlon::show Figure 2 Items involving member functions in taxonomy For example suppose a class app\222myDialog calls app\222myDialog::accept and app\222myPushButton::show The trans action for app\222myDialog contains items class-cal1s:app\222my Dialog accept  and class-calls:app\222myPushButton::show Figure 2 shows the contributions made by these two items to the taxonomy 7 Observe that another transaction has con tributed the node class-calls:lib\222PushButton::show and the edge from class-calls:lib\222PushButton::show to class-calls:lib\222PushButton^::show Pruning We do not present all generalized association rules to the user but only those that we deem 223interesting\224 This is par ticularly important since in practice we find that there are thousands of similar andlor redundant rules that would over whelm the user otherwise We shall assume that there is only one item in the consequent of each generalized association rule This is not a serious limitation since X  y1 A y2 A  A yn is logically equivalent to X  y A X  yz A  A X  yn so instead of showing a rule with n items in the consequent to the user, we instead show n rules each having a consequent of one item Global Pruning Initially we perform a global pruning that is applied to all rules discovered by data mining Afterwards we shall per form local pruning on various subsets of rules that survive global pruning Uninteresting Rules We prune rules such as the following class-calls:lib\222A::f  class-instantiates:lib\222A Such a rule is hardly surprising It is quite likely that any reuse of a class member function implies that the class is inherited from or instantiated at some point Consequently we prune rules where an item in the antecedent involves a member function lib\222A::f and an item in the consequent instantiates or inherits a class B  where B may be A an ancestor of A or a descendent of A  that defines or inherits member function f In addition we prune rules with a class in the an tecedent that is a strict descendent or ancestor of the class in the consequent For example, a rule such as c1assJnstantiates:lib\222K  class-calls:lib\222B::f is pruned if and only if A is a descendent of B or B is a descendent of A The rationale behind this heuristic is to avoid the numerous rules that would result in a deep inheritance hierarchy e.g if say A has many descendents B Misleading Rules Some generalized association rules are misleading 2 For example, suppose the rule xAy  z has confidence 60 while the rule y  z has confi dence 80 In that case the first rule is misleading since the presence of x actually decreases the likeli hood of finding the item z More generally given a rule X  y with confidence c we say it is mislead ing if and only if there is another rule X\222  y with confidence c\222 where 8 C X\221 C X c%/d  y and where y is a user-defined threshold typically set at one or over In this case we allow X\222  8 in this other 223rule\224 in which case the confidence is simply the sup port of item y Statistically Insignificant Rules We can view the sup port of an itemset X as the probability of finding X in a transaction A rule X 3 Y is not very interesting to us if X and Y just happen to co occur in transactions by chance Specifically if supp\(X  Y x supp\(X x supp\(Y then it is likely that X and Y are independent and X  Y would not be statistically significant Yet if supp\(X  Y  supp\(X x supp\(Y then this is not likely to be the case More specifically suppose we find that X and Y have supports p and py which we shall use as esti mates for the true probabilities of finding the respective itemsets in any given transaction If we assume that X and Y are independent then the probability of finding both in a particular transaction is pZpy Now suppose we have n transactions and the rule X 3 Y occurs in k of them \(with support k/n Then the probability that X  Y occurs in k or more transactions assuming that X and Y are independent is 7 172 


Clearly the lower the above probability  the so-called p-value  the more statistically significant the rule X  Y since it is less likely that X and Y are inde pendent In our experiments we ensure that all rules have p-values of X or less, where X is a user-specified threshold Local Pruning In addition to the global pruning described above we also prune locally on various subsets of the rules discovered Specifically our tool allows the user to browse 1 rules that demonstrate reuse of a particular library class and 2 rules that are violated in a particular application \(where the tool acts like a \223reuse lint\224 In the former case we consider only the set of rules with that library class in the antecedent or consequent In the latter case we consider only those rules that are violated by at least one class in the application of interest. Either way once we have extracted the subset of rules we follow the same local pruning procedure when presenting the results to the user The motivation for local pruning is the following given the presence of a particular rule, another rule may not be surpris ing to us In that case it is desirable to additionally prune the latter rule to focus the user\222s attention on those rules that are interesting The pruning process that follows builds upon several existing techniques 2 111 Consider rules X  y and rule X\222  y, where X\222 is a sub set of X If we know the confidence c\222 for rule X\222  y then we expect the confidence for rule X  y to also be c\221 since there is no reason to believe  without prior knowl edge of the library and/or applications  that the additional items X-X\222 in the antecedent are likely to increasefdecrease the occurrence of y. Thus we shall consider pruning X  y if its confidence c is not much greater than c\221 More specifically we set an interest threshold 6 and prune any such rule X  y where c%/c\221  6 If it is not pruned we say that X  y is interesting with respect to X\222  y We also perform anotherform of pruning Suppose we have two rules X  y and X 3  where X is an ancestor of itemset X contqning the same number of items \(where 223an cestor\224 means X  X as defined in Section 2 or Q is an ancestor of y or both In such a cye we may keep the more specific rule X  y and prune X 3 6 Generally speaking we would like to show the more specific rule which tends to be more informative However we may also wish to show the more general rule if its confidence is much greater than expected If X  y has confidence c then X  y has expected confidence c since there is no reason to believe without prior knowledge, that y is more/less likely to be in a trans action with X than one with X However as  is an an cestor of y the rule X   clearly has confidence c and possibly much more To get a reasonable estimate for ex pected support we shall assume prior knowledge of the rel ative support of y and  With such knowledge we would expect X  Q to have y  c since of those transactions that support X we would expect supp\(Q y of them to support Q By the first observation X  y has expected confidence-c Given the confidence c for X  y we would expect X   to have y  c as explained above Consequently we prune the rule X  ij if and only if supp~~~~~upp~y~~~c  6 for some interest threshold 6 Finally combining this analysis with our earlier results on smaller antecedents X\222 we shall prune a rule X  ij given confidence c\222 for X\222  y if and only if  6 This follows because the ex pected confidence for X  y is the same as the confidence c\222 for X\222  y Now we are ready to describe the complete pruning proce dure Given a set of rules XI  y1    X  yn we first construct a partial order with a node for each rule The nodes in the partial order are ordered as follows Xi  yi  Xj  yj if and only if 1 the rules are not identical 2 0 E Xi C Xj and 3 X is more specific than or equal to Xj and y is a descendent of or equal to yj Pruning proceeds by considering the nodes of the partial or der in topological sort order That is, an ancestor is always processed before its descendents In this process a rule X  y is not pruned if and only if it is &interesting with respect to all ancestors in the partial order that have survived the pruning process to that point 4 BROWSING REUSE PATTERNS In this section we shall demonstrate how one might browse and learn from generalized association rules by considering code written for the KDE desktop environment. The KDE li braries provide a C application framework for developing GUI applications. In our experiment we have mined reuse patterns for the KDE 1.1.2 core libraries \(which include the Qt toolkit by analyzing 76 real-life applications Specifically, we have used our tool CodeWeb to mine for generalized association rules with confidence of at least 10 and support of at least 15 transactions There were 1365 transactions total so the support requirement as a percentage is about 1.1 The global pruning parameters were set at y  1.25 and X  0.01 The local pruning parameter 6 was set to 1.25 Only rules with one item in the antecedent and one item in the consequent were considered To contrast generalized association rule mining with our ear lier work on standard association rule mining we also in clude the data mining results where inheritance was ignored all together On a Sparc Ultra 1 mining generalized asso ciation rules took about 50 minutes while mining standard E supp~g~~supp~y~~~c E 173 


association rules took 20 minutes The rule statistics are as follows Rules Global Pruning Mined Uninteresting Misleading Insignificant Generalized 5 1308 13299 1904 6681 Standard 21594 996 320 978 Rules Left 34271 19636 Observe that while the number of rules mined by generalized association rules is significantly more than that using stan dard association rules a greater percentage of these rules is eliminated during global pruning Of course the number of rules pruned locally varied depending upon the local context and is not shown here Typically a developer just starting out with a library would identify important library classes and browse their reuse pat terns By 223important\224 we mean those library classes that are reused in many existing applications and are thus likely to be relevant in new applications also For example, a developer using our tool would notice that the KDE classes KApplica tion and QObject are reused in 99 and loo respectively of the 76 applications mined  and are thus essential in any KDE application We consider the reuse patterns for these two classes in what follows KApplication Reuse Patterns Figure 3 shows all reuse patterns predicated on the instanti ation of KApplication in an application class The support ers of a rule are those application classes for which all rule items apply For example, an application class that supports reuse pattern 1 must instantiate KApplication and calls its member function exec We also show the detractors of a rule which are those application classes for which the an tecedent items apply but where the consequent item does not hold For example, an application class that detracts from reuse pattern 1 must instantiate KApplication and not call exec Our tool allows users to browse the source code for both supporters and detractors of reuse patterns these ap plication classes illustrate characteristic and uncharacteristic reuse respectively In Figure 3 we find  among other things  that of those applications classes that instantiate the KApplication class 72.3 call its member function exec 58.5 instantiate KT~pLevelWidget 53.8 call the member function set Mainwidget of the class KApplication and 46.2 call the show member of the class KTopLevelWidget Re call that the symbol 221A\222 indicates that some application class may reuse a strict descendent of KTopLevelWidget rather than the class itself By browsing reuse patterns in combination with library ref erence documentation which is usually available\and appli cation source code a developer can learn to use a library by example in much the same way as studying manually con structed tutorials and/or toy programs both of which may not be available For example, doing this for the rules in Figure 3 reveals that the class KApplication instantiated in the main function of most KDE applications manages the application event queue We also observe that applications inherit from KTo pLevelWidget to define the main widget of the application e.g one that is not contained in any other this widget is then instantiated and a call to setMainWidget0 tells the li brary that whenever the user closes this widget that the appli cation should terminate all together Afterwards the exec member of KApplication is called to enter the main event Finally it turns out that all applications that instantiate KTo pLevelWidget always instantiate a descendent that they de fine Without taking into account the inheritance hierarchy e.g using generalized association rules we would miss reuse patterns involving this class all together QObject Reuse Patterns The class QObject is an ancestor of almost all classes in the KDE libraries According to the reference documentation this class provides facilities for event handling and timing operations Figure 4 shows some of the reuse patterns re ported by our tool for QObject of the 53 rules found for this class 47 involve a 221*\222 symbol in the antecedent and/or consequent It turns out that application classes rarely reuse QObject directly; typically they reuse it indirectly through one of its descendents Although QObject is very funda mental to the KDE libraries only six rules would have been found without taking into account the inheritance hierarchy 5 RELATEDWORK In this paper we have looked for pattems in the way library classes have been reused in practice by existing applications In this section we shall talk about several related techniques Exemplars An exemplar is an executable visual model consisting of one or more instances of at least one concrete class for each ab stract class in a library 6 By browsing these classes as well as their static relationships and dynamic interactions one can get a general understanding of how the framework works in a small example While an exemplar may be helpful it is a pre-selected toy example that may not be representative of 223real-life\224 appli cations Moreover, exemplars place an extra burden on the developers of the software library In contrast our approach allows the user to browse reuse patterns and the correspond ing supporter and detractor classes in real-life applications Moreover, the tool is automated and works on any existing code Reengineering Libraries Recently research has been done on reengineering libraries by analyzing their usage in several existing applications lo This is done by constructing a lattice that provides insights loop 174 


lllllll_l  Figure 3 KApplication reuse patterns Clicking on kasteroids a supporter of reuse pattern 1 yields the code on the right Figure 4 QObject reuse patterns 175 


into the usage of the class hierarchy in a specific context Such a lattice can be used to reengineer the library class hi erarchy to better reflect standard usage In contrast we are interested in helping novice users learn to use a library to write new applications  not reengineer the library itself This different perspective has led us to 1\initiate a new search direction for mining code for the purposes of illus trating characteristic code reuse 2 use data mining tech niques that scale to a hundred or more applications  not just a few examples for which confidence and support mea sures would not be meaningful 3 look for different kinds of reuse patterns that are more helpful for demonstrating reuse of the library classes and 4 construct a tool whose user in terface is aimed at users of a software library rather than its developers Other Work involving Data Mining Researchers have used data mining and related techniques for a variety of purposes. For example, data mining has been used to discover likely program invariants infer spec ifications in software 3 and decompose a software sys tem into data cohesive subsystems to assist developers with reengineering and maintenance tasks 4 The last of these is the only other work we are aware of that uses association rule mining in the software engineering domain 6 CONCLUSIONS AND FUTURE WORK In this paper, we have shown how data mining can be used to discover library reuse patterns in existing applications Specifically we considered the problem of discovering li brary classes and member functions that are typically reused in combination by application classes This paper improves upon our earlier research using \223associ ation rules\224  by taking into account the inheritance hier archy using \223generalized association rules\224 This has turned out to be non-trivial due to the significantly larger number of rules that arise as a result Consequently, pruning is impor tant and we showed several ways in which it can be done By browsing generalized association rules a developer can discover patterns in library usage in a way that takes into ac count inheritance relationships We have illustrated the ap proach using our tool CodeWeb by demonstrating charac teristic ways in which applications reuse classes in the KDE application framework We have observed that some impor tant rules would not have been found without taking into ac count the inheritance hierarchy I One can view our general approach to mining reuse patterns as learning from positive experience That is, library reuse that has worked in practice Presumably, one would se lect 223stable\224 applications to demonstrate reuse patterns in a library However one can also mine negative experi ence That is misunderstandings and problems that came up when reusing components from a software library For future work it would be interesting to determine if one can  mine negative experience in an automated way perhaps by analyzing application CVS logs for reuse patterns that were problematic and later corrected REFERENCES  11 R Agrawal and R Srikant Fast algorithms for mining association rules In Proceedings of the 20th Very Large Data Bases Conference pages 487499,1994 2 M Chen J Han and P S Yu Data mining An overview from a database perspective ZEEE Transac tions on Knowledge and Data Engineering 8\(6 883,1996 3 W W Cohen. Inductive specification recovery Under standing software by learning from example behaviors Automated Software Engineering 2\(2 107-129,1995 4 C Montes de Oca and D L Carver Identification of data cohesive subsystems using data mining tech niques. In Proceedings of the Zntemational Conference on Software Maintenance pages 1623,1998 5 M D Ernst J Cockrell W G Griswold and D. Notkin. Dynamically discovering likely program in variants to support program evolution. In Zntemational Conference on Software Engineering pages 2 13-224 1999 6 D Gangopadhyay and S Mitra. Design by framework completion Automated Software Engineering 3:219 237,1996 7 N Megiddo and R Srikant Discovering predictive as socation rules In Proceedings of the 4th International Conference on Knowledge Discovery in Databases and Data Mining 1998 8 A Michail Data mining library reuse patterns in user selected applications In 14th ZEEE Zntemational Con ference on Automated Software Engineering pages 24 33, 1999 9 G Piatetsky-Shapiro and W J Frawley Knowledge Discovery in Databases AAAVMIT Press 1991  101 G Snelting and F Tip. Reengineering class hierarchies using concept analysis In 6th ACM SIGSOFT Intema tional Symposium on the Foundations of Software En gineering pages 99-1 10,1998  113 R Srikant and R Agrawal Mining generalized associ ation rules In Proceedings of the 21st Very Large Data Bases Conference 1995  121 Will Tracz Confessions of a Used Program Salesman Institutionalizing Sofhyare Reuse Addison-Wesley 1995 176 


18001  balancing mechanism which requires further investi gation 4.5 Speedup Figure 12 shows the speedup ratio for pass 2 vary ing the number of processors used, 16 32 48 and 64 where the curve is normalized with the 16 processor execution time The minimum support value was set to 0.4 4.5 0.5 1 1 0 I 10 20 30 40 50 60 70 number of mxessors Figure 12 Speedup curve NPA HPA and HPA-ELD attain much higher lin earity than SPA HPA-ELD an extension of HPA for extremely large itemset decomposition further in creases the linearity HPA-ELD attains satisfactory speed up ratio This algorithm just focuses on the item distribution of the transaction file and picks up the extremely frequently occurring items Transferring such items could result in network hot spots HPA-ELD tries not to send such items but to process them locally. Such a small mod ification to the original HPA algorithm could improve the linearity substantially 4.6 Effect of increasing transaction Figure 13 shows the effect of increasing transac tion database sue as the number of transactions is increased from 256,000 to 2 million transactions We used the data set t15.14 The behavior of the results does not change with increased database size The minimum support value was set to 0.4 The num ber of processors is kept at 16 As shown each of the parallel algorithms attains linearity 5 Summary and related work In this paper we proposed four parallel algorithms for mining association rules A summary of the four database size Sizeup 0 I 0 500 loo0 1500 uxw amount of transaction thousands Figure 13 Sizeup curve algorithms is shown in Table 5 In NPA the candi date itemsets are just copied amongst all the proces sors Each processor works on the entire candidate itemsets NPA requires no data transfer when the supports are counted However in the case where the entire candidate itemsets do not fit within the mem ory of a single processor the candidate itemsets are divided and the supports are counted by scanning the transaction database repeatedly Thus Disk 1/0 cost of NPA is high PDM, proposed in 6 is the same as NPA which copies the candidate itemsets among all the processors Disk 1/0 for PDM should be also high The remaining three algorithms SPA HPA and HPA-ELD partition the candidate itemsets over the memory space of all the processors Because it better exploits the total system's memory, disk 1/0 cost is low SPA arbitrarily partitions the candidate itemsets equally among the processors Since each processor broadcasts its local transaction data to all other pro cessors the communication cost is high HPA and HPA-ELD partition the candidate itemsets using a hash function which eliminates the need for transac tion data broadcasting and can reduce the comparison workload significantly HPA-ELD detects frequently occurring itemsets and handles them separately which can reduce the influence of the workload skew 6 Conclusions Since mining association rules requires several scans of the transaction file its computational requirements are too large for a single processor to have a reasonable response time This motivates our research In this paper we proposed four different parallel algorithms for mining association rules on a shared nothing parallel machine and examined their viabil 29 


Table 5 characteristics of algorithms ity through implementation on a 64 node parallel ma chine the Fujitsu AP1000DDV If a single processor can hold all the candidate item sets parallelization is straightforward It is just suf ficient to partition the transaction over the proces sors and for each processor to process the allocated transaction data in parallel We named this algo rithm NPA However when we try to do large scale data mining against a very large transaction file the candidate itemsets become too large to fit within the main memory of a single processor In addition to the size of a transaction file a small minimum support also increases the size of the candidate itemsets As we decrease the minimum support computation time grows rapidly but in many cases we can discover more interesting association rules SPA HPA and HPA-ELD not only partition the transaction file but partition the candidate itemsets among all the processors We implemented these al gorithms on a shard-nothing parallel machine Per formance evaluations show that the best algorithm HPA-ELD attains good linearity on speedup by fully utilizing all the available memory space which is also effective for skew handling At present we are doing the parallelization of mining generalized association rules described in 9 which includes the taxonomy is-a hierarchy Each item belongs to its own class hierarchy In such mining associations between the higher class and the lower class are also examined Thus the candidate itemset space becomes much larger and its computation time also takes even longer than the naive single level association mining Parallel pro cessing is essential for such heavy mining processing Acknowledgments This research is partially supported as a priority research program by ministry of education We would like to thank the F\221ujitsu Parallel Computing Research Center for allowing us to use their APlOOODDV sys tems References l R.Agrawal T.Imielinski and ASwami 223Min ing Association Rules between Sets of Items in Large Databases\224 In Proc of the 1993 ACM SIGMOD International Conference on Manage ment of Data pp207-216 May 1993 2 R.Agrawal and RSrikant 223Fast Algorithms for Mining Association Rules\224 In Proc of the 20th International Conference on Very Large Data Bases pp.487-499 September 1994 3 J.S.Park M.-S.Chen and P.S.Yu 223An Effec tive Hash-Based Algorithm for Mining Associ ation Rules\224 In Proc of the 1995 ACM SIG MOD International Conference on the Manage ment of Data SIGMOD Record Vo1.24 pp.175 186 June 1995 4 H.Mannila H.Toivonen and A.I.Verkamo 223Ef ficient Algorithms for Discovering Association Rules\224 In KDD-94:AAAI Workshop on Knowl edge Discovery in Databases pp.181-192 July 1994 5 A.Savasere, E.Omiecinski and S.Navathe 223An Effective Algorithm for Mining Association Rules in Large Databases\224 In Proc of the 21th International Conference on Very Large Data Bases pp.432-444 September 1995 6 J.S.Park M.-S.Chen and P.S.Yu 223Efficient Parallel Data Mining for Association Rules\224 In Proc of the 4th International Conference on In formation and Knowledge Management pp.31 36 November 1995 7 T.Shintani and M.Kitsuregawa 223Considera tion on Parallelization of Database Mining\224 In Institute of Electronics Information and Com munication Engineering Japan SIG CPS Y95 88 Technical Report Vo1.95 No.47 pp.57-62 December 1995 8 T.Shimizu T.Horie and H.Ishihata 223Perfor mance Evaluation of the APlOOO Effects of message handling broadcast and barrier syn chronization on benchmark performance-\224  In S WO PP 22292 9.2 ARC 95 Information Processing Society of Japan Vo1.92 No.64 1992 9 R.Srikant and R.Agrawal 223Mining Generalized Association Rules\224 In Proc of the 21th Inter national Conference on Very Large Data Bases pp.407-419 September 1995 30 


Plenary Panel Session 30 XML Databases   Moderator: Michael Carey, IBM Almaden Research Center USA Panelists Adam Bosworth, Microsoft Corporation USA David De Witt University of Wisconsin-Madison, USA Alon Levy University of Washington USA Bruce Lindsay IBM Almaden Research Center USA Jennifer Widom Stanford University USA Demo Session 1 Web Query Optimizer  661 V Zadorozhny L Bright L Raschid T Urhan and M Vidal ReQueSS: Relational Querying of Semi-structured Data  664 R Sunderraman The IDEAL Approach to Internet-Based Negotiation for E-Business  666 J Hammer C Huang Y Huang C Pluempitiwiriyawej M Lee H Li L Wang Y Liu and S Su READY A High Performance Event Notification Service  668 R Gruber B Krishnamurthy, and E Panagos A Multimedia Information Server with Mixed Workload Scheduling  670 G Nerjes DISIMA An Object-Oriented Approach to Developing an Image Database System  672 V Oria T Ozsu P Iglinski B Xu and L Cheng Demo Session 2 The Collaboration Management Infrastructure  677 H Schuster D Baker A Cichocki D Georgakopoulos and M Rusinkiewicz Assisting the Integration of Taxonomic Data The LITCHI Toolkit  679 I Sutherland J Robinson S Brandt A Jones S Embury W Gray R White and F Bisby TheaterLoc: Using Information Integration Technology to Rapidly Build Virtual Applications  681 G. Barish Y.4 Chen D Dipasquo, C Knoblock S Minton I Muslea and C Shahabi Lineage Tracing in a Data Warehousing System  683 Y Cui and J Widom xiii 


The Mentor-Lite Prototype A Light-Weight Workflow Management System  685 J Weissenfels M Gillmann 0 Roth, G Shegalov and W Wonner Location Prediction and Queries for Tracking Moving Objects  687 0 Wolfson B Xu and S Chamberlain Semiorder Database for Complex Activity Recognition in Multi-Sensory Environments  689 S Bhonsle A Gupta S Santini and R Jain Tutorial 1 Web Information Retrieval  693 M Henzinger Tutorial 2 Mobile and Wireless Database Access for Pervasive Computing  694 P Chrysanthis and E Pitoura Tutorial 3 Data Mining with Decision Trees  696 J Gehrke Tutorial 4 Directories Managing Data for Networked Applications  697 D Srivastava Tutorial 5 Indexing High-Dimensional Spaces Database Support for Next Decade\222s Applications  698 S Berchtold and D Keim xiv 


 T5.I2.D100K T10.I4.D100K T15.I4.D100K T10.I6.D400K T10.I6.D800K T10.I6.D1600K Optimizations across Databases 5 0 5 10 15 20 25 30 35 40 45 Improvement COMP TREE COMP-TREE 1 2 4 8 1 2 4 8 1 2 4 8 2 4 8 2 4 8 1 2 4 8 Processors Databases Figure 5 Effect of Computation and Hash Tree Balancing good as the COMP optimization The reason that the hash tree balancing is not suf\336cient to offset inherent load imbalance in the candidate generation in this case The most effective approach is to apply both optimizations at the same time COMP-TREE The combined effect is suf\336cient to push the improvements in the 40 range in the multiple-processor case On 1 processor only hash tree balancing is bene\336cial since computation balancing only adds extra cost 5.4 Short-circuited Subset Checking Figure 6 shows the improvement due to the short-circuited subset checking optimization with respect to the unoptimized version The unoptimized version is the Apriori algorithm due to Agrawal et al 5 The results are presented for dif ferent number of processors across dif ferent databases The results indicate that while there is some improvement for databases with small transaction sizes the optimization is most effective when the transaction size is large In this case we get improvements of around 25 r the unoptimized version To gain further insight into this optimization consider 336gure 7 It shows the percentage improvement obtained per iteration on applying this optimization on the T20.I6.D100K database It shows results only for the uni-processor case r similar results were obtained on more processors We observe that as the iteration k increases there is more opportunity for shortcircuiting the subset checking and we get increasing bene\336ts of up to 60 The improvements start to fall off t the high end where the number of candidates becomes small resulting in a small hash tree and less opportunity for short-circuiting It becomes clear that is an extremely effective 15 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 T5.I2.D100K T10.I6.D800K T15.I4.D100K T20.I6.D100K procs across Databases 0 5 10 15 20 25 Improvement 1 2 4 8 Figure 6 Effect of Short-circuited Subset Checking 23456789101112 Iterations 0 10 20 30 40 50 60 improvement T20.I6.D100K Figure 7  Improvement per Iteration  proc   16 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


optimization for larger transaction sizes and in cases where there are large number of candidate k itemsets 6 Conclusions In this paper e presented a parallel implementation of the Apriori algorithm on the SGI Power Challenge shared memory multi-processor We also discussed a set of optimizations which include optimized join and pruning computation balancing for candidate generation hash tree balancing and short-circuited subset checking We then presented experimental results on each of these Improvements of more than 40 were obtained for the computation and hash tree balancing The short-circuiting optimization was found to be extremely effective for databases with large transaction sizes Finally we reported the parallel performance of the algorithm While we d good speed-up we observed a need for parallel I/O techniques for further performance gains References  R Agra wal T  Imielinski and A Swami Database mining A performance perspecti v e  I n IEEE Trans on Knowledge and Data Engg  pages 5\(6 1993  R Agra wal T  Imielinski and A Swami Mining association rules between sets of items in lar ge databases In Proc M SIGMOD Intl Conf Management of Data  May 1993  R Agra wal H Mannila R Srikant H T o i v onen and A I V erkamo F ast disco v ery of association rules In U F et al editor Advances in Knowledge Discovery and Data Mining  MIT Press 1996  R Agra wal and J Shafer  P arallel mining of association rules design implementation and e xperience Technical Report RJ10004 IBM Almaden Research Center San Jose CA 95120 Jan 1996  R Agra wal and R Srikant F ast algorithms for mining association rules In Proc 20th VLDB Conf  Sept 1994  M Cierniak W  Li and M J Zaki Loop scheduling for heterogeneity  I n 4th IEEE Intl Symposium on High-Performance Distributed Computing also as URCS-TR 540 CS Dept Univ f Rochester  Aug 1995  M Holsheimer  M  K ersten H Mannila and H T o i v onen A perspecti v e on databases and data mining In 1st Intl Conf Knowledge Discovery and Data Mining  Aug 1995  M Houtsma and A Swami Set-oriented mining of association rules In RJ 9567  IBM Almaden Oct 1993  H Mannila H T o i v onen and I V erkamo Ef 336cient algorithms for disco v ering association rules In AAAI Wkshp Knowledge Discovery in Databases  July 1994  J S P ark M Chen and P  S Y u  A n e f fecti v e hash based algorithm for mining association rules In Proc M SIGMOD Intl Conf Management of Data  May 1995 17 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 J S P ark M Chen and P  S Y u  E f 336cient parallel data mining for association rules T echnical Report RC20156 IBM T J Watson Research Center Aug 1995  G Piatetsk y-Shapiro Disco v ery  presentation and analysis of strong rules In G P S et al editor  KDD  AAAI Press 1991  A Sa v asere E Omiecinski and S Na v athe An ef 336cient algorithm for mining association rules in large databases In Proc 21st VLDB Conf  1995  M J Zaki M Ogihara S P arthasarathy  and W  Li P arallel data mining for association rules on shared-memory multi-processors Technical Report 618 Department of Computer Science University of Rochester 618 1996 18 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


