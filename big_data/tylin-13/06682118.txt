Abstract 
In large scale Internet of Things \(IoT\stems statistical analysis is a crucial technique for transforming data into knowledge and for obtaining overall information about the physical world.  However most existing statistical analysis methods for sensor sampling data are impleme nted outside the database kernel and focus on 
 Zhiming Ding, Xu Gao, Jiajie Xu, and Hong Wu Institute of Software, Chin ese Academy of Sciences Beijing 100190, P.R.China zhiming, gaoxu jiajie, wuhong}@iscas.ac.cn   
IOT-StatisticDB: A General Statistical Database Cluster Mechanism for Big Data Analysis in the Internet of Things 
specialized analytics, making them unsuited for the IoT environment where both the data types and the statistical queries ar e diverse. To solve this problem, we propose a General Statistical Database Cluster Mechanism for Big Data Analysis in the Internet of Things Keywords - Statistical Database, Internet of Things, Big Data 
IOT-StatisticDB\this paper. In IOT-StatisticDB, statistical functions are performed through statistical operators inside the DBMS kernel, so that complicated statistic al queries can be expressed in the standard SQL format. Besides, statistical analysis is executed in a distr ibuted and parallel manner over multiple servers so that the performance can be greatly improved, which is co nfirmed by the experiments 
Sensor Sampling Data, Spatial-Temporal Data 
I I NTRODUCTION  With the recent advances in sensor networks and in the Internet of things \(IoT\atistical analysis of massive sensor data becomes a key research issue. In a large scale IoT system, there are numerous sensors and / or monitoring devices connected, which repeatedly send sampling data to the data center. The data center not only needs to store manage, and query the individual sampling data efficiently but also needs to conduct statistical analysis in order to extract more general informati on about the physical world Such a scenario is a typical big data environment because of 
the huge volume of data and high frequency of updates. As a result, a lot of challenging prob lems need to be solved Statistical analysis of sensor sampling data is one of the most important procedures in IoT systems in order to transform çdataé into çknowledgeé, and is crucial in a lot of applications like disaster monitoring, emergency management, e-health, intelligen t transportation systems and so forth. As an example, letês consider the pollution monitoring in a large city. Each pollution sensor can only monitor a small area, and only through statistical analysis we can get more general information over large areas such as  what is the most polluted region of the city 
how the most polluted region changes over time 
and It is obvious that such general information is far more important than the individual sampling valu es collected from the sensors Another example is traffic flow analysis through GPStracked vehicles \(or çmoving objectsé\moving object can sample its motion vectors \(including location, speed, and direction\atedly through GPS an d send them to the data center. However, a motion vector can only reflect the status of a certain vehicle at a certain time instant. To get the traffic flow information of the whol e traffic network, statistical analysis should be conducted 
based on huge numbers of motion vectors There are many existing works which can be used for statistical analysis on sensor sampling data. However, most of them are implemented outside the database kernel, and focus on the specialized analytic methodologies making them unsuited for the IoT environment where both the data types and the statistical queries are heterogeneous and diverse. For instance, in a modern intelligent transportation system, there coul d be many different kinds of sensors which can collect raw data for traffic flow analysis, like loop sensors, traffic video cameras, GPS 
sens ors RF ID rea ders  optic al sens ors m i crowa ve vehic l e detectors, and so forth. The sampling data of these sensors have totally deferent formats and semantics. Therefore, each kind of sensors needs a different statistical analysis module which could be a heavy work load for system developers On the other hand, if we support generalized statistical analysis in database kernel level, then complicated statistical analysis can be easily expressed in the standard SQL interface  Another lim itation for existing statistical analysis methods is that most of them are centralized solutions [5  whic h are uns uited for bi g data analysi s For insta n ce  
the most effective clustering algorithms, DBSCAN  OPTICS [7  K Mean s and its variations [9-10 are all designed for centralized data analysis environments and can not be directly used in distributed and parallel environments. Besides, a lot of index methods to speed up the statistical analysis are no t suited for the IoT environment because the frequent data updates can cause very high index update costs There are several database management systems which can support statistical analysis on structured data However, only simple statistical functions \(like average 
2013 IEEE International Conference on Green Computing and Communications and IEEE Internet of Things and IEEE Cyber Physical and Social Computing 978-0-7695-5046-6/13 $26.00 © 2013 IEEE DOI 10.1109/GreenCom-iThings-CPSCom.2013.104 535 


 spatialAggrEU parameterAggrEU spatialAggrNet parameterAggrNet 
Spatial Aggregation Parameter Aggregation Euclidean-Based Network-Based 
IoT-Storage and Statistics Layer IoTR aw Data Storage Layer Sersor and Monitoring Device Layer  
Master Server Node Servers Sampling Recerver 
116.17 116.4 116.73 117.17 117.4 115.4 115.73 39.2 41.2 39.6 40 40.4 40.8 A ir Pollution Index Output of the statistical query 300 600 0 
 min, max, and count can be supported while spatialtemporal statistical analysis and network-based analysis on large-scale sensor sampling data can not be supported It is thus critical to investigate th e database kernel level parallel statistical analysis techniques for massive sensor sampling data in the In ternet of Things. Under the framework of IoT database cluster, we seek to design some general statistical operators that can be used in SQL such that the complicated statistical analysis requirements can be easily expressed in a generalized manner. In this way, the application designers and th e system developers can work collaboratively in different la yers, which can significantly improve the efficiency of IoT system development However, according to literature analysis, there is no existing work in this direction To solve the above problems, we propose a 
General Statistical Database Cluster Mechanism for Big Data Analysis in the Internet of Things A Architecture of IOT-StatisticDB What is the geographical area in Beijing with air pollution index exceeding the threshold 002=300 currently Tell me the road sections where the vehicle speed is slower than 5 km/h in the WestBeijing area at time t What is the average PM2.5 level in Beijing at time t Tell me the traffic parameters of every road section in West Beijing 
GPS Sensors V ideo Monitors Telemetric Monitors Geological Sensors Hydrological Sensors Traffic Sensors  Raw Data Storage Raw Data Storage  Raw Data Storage  Raw Data Storage Raw Data Storage  Raw Data Storage 
IOT-StatisticDBé for short\n this paper. The remaining part of this paper is organized as follows: Section 2 describes the architecture the data types, and operators of IOT-StatisticDB, Section 3 presents the parallel statistical analysis methods of IOTStatisticDB, Section 4 discusses implementation issues and performance evaluation results, and Section 5 finally concludes the paper II A RCHITECTURE OF IOT-S TATISTIC DB AND THE D ATA T YPES AND O PERAORS FOR S TATICAL A NALYSIS  In many applications like environment monitoring, we need to conduct complex statistical analysis to understand the physical world and to explore useful knowledge based on the IoT sampling data. We should notice that many applications require similar or even the same statistical operations at the database leve l. This observatio n motivates us to propose a databa se kernel level statistical analysis mechanism to support high performance common analytics on IoT sampling data Among the complex statistical analysis operations in demand, we classify some typi cal ones and implement uniform operators for them. In general, most of the statistical operations in IoT systems can be classified into spatial aggregations and parame ter aggregations. For a given data set, spatial aggregations can cluster the geographical values extracted from sensor data to larger groups so that meaningful knowledge about spatial distributions can be extracted. On the other hand, parameter aggregations allow us to get aggregation information like average, minimum, maximum, and count from the sensor sampling values In addition, both param eter aggregations and spatial aggregations can be further divided into Euclidean-based and network-based. Euclidean-based aggregations do not consider traffic networks whi le network-based aggregations take the underline traffic networks into account. Therefore in IOT-StatisticDB, we can have 4 kinds of statistical analysis methods, designed as statistical analysis operators as shown in Table 1 TABLE I C LASSIFICATION OF S TATISTICAL A NALYSIS M ETHODS IN IOT-S TATISTIC DB Suppose that we have various kinds of sensor sampling data about Beijing Euclidean-based spatial aggregations can answer queries like the output of the query is a spatial region with hole, as illustrated in Figure 1\networkbased spatial aggregations can answer queries like    Figure 1. Euclidean-based Spatial Aggregation  Example Euclidean-based parameter aggregation queries include and network-based parameter aggregations can answer queries like Network-based parameter aggregations compute the tr affic parameters of each road section of a given area by analyzing the GPS trajectories of moving objects or by analyzing the sampling data of traffic flow sensors To support IoT data statistical analysis efficiently, we adopt a three-layered architecture in IOT-StatisticDB, as shown in Figure 2           Figure 2. Architecture of IOT-StatisticDB  
536 


Definition 1 \(Traffic Network Definition 2 \(Sampling Value Definition 3 \(Sampling Value Component Definition 4 \(Sampling Sequence 
 1, \(39.5, 145.2\, null, çtemperature: real 27.5  2, \(39.3, 144.3 201, çspeed: real, direction realé, \(62.5, 22  3, \(38.2, 142.8\eed: real winddir: realé, \(62.5, 22  4, \(39.7, 142.1 202, çaverageSpeed: real jam: boolé, \(62.5, true A sampling value can have multiple comp onents. For instance, the GPS sampling value has 2 components: speed 62.5\ and direction \(22\\(node that longitude and latitude are expressed in 
004 
t t e t t e 
Temperature Sensor GPS Sensor Wind Sensor Vitalized value from Traffic Video Camera 
1 
004 004 
includes various kinds of sensors and /or monitoring devices \(multimedia monitoring devices plus the corresp modules are equivalent to sensors, so that they are uniformly called sensors in this paper\All the sampling values \(including numeric values and multimedia values\generated fr om this layer are sent to and kept at the These values can be organized in key-value stores \(like Cassandra MangoDB, and so forth\by ta king sensor identifiers as the key. Since data are sampled densely, not all samplings need to be stored at the Only key sampling values \(for numeri c sensors\values for multimedia devices\re kept at this layer The is the key for multimodal data query processing \(like spatial-temporal queries keyword-based queries, and value-based approximate queries In the following two subsections, we describe th e working mechan ism of this layer, including the data types a nd the related operators for storing and analyzing the IoT data As shown in Figure 2, the assumes a 2-layered structure. The master server is the coordinator which only keeps global catalogs and global indices, while the node servers store the key sampling values sent from the All key sampling values are sent to the sampling server first, which then distributes them to th e corresponding node servers according to their sampling locations In this subsection, we first describe how traffic network and sampling values are expressed at the of IOT-StatisticDB, and then discuss how they are distributed among multiple servers A traffic network  is defined as follows   where is a set of directed edges and is a set of nodes A direct edge \(or simply edge  is defined as the form   here  String is the identifier of    Polyline is the geometry of where 1     Point is the th vertex of the polyline  Real is the length of and   String are the identifiers of the starting and ending nodes which are connected by edge  A node  is defined as the form        String is the identifier of   Point is the location of  1     String is the identifier of the th edge connected by  and is the connectivity matrix of which describes the traffic transferability among different edges through the node A sampling value denoted as is defined as follows       where  Instant is the sampling time Point is the sampling location String is the network position of the sampling \(expressed with an edge iden tifier, and set to null if not on road network String and  String denote the format and the actual value of the sampling respectively Through the data type, we can express heterogeneous sensor sampling value in a uniformed manner. Table 2 shows some examples TABLE II E XAMPLES OF S ENSOR S AMPLING V ALUES  instead of as components\ Components of a sampling value can be expressed through the Sampling Value Component data type A sampling value component, denoted as  can be defined as follows    where and are the schema and the value of the component respectively. For instance, the two components of the GPS sampling value in Table 2 are expressed as \(çspeed: realé, 62.5\nd \(çdirection: realé, 22 respectively For a certain sensor its sampling sequence, denoted as is composed of all sampling values from the sensor for a certain time period, ordered by sampling time, and can be expressed as follows         where is the format of the sampling values    are the time, location the network position and the actual value of the th sampling respectively; and indicates whether the th sampling value is a çbreaking pointé in the sequence For static sensors, as their attribute is a constant value, we can further simp lify their SamplingSequence format as         Above two different formats for sampling sequences can be differentiated by the database automatically 
002 002 002 003 003 002 002 002 002 002 002 003 003 002 002 002 002 002 002 
n i n i 
m i 
 As shown in Figure 2, the 
sensor and mo nitoring device layer IoT-raw data storage layer IoT-storage and statistics layer IoT-storage and statistics layer B Data Storage and Distributi on at the IoT-Storage and Statistics Layer IoT-storage and statistics layer IoT-raw data storage layer IoT-storage and statistics layer Net Net E, N E N e E e eid geo, len, nid s nid e eid e geo p p p n e p i i n i len e nid s nid e  e n N n nid loc  eid i mat nid n loc n eid i i m i n  mat n SamplingValue SamplingValue t loc npos schema value t loc npos schema value SamplingValue loc SamplingComponent  SamplingComponent cSchema cValue cSchema cValue SamplingSequence SamplingSequence schema t i loc i npos i value i flag i schema t i loc i npos i value i i flag i i loc SamplingSequence schema loc npos t i value i flag i 
1 1 
1 2 
Type of Sensor Sensor Sampling Value 
537 


CREATE TABLE IoTData \(SensorID: String, SensorType String, DeployedBy: String, DepoyedTime: Instant Samplings: SamplingSequence truncateGeo truncateTime atInstant sProjectLines sProjectPoint sProjectNetPos sProjectTime vProjectPoint vProjectNetPos vProjectTime getComponent spatialAggrEU spatialAggrNet String parameterAggrEU String parameterAggrNet String 
SamplingSequence Region SamplingSequence SamplingSequence Periods SamplingSequence SamplingSequence Instant SamplingValue 2\ Projection Operators SamplingSequence Lines SamplingSequence Point SamplingSequence String SamplingSequence Periods SamplingValue Point SamplingValue String SamplingValue Instant 3\ Component Extraction Operator SamplingValue integer SamplingComponent String String Region String Lines String Real String String String  node 
1  2  3  4  1  2  4  3     
node node node Master Node Node Servers 003 node 003 node 003 node 003 node 
truncateGeo truncateTime atInstant sProjectLines ProjectPoint ProjectNetPos sProjectTime vProjectPoint vProjectNetPos vProjectTime getComponent 
 breaking points locations of sampling values Service Areas         
 In implementation, the          for moving sensors   for static sensors Set                         Set   
SamplingSequence IoT-storage and statistics layer node 003 node node G G v t loc npos schema value v loc v node 003 node C Query Operators for Data Retrieval and for Statistical Analysis at the IoT-Storage and Statistics Layer 1\ Truncation Operators on Sampling Sequences t t i 4\ Statistical Analysis Operators 
data type can be designed and implemented as a pointer in the tuple leading to a file block where the real data are stored. In this way, data updates triggered by new samplings can be conducted quickly without database updates involved With the above data types, we can create the following table for storing sensor sampling data where SensorID, SensorTyp e are the identifier, the type \(e.g VehicleGPS, RFID, etc.\of the sensor; DeployedBy and DeployedTime are the deplorer and time of the deployment SamplingSquence is the sampling sequence from sensors Traffic network is not stored as relational tables. Instead it is directly stored in file system. To speedup the data access, indices are built on traffic network In the following, we discuss how the sampling data and the traffic network are distributed among the master server and the node servers. In the  sampling data are distributed at the node servers according to their geographical attribu te. Each node server  corresponds to a spatial area  ch is called the service area of Any two service areas do not intersect each other and the union of all services areas is equal to the whole application area Therefore, the service areas actually make a spatial partition of  For any sampling value       if is from a static sensor, then the sampling receiver simply transfers it to the node server whose service area contains If is from a mobile sensor \(like GPS sensor the sampling receiver needs to conduct necessary interpolations at the bo rder of service areas, and sends the resultedvalues to the corresponding node server\(s\as shown in Figure 3               Figure 3. Data Distribution at the IoT-Storage and Statistics Layer The traffic network is also distributed among the node servers. Node server only keeps the edges and the nodes which are inside or intersect  For the sake of efficiency, the master server needs to store the whole traffic network The data types allow us to express sensor sampling data and the underlying traffic network in databases and in file systems. To query the sensor data and to conduct statistical analysis, we need to further defi ne a set of operators so that complicated statistical functions can be expressed in SQL In defining operators, we use signatures which describe the input and the output data types of the general, the operators in IOT-StatisticDB can be divided into the following 4 categories returns part of sampling sequence which is inside a given region spatially, while returns part of the sampling sequence which is inside a given time period temporally computes and returns a sampling value corresponding to a specified time instant  If is not a sampling time then necessary in terpolation is required. The signatures of these operators are as follows Projection operators can be further divided into sampling-sequence-based and sampling-value-based Sampling-sequence-based projection operators include s and s which project a sampling sequence towards the spatial plane, and which project a sampling sequence towards the temporal axle. Th eir signatures are as follows Sampling-value-based projection operators include and which get the sampling valueês sampling location and the corresponding network position respectively, and which get the sampling valueês sampling time. Their signatures are as follows The operator returns the th component of a sampling value, and its signature is There are 4 statistical operators as introduced in Table 1 Their signatures are as follows 
005 006 005 006 005 006 006 006 006 006 006 006 006 005 006 005 006 005 006 005 006 005 006 005 
t   
538 


t edgeID para para edgeID A Euclidean-Based Spatial Aggregation Q cMethodPara Q  cMethodPara Q Query the area in BeijingGeo where the pollution level is above 450 at time t BeijingGeo Q distance number queryRegion Q queryRegion Q cMethodPara B Network-Based Spatial Aggregation 
Q cMethodPara R queryRegion Q Nodes node area node queryRegion  node Nodes StatisticalRawData Q R node StatisticalRawData cMethodPara R node Results R node node Nodes R Results R 
data  Output region of statistical query     1  2  3  4  
Output points of     
 SELECT s s ProjectPoint Samplings FROM IoTData WHERE SensorType = çPollutionSensoré AND inside s s ProjectPoint Samplings BeijingGeo ND getComponent a a tInstant Samplings t 1\ > 450 Select s s patialAggrEU  Q 
spatialAggrEU 
007 002 002 
FOR DO IN PARALLEL ENDFOR 
Q 003 node 003 node 003 node 003 node 
 
data  data 1  data to collect the statistical raw data, and the result is a set of points. Th en it calls the DBScan algorithm with data  servers whose service areas intersect with data line 4\ to get statistical raw data, and th en calls the clustering procedure specified by 
data 
data data data String; // Statistical raw data collection query  data  2 data  5  
BeijingGeo 
 Each statistical operator has two input strings. The first input string is an SQL statement which collects statistical raw data, while the second in put string specifies a statistical method and its parameters. For example INPUT String Clustering method and its parameters OUTPUT Region 1 GetQueryRange      002  3      4  Execute  clusterContour    6 SendMaster   7  8      9 regionMerge  10 Return  Algorithm 1 first gets the query range 
Let Q  SELECT s s ProjectPoint Samplings FROM IoTData WHERE SensorType = çPM25Sensoré AND inside s s ProjectPoint Samplings BeijingGeo ND getComponent a a tInstant Samplings t 1\ > 350 Select s s patialAggrEU  Q1 DBScan distance1  number1  Let Q SELECT g g etComponent a a tInstant Samplings t 2\ 1 FROM IoTData WHERE SensorType = çTrafficSensoré AND inside s s ProjectPoint Samplings BeijingGeo  Select p p arameterAggrNet  Q TrafficSensorAnalysis Let Q DBScan distance 1 number 1 
The output of the above query is a Region value, which corresponds to the sp atial area with PM2.5 level over 350 at time Letês see another example The output of this query is a set of   where is a structured string describing the traffic parameters of edge including average speed, traffic jam status, flux, number of vehicles, and so forth III P ARALLEL S TATISTICAL A NALYSIS A LGORITHMS IN IOTS TATISTIC DB In IOT-StatisticDB, all queries are sent to the master server first, which then conducts global execution of the query by coordinating multi ple node servers for parallel execution. In this sectio n, we describe the parallel processing mechanism for statistical queries in IOTStatisticDB The Euclidean-b ased spatial aggregation operator takes the form   String is an SQL statement which collects the statistical raw data and specifies the clustering method and its parameters. The output of the operator is a region As an example, letês co nsider the fo llowing query Query  When receiving the above query, the master server first sends the query to all node servers whose service areas intersect with the query range  After a node server receives the above query, it first executes 1 1 as parameters\to cluster the points into a region, and sends the final result to the master server, as shown in Figure 4      Figure 4. Euclidean-Based Spatial Aggregation When all the participating n ode servers have returned the query results, the master server needs to merge the results and returns the final result to the querying user Algorithm 1 describes the pr ocessing of the EuclideanBased Spatial Aggregation operator  through the GetQueryRange  execute the statistical analysis in parallel Each related node server first executes to cluster the raw data and outputs the contour of the clusters \(which is a region line 5 and then sends the result to the master server line 6 After the master server receives the feedback from all related node servers, it merges the feedbacks into one region through the reg ionMerge function \(lines 8, 9 the final result to th e querying user \(line 10 Network-based spatial aggregation is similar to Euclidean-based sp atial aggregation. The main difference is that the clustering method takes traffic network as the clustering center and the outpu t is a Lines value instead of a 
002 
Algorithm 1 Processing of the spatialAggrEU Q  cMethodPara operator 
539 


1 1 
011 011\012 
010 004 004 
2  data which outputs a set of sampling values at time data contains location, speed, and direction at time 3  data whose result is a set of po llution level values. Then, the node server computes the average of the raw data, and sends the pair data  1  1  2  2  1  2  1  2  
012 
007 002 002 
FOR DO IN PARALLEL ENDFOR 
method 004 004 004 n 004 004 004 n method 
n i i n i ii R 
    
Q cMethodPara TrafficNet R queryRegion Q Nodes node area node queryRegion  node Nodes StatisticalRawData Q R node StatisticalRawData trafficNet cMethodPara R node Results R node node Nodes R Results R 
parameterAggrEU parameterAggrEU 
DBScanNet 
1 
010 010 004 004 005 004 
Algorithm 2 Processing of the spatialAggrNet Q data  cMethodPara operator INPUT 
 In processing this query, the master server first sends the query to the node servers whose service areas intersect the query range  For each related node server, it first executes the data collection query which satisfying the que ry condition. For a certain sampling sequence   computes the sampling value corresponding to time and the output sampling value include s the location, the speed and the direction of the corresponding moving object at time as shown in Figure 5           Figure 5. Network-Based Spatial Aggregation Then, the node server calls th e network-based clustering method which takes traffic network as the clustering center. As illustrated in Figure 5, the sampling values returned from see Table 2\o that they can be matched to the right edges easily. The result of the network-based clustering in Figure 5 contains 4 polylines After the master server receives the feedback from all related node servers, it merges the results and returns the final result to the querying user The detailed processing of network-based spatial aggregation query is described in Algorithm 2 The Euclidean-based parameter aggregation operator can be used to compute the aggregation of a set of raw values, such as average, min, max, and count Letês consider the following example Query  When processing this query, th e master server first sends the query to all the node servers whose service areas intersect with the query range Each related node server first executes the statistical raw data collection query   is the average of the raw data and is the number of raw data, to the master server for merging. The merged final result is sent to the querying user The general format of the Euclidean-based parameter aggregation operator is   Depending on the aggrega tion method specified by  the master server adopts different merging methods. Suppose that the feedback is    averageé, the merging result can be computed as follows  If Miné or çMaxé, then the merging result is simply Min ax  If counté, then the merging result is  
n i i R 
Let Q SELECT a a tInstant Samplings t  FROM IoTData WHERE SensorType = çVehicleGPSé AND inside s s ProjectPoint a a tInstant Samplings t  BeijingGeo  AND g g etComponent a a tInstant Samplings t 1 Select s s patialAggrNet  Q DBScanNet distance 1 number 1 atInstant Samplings Let Q SELECT g g etComponent a a tInstant Samplings t  FROM IoTData WHERE SensorType = çPollutionSensoré AND i i nside s s ProjectPoint Samplings BeijingGeo  Select p p arameterAggrEU  Q Average 
1  2  3 4  5  6  7  8      1  2  3  4  Output of data  
edge edge edge edge edge edge edge edge 003 node 003 node 003 node 003 node Q 
data data data String; //Raw data collection query  data  2 data  5  data data 
 Region value \(note that a Lines value may contain multiple      As an example, letês co nsider the fo llowing query Query String; //clustering method& parameters  Net; //the traffic network OUTPUT Lines 1 GetQueryRange      002  3      4  Execute      6 SendMaster   7  8      9 linesMerge  10 Return  Algorithm 2 is similar to Algorithm 1. The main difference is that the clust ering method, netClusterLines need to use the traffic network to get the output \(line 5 the merging is line-based \(line 9 
Q Query the blocked edge sections \(with vehicle speed lower than 5 km/h at time t in the traffic network of Beijing area \(in side the region BeijingGeo BeijingGeo Q t samplings t t t Q t C Euclidean-based Parameter Aggregation Q Query the average pollution level at time t in BeijingGeo BeijingGeo Q average number average number Q method method 004 005 004 005 004 n 005 n method R 
540 


002 013 002 
2 road 3 road 1 road 1    1 2 3 9 10 8 4 7 6 5     
n i i countpara count 
1   Algorithm 4 describes the pr ocessing of network-based parameter aggregation queries. In Algorithm 4, the trafficAnalysis 
data  4  data is executed and the result is a set of trajectories pieces 2\hen the node server computes the traffic parameters of each edge based on the trajectory pieces. For instance from the trajectory, the entering time and exiting time can be obtained, so that the speed of the vehicle can be derived Detailed calculation methods can be found 3\node server sends the result, which is a set of pairs 1  1  2  2  1 2 
007 002 002 
Let Q SELECT s s TruncateTime s s TruncateGeo Samplings BeijingGeo  t 5*Minute t  FROM IoTData WHERE SensorType = çVehicleGPS  Select p p arameterAggrNet  Q TrajectoryAnalysis 
r r r r e e e e e e e e e e 
    
003 node 003 node 003 node 003 node 
Algorithm 3. Processing of the parameterAggrEU Q  method operator 
parameterAggrNet parameterAggrNet 
010 004 004 
Q method R queryRegion Q Nodes node area node queryRegion  node Nodes StatisticalRawData Q R node StatisticalRawData method N node StatisticalRawData R node N node Results R node N node node Nodes R Results method R 
010 010 004 004 005 004 
 putes the aggregation value of the raw data according to the aggregation method indicated by line 5\ValueMerge   function merges the feedback results from the node servers according to line 10 The network-based paramet er aggregation operator can be used to computer the traffic flow parameters of the edges \(including average speed traffic jam status, flux, count of vehicles, and so forth\ed on the traffic sensor values collected from GPS sensors and or from road side traffic sensors. The format of the operator is     TrajectoryAnalysisé, çTrafficSensorAnalysisé} specifies the traffic flow analyzing method The output of the operator is a set of pairs  re is an edge identifier, and is a structured string describing the traffic flow parameters of the edge If TrafficSensorAnalysisé, the statistical raw data are traffic flow values samp led from different road side traffic sensors. Through the tr affic sensors distributed all over the city, the overall traffic status can be referred In the following, we mainly focus on TrajectoryAnalysis method. Letês consider th e following example Query  When executing this query, the master server first sends the query to the related node servers whose service areas intersect with the query range Each node server will do the following 1\raw data collection query   here is the traffic parameters of edge and is the number of trajectory pieces in the raw data conc erning this edge, to the master server for merging After the master server receives the feed back from all related node servers, it needs to merge the results, since the same edge can cover more than one service areas         Figure 6. One edge covers multiple service areas As illustrated in Figure 6, the edge 3 covers three service areas, so that three nod e servers will return its traffic parameters. In this case, multiple feedback values should be merged. Different traffic parameters can have different merging methods. For a cert ain edge, suppose that the feedback is   n the average speed, the flux, the number of vehicles, and the traffic jam status can be computed as follows Max    True \(if      True False \(Otherwise   computes the traffic parameter values for each edge based on the raw data, and returns a set of pairs of the form Set string line 5 edgeBasedValueMerge erges the feedback results from the node servers \(line 9  
FOR DO IN PARALLEL ENDFOR 
1  2  3  4  
1 1   
StatisticalRawData method method Results method method D Network-based Parameter Aggregation Q method method edgeID para edgeID para method Q Query the traffic flow parameters at time t for each edge in BeijingGeo BeijingGeo Q edgeID para nv para edgeID nv e ParaSet para nv para nv para n nv n flux para flux para flux para n flux para nv ParaSet para.jam StatisticalRawData method edgeID para Results jam 
n i i n i i i nv nved averageSpe para ed averageSpe 
data 
road 
data String; //Raw data collection query  data  2 data  5  data data 
 Algorithm 3 describes the detailed processing of Euclidean-based parameter aggregation query INPUT String; //aggregation method OUTPUT Real 1 GetQueryRange      002  3      4  Execute  aggregate   6     7 SendMaster     8  9        10 valueMerge   11 Return  In Algorithm 3, the aggregate 
541 


Q method R edgeID para queryRegion Q Nodes node area node queryRegion  node Nodes StatisticalRawData Q R node StatisticalRawData method R node Results R node node Nodes R Results R 
Centralized Statistical Analysis with Data Source Distributed Q Q Q Q 
007 002 002 
1  2  3  and 4 described in Section 3 Figure 7 shows how the query response time of CSADSD and IOT-StatisticDB changes when the number of node servers increases, with the number of sensors fixed to 220,000 From Figure 7 we can see that, in general, IOTStatisticDB has better performance than CSA-DSD. The main reason is that CSA-DSD ne eds to transfer large volumes of statistical raw data from the database servers to the master server for statistical analysis, which is very time consuming, while in IOT-StatisticDB, only statistical analysis results, whose sizes are very small compared with that of the raw data, need to be transferred from the node servers to the master server Another reason is that in CSA-DSD, the whole statistical analysis task is fulfilled by the master server alone, which forms a bottleneck. Therefore, the performance does not ch ange much when the number of node servers increases. In comparison, IOT-StatisticDB conducts statistical analysis at the node servers in parallel while the master server only needs to merge the statistical results. Therefore, with the number of node servers increases, the performance can be dramatically improved                    Figure 7. Query response time vs. number of nodes Figure 8 shows how the query response time changes when the data size increases, with the number of node servers fixed to 16                     Figure 8. Query response time vs. data size 0 500 1000 1500 2000 2500 3000 3500 4000 4500 2 4 8 16 32 Number of Node Servers Query Response Time\(ms\ of Q 2 IOT-StatisticDB CSA-DSD 0 200 400 600 800 1000 1200 1400 1600 1800 2000 2481632 Number of Node Servers Query Response Time\(ms\ of Q3 IOT-StatisticDB CSA-DSD 0 1000 2000 3000 4000 5000 6000 7000 8000 2481632 Number of Node Servers Query Response Time\(ms\ of Q 4 IOT-StatisticDB CSA-DSD 0 500 1000 1500 2000 2500 3000 2481632 Number of Node Servers Query Response Time\(ms\ of Q1 IOT-StatisticDB CSA-DSD 0 200 400 600 800 1000 1200 20k 60k 100k 140k 180k 220k Number of Sensors Query Response Time\(ms\ of Q1 IOT-StatisticDB CSA-DSD 0 200 400 600 800 1000 1200 1400 1600 1800 20k 60k 100k 140k 180k 220k Number of Sensors Query Response Time\(ms\ of Q2 IOT-StatisticDB CSA-DSD 0 500 1000 1500 2000 2500 3000 3500 4000 4500 20k 60k 100k 140k 180k 220k Number of Sensors Query Response Time\(ms\ of Q4 IOT-StatisticDB CSA-DSD 200 250 300 350 400 450 20k 60k 100k 140k 180k 220k Number of Sensors Query Response Time\(ms\ of Q3 IOT-StatisticDB CSA-DSD 
data String; //Raw data collection query  data  2 data  5  
 String; //aggregation method OUTPUT of the form Set string string 1 GetQueryRange      002  3      4  Execute  sis   6 SendMaster   7  8      9 edgeBasedValueMerge  10 Return  IV E XPERIMENTAL S TUDY  The IOT-StatisticDB framework proposed in this paper has been implemented as a prototype based on PostgreSQL8.2.4 \(with PostGIS ex tension for spatial support\ prototype system contains 1 master server and 2~32 node servers. The experi mental data set is composed of two parts 1\The real GPS trajectory data collected from 20,000 taxi cabs in Beijing. The average GPS sampling frequency is 30 seconds 2\The sampling sequence data of 200,000 static sensors generated through simulation. The average sampling frequency of static sensors is 5 minutes Therefore, for each experimental test, experimental data set can be derived by mixing above data according to the fixed proportion \(we set the ratio between data from moving sensors with that of sta tic sensors as 1:10 In the experiments, we mainly focus on the query response time for statistical analysis. Since most existing statistical analysis met hods are implemented outside the  
Algorithm 4 Processing of the paraAggrNet Q data  method operator INPUT 
method CSA-DSDé for short\ the object for comparison Similar to IOT-StatisticDB, CSA-DSD stores sensor sampling data in a distribut ed manner among multiple node servers. However, the master server is a statistical analysis server which conducts various kinds of statistics outside the database kernel. The test cases include the queries 
FOR DO IN PARALLEL ENDFOR 
542 


014 014 
014 014 004 
vol 15, issue 2, 2006, pp165190  Ding Z, Huang G, "Real Time Traffic Flow Statistical Analysis Based on Network-Constrained Moving Object Trajectories", proc. of 20th Intl. Conf. on Database and Expert Systems Applications DEXA'09\August, 2009 
Sensor number 4 Node Servers 32 Node Servers 
speedup Q Q  Q General Statistical Database Cluster Mechanism for Big Data Analysis in the Internet of Things 
VLDB Journal 
 SNQP IOTStatisticDB 
005 1000 
icDB IOTStatist SNQP speedup 
1  2 4 have similar results TABLE III S PEEDUP R ATE OF IOT-S TATISTIC DB 
 
 From Figure 8 we can see that, when data size increases the performance of CSA-DSD decreases rapidly while the performance of IOT-StatisticDB is relatively stable. The main reason is that in CS A-DSD, large volumes of statistical raw data needs to be transferred to and stored at the master server for statistical analysis. Therefore, the query response time is prop ortional to the whole data size On the other hand, in IOT-StatisticDB, the main workload is distributed among the nod e servers, so that the overall performance is less sensitiv e to the overall data size To better analysis how the statistical analysis workload is shared by multiple node servers in IOT-StatisticDB, we define the speedup rate 60 100 140 180 220 2.85 3.05 3.71 3.81 3.73 19.25 21 22.36 22.5 21.85 We can observe from Table 3 that when the number of node servers is 4, the speedup rate is between 2.85~3.81 and when the number of node servers is increased to 32, the speedup rate is between 19.25~22.36. In general, with the number of node servers incr easing, the query response time decreases, since in IOT-StatisticDB, the query response time is main decided by the da ta size of each node server V C ONCLUSIONS  Statistical analysis on sensor sampling data is one of the most important procedures in IoT systems to transform dataé into çknowledgeé. In this paper, we propose a 
as follows where is the query response time of single node query processing, and is the query response time of IOT-StatisticDB. Table 3 shows th e speedup rate of  IOT-StatisticDB The main contribution is as follows 1\general statistical database cluster mechanism is proposed, with data typ es and operators for statistical analyzing provided. The mechanism is a general model which can support complicated statistical queries through standard SQL statements 2 methods, including Euclidean-based spatial aggregation, Network-based spatial aggregation, Euclidean-based parameter aggregation, and Network-based parameter aggregation, are proposed with detailed algorithms presented 3\he parallel processing techniques of statistical queries are proposed, so that multiple servers can conduct statistical analysis in parallel and the performance can be greatly improved As the future work, event detections and data mining techniques based on IoT statistical analysis will be studied A CKNOWLEDGMENTS  The work was partially supported by National Natural Science Foundation of Chin a \(NSFC\under grant number 91124001 and by National High-Tech. R&D Program of China \(863 program\gr ant number 2013AA01A603 R EFERENCES   W a ng D, çClustering Mesh-like W i reless Sensor Networks with an Energy-efficient Scheme,é International Journal of Sensor Networks vol. 7 No. 4 2010, pp. 199-206  Chen H, Minen o H Mizuno T, çA Meta-data-based Data  Aggregation Scheme in Clustering Wireless Sensor Networksé. Proc of Intl. Conf. on Mobile Data Managem ent \(MDMê06 May 2006, pp. 154-161  Liu C, W u K Pei J, çA Dy nam i c Clustering and Scheduli ng Approach to Energy Saving in Data Collection from Wireless Sensor Networksé, Proc. of IEEE Conf. on Sensor, Mesh and Ad Hoc Communications and Networks \(SECONê05 IEEE press, Sep. 2005 pp. 374-385  Z hang Y, W a ng H T i an L   E ner gy and Data Awar e Cluster ing for  Data Aggregation in Wireless Sensor Networ ksé, Proc. of IEEE 4th Intl. Conf. on Mobile Ad hoc and Sensor Systems \(MASSê07 Press, Oct. 2007 pp. 1-6  Ordonez C S tatistical Model Com putation with UDFs IEEE Transactions on Knowledge and Data Engneering \(TKDE Dec. 2010, pp. 1752-1765  Ester M, K r iegel H P, Sander J Xu X A Density-Ba sed Algorith m for Discovering Clusters in Large Spatial Databases with Noise Proc. of Intl. Conf. on Knowledge Discovery and Data Mining KDDê96\, Aug. 1996, pp:226-231  Ankerst M, Breunig M, Kriegel H P, Sander J, çOptics: Or der ing Points to Identify the Clustering Structureé, Proc. of ACM Intl. Conf on Management of Data \(SIGMODê9 9  Yang Y, W u L Guo J, Liu S, çResearch on Distrib uted Hilbert R  Tree Spatial Index Based on Birch Clusteri ngé, Proc. of Intl. Conf. on Geoinformatics \(Geoinformaticsê12\IEEE Pr ess, Jun. 2012, pp. 1-5  Chitta R, Jin R Havens T, Jain A   A pproxim ate Ke rnel k-Means  Solution to Large Scale Kernel Clustering Proc. of ACM Intl. Conf on Knowledge Discovery and Data Mining \(SIGKDDê11  Zhang Z Yang Y Tung A, Papadias D, çContin uous kMeans Monitoring over Moving Objects IEEE Transactions on Knowledge and Data Engineering \(TKDE May 2008, pp. 1205-1216  Feng X, Ku m a r A, Recht B, RÈ C  Towar ds a Unified Ar chitecture for in-RDBMS Analyticsé Proc. of ACM Intl. Conf. on Management of Data \(SIGMODê12\, May 2012, pp. 325-336  Heller stein J R C Schopp m a nn F, W a ng D, Fr atkin E, Gor ajek A et al. çThe MADlib Analytics Library or MAD skills, the SQL Journal Proceedings of the Very Large Data Base Endowment, vol. 5 issue 12, 2012, pp. 1700-1711  Jam p ani R Xu F W u M, P e rez L Jermaine C, Haas P, çThe Monte Carlo Database System: Stochastic Analysis Close to the Data ACM Transactions on Database Systems \(TODS\1 pp. 18:1-18:41  Xiong Z Luo W   Chen L Ni L Data Vitalization: A New Par adig m  for Large-Scale Dataset Analysisé. Proc of IEEE 16th Intl. Conf. on Parallel and Distributed Systems ICPADSê10 Dec. 2010  G¸ting R.H, Al m e ida V, Ding Z, çModeling and Quer y i ng Moving Objects in Networks 
543 


  


Bottom Top A B 
Figure 15 Figure 16 
messages seen for all workers in a superstep \(Figures 10 and 13\. When looking at the messages sent by workers in a superstep for METIS, we see that there are message load imbalances within work ers in a superstep, caused due to concentration of vertices being traversed in that superstep in certain partitions This variability is much more pronounced in CP as compared to WG \(Figures 11 and 14\ E.g. in superstep 9 for CP, twice as many messages \(4M\ are generated by a worker compared to another \(2M\.  For Pregel BSP, the time taken in a superstep is determined by the slowest worker in that superstep. Hence increase d variability in CP causes even çgoodé partitioning strategies to cause an increase in total execution time wh en using the Pregel/BSP model VIII A NALYSIS OF E LASTIC C LOUD S CALING  Cloud environments offer elasticity Ö the ability to scale-out or scale-in VMs on-demand and only pay for what one uses [28   On th e f l i p s i de  on e en ds u p  paying for VMs that are acquired even if they are underutilized. We have already shown the high variation in compute/memory resources used by algorithms like BC and APSP across different supersteps. While our earlier swath initiation heuristics attempt to flatten these out by overlapping swath executions, one can consider leveraging the cloudês elasticity to, instead, scale up and down the concurrent workers \(and graph partitions\ allocated in each superstep The peak and trough nature of resource utilization combined with Pregel/BSPês synchronous barrier between supersteps offers a window for dynamic scaleout and Öin at superstep boundaries. Peak supersteps can greatly benefit from additional workers, while those same workers will contribute to added synchronization overhead for trough supersteps We offer an analysis of the potential benefits of elastic scaling by extrapolating from observed results for running BC on WG and CP graphs, using four and eight workers.  To provide a fair and focused comparison, we turned off swath heuristics in favor of fixed swath sizes and initiation intervals Figure 15 \(Bottom\ plots the speedup of BC running on eight workers when normalized to BC running on four workers, at corresponding supersteps.  The number of workers does not impact the number of supersteps We also plot the number of active vertices \(i.e. vertices still computing for a given swath\these supersteps which is a measure of how much work is required \(Fig 15 \(Top\. We find that we occasionally get superlinear speedup spikes \(i.e. >2x\ that shows a strong correlation with the peaks of active messages, for both WG and CP graphs. At other times, the sp eedup is sublinear or even a speed-down \(i.e. <1\responding to inactive vertices.  The superlinear speedup is attributable to the lower contention and reduced memory pressure for 8 workers when the active vertices peak \(similar to what we observed for the swath initiation heuristics Similarly, the below par speedup during periods of low activity is contributed by the increased overhead of barrier synchronization across 8 workers. Intuitively, by dynamically scaling up the number of workers for supersteps with peaking active vertices and scaling them down otherwise, we can leverage the superlinear speedup and get more value per worker Using a threshold of 50% active vertices as the threshold condition for between 4 and 8 workers in a superstep, we extrapolate the time per superstep and compared this to the fixed 4 and 8 worker runtimes. We also compute the best-case run time using an çoracleé approach to i.e. for each superstep, we pick the minimum of the 4 or 8 workerês time.  Note that these projections do not yet consider the overheads of scaling, but are rather used to estimate the potential upside if we had an ideal or an automated heuristic for scaling. The total time estimates for running BC on WG and CP graphs, normalized to  
 plot shows speedup of 8 workers relative to 4 workers, for each superstep, when running BC on WG and CP graphs plot shows the number of vertices active in that superstep Estimated time for BC using elastic scaling, normalized to time taken for 4 workers. Normalized cost is shown on secondary Y axis WG graph shown on left CP graph shown on right. Smaller is better 
022\011 022\010 022\007 022\002 006 002 007 006 002 007 010 011 012 013 014 015 006 006\003\002 006\003\007 006\003\010 006\003\011 006\003\012 006\003\013 006\003\014 006\003\015 006\003\016 002 027\031\030\037\020#@\020"\031\030\027\020\035 0201!2#\024$#\015#5\024",\020"#\017\003"\003\031\003#\011#5\024",\020"\035 024"'\033\026\0309\0201#\\031\020 2 035#\032\020"#+!\034 017\020\021\022\023\024\024\025\026\020 027\030\031\022\032\033\031\020\034\031\035 017\020\021\022\023\024\024\025\026\020#?#/\027\031\030\037\020#@\020"\031\030\027\020\035 027\030\031\022\032\033\031\020\034\031\035#?#/\027\031\030\037\020#@\020"\031\030\027\020\035 036\030\034\020\033"#\\0201!2 006 006\003\007 006\003\011 006\003\013 006\003\015 002 002\003\007 006 006\003\002 006\003\007 006\003\010 006\003\011 006\003\012 006\003\013 006\003\014 006\003\015 006\003\016 002 011#5\024",\020 B\034\0267 015#5\024",\020 B\034\0267 1\0332\031\030\037\020 030\034\025 1\0332\031\030\037\020 036\024\017\020 024!\0341 024\035\031#>\024"'\033\026\0309\0201#\031\024#\011#5\024",\020"#.\024\035\031 017\020\021\022\023\024\024\025\026\020#+!\034\022&\030'\020#>\024"'\033\026\0309\0201#\031\024#\011#5\024",\020"#&\030'\020 011#5\024",\020"#&\030'\020 015#5\024",\020"#&\030'\020 024\035\031 006 006\003\007 006\003\011 006\003\013 006\003\015 002 002\003\007 002\003\011 002\003\013 006 006\003\002 006\003\007 006\003\010 006\003\011 006\003\012 006\003\013 006\003\014 006\003\015 006\003\016 002 011#5\024",\020 B\034\0267 015#5\024",\020 B\034\0267 1\0332\031\030\037\020 033\026\030\034\025 1\0332\031\030\037\020 036\024\017\020 024!\0341 024\035\031#>\024"'\033\026\0309\0201#\031\024#\011#5\024",\020"#.\024\035\031 027\030\031\022\032\033\031\020\034\031\035#+!\034\022&\030'\020#>\024"'\033\026\0309\0201#\031\024#\011#5\024",\020"#&\030'\020 011#5\024",\020"#&\030'\020 015#5\024",\020"#&\030'\020 024\035 031 
 
dynamically scaling ideal scaling 
Our hypothesis is that an intelligent adaptive scaling of workers can achieve a similar performance as a large, fixed number of workers, but with reduced cost 
213 


Nature Nature Ecological Applications Nature ACM International Conference on Management of Data \(SIGMOD In Parallel Object-Oriented Scientic Computing \(POOSC Science Communications of the ACM ACM Workshop on Mining and Learning with Graphs Communications of the ACM HotCloud Proceedings of the 19th ACM International Symposium on High PErformance Distributed Computing HPDC Knowledge and Information Systems KAIS International Conference on Computational Science IEEE International Conference on Cloud Computing Technology and Science ACM/IEEE Conference on Advances in Social Network Analysis and Mining \(ASONAM IEEE International Parallel and Distributed Processing Symposium \(IPDPS International Conference on Distributed Computing and Networking Journal of Mathematical Sociology International Conference on Parallel Processing Communications of the ACM 
 
observed time taken using 4 workers, are plotted in Figures 16\(A\ and 16\(B We see that our dynamic scaling heuristic using the percentage of active vertices achieves nearly the same CP\ or better \(WG\ performance as a fixed 8 worker approach. Clearly there is benefit of using fewer workers for low utilization su persteps to eliminate the barrier synchronization overhead. Also, the dynamic scaling heuristic performs almost as well as the ideal scaling. Finally, when we consider the monetary cost of the proposed approaches, assuming a pro-rata normalized cost per VM-second plotted on the secondary Y axis, we see that dynamic scaling is comparable \(CP\ or cheaper \(WG\ than a 4 worker scenario while offering the performance of an 8 worker deployment IX C ONCLUSION  In conclusion, we introduce optimization and heuristics for controlling memory utilization and show they are critical to performance.  By breaking computation into swaths of vertices and using our sizing heuristics we achieve up to 3.5x speedup over the maximum swath size that does not cause the a failure.  In addition overlapping swath executions can provide a 24% gain with automated heuristics and even greater speedup when a priori knowledge of the network characteristics is applied This evaluation offers help to eScience users to make framework selection and cost-performancescalability trade-offs. Our he uristics are generalizable and can be leveraged by other BSP and distributed graph frameworks, and for graph applications beyond BC. Our work uncovered an unexpected impact of partitioning and it would be worthwhile, in future, to examine the ability to pred ict, given certain graph properties, a suitable partitioning model for Pregel/BSP It may also be useful to perform such evaluations on larger graphs and more numbers of VMs. At the same time, it is also worth considering if non-linear graph algorithms are tractable in pr actice for large graphs in a distributed environment B IBLIOGRAPHY  1  F  L i lj er os C   Ed l i n g L  A m a r a l H  S t an ley   and Y    berg The web of human sexual contacts 
vol. 411, pp. 907908, 2001   H Je o n g  S   Ma so n A  L   B a ra b s i  a nd Z   Oltva i  L e t ha l i t y  and centrality in protein networks vol. 411, pp. 41-42 2001   O. B o din and E   E s t r ada    U s i n g n e t w ork c e nt r a l i t y  m e a s ures t o  manage landscape connectivity vol 18, no. 7, pp. 1810-1825, October 2008   D. W a ts s  and S  S t r ogat z  C olle c t i v e  d y nam i cs of  s m a ll-w orl d   networks vol. 393, no. 6684, pp. 440Ö442, June 1998   G  Ma lew i c z   M A u s t er n A   Bik  J   Dehn er t I  Hor n   N. L e i s er and G. Czajkowski, "Pregel: A system for large-scale graph processing," in 2010   D. G r egor  and A  L u m s dain e  T h e  pa r a llel  B G L  A gen e r i c  library for distributed graph computations," in 2005   B. S h a o  H. W a n g  and Y  L i T he T r init y G r aph E n g i n e    Microsoft Research, Technical Report MSR-TR-2012-30, 2012   A  F ox  C lo ud c o m putin g w h at  s  in it for m e  as  a  s c i e n tis t     vol. 331, pp. 406-407, 2011   S. G h e m a w a t  and J  De an   Map re duc e s i m p lifi e d data  processing on large clusters vol 51, no. 3, pp. 107-113, 2008   J  L i n and M. S c hat z   Des i g n  patt er n s  for eff i ci ent gr aph algorithms in MapReduce," in 2010   L   Va l i ant   A b r id g i n g m o d e l f or pa r a llel com putati o n  vol. 33, no. 8, pp. 103-111, 1990 12 a c h e  Ha ma    O n l i n e    http://hama.apache.org   13 Ap a c h e  Ha d o op    O n l i n e    http://hadoop.apache.org     M Z a h a r i a, M. Ch ow dhu ry M F r ank l in S  S h e n k e r, and I   Stoica, "Spark: Cluster Computing with Working Sets," in 2010   J  Ekana y ak e e t a l     T w i st er A  r untim e f o r it er ati v e  MapReduce," in Chicago, 2010, pp. 810-818   U. K a n g  C  T s o u rakakis   and C. F a l outs o s  Peg a s us   Minin g  Peta-scale Graphs," in 2010   M. P a c e  B S P vs  MapR e duc e    in vol. 103.2081, 2012   S. Seo  E  Yoo n, J  K i m  S  J i n  J-S. K i m   and S   Ma e n g HAMA: An Efficient matrix computation with the MapReduce framework," in 2010, pp. 721-726   S. S a l i h ogl u  and J  W i d o m  G PS A G r a ph P r oc e s s i n g Sy s t em    Stanford University, Technical Report 2011   R L i cht e n w a l t e r and N   Cha w la D is Ne t  A fr am ew ork for  distributed graph computation," in  2011   K  Maddu r i  D. E d i g er K   J i an g  D. Bad e r  and D  Cha v a r riaMiranda, "A faster parallel algorithm and efficient multithreaded implementations for evaluating betweenness centrality on massive datasets," in 2009   E  K r e p s k a, T  K i el m a nn, W  F o kkink, H   Ba l, "A  hi g h level framework for distributed processing of large-scale graphs," in 2011, pp. 155-166   L   Pa ge  S  B r in R. M o t w ani and T  W i nogr ad  T h e P a geRank citation ranking: Bringing order to the web," Stanford InfoLab Technical Report 1999-66, 1999   U  Brand  s  A f a s t er  a l gor ith m for  b e t w eenn e s s c e nt r a l i t y    vol. 25, no. 2, pp. 163-177 2001   Stan fo r d  Net w or k A na l y s is Pro j e c t  O n l in e    http://snap.stanford.edu    I  S t ant o n and G  K l i o t, "S t r e a m i n g G r aph P a rtiti o n in g  for L a rge Distributed Graphs," Microsoft Corp., Technical Report MSRTR-2011-121, 2011   G   K a ry pis and V   K um a r A fas t and hi g h qua l i t y m u l t i l evel scheme for partitioning irregular graphs," in 1995, pp. 113-122   M. A r m b r u s t e t  a l   A v i ew of  c l o u d  c o m putin g    vol. 53, no. 0001-0782, pp. 50-58 April 2010  
214 


  13  or gani c  c he m i s t r y  i n our  Sol ar  Sy s t e m       Xi a n g  L i r e c e i v e d h i s B  S   m is tr y  fr o m  th e  P e k in g  U n iv e r s ity  C h in a  in  2 0 0 3  and P h D   i n P hy s i c al  C he m i s t r y  f r om  t he  J ohns  H opk i ns  Un i v e r s i t y  i n  2 0 0 9   He  h a s  b e e n  a  R e s e a r c h  A s s o c i a t e  wi t h  a  j o i n t  a p p o i n t m e n t  a t  t h e  U n i v e r s i t y  o f  M a r y l a n d   Ba l t i m o r e  C o u n t y  a n d  N AS A G o d d a r d  S p a c e  Fl i  Ce n t e r  s i n c e  2 0 1 1   H i s  r e s e a r c h  f o c u s e s  o n  t h e  d e t e c t i o n  of  t r ac e  e l e m e nt  and as t r obi ol ogi c al l y  r e l e v ant  or gani c  mo l e c u l e s  i n  p l a n e t a r y  s y s t e ms   l i k e  M a r s   He  i s  es p eci a l l y i n t er es t ed  i n  t h e d evel o p m en t  o f  T i m e of  and I on T r ap m as s  s pe c t r om e t e r s w i t h v a r i o u s i o n i z a t i o n  ng te c h n iq u e s   Wi l l  B r i n c k e r h o f f  sp a c e  sc i e n t i st  i n  t h e  Pl a n e t a r y  En v i r o n m e n t s  La b  a t  N A S A  s  G o d d a r d  Spac e  F l i ght  C e nt e r  i n Gr e e n b e l t   M D w i t h  pr i m ar y  r e s pons i bi l i t y  f or  th e  d e v e lo p m e n t o f th e  L D TO F  m a s s  s p e c t r o  th is  p r o je c t H e  h a s  fo c u s e d  re c e n t l y  o n  t h e  d e v e l o p m e n t  o f  m i n i a t u re  l a se r d ma s s  s p e c t r o me t e r s  f o r  f u t u r e  p l a n e t a r y  mi s s i o n s  a l o n g  wi t h  b a s i c  e x p e r i m e n t a l  r e s e a r c h  i n  a s t r o b i o l o g y  a n d  p r e bi ot i c  s y nt he s i s   D r   B r i nc k e r hof f  i s  i nv ol v e d i n t he  de v e l opm e nt  of  m as s  s pe c t r om e t e r  f or  bot h t he  2011 Ma r s  S c i e n c e  L a b o r a t o r y  a n d  t h e  2 0 1 8  E x o Ma r s  mi s s i o n s   


  14   


Copyright © 2009 Boeing. All rights reserved  Issues and Observations Initial load of one day of data ~ 7 hours Optimizations  Write data in batches  Use a mutable data structure to create data strings  Deploy a higher performance machine  Use load instead of insert  Use DB2 Range-Partitioned tables  Database tunings Time reduced from 7 hours to approx 30 minutes 


Copyright © 2009 Boeing. All rights reserved  Optimizations Use a mutable data structure to create data strings  Original application created the SQL statement by appending elements to a Java String  It was taking five hours \(of the seven hours Strings  Instead Java StringBuilder used  Java Strings immutable  Time savings of 71.4 


Copyright © 2009 Boeing. All rights reserved  Optimizations Deployed on a higher-performance machine  Application ported from IBM Blade Center HS21 \(4GB of RAM and 64-bit dual-core Xeon 5130 processor to Dell M4500 computer \(4GB of RAM and 64-bit of quad-core Intel Core i7 processor  Reduced the time to thirty minutes Bulk loading instead of insert  Application was modified to write CSV files for each table  Entire day worth of data bulk loaded  Reduced the time to fifteen minutes 


Copyright © 2009 Boeing. All rights reserved  Optimizations Range-Partitioned tables \(RPT  To limit the size of tables, the original code created multiple tables per table type  This puts burden on the application to query multiple tables when a range crosses several tables  With RPT, user is not required to make multiple queries when a range crosses a table boundary  Increased the time to thirty minutes  Additional fifteen minute cost per day of partitioning enabled time savings during queries 


Copyright © 2009 Boeing. All rights reserved  Optimizations Database tunings  Range periods changed from a week to a month  Automatic table space resizing changed from 32MB to 512KB  Buffer pool size decreased  Decreased the time to twenty minutes Overall, total time savings of 95.2 


Copyright © 2009 Boeing. All rights reserved  20 IBM Confidential Analytics Landscape Degree of Complexity Competitive Advantage Standard Reporting Ad hoc reporting Query/drill down Alerts Simulation Forecasting Predictive modeling Optimization What exactly is the problem What will happen next if What if these trends continue What could happen What actions are needed How many, how often, where What happened Stochastic Optimization Based on: Competing on Analytics, Davenport and Harris, 2007 Descriptive Prescriptive Predictive How can we achieve the best outcome How can we achieve the best outcome including the effects of variability Used with permission of IBM 


Copyright © 2009 Boeing. All rights reserved Initial Analysis Activities Flights departing or arriving on a date Flights departing or arriving within a date and time range Flights between city pair A,B Flights between a list of city pairs Flights passing through a volume on a date. \(sector, center, etc boundary Flights passing through a volume within a date and time range Flights passing through an airspace volume in n-minute intervals All x-type aircraft departing or arriving on a date Flights departing or arriving on a date between city pair A,B Flights departing or arriving on a date between a list of city pairs Flights passing through a named fix, airway, center, or sector Filed Flight plans for any of the above Actual departure, arrival times and actual track reports for any of the above 


Copyright © 2009 Boeing. All rights reserved  Initial SPSS Applications Show all tracks by call sign 


Copyright © 2009 Boeing. All rights reserved  Predictive / Prescriptive Analytics Use-Case For a given Airspace Volume of Interest \(AVOI compute distinct traffic volume at some point in the future  Aim to alert on congestion due to flow control areas or weather if certain thresholds are exceeded  Prescribe solution \(if certain thresholds are exceeded Propose alternate flight paths  Use pre-built predictive model  SPSS Modeler performs data processing Counts relevant records in the database \(pattern discovery Computes traffic volume using statistical models on descriptive pattern Returns prediction with likelihood 


Copyright © 2009 Boeing. All rights reserved  Predictive / Prescriptive Analytics Use-Case Advanced Arrival Procedures with Active Abatement Potentials   9/23/10  24 Pulls in the TRACKINFO table of MAIN using SQL Limits the data to database entries which fall inside the AVOI Combines the SOURCE_DATE and SOURCE_TIME to a timestamp that can be understood by modeler Computes which time interval the database entry falls in. The time interval is 15 minutes Defines the target and input fields needed for creating the model Handles the creation of the model Produces a graph based off of the model results Final prediction 


Copyright © 2009 Boeing. All rights reserved  Initial Cognos BI Applications IBM Cognos Report Studio  Web application for creating reports  Can be tailored by date range, aircraft id, departure/arrival airport etc  Reports are available with links to visuals IBM Framework Manager  Used to create the data package  Meta-data modeling tool  Users can define data sources, and relationships among them Models can be exported to a package for use with Report Studio 


Copyright © 2009 Boeing. All rights reserved  Flights Departing Las Vegas on Jan 1, 2012 1 of 3 Report shows the departure date, departure and arrival locations and hyperlinks to Google Map images DeparturePosition and ArrivalPosition are calculated data items formatted for use with Google Maps Map hyperlinks are also calculated based on the type of fix 


Copyright © 2009 Boeing. All rights reserved  Flights Departing Las Vegas on Jan 1, 2012 2 of 3 DeparturePosition, Departure Map, ArrivalPosition and Arrival Map are calculated data items \(see departure items below DepartureLatitude DepartureLongitude DeparturePosition Departure Map 


Copyright © 2009 Boeing. All rights reserved  Flights Departing Las Vegas on Jan 1, 2012 3 of 3 


Copyright © 2009 Boeing. All rights reserved  Conclusion and Next Steps Current archive is 50 billion records and growing  Approximately 34 million elements per day  1GB/day Sheer volume of raw surveillance data makes analytics process very difficult The raw data runs through a series of processes before it can be used for analytics Next Steps  Continue application of predictive and prescriptive analytics  Big data visualization 


Copyright © 2009 Boeing. All rights reserved  Questions and Comments Paul Comitz Boeing Research & Technology Chantilly, VA, 20151 office Paul.Comitz@boeing.com 


Copyright © 2009 Boeing. All rights reserved Advanced Arrival Procedures with Active Abatement Potentials   9/23/10  31 


Copyright © 2009 Boeing. All rights reserved Advanced Arrival Procedures with Active Abatement Potentials   9/23/10  32 Backup Slides 


Copyright © 2009 Boeing. All rights reserved  Initial Approach Initial Investigations  Apache Solr/Lucene  Data Warehouse Evaluate Hadoop in the future 


Copyright © 2009 Boeing. All rights reserved  Using SOLR Uncompress Track Information Messages To use with Solr  Transforming track messages from their  original schema to Solr required building a ìkey, valueî list using an XSTL  Queries made against this list of ìkey, valueî pairs Transformation Process  One day of data ~ 4.5 hours Once transformation complete search/query performance very good Geo spatial queries using  unique query language 


Copyright © 2009 Boeing. All rights reserved  Representation Aviation data is frequently represented in more than one form 


