Mining Frequent Development Patterns of roles in Open Source Software  Lin Yuan 1,2 Huaimin Wang 1 Gang Yin 1 Dianxi Shi 1 Xiang Li 1 Bixin Liu 1  School of Computer 3  National University of Defense Technology Changsha Hunan, China Email: jack.nudt@gmail.com 2  School of Electronic Technology Information Engineering University Zhengzhou Henan,China Email: fkefss@gmail.com 3  Institute of Electronic System Engineering of China Beijing, China    Abstract  Participants of a software project have a significant 
impact on whether the project could achieve success, and the relevant information can reflect some trustworthy properties of software. B y studying a large number of OSS projects in SourceForge, the role configuration of these projects is analyzed, and some latent frequent patterns are discovered in this paper. It prepares the ground for quantification and utilization of the 1   I NTRODUCTION  software trustworthiness evidence from the roles information Keywords : trusted software; trustworthiness evidence association rules; metrics Since the software appeared, how to assess the quality of 
software objectively and efficiently and prevent huge losses caused by software problems has been one of the core issues in software engineering. With the development of the Internet and appearance of trusted software conception, trustworthy evaluation technology of software has become an urgent problem in the field of software trustworthy research. Software trustworthy assessment is a complex, multi-angle, multi-level issue, which is influenced by the software application, domain environment, and many factors outside software itself, and the  process of evaluating the trustworthiness of software is very sophisticated and tedious With the rapid development of open source software \(OSS 
OSS attracts more and more attention of researchers. OSS provides free and vast software resources ranging from lowquality individual efforts to high-quality enterprise solutions. In their whole life cycle, OSS produced a very large amount of data with various types. These data may provide some new ideas for software trustworthy assessment, yet up to now they still have not been made full use of In the OSS software repository, some information about participants of project development can reflect some trustworthy properties of software authentically and effectively  in the field of software trustworthy assessment    S o  i f w e c a n  q u a n t i f y a nd m a ke us e o f t h e i n f o r m a t i o n  
about participants of software reasonably, it should be able to improve the limitation of some metrics in software trustworthy assessment to some extent. Therefore, this would be very significant for producing an objective, accurate and easy-to-use assessment mechanism of software trustworthy in the future On the basis of previous work, by mining a large amount of OSS projects in SourceForge, we will continue analyzing the information about the roles that participants acted as in OSS projects with association rules and making an intensive study of role configuration of OSS The rest of the paper is structured as follows. Some conceptions and definitions are described in Section 2 
Previous and related work are concluded in Section 3. The famous Apriori algorithm and our computation model are introduced in Section 4. In section 5, the results analyzed by Apriori algorithm are presented and the frequent patterns of roles in OSS projects are discussed. Section 8 concludes and mentions of the future work 2  R ELATED CONCEPTIONS  2.1  T RUSTED S OFTWARE  Since the early 70s in the 20th century, the conception of trusted system was presented for the first time by Anderson After that, the trustworthiness of information system is always concerned by the academia and industry 
Trusted software usually refers to the software whose behavior and results are always consistent with peoples expectation and would be able to provide continuous service even if it was interfered [3  A s  a p pe ar an ce o f th e tr usted software conception, the quality of software is no longer limited to traditional software properties, such as the reliability maintainability, availability, security and so on, and it attempts to understand the essence of software quality to a deeper extent 2.2  S OFTWARE T RUSTWORTHINESS E VIDENCE  Software trustworthiness evidence is the evidence which could be validated and can be used to affirm 
4 the facts of software quality. It must satisfy the following three conditions    1  Objectivity: Evidence is objective facts and independent of peoples’ will. T 2  Relevance: Evidence is real relevance to the trustworthy properties to be proved his is the essential feature of evidence 2010 Symposia and Workshops on Ubiquitous, Autonomic and Trusted Computing 978-0-7695-4272-0/10 $26.00 © 2010 IEEE DOI 10.1109/UIC-ATC.2010.113 444 


3  Availability: Evidence could be collected, reviewed judged, accessed and inspected in accordance with established procedure 2.3  E VALUATION M ODELS OF O PEN S OURCE S OFTWARE  Different approaches have been presented to evaluate OSS projects. The Open Source Maturity Model developed by Bernard Golden of Navicasoft [5  a n d  t h e Ca pG e m i n i O p e n  Source Maturity Model [6  a i m  t o offe r a  m e t h odo l ogy f o r  assessing and evaluating the suitability of open source software The Center for Open Source Investigation at Carnegie Mellon West, and Intel Corporation have developed the Business Readiness Rating model \(BRR\ [7  w h i c h l e t s  I T  m a n a g e r s  quickly make informed and educated decisions about open source software. Atos Origin Corporation conceived and formalized the method for Qualification and Selection of Open Source software \(QSOS\ [8  TABLE I   A SSESSMENT C ATEGORIES OF O PEN BRR These models adopt almost similar evaluation process scoring and weighting all of the related metrics and properties of OSS projects, comparing and selecting the project which is considered the most suitable. The assessment categories of BRR are listed in Table  I  I n d e x    A  A s s e s s m e n t  C  C a t e g o r y    D  D e s c r i p t i o n    1 Functionality How well will the software meet the average user’s requirements 2 Usability How good is the UI? How easy to use is the software for end-users How easy is the software to install, configure deploy, and maintain 3 Quality Of what quality are the design, the code, and the tests? How complete and error-free are they 4 Security How well does the software handle security issues? How secure is it 5 Performance How well does the software perform 6 Scalability How well does the software scale to a large environment 7 Architecture How well is the software architected? How modular, portable, flexible, extensible, open, and easy to integrate is it 8 Support How well is the software component supported 9 Documentation Of what quality is any documentation for the software 10 Adoption How well is the component adopted by community, market, and industry 11 Community How active and lively is the community for the software 12 professionalism What is the level of the professionalism of the development process and of the project organization as a whole I 3  R ELATED WORK  n the process of evaluating OSS projects, many metrics in these models are not only hard to obtain, but also difficult to score even after they had been obtained, such as end-user UI experience, quality of professional support, number of books in Amazon, leading team, training, documentations, and so on Therefore it is very important to find some evidence in software repository, which would be obtained easily and quantified convincingly SourceForge is the largest OSS development web site in the world. By June 2009, more than 230,000 software projects have been registered by more than 2 million users. It provides large amounts of real data covering the entire software life cycle for academic research In SourceForge, the recommendation and rank of projects are determined by activity scores. It means the rank of project is actually one kind of quantization of project’s recent activity in generally, we are able to consider that the projects with higher ranks indicate that they have enjoyed higher popularity and won more widespread applications. So the rank can reflect the some facets of projects quality There are 7 kinds of projects statuses in SourceForge which are planning, pre_alpha, alpla, beta, production/stable mature, and inactive During OSS software development, roles are used to distinguish different development tasks. After combining the roles which actually undertaking the same activities,  28 kinds of roles were found in all SourceForge projects, which are listed in Table TABLE II  T HE R OLES IN S OURCE F ORGE   I  I n d e x    R  R o l e  N a m e    I  I n d e x    R  R o l e  N a m e    1  Advisor/Mentor/Consultant 2  Cross Platform Development 3  All-Hands Person 4  Project Manager 5  Analysis/Design 6  Requirements Engineering 7  Build Engineer 8  Researcher 9  Content Management 10  Sr. Customer Support Manager 11  Database Administrator 12  Support Manager 13  Developer 14  Support Technician 15  Director of Operations 16  Tester 17  Distributor/Promoter 18  Translator \(I18N/L10N 19  Doc Writer 20  Systems Programmer/Analyst 21  Editorial/Content Writer 22  Unix Admin 23  Graphic/Other Designer 24  UI Designer 25  Packager\(.rpm, .deb, etc 26  VP of Media Operations 27  Web Designer 28  No specific role By analyzing the OSS projects in SourceForge[1  it c a n b e  concluded that the maximum In the further work number of roles in one project is 13, and the number of projects with number of roles more than 8 is very small, so only those projects with no more than 7 roles are considered in this paper. It has been proved that there is strong relationship between the number of roles in projects and the rank of projects. The projects with higher rank would be inclined to have more roles. In other words, it means that the projects with higher rank would be organized better and the work of these projects would be divided and assigned better 2  i n  o r d e r t o re t r i e v e  t h e ro l e  s t ruc t u re  model that can provide better support \(e.g. helping projects to get higher rank\ for the development of OSS projects, the absolute centralities and relative centralities of each role in different rank intervals are calculated by social network analysis. And for the purpose of characterizing the role structure of OSS projects in SourecForge rationally, the relative centralities of some major roles were compared and the role structure of OSS projects is constructed 445 


The previous work mentioned above prepared the ground for quantification and utilization of the 4  M INING F REQUENT P ATTERNS OF R OLES  software trustworthiness evidence based on role information In the field of data mining, association rule mining is a popular and well researched method. Association rule mining could discover interesting associations and/or correlation relationships among large set of data items. Association rules show attributes value conditions that occur frequently together in a given dataset. A typical and widely-used example of association rule mining is “market basket analysis”. An example of such an association rule is the statement that 90 of transactions that purchase bread and butter also purchase milk 4.1  F ORMAL M ODEL OF M INING A SSOCIATION R ULES  Given a set of transactions D the problem of mining association rules is to generate all association rules that have support and confidence greater than the user-specified minimum support \(minsupport\ and minimum confidence minconfidence \ respectively The formal model of mining association rules i s g i v e n  as follows   I 1  I 2  I m be a set of binary attributes, called items. Let T be a database of transactions. Each transaction t is represented as a binary vector, with t  k  1 i f  t bought the item I k and t  k   0 o t h e r w i s e   T h e r e  i s o n e t u p l e i n  t h e da t a ba s e for  each transaction. Let X be a set of items in So a transaction t satisfies X if for all items I k An association rule is defined as the form X   I in X  t  k   1   j where X  is a set of items in and I j The rule X   I is a single item in that is not present in X  j is satisfied in the set of transactions T with the confidence factor 0 c 1 iff at least c of transactions in T that satisfy X also satisfy I j The notation X   I j c is used to specify that the rule X  I j 4.2  A PRIORI A LGORITHM  has a confidence factor of c  The minconfidence is a threshold of confidence factor defined by user The support for a rule is defined to be the fraction of transactions in T that satisfy the union of items in the consequent and antecedent of the rule The minsupport is defined as a threshold, which is used to generate all rules which were concerned about. Those combinations in concerned rules which meet the threshold are called large itemsets, and all the other combinations that do not meet the threshold are called small itemsets Another motivation for support constraints comes from the fact that we are usually interested only in the rules with the support a bove some minimum threshold. If the support is not large enough, it means that the rule is not worth consideration or that it is simply less preferred Apriori[10  is t h e  b e s t k n o w n  a l go r i t h m to mi n e as s o c i a tio n rules and frequent itemsets in transaction database. It uses a breadth-first search strategy to counting the support of itemsets and uses a candidate generation function which exploits the downward closure property of support The Apriori algorithm is described as follows  L 1  for  k 2 L large 1-itemsets k-1   k  do begin   C k apriori-gen L k-1  candidates  forall transactions t  D  do begin    Ct = subset C k  t  contained in t   forall candidates c  C t  do     c count  end   L k  c  C k  c count  minsup  end  Answer k  L k  D transactions database; each database record is a TID, item> pair, where TID is the identifier of the corresponding transaction  The notations used in the algorithms are explained below  L k  C Set of large k-itemsets \(those with minimum support\. Each member of this set has two fields: i itemset and ii\ support count k  Set of candidate k-itemsets when the TIDs of the generating transactions are kept associated with the candidates Set of candidate k-itemsets \(potentially large itemsets\. Each member of this set has two fields: i itemset and ii\ support count The first pass of the algorithm simply counts item occurrences to determine the large 1-itemsets. A subsequent pass, say pass k consists of two phases. First, the large itemsets L k-1 found in the k-1 h pass are used to generate the candidate itemsets C k Next, the database is scanned and the support of candidates in C k is counted. For fast counting, we need to efficiently determine the candidates in C k  that are contained in a given transaction t  The mining process is described in Fig.1 Figure 1  Process of mining association rules with Apriori 446 


4.3  M INING F REQUENT P ATTERNS IN OSS WITH A PRIORI  4.3.1  Data selection In our studies, the selection of data source relies on two factors: project status and its rank. We selected the projects which are beta, production/stable, or mature status, and before 10000 in rank list. There are total 7,779 projects meeting both conditions in SourceForge in Jun 2009. As we are only concerned about the difference of role structure in different rank intervals, and in order to observe the difference clearly then we choose 2 rank extent, [1,30  a n d  700 0  10 000   f o r  mining the frequent patterns We collected all related data of projects satisfied above conditions, which include all participants in target projects and roles information about what each participant acted as in every project 4.3.2  Data Structure For analyzing the relationship among roles and revealing the frequent patterns in OSS projects, the data structure is built as follows The information about roles of projects is defined as a matrix and it can be described as                      Where  can be calculated as follows        The variables n, m represent the total numbers of projects selected and role types respectively The set of target projects is denoted by P p 1  p 2  p n  and the same to roles by R r 1  r 2  r n In order to find all the frequent patterns of roles in target OSS projects, association rules are set as where the During the mining process, the problem of mining frequent patterns could be transformed into the form as follows The sets P and R are taken as the transaction database and items respectively For all target projects to be analyzed, the new specific item i which is always set as 1 is added into transaction database. In the association rules only those rules in which the consequent satisfy  is considered. As a consequence of this method, the minconfidence can be neglected and we can only focus on the minsupport of association rules. This allows us to pay major attention to the combination of antecedents. In other words, we can concentrate on the question of role configuration itself In practice, if we expect to explore the projects before 3000 in rank list, we only need to set the item i of these projects as 1 and set i of others projects as 0. This method could greatly reduce the workload of analysis and conduce to mining the frequent patterns of roles in a large number of OSS projects 5  E XPERIMENT AND R ESULTS  The number of participants within an OSS project would determine the configuration of roles greatly, so projects with different number of participants may have different frequent patterns of roles. Consequently, all of the target projects are divided into 5 groups based on the number of participants which are described in Table TABLE III  G ROUPS DIVIDED BY THE NUMBER OF PARITCIPANTS   index Number of develo p ers G1 2-4 G2 5-10 G3 11-20 G4 21-30 G5 31 5.1  D ISTRIBUTION OF F REQUENT P ATTERNS OF R OLES  Each group is analyzed respectively in two different rank extent by Apriori algorithm with the minsupport = 5%, and the conclusion is given in Table TABLE IV  S TATISTIC OF FREQUENT PATTERNS WITH MINSUPPORT 5   Group_id Rank range Number of projects Number of frequent patterns 1   2 3 4 5 6 G1 [1  591  3 2 0 0 0 0 7000,1000 1094  3 2 0 0 0 0 G2 [1  470  10  10  2 0 0 0 7000,1000 443  5 5 0 0 0 0 G3 [1  287  11  27  7 0 0 0 7000,1000 339  11  18  7 0 0 0 G4 1  95  15  46  44 12 0 0 7000,1000  76  11  24  15 1 0 0 G5 1  117  20  86 143 103 29 2 7000,1000  58  17  51  48 14 0 0 The number represents the quantity of  antecedent in association rules 5.2  R ESULT A NALYSIS  There are some reasons in the statistical perspective to believe that the projects with higher rank would be more trustworthy than others, so we only inspect the frequent patterns of roles appearing in rank [1,30  L i m i t e d b y t h e  paper length, we take the G5, in which the data about roles is the most reasonable, as example, and the support of frequent patterns in top5 is listed in Table 1  To the role configuration, only the support of ProjectManager & Developer is beyond 70%, and the support of the rest patterns is not high. The highest s upport in the case of 3 roles is about 35%, in case of 4 roles is about15%, and 5 is even lower than 5  Based on the mining result, several observations can be discovered and be discussion 2  In the G1 group, there is no obvious difference of role configuration between the rank extent [1, 30 a n d [7 000    T h e r e  a r e o n l y 3 k i n d s o f f r e q u e n t p a t t e r n s o f  r o l e s  with support more than 30%, which are ProjectManager 447 


35.36%,36.02%\, Developer \(92.72%,93.42%\ and ProjectManager & Developer \(30.46%,30.35%\ The reason may be that in these projects the number of total participants is no more than 4. And so it can be concluded that in this kind of projects the labor division is not clearly most kinds of development are undertook by few developers or project managers 3  Except G1 and the case with only 1 role, the number of frequent pattern s in rank extent [1,3000 is  obvious greater than in the extent [7000,100  T h e  p h e n o m e n o n s h o w s  that the projects with higher rank usually own more kinds of roles, and it may be judged that these projects generally were well organized. Such as in G2, the support of frequent patterns with TranslatorI18NL10N, DocWriter, Tester WebDesigner in rank extent [1 i s  hi g h e r t h a n  t h e  extent [7000,10000  T h e r e  i s s i m i l a r Except G1, it can be believed that the frequent patterns in rank extent [1,30 c oul d r e fl e c t t h e  m o s t  r e a s o n a b l e  r o l e  configuration in OSS projects phenomenon in other groups TABLE V  F REQUENT PATTERNS OF G5 IN TOP 5 6   C ONCLUSION AND F UTURE W ORK  Some information related to participators and role structure of projects can reflect some properties of OSS projects and be obtained from software repository automatically, so they could be taken as a kind of evidence in software trustworthy assessment. Through a large number of OSS projects in SourcForge, some interesting frequent patterns of roles are discovered by association rules. Based on the work in this paper, it can be believed that the data about roles and participators from software repository can be used to improve or even replace some metrics in the existing evaluation models and will help evaluate OSS projects efficiently and automatically. This work is part of the research on evaluation of OSS projects by using the roles, tasks and contributions of projects participators, and can be regarded as a further step of previous work A CKNOWLEDGEMENT  This work was partially funded by National High-Tech Research and Development Plan of China under Grant 2007AA010301\ National Natural Science Foundation of China under Grant \(No.60903043\, and the Core electronic devices, high-end general chip and fundamental software  Major Project\(2009ZX01043-001-04 R EFERENCES  1  Lin Yuan, Huaimin Wang, Gang Yin, et al. Trustworthy Evaluation Technology of Software Based on Roles. Journal of Beijing University of Technology, Vol.36, No.5, 611--615\(2010 2  Lin Yuan, Huaimin Wang, Gang Yin, et al. Mining Roles of Open Source Software. In 2nd International Conference on Software Engineering and Data Mining, IEEE Press Chengdu\(2010 3  LIU Ke, SHAN Zhi-guang, WANG Ji, et al. Basic research of trustworthy software” survey of the grand research plan. China Science Fund, 2008\(3\: 145-151 4  TRUSTIE-STC, Software Trustworthiness Evidence Framework Specification \(V2.0\, http://www.trustie.net/download/ STEFS-2.0.pdf 5  Golden's OSMM, http://www.navicasoft.com/pages 6  CapGemini's OSMM. http://www.seriouslyopen.org/nuke/html 7  OpenBrr. Business Readiness Rating for Open Source. \(2005-110\[2009-10-20 h t t p    www o p e n b rr o r g  BRR 2005.pdf 8  Atos Origin. Method for Qualification and Selection of Open Source software \(V1.6\. http://www.qsos.org/ download/qsos-1.6-en.pdf 9  R. Agrawal, C. Faloutsos, and A. Swami. Efficient similarity search in sequence databases. In Proc. of the Fourth International Conference on Foundations of Data Organization and Algorithms, Chicago, October 1993   Agrawal, R. and Srikant, R. 1994. Fast algorithms for mining association rules. In Proc. of the 20th VLDB Conference, pp.487-499 N  N u  u m b e r  o  o f  r o l e s    F  F r  r e q u e n t  p a t t e r n s  o f  r o l e  c  c o n f i g u r a t i o n    S  S u  u p p o r t    2 ProjectManager & Developer 70.085 Tester & Developer 41.026 Tester & ProjectManager 35.043 DocWriter & Developer 33.333 AllHandsPerson & Developer 31.624 3 Tester & ProjectManager & Developer 35.043 DocWriter & ProjectManager Developer 27.350 AllHandsPerson & ProjectManager Developer 24.786 Nospecificrole & ProjectManager Developer 23.932 TranslatorITLT & ProjectManager Developer 23.077 4 Nospecificrole & Tester ProjectManager & Developer 15.385 AllHandsPerson & Tester ProjectManager & Developer 15.385 DocWriter & Tester & ProjectManager Developer 15.385 Nospecificrole & DocWriter ProjectManager &Developer 13.675 WebDesigner & Tester & ProjectManager Developer 12.821 5 Nospecificrole & AllHandsPerson Tester & ProjectManager & Developer 8.547 Nospecificrole & DocWriter & Tester ProjectManager & Developer 8.547 PorterCrossPlatformDevel WebDesigner & Nospecificrole ProjectManager & Developer 6.838 PorterCrossPlatformDevel WebDesigner & DocWriter ProjectManager & Developer 6.838 448 


002p 002p     1         1     v<h p 006 212 006 006 212 212 212 006 006 212 212 006 It forms projected DBs for valid items i.e v<h c a   b c in the UF-tree For instance if R R R R  R R R R R R R R 006 R      p 005 005 005 2  3     4  1  1 1 also satisfy 125 min 1    max 005 005 5 batches and each batch to contain 1M transactions In addition to this dataset we also conducted the following experiments using some other datasets including UCI real-life datasets as well as FIMI datasets The observations or trends were consistent 002 p X X X X  are guaranteed to be invalid due to projected DB where where  Note that instead of checking all as in UF-streaming  CUF-streaming only needs to check O  Again CUF-streaming only needs to check O  However 322frequent\323 itemsets found in these projected DBs need to be checked against if  the algorithm only needs to check sum sum sum sum for for for for  items are arranged in non-ascending order j j j j j 2 2 e d c b a e d n n  r j is of the form  the algorithm only needs to form projected DBs for itemsets satis\336es such that valid items come before/below invalid items in the UF-tree For instance if is of the form is of the form value items are arranged in non-descending order is of the form is of the form  items are arranged in non-descending order until it 336nds the 336rst invalid item  All remaining items domain items and ii  items where  CUF-streaming also stores only valid itemsets in the UF-stream structure Unlike UF-streaming  until it 336nds the 336rst valid item 1.5 1.6 1.8 as well as their 322extensions\323 No more constraint checking is needed as any 322frequent\323 itemsets found in the projected DBs of valid items and their 322extensions\323 are guaranteed to be valid due to anti-monotonicity of in the UF-stream structure Same approach is then applied to the second batch and results in the same UF-stream structure as shown in Fig 2\(a Afterwards CUF-streaming applies the same approach to the third batch this results in the same UF-stream structure as shown in Fig 2\(b  From the 322frequent\323 itemsets against are guaranteed to be valid further constraint checking is needed for 322extensions\323 of the  from leaves to the root The algorithm then checks  322Frequent\323 itemsets found in these projected DBs are guaranteed to be valid due to the anti-monotonicity of  322Frequent\323 itemsets found in these projected DBs are guaranteed to be valid due to the monotonicity of  Unlike the procedures for other three types of constraints the algorithm forms projected DBs for 322extensions\323 of of Type III or IV having selectivity   the algorithm forms projected DBs for itemsets  are guaranteed to be invalid due to  then all supersets of values from leaves to the root if as not all of them are valid By exploring the convertible anti-monotonicity of  domain items are arranged in non-ascending order values from leaves to the root if is an itemset with non-positive is an itemset with non-negative is a Type I constraint So when the 336rst batch of transactions from uncertain data stream 337ows in our proposed CUF-streaming algorithm arranges domain items in ascending order of also violate  domain items where of of the form of  domain items are arranged in non-descending order of  domain items against of or of values By doing so the algorithm checks violates  then all 322extensions\323 of also violate of of values By doing so the algorithm checks each domain item against  All 322extensions\323 of a valid of WBC counts i.e items due to convertible monotonicity of re guaranteed to be invalid due to gainst    invalid e.g e.g e.g gainst items because some of these 322extensions\323 may be valid With i i.e if as all remaining items and UF-streaming 006  T YPE II M ONOTONE C ONSTRAINT  CUF-streaming arranges domain items in a monotonic decreasing or increasing order  T YPE III C ONVERTIBLE A NTI MONOTONE C ON STRAINT  Like Type II CUF-streaming arranges domain items in  The mined 322frequent\323 itemsets that satisfy one of the above four types of constraints are then stored in the UF-stream structure Afterwards CUF-streaming handles subsequent batches of streaming transactions of uncertain data in a similar fashion Like UF-streaming  006    1.35 CUF-streaming then stores all four constrained 322frequent\323 itemsets 006 005 006 005 attr attr attr attr  0,1 CUF s t re a m i n g c he c k s O    k v v i m h h v v i v v h h v h h m items as well as avg avg a c a c 1  n n  j j j 005 006 006 VI E XPERIMENTAL R ESULTS We used different datasets for experimental evaluation For space limitation we reported here the experimental results on a dataset generated by the program developed at IBM Almaden Research Center T hi s da t a s e t c ont a i ns 10M re c ords w i t h an average transaction length of 10 items and a domain of 1,000 items We assigned an existential probability from the range 0,1 t o each i t em i n each t r an s act i o n  W e s et t h e window size to be  005 013 013 013  For each values such that values from leaves to the root if against each domain item until it 336nds the 336rst invalid one  For each against each domain item until it 336nds the 336rst invalid one  Again projected DBs are formed only for the valid items against each item in the projected DB until it 336nds the 336rst invalid one T YPE IV C ONVERTIBLE M ONOTONE C ONSTRAINT  Again CUF-streaming arranges domain items in such that valid items come before/below invalid items in the UF-tree For instance if against each domain item in the UF-tree i.e attr X.attr const attr X.attr const attr X.attr const const attr attr X.attr const const attr attr const attr const attr because all remaining items values By doing so the algorithm checks value domain items are arranged in non-ascending order 1 r x C x x Y x C O C m m C C C C C x x x x Y x C x C x C m C C C X C X C x x x C C X C X C C C C C C x x C X m C 002 m C C C c c b a C w f  f  i v 005     CUF-streaming mines constrained 322frequent\323 itemsets more effectively as it pushes the constraint inside the mining process and explores properties of the constraint Revisit the uncertain data stream in Example 1 r i>v items While further constraint checking is unnecessary for 322extensions\323 of the Example 3 valid items come before/below invalid items valid valid invalid Y Y 


preMinsup Fig 3 Experimental results runtimes All experiments were run in a time-sharing environment in an 800 MHz machine The reported 336gures are based on the average of multiple runs Runtime includes CPU and I/Os it includes the time for both tree construction and frequent itemset mining steps We evaluated different aspects of the proposed algorithms which were implemented in C First we compared the performance of the three proposed algorithms using four different constraints one from each type of the above constraints Experimental results showed that the runtimes for both UF-streaming 100   150   200   250   10   20   30   40   50   60   70   80   90  Selectivity \(i.e., percentage of items selected CUF-streaming \(w=5 batches, each with 1M transactions Type IV constraint C4  Type II constraint C2                      Type III constraint C3                      Type I constraint C1                                 100   150   200   250   300   350   400   450   10   20   30   40   50   60   70   80   90  Selectivity \(i.e., percentage of items selected CUF-streaming \(w=50 batches, each with 1M transactions Type IV constraint C4  Type II constraint C2                      Type III constraint C3                      Type I constraint C1                                 50   55   60   65   70   75   80   85   90   0.002   0.003   0.004   0.005  preMinsup \(in percentage Runtime vs. existential probability & preMinsup Items take on an average number of existential probability values                      005 005    t t 327 327 005 items All 322extensions\323 of valid items were valid Due to the item ordering the algorithm stopped checking constraints whenever it detected the 336rst invalid items However for on the mining results For example using 0.8 C C C C C C C C C C w w C C w 0.9 preMinsup  90 of the mined constrained 322frequent\323 itemsets were truly frequent When and UF-streaming Asitexplored properties of these four constraints and pushed the constraints inside the mining process CUF-streaming required shorter runtimes than the other two algorithms As shown in Fig 3\(a the runtimes for handling all four types of constraints increased when the selectivity increased Among them a Runtime vs selectivity  a Type I constraint incurred the lowest runtime among the four types of constraints because CUF-streaming formed fewer 322extensions\323 as they consisted of only valid items Again due to the item ordering the algorithm stopped checking constraints whenever it detected the 336rst valid items Next we repeated the above experiment with a different the window size was low say 10 only a few small UF-trees were constructed and mined as the algorithm only 322extended\323 valid items and a shorter runtime 50 c Runtime vs  and the convertible monotonicity of  the monotonicity of  the convertible anti-monotonicity of 110 sec cf 160 sec in Fig 3\(a was required As another example for 5 batches when  the algorithm applied constraint checking on projected DBs for valid items as well as their 322extensions\323 because not all 322extensions\323 of valid items were valid  the algorithm 322extended\323  many bigger UF-trees were constructed and mined as the algorithm formed projected DBs for both valid as well as invalid domain items which took or having more batches in the sliding window had the bene\336ts of increasing the chance of not pruning relevant expected support information for truly frequent itemsets Moreover as shown in Fig 3\(c when increased fewer itemsets had expected support performed constraint checking as an intermediate step prior to storing the 322frequent\323 itemsets into the UF-stream structure In contrast CUF-streaming was more interesting as it runtimes depended on the type of constraints as well as the constraint selectivity Speci\336cally the algorithm explored the anti-monotonicity of a Type II constraint and a Type III constraint incurred the next two highest runtimes For  and thus shorter runtimes were required The 336gure also showed the effect of the distribution of item existential probability When items took on a few unique existential probability values the UF-tree b ecame smaller Thus times for both UF-tree construction and mining became shorter In addition we also measured the number of nodes in each UF-tree The experimental results showed that the total number of nodes in a UF-tree was no more than the total number of items with their existential probability in all transactions in the current batch of uncertain data stream Furthermore we measured the number of nodes in the UF-stream structure as well As UF-streaming   126 400 sec cf 230 sec in Fig 3\(a As all three algorithms are approximate algorithms we evaluated the effect of  95 of the mined constrained 322frequent\323 itemsets were truly frequent However lowering 5 b Runtime vs selectivity  were constant regardless of the constraint selectivity because these two algorithms did not explore property nor did they push the constraints inside the mining process Speci\336cally UF-streaming only valid preMinsup minsup preMinsup minsup preMinsup preMinsup preMinsup performed constraint checking as a postprocessing step whereas UF-streaming a Type IV constraint incurred the highest runtime because CUF-streaming 322extended\323 i.e formed projected DBs for both valid and invalid items performed constraint checking at a post-processing step the size of UF-stream was observed to be independent of the constraint selectivity In contrast as Items take on many different existential probability values  50 336xed-sized batches with each batch containing 0.1M transactions instead of using 5 336xed-sized batches with each batch containing 1M transactions With this setting each batch was smaller 0.1M vs 1M transactions Thus each batch required lower runtime e.g for constructing and mining UF-trees However the number of batches was higher 50 vs 5 batches than the previous setting This explains why the runtimes see Fig 3\(b took on a broader range than the previous experimental results For example when the selectivity of 1 2 3 4 4 2 3 2 3 1 2 4 w w 0   Runtime \(in seconds 0   Runtime \(in seconds 0   Runtime \(in seconds Items take on a few unique existential probability values                     50   50   0.001   


 ch 6 AAAI/MIT Press 2004  G  G r ahne L  V  S  L aks h m a nan and X  W ang 322E f 336 ci ent m i n i n g o f constrained correlated sets,\323 in ACM TKDD  Proc KDD 2009 Proc VLDB 1994 Proc KDD 2009 Proc IEEE ICDE 2008 Proc PAKDD 2007 Proc VLDB 2008 Proc IEEE ICDE 2000 Proc VLDB 2008 Proc IEEE ICDE 2009 Proc IEEE ICDM 2006 Proc IEEE ICDE 2002 Proc IEEE ICDE 2001 Proc IEEE ICDE 2008 preMinsup minsup Proc U  09 Proc PAKDD 2008 Proc ACM SIGMOD 2008 Data Mining and Knowledge Discovery Proc ACM SIGMOD 1993 Proc SSTD 2005 Proc ACM SIGMOD 2000 Proc ACM SIGMOD 2009 Proc ACM SIGMOD 1998 Proc ACM SIGMOD 2008 2 pp 18\32026 June 2005 12 C G ia n n e lla e t a l 322 M in in g f r e q u e n t p a tte r n s in d a ta s tr e a m s a t m u ltip le time granularities,\323 in 4 pp 337\320389 Dec 2003  C  K  S  L eung 322F r e quent i t e m s et m i ni ng w i t h cons t r ai nt s  323 i n 127 1 batch containing the entire dataset Then we compared our algorithms with UF-growth 22 b y as s i g n i n g t o each i t em i n e v er y t r an s act i o n in a dataset an existential probability of 1 i.e all items are de\336nitely present in the dataset and 005 005 Encyclopedia of Database Systems queries on uncertain streams,\323 in 34 28 34  pp 29\32037 2 R  A gr aw al et al   322M i n i n g a s s o ci at i o n r ul es bet w een s e t s of i t e ms i n large databases,\323 in  pp 207\320216 3 R  A gr aw al and R  S r i kant  322 F a s t al gor i t h ms f o r m i n i n g a s s o ci at i o n rules,\323 in  pp 487\320499 4 R  J  B ayar do J r   R  A g r a w a l  and D  G unopul os  322 C ons t r ai nt b as ed rule mining in large dense databases,\323 2\3203 pp 217\320240 July 2000 5 T  B e r n e c k e r e t a l 322 P r o b a b ilis tic f r e q u e n t ite m s e t m in in g in u n c e r ta in databases,\323 in  pp 119\320127 6 R  C h e n g e t a l 322 P r o b a b ilis tic v e r i\336 e r s  e v a lu a tin g c o n s tr a in e d n e a r e s tneighbor queries over uncertain data,\323 in  pp 47\32058 8 G  C or m ode and M  H adj i e l e f t her i ou 322F i ndi ng f r e quent i t e m s i n dat a streams,\323 in  pp 1530\3201541 9 G  C o r m o d e e t a l 322 F in d in g h ie r a r c h ic a l h e a v y h itte r s in s tr e a m in g d a ta  323  pp 400\320417  M M G a ber  A  B  Z a s l a v s k y  and S  K r i s hnas w am y  322Mi n i n g d at a streams a review,\323  pp 512\320521  J  H a n J  P e i  and Y  Y i n  322 Mi ni ng f r e quent pat t e r n s w i t hout candi dat e generation,\323 in  pp 1\32012 15 J  H u a n g e t a l 322 M a y B M S  a p r o b a b ilis tic d a ta b a s e m a n a g e m e n t s y s tem,\323 in  pp 1071\3201074  C  J i n e t a l   322 S l i di ngw i ndo w t op pp 301\320312  L  V  S  L a ks hm anan C  K  S  L e ung and R  T  N g 322E f 336 ci ent dynam i c mining of constrained frequent sets,\323  pp 9\320 18  C  K  S  L eung and B  H ao 322 Mi ni ng of f r e quent i t e m s et s f r o m s t r eam s of uncertain data,\323 in  pp 1663\3201670  C  K  S  L eung and Q  I  K han 322D S T r ee a t r e e s t r uct u r e f o r t he m i ni ng of frequent sets from data streams,\323 in  pp 928\320 933  C  K  S  L eung M A  F  Mat e o and D  A  B r a j czuk 322 A t r eebas e d approach for frequent pattern mining from uncertain data,\323 in  pp 13\320 24  J  P e i  J  H a n and L  V  S  L aks h m a nan 322Mi n i n g f r e quent i t e m s et s w i t h convertible constraints,\323 in  pp 433\320442  C  R 253 e et al 322Event queries on correlated probabilistic streams,\323 in  pp 715\320728 27 A  D  S a r m a  M  Th e o b a ld  a n d J  W id o m  322 Ex p lo itin g lin e a g e f o r con\336dence computation in uncertain and probabilistic databases,\323 in  pp 1023\3201032  K  Y i et al   322S m a l l s ynops es f o r g r oupby quer y ver i 336 cat i o n o n outsourced data streams,\323  pp 819\320832 322frequent\323 itemsets from uncertain data streams In terms of ef\336ciency the experimental results showed that UF-streaming was slightly faster because it did not perform any constraint checking whereas our three proposed algorithms performed the extra constraint checking step Among them CUF-streaming only performed constraint checking on some 322frequent\323 itemsets and the other two performed constraint checking on all 322frequent\323 itemsets However in terms of the mining results we observed that all four algorithms returned the same collection of 322frequent\323 itemsets This illustrated that our proposed algorithms could be used for mining unconstrained frequent itemsets from uncertain data streams Moreover it is important to note that while the UF-streaming is con\336ned to 336nding 322frequent\323 itemsets satisfying constraints with 100 selectivity our algorithms are capable of 336nding 322frequent\323 itemsets that satisfy constraints having lower selectivity Along this direction we set and CUF-streaming both pushed the constraint early the corresponding size of UF-stream was proportional to the selectivity of constraints Finally we evaluated the functionality and applicability of our proposed algorithms We again used four different constraints and we also set the constraint selectivity be 100 i.e all items are selected Then we compared our three proposed algorithms with UF-streaming  w hi c h w a s designed to mine 1 UF-streaming 4 article 2 Jan 2008 10 X  D a i e t a l 322 P r o b a b ilis tic s p a tia l q u e r ie s o n e x is te n tia lly u n c e r ta in data,\323 in 3 article 15 Aug 2009 29 Q  Zh a n g  F  Li a n d K  Y i 322 F in d in g f r e q u e n t ite m s in p r o b a b ilis tic data,\323 in  pp 1179\3201183 Springer 2009  C  K  S  L eung and D  A  B r a j czuk 322E f 336 ci ent a l gor i t h m s f o r m i n i n g constrained frequent patterns from uncertain data,\323 in Data Mining Next Generation Challenges and Future Directions w  UF-streaming unconstrained and CUF-streaming\321 which integrate i mining of uncertain data ii constrained mining and iii mining of data streams These algorithms effectively mine constrained frequent itemsets from uncertain data streams A CKNOWLEDGMENT This project is partially sponsored by Natural Sciences and Engineering Research Council of Canada NSERC and the University of Manitoba in the form of research grants R EFERENCES 1 C  C  A ggar w al et al   322F r e quent pat t e r n m i ni ng w i t h uncer t a i n dat a  323 i n  pp 653\320661  C  K  S  L eung R  T  N g  a nd H  Manni l a  322 O S S M  a s e gm ent a t i o n approach to optimize frequency counting,\323 in SIGMOD Record ACM TODS ACM TODS k 4   Again we observed that all four algorithms returned the same collection of frequent itemsets This illustrated that our proposed algorithms could also be used for mining unconstrained frequent itemsets from static uncertain datasets VII C ONCLUSIONS Frequent itemsets generally serve as building blocks for various patterns in many real-life applications Most of the existing algorithms 336nd unconstrained frequent itemsets from traditional static transaction databases consisting of precise data However there are situations in which ones are uncertain about the contents of transactions There are also situations in which users are only interested in some subsets of all the mined frequent itemsets Furthermore a 337ood of data can be easily produced in many situations To deal with all these situations we proposed three tree-based algorithms\321 namely UF-streaming   pp 973\320982 7 C  K  C hui  B  K ao a nd E  H ung 322Mi n i n g f r e quent i t e m s et s f r o m uncertain data,\323 in     pp 583\320592  R  T  N g et al   322E xpl or at or y m i n i n g a nd pr uni ng opt i m i zat i ons of constrained associations rules,\323 in  


              


   


                        





