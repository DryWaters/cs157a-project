A Uniform Framework for Processing Temporal Object Queries L Wang, M Wing C Davis N Revel1 School of Computing Science Middlesex University Bound Green Road London N112NQ United Kingdom email  l.c.wang m.wing, c.davis n.revel1 mdx.ac.uk Abstract This paper explores a uniform framework for processing temporal queries in the context of 
object-oriented databases A temporal object data model is developed by extending the un@ed rvdel of RDBs and OODBs from UniSQLLY with a time-dimension, that forms temporal relational llke cubes but with aggregation and inheritance hierarchies A query algebra is thereby defined to provide an access of objects through these associations of aggregation inheritance and time rleference Due to the hierarchy 
of the data model and reducibility of the query algebra an txtensible approach to processing temporal object queries within the uniform query processing framework is attained A set of transformation rules is identiped for query rewrite, that includes the known relational and object rules plus those pertaining to the time-reference To evaluate temporal queries involved in the path a decomposition strategy is proposed It 
has been shown that temporal object queries can be processed and optimized within the uniform query processing framework l Introduction Whilst the semantic limitations of relational databases RDBs are widely recognised cbject-oriented database systems OODBs are emerging as the most promising database tkxhnology to satisfy the needs of advanced database applications such as computer-aided tilesign CAD computer-aided manufacturing CAM computer-aided software engineering CASE document and multimedia preparation office automation and scientific computing Many of these advanced database applications require 
a support for time-varying data. Management c!f temporal data becomes one of the key challenges that today\222s OODBs need to address 6 181 As lieported in lo 11 13 81 the vast majority of research on temporal databases \(TDBs\has been lbcused on the incorporation of time elements into existing data models Little work that has been clone on 
query processing and optimization 7 12 141 is in the context of RDBs. Dayal and Wuu 131 proposed a uniform approach to processing temporal queries in the context of functional object oriented data model But their work didn\222t take account the query optimization and evaluation within a query processing framework. Also their work is based on a functional model 
and language fbat would lead the functional optimization quite different from the algebraic cost-based ciptimization techniques employed in RDBs as well as a number of OODBs 9  In this paper we investigate processing temporal object-oriented queries within a uniform ltramework By the uniform framework we mean that temporal queries can be processed and cbptimized within the existing object-oriented framework that 
is extended from the relational l/ramework, through smoothly extending the techniques developed for existing OODBs and TDBs Query optimization techniques are dependent upon the query modelllanguage The query model iln turn is based on the data model underlying the data, as the latter defines the access primitives 28 0-8186-8551-4/98 10.00 0 1998 IEEE 


29 that are used by the query model 9 So our work started from the development of temporal object data model We adopt the unified model of RDB and OODB from UniSQLlx 6,2 as a snapshot object data model and then incorporate within it with a time dimension A temporal object query algebra is thereby defined as a query modeVlanguage to provide an access of objects. The features of the hierarchy of data model and the reducibility of query algebra provide a basis to explore or extend the techniques and strategies for processing temporal object queries within the existing query processing framework An extensible approach to temporal query processing within the uniform framework is therefore attained 221The remainder of this paper is organised as follows Section 2 describes the adaptation of the unified data model of RDB and OODB with the inclusion of a time dimension The algebra for the data model is given in Section 3 Section 4 presents an extensible approach to temporal query processing. Processing the temporal query components is discussed in Section 5 Section 6 includes conclusions and future work 2 221me data model 2.1 The unified model of OODB and RDB 221The unified data model of RDB and OODB from UniSQLlx 6 21 extends the relational data model in three important ways, each reflecting a key object-oriented concept 1 nested predicates 2\inheritance 3 methods. Allowing a column of a relation to hold a tuple of another relation directly leads to a nested relation. Allowing the users to attach procedures to a relation and to have the procedures operate on the column values in each tuple achieves the combination of data with program Allowing the users to organise all relations in the database into a hierarchy such that between a pair of relations P and C P is made the parent of C if C takes inherits all columns and procedures defined in P besides those defined in C the relational model integrates the object oriented concept of inheritance UniSQUX actually makes one more extension to the relational model allowing the row/column entry of a relation to have a set of values i.e any number of values rather than just a single value: and further allowing the set of values to be of more than one arbitrary data type This provides an ability to represent the many-to-many relationship between two collections. The model is an object-oriented model and it is adopted as a snapshot model to inclxporate time I:n addition we preserve the basic object concepts such as 223any real-world entity is uniformly modelled as an object\224 223each object is associated with a unique identifier\224 etc so that het\(5rogeneity in the time dimension and the grouped completeness of algebra can be maintained as discussed in our previous work  171 2.2 A temporal object Let T   t tl I be a set of times at most countably infinite, over which is defined the linear total\order 221 where tl 221t means t occurs before \(earlier than tJ For the sake of simplicity we can assume that T is isomorphic to the set of natural numbers Any subset of Tis called a temporal set A temporal set can be represented as a union of disjoint time intervals The most basic property of temporal sets is that they are closed under finite unions intersections and complementation That is if TI and TZ are temporal sets then so are TJuT TInT2 TI-T2 and 7Tl If an object o which is any real world entity, exists for a certain period of time which is a subset of T\(i.e the temporal set this period is called the object\222s lifespan denoted as yo for the object 0 If the lifespan Uo  the duration of time is called a span spun\(o tpnd tstun+l In 


30  Regular experimantal eas order to support for derived lifespans, we allow the usual set-theoretic operations over lifespans That is if Ll and L2 are lifespans then so are LpL2 LlnL2 L1 and A temporal object is defined as a time sequence TS for short t o\(t tgL\(o denoted as L\(o o\(t or simply o\(f or o  A temporal object Yo o\(t asserts that the object o\(t is valid for its lifespan L\(o and its value changes with time For a constant object 0 it may be represented with no timestamp where its time reference is implied as L\(o It can also be represented with the explicit time reference as a temporal object L\(o o Fig 1 gives three basic types of time-varying entity. For the step-wise constant yo oft    ti ovi.1 ti ovi ti+l ovjt1  The term epoch from signal processing is used to refer to the time at which the object changes its value e.g ti The interval during which the value ovi persists is determined by the epoch ti and its succeeded epoch tit i.e ti ti+l If there are n elements in a TS it is said that there are n epochs For the discrete time event if the value of the entity is recorded at every single time point \(if it does not it can be represented by a time series with unequal spacing in time like the step wise constant and the entity value at the time point between recorded time points can be assumed or determined depending on the application we have L\(o o\(t   t;.I ovi.1 tl ovi ti+l continuous time event it can be treated as a sampled continuous time signal and therefore be OV I   OV ovi ov;+l   ovJ i.e it can be represented by a discrete time series. For the ir ment: discrete represented by a discrete time series If a TS contains a value for each time point in the lifespan duration it is called a regular TS 5 e.g the above discrete time event If a TS contains values for only subset of time points within the lifespan, it is called an irregular TS e.g the step-wise constant The complete history of an irregular TS can be reconstructed by a function e.g linear interpolation As a TS is a set so a temporal object can be represented by its sub-objects. In practice the lifespan may consist of disjoint noncontiguous segments as in 5 we  Salary Step-wise constant Entity Value t ptity Value Atmospheric temperataure continuous prefer to use null values rather than defining multiple segments in the lifespan In OODBs every real world entity is uniformly modelled as an object that is grouped into a class \(relation and interrelated to other objects through associations Now we isolate a class relation C from its association relationship Time  as shown in Table 1 The value is an object with lifespan lmn The tuple is also an object its lifespan is L\(tm  ulmn The lifespan of attribute A is L\(An Limn    t-.\221  denoted as L\(tJ We have    Values The lifespan of relation C is Fig 2 A 3-Dimensi~nal Class Thus a 2-dimensional relation class\\223table\224 becomes a 3-dimensional \223cube\224 as shown in Fig 2 L\(C A  A uL\(A    VL\(t,,J It is obvious that 


31 j=Uti This implies that there is no value for an attribute in a tuple for any moment in time outside the intersection of the life spans of the tuple and the attribute. Clearly our temporal object model can support a completely heterogeneous temporal dimension It is possible to refer to the components of a temporal object. For a temporal object o=<T,o o.~and o.Trefer to its value and temporal set components respectively \(sometimes we omt U i.e 0.2 o or o.Z;rt t  to refer to the value of the object 0 Let A be the name of an attribute that can take a temporal object for its values then A.u and A.T represent names for the value and temporal set components of the attribute A Further, the same notation may be applied to class relation C If C is the name of a temporal relation then C U and C.Trepresent names for the value and temporal set components of the class C If the domain of attribute A of class C is another class C\222 then implicitly L\(A C\222 If class C is a subclass of class C\222 then L\(C C\222 Moreover if a database consists of n classes \(relations C 22  Cm the lifespan of the database schema is L L\(C C  uL\(C,J Join 01 W p  Ad Aoi  02 ible 2 Summary of basic Definition 03={0 I M 0 where L\(O 03={0 I SO where L\(O3 T2 where L Ol oz 03=01Up?={O ISo1VM where L\(03 Ol oz where L Ol oz 01-@={0 1 M 01 A*\200 07 03qm={O I OE  AO\200 op o=\(o I 0 E 0 Ar\(0,t Wl  Ai 0 41:gl\(o  Ai:gi\(o I OEO m\(o o gebraic operators O\(Tl o\(T 2 0 Notes 0 is a ColIection L\(0i  is the life-span of Oj  op 0 selects the elements 2230\224 of set 0 such as the predicate P\(o t holds For the type of objects in 01 i.e OEO g retums an object of type of   i.e g\(o oz If gi=l it retums the OID of the domain object of Ai unless Ai is atomic We retain gi=l so that project on a set of objects relation likes the relational project Essentially a join as in relational algebra 7he life-span of l\(O is TlnL.\(o 221Iime-slice purely reduces the relation along the tempoid dimension If Ti equals to time point ti i.e T1=tl then l\(O represents an event o\(t1\happened at ti 223Shifts\224 a snapshot relation at ti by the number of positions specified by the offset 1 Maps a set of objects 0 to its temporal set 3 Queryalgebra 


32 From the algebra point of view a temporal OODB TOODB\can be viewed as a collection of temporal objects grouped together in classes relations\and interrelated through three associations aggregation generalisation and time-reference Each temporal relation can be viewed as a 3 dimensional structure i.e a cube Basically, the standard relational algebra provides a unary operator for each of its two dimensions select for the value dimension and project for the attribute dimension. The temporal algebra supports an operation on the third dimension i.e the time dimension time-slice An object algebra allows the predicate of the select operation on a contiguous sequence of attributes along a branch of class-aggregation hierarchy This sort of query is usually represented by a path l and is often referred as an implicit join We have defined the enhanced path that extends the path with time-reference so that the select provides an access of data along associations of both aggregation hierarchy and time-reference A complete set of algebraic operators has been defined for our temporal object data model The detailed definitions are given 17 Table 2 simply lists some basic algebra operators 4 An extensible approach to processing temporal object-oriented queries The temporal object data model and an algebra for this model presented in the previous sections provide a basis for query processing Due to the hierarchical feature of our data model, as shown in Fig 3 our algebra possesses the property of reducibility. That is when time dimension is not taken into account the temporal object algebra will be reduced to the object algebra and when the object-oriented features of aggregation and inheritance are not taken into consideration the algebra will be reduced to the relational algebra We therefore could explore an extensible approach to processing temporal queries within the existing object query processing framework that in turn is extended from relational query processing framework 4.1 Optimizer hierarchy Our optimizer is of a hierarchical structure as shown in Fig 4 where the temporal optimizer is built on the top of the object optimizer that in turn is on the top of the relational optimizer The temporal object queries can be processed and optimized within the existing query processing framework through smoothly extending the existing query processing techniques Fig 3 Data model hierarchy 4.2 Query transformations I lh emporal optimizer I Fig 4 Optimizer hierarchy One important aspect of query optimization is the transformation of one query into an equivalent query that might be more efficient to evaluate The size of the search space of equivalent query plans for a snapshot query is determined in part by the algebraic equivalence available in the snapshot algebra As we represent a temporal object as a time series that can 


33 be thought of as the equivalence of a 221blob\222 object the transformation rules in object algebra can directly apply As our object algebra is also consistently extended from relational algebra the relational algebraic transformation rules can directly apply. Now we identify the following transformation rules Relational rules techniques in RDBs They are called relational rules The following set of equivalencies is derived from well-known algebraic optimization C,UC c2 uc commutative law C,n C2  C2 n C commutative law CiD6 Ci=cj CI U c1 c idempotent law C,n CI=cI idempotent law c,-c,=0 c1 u0 c C1nO=O Ci D 60G0 c 0 e 0-c,=0 C c2 e2  CI CI  c2  C3 CI  C2 c3 OPI CIW2  C2UOPl c OPI OP2 Cl  OPl cl CP1.4 P2 Cl ClDC c2 cc2 DC c1 CiDG c2 D6 C3 C2 c3 nAi\(clW2 c1 commutative law commutative law associative law associative law It is a good heuristic to push select, project and time-slice or offset as far down the query graph as possible esp to perform the time-slice as early as possible It has been identified some transformations are incorrect in general 14 A selection can not be pushed through an aggregate operator or offset operator An aggregation operator can not be pushed through an offset operator and vice versa Path transformation rules In OODBs select operation allows its predicate on a contiguous sequence of attributes along a branch of the class-aggregation hierarchy We use the path to express this sort of predicate and the 


34 enhanced path expression to represent the path that includes the time references For simplicity we suppose the time-reference occurs at the end of the path even if it is not, it will only involve the looking up storage and will not provide any difficulty to the query optimization Generally speaking the attribute/domain link between a class C and domain D of one of the attributes A of C creates the join between the class C and 0 in which the attribute A of the class C and identifier OID which is defined by the system and which can be considered as an attribute of class D are join attributes l Therefore, an object query with a path expression involving N classes is equivalent to a relational query which requires the join in N relations corresponding to N classes  11 This is why select operator is usually called an implicit join According to the definition of our algebra when the predicate of select involving a path expression is as path op value=CI.AI.A 2....AnrM op v the equivalence between an implicit join and an explicit join is as CI  7C ci DQP 7Z c2  DUP Cn 1 Ai 0 CI AI A2 AnrM Op U A\(CI We use Dd to represent the join that is slightly different from the join defined in our algebra in that the join attributes are the attribute Ai of the class Ci and identifier OID of C if we join Ci.1 and Ci The project specifies the query target If there is a complex predicate involving a single path such as P  CI AI op VI and CI Ai.Az op v2  and CI.AI Az A vn  Pi and Pz  and P then we have a general form 0 c  n cP,c1 DQ nAZaP2\(cz DQ  DQ apn\(Cn 2 P\(C8 AI Ai AIC where Pi is optional that can be omitted if it does not exist P involves both time and value dimensions and the first project specifies the query target The way to visit the path introduces a path traversal operator. The Linear path traversal operator is a navigational operator N-op[Cl.A 2....A T to execute the implicit join along a path It is equivalent to a set of joins as in equation 2 N-op[Ci AI A2 A  OP,Ci DUP 0 C DQP...D4P OPn\(C 3 A P According to the associative law in previous subsection, the above linear path traversal operator can be further rewritten into the following form N-op[Cl AI A1 A N-op[C AI A  I bap c C N_op[Cl.Al A2 bU c 4 0 C  z A\(C,i\(N-~p[CI.Al _.__ A DQ C 5 Cm A=OlD\(C Thus Cn-i A=olD\(c",nP P\(CI AI A1 i Fig 5 A sample path temporal queries      Fig 6 A operator graph Fig 5 is a single path with n classes Fig 6 gives an operator graph \(OG for equation 5 that involves such a single path An OG is a labelled n-ary tree where the leaf nodes represent collection of objects, the non-leaf nodes represent operators e.g join navigational operator etc and the edges represent temporary collections that can be represented by support tables 


35 4 A support table can be regarded as a collection of tuples of qualified object identifiers and attributes Two support tables can be joined together if there exists a common supported collection between them The execution of an OG follows bottom-up order In order to processing temporal queries we have assumed a temporal class is at the end of a path. Therefore the evaluation of the enhanced path can be initially decomposed by dividing the path into two parts a sub-path with time-referenced class and an ordinary sub-path without time-stamped classes\that can be further divided into sub-paths The decomposition strategy for processing temporal queries can be further illustrated in Fig 7 A complex user query with path expressions that involves time-references is first translated into a set of single path expressions A single path is then divided into two sub-paths a sub-path containing a time-stamped class that can be optimized by making use of the ordering information of temporal data and an ordinary sub-path that can be further decomposed and traversed using different algorithms The intermediate results of traversed two sub-paths are joined together to create the output query Fig 7 A decomposition strategy 5 Processing temporal query components The block B in Fig 6 consists of temporal predicate evaluation as well as time-series processing and a join which can be further expressed in Fig 8 As temporal data provide more opportunities for optimization 7 141 temporal optimization comes into play at this stage When optimizing such a query the object optimizer takes charge of the outer query block and the temporal optimizer operates on the nested query block Each optimizer is responsible for its own query blocks 5.1 Time-related operations and optimization Predicate evaluation in Fig 8 involves the time-related operation and value evaluation Temporal operations such as time-slice offset aggregation can be treated as methods and its output can then participate in the value evaluation. Temporal optimizer must be sure to 221plan\222 the evocation of function and make use of the ordering information for optimization. Stream processing approach is a strategy for optimization utilising the ordering information of data 7 141 5.2 Join Let C and D represent the supporting tables or the intermediate results of block A in Fig 6 and B\222 in Fig 8 as shown in Fig 9 There are various join algorithms to join C and D together The advantage in representing it as an explicit join is that we can use well-known join algorithms to perform optimization Here a temporal object stands as a 221blob\222 object that can be treated as an ordinary object in a snapshot OODB Two basic types ofjoins are: forward join and reverse join Forward-Join FJ The idea of FJ can be informally presented as follows l Given a pair of classes C and 13 such that D is the domain of an attribute A of C the values of that attribute A are identifiers of 


36 the instances of class D If classes C and D are in this order in a given permutation the join between these classes is obtained by the following operations ForcinCdo begin retrieve c.A a  B  OID\(d A is single-valued C    i g g rzg all0 n upport lable f block A retrieve d in D such that tc  OID\(d A is multi-valued evaluate the predicate on d end sub-path Fig 8 Further decomposition of temporal Implementation of forward join can integrate pointer-chasing with well-known join algorithms for optimization, such as pointer-based nested loops pointer-based sort-merge and pointer-based hybrid-hash etc 151 If however the permutation involves retrieving the instances in class D before the retrieval of the instances in C then the following reverse join schema will apply Reverse-Join RJ The idea of RJ can be informally presented as follows  13 ford in D do retrieve u=OID\(d evaluate the predicate on d retrieve c in C such that c.A=u ifA is single-valued u~c.A ifA is multi-valued end begin  Z Fig 9 Join between block A and block B As there is no direct link from D collection to C a value-based join must be used to check the OID membership condition. This algorithm is efficient when the predicate in the last collection is selective It performs value-based comparisons of OIDs which is generally inefficient on a CPU 4 Again, the implementation can employ relational algorithms of nest loop join sort-merge join etc 6 Conclusions In this paper we present a uniform framework for processing temporal object-oriented queries The temporal data model presented is of a hierarchical structure it forms the relational-like cubes but with aggregation and inheritance associations as it is evolved from the unified model of RDB and OODB that is in tum extended from the relational model A query algebra that is thereby defined to provide an access of objects through these associations of aggregation inheritance and time-reference possesses the property of reducibility i.e when the time-reference is not taken into account it will be reduced to the object algebra that in tum will be reduced the relational algebra when the hierarchies of aggregation and inheritance do not exist. The hierarchical structure of data model and the reducibility of query algebra provide a basis to extend existing query processing and evaluation techniques for temporal object query processing Query transformation can then be carried out based on a set of algebraic transformation rules identified A strategy of decomposition is then proposed for processing temporal queries that involve paths That is evaluation of an enhanced path which is defined to refer to the path with the time-reference is decomposed by 


37 initially dividing the path into two sub-paths one containing the time-stamped class that can be optimized by making use of the ordering information of temporal data and another an ordinary sub path with no time-stamped class which can be further decomposed and evaluated using different algorithms. The intermediate results of traversed two sub-paths are then joined together to create the query output It has been shown that techniques developed for relational join pointer-based join and sequential processing can be adapted to process the decomposed temporal query components 4 temporal object is defined as a time series which can be treated as a function of time, that avoids thie complexity of a general temporal relational join Temporal optimizer is built on the top of object optimizer that requires less modification of object optimizer since the techniques of object-oriented query processing and evaluation as well as sequence processing can directly apply Future work will involve a detailed study of execution algorithms and cost analysis References 1 Bertino E and Martino L 1993 Object-Oriented Database Systems Concepis and Architecrures Addison-Wesley Publishers Ltd 2 DAndrea A and Janus P 1996 UNISQL's next-generation object-relational database management system SIGMOD RECORD 25\(3 3 Dayal U and Wuu G.T.J 1992. A uniform approach to processing temporal queries Proc ofthe 18th lnt Con on VLDB p407-417 Canada 4 Gardarin G er al 1996. Cost-based selection of path expression processing algorithms in object-oriented databases Proc offhe 22th Int Con on VWB p 390-401, Mumbai, India 5 Ginsburg S 1993 A temporal data model based on time sequences Temporal Databases Theory, Design and Implementation edited by A U Tansel er al p248-270 Benjamin Cummings Publishing 6 Kim W 1993. Object-oriented databases systems: promises, reality, and future Proc ofthe 19th Int Con on VLD6 p676-687, Dublin, Ireland 7 hung T.Y.C., and Muntz R.R 1993 Stream Processing: Temporal Query Processing and Optimization Temporal Databases: Theory, Design and Implementarion edited by A.U Tansel et al p329-355 Benjamid Cummings 8 Ozsoyoglu G and Snodgrass R T 1995. Temporal and real-time databases a survey IEEE Trans on Knowledge and Data Engineering 7\(4 9 Ozsu M T and Blakeley J A 1995 Query processing in object-oriented database system Modem Database Sysrems the Object Model Interoperabiliry and Beyond edited by W Kim p146-174 ACM Press 10 Pissinou N et al 1993 On temporal modelling in the context of object databases SIGMOD RECORD 22\(3\8-15 11 Pissinou N et al 1994. Towards an infrasmcture for temporal databases report of an invitational ARPmSF 12. Segev A 1993 Join processing and optimization in temporal relational databases Temporal Databases Theoiy 13. Segev A et al 1995. Report on the 1995 international workshop on temporal databases SIGMOD RECORD 24\(4 14. Seshadri P et al 1996. The design and implementation of a sequence database system Proc of the 22th Int Con on 15 Shekita E J and Carey M.J 1990 A performance evaluation of pointer-based joins Proc ofACM SIGMOD Conf 16 Snodgrass R 1995. Temporal object-oriented databases a critical comparison Modem Database Systems the Object 17 Wang L Wing M Davis C and Revell N 1996 An algebra for a temporal object data model LNCS 1134 18 Wang, L Wing M Davis, C and Revell N 1996 Query processing in object-oriented databases Proc of 13th workshop SIGMOD RECORD 23\(1 35-51 Design and Implementation edited by A.U Tansel er al p356-387. Benjamin/ Cummings 46-52 VWB p 99-1 IO India 300-311 Atlantic NJ Model, Interoperabilify and Beyond edited by W Kim\p 386-408. ACM Press Database and en Systems Applications p667-677, Proceedings Zurich Switzerland European Meeting on Cybemetics and System Research p803-808 Vienna Austria 


CMP A Fast Decision Tree Classifier Using Multivariate Predictions  449 H Wang and C Zaniolo Mining Recurrent Items in Multimedia with Progressive Resolution Refinement  461 0 Zai'ane J Hun and H Zhu Panel Session 22 Is E-Commerce a New Wave for Database Research Moderator Anant Jhingran IBM T.J Watson Research Center USA Panelists Sesh Murthy IBM T.J Watson Research Center USA Sham Navathe, Georgia Institute of Technology USA Hamid Pirahesh IBM Almaden Research Center USA Krithi Ramamrithan University of Massachusetts-Amherst USA Industrial Session 23 Java and Databases Pure Java Databases for Deployed Applications  477 N Wyatt Database Technology for Internet Applications  700 A Nori Session 24 Association Rules and Correlations Finding Interesting Associations without Support Pruning  489 E Cohen M Datar S Fujiwara A Gionis P Indyk R Motwani J Ullman and C. Yang Dynamic Miss-Counting Algorithms Finding Implication and Similarity Rules with Confidence Pruning  501 S Fujiwara J Ullman and R Motwani Efficient Mining of Constrained Correlated Sets  512 G Grahne L Lakshmanan and X Wang Session 25 Spatial and Temporal Data Analyzing Range Queries on Spatial Data  525 J Jin N An and A Sivasubramaniam Data Redundancy and Duplicate Detection in Spatial Join Processing  535 J.-P Dittrich and B Seeger Query Plans for Conventional and Temporal Queries Involving Duplicates and Ordering  547 G Slivinskas C Jensen, and R Snodgrass xi 


Industrial Session 26 XML and Databases Oracle  The XML Enabled Data Management System  561 S Banerjee V Krishnamurthy M Krishnaprasad, and R Murthy XML and DB2  569 J Cheng and J Xu Session 27 High-Dimensional Data Independent Quantization An Index Compression Technique for High-Dimensional Data Spaces  577 S Berchtold, C Bohm H Jagadish H.-P. Kriegel and J Sander Deflating the Dimensionality Curse Using Multiple Fractal Dimensions  589 B.-U Pagel F Korn and C. Faloutsos Similarity Search for Multidimensional Data Sequences  599 S.-L Lee S.-J Chun D.-H Kim, J.-H Lee and C.-W Chung Session 28 Web-Based Systems WRAP An XML-Enabled Wrapper Construction System for Web Information Sources  611 L Liu C Pu and W. Hun Self-Adaptive User Profiles for Large-scale Data Delivery  622 U Cetintemel M Franklin and C. Giles Industrial Session 29 Main Memory and Small Footprint Databases In-Memory Data Management in the Application Tier  637 The TimesTen Team SQLServer for Windows CE -A Database Engine for Mobile and Embedded Platforms  642 P Seshadri and P. Garrett Join Enumeration in a Memory-Constrained Environment  645 I Bowman and G Paulley xii 


Plenary Panel Session 30 XML Databases   Moderator: Michael Carey, IBM Almaden Research Center USA Panelists Adam Bosworth, Microsoft Corporation USA David De Witt University of Wisconsin-Madison, USA Alon Levy University of Washington USA Bruce Lindsay IBM Almaden Research Center USA Jennifer Widom Stanford University USA Demo Session 1 Web Query Optimizer  661 V Zadorozhny L Bright L Raschid T Urhan and M Vidal ReQueSS: Relational Querying of Semi-structured Data  664 R Sunderraman The IDEAL Approach to Internet-Based Negotiation for E-Business  666 J Hammer C Huang Y Huang C Pluempitiwiriyawej M Lee H Li L Wang Y Liu and S Su READY A High Performance Event Notification Service  668 R Gruber B Krishnamurthy, and E Panagos A Multimedia Information Server with Mixed Workload Scheduling  670 G Nerjes DISIMA An Object-Oriented Approach to Developing an Image Database System  672 V Oria T Ozsu P Iglinski B Xu and L Cheng Demo Session 2 The Collaboration Management Infrastructure  677 H Schuster D Baker A Cichocki D Georgakopoulos and M Rusinkiewicz Assisting the Integration of Taxonomic Data The LITCHI Toolkit  679 I Sutherland J Robinson S Brandt A Jones S Embury W Gray R White and F Bisby TheaterLoc: Using Information Integration Technology to Rapidly Build Virtual Applications  681 G. Barish Y.4 Chen D Dipasquo, C Knoblock S Minton I Muslea and C Shahabi Lineage Tracing in a Data Warehousing System  683 Y Cui and J Widom xiii 


The Mentor-Lite Prototype A Light-Weight Workflow Management System  685 J Weissenfels M Gillmann 0 Roth, G Shegalov and W Wonner Location Prediction and Queries for Tracking Moving Objects  687 0 Wolfson B Xu and S Chamberlain Semiorder Database for Complex Activity Recognition in Multi-Sensory Environments  689 S Bhonsle A Gupta S Santini and R Jain Tutorial 1 Web Information Retrieval  693 M Henzinger Tutorial 2 Mobile and Wireless Database Access for Pervasive Computing  694 P Chrysanthis and E Pitoura Tutorial 3 Data Mining with Decision Trees  696 J Gehrke Tutorial 4 Directories Managing Data for Networked Applications  697 D Srivastava Tutorial 5 Indexing High-Dimensional Spaces Database Support for Next Decade\222s Applications  698 S Berchtold and D Keim xiv 


 T5.I2.D100K T10.I4.D100K T15.I4.D100K T10.I6.D400K T10.I6.D800K T10.I6.D1600K Optimizations across Databases 5 0 5 10 15 20 25 30 35 40 45 Improvement COMP TREE COMP-TREE 1 2 4 8 1 2 4 8 1 2 4 8 2 4 8 2 4 8 1 2 4 8 Processors Databases Figure 5 Effect of Computation and Hash Tree Balancing good as the COMP optimization The reason that the hash tree balancing is not suf\336cient to offset inherent load imbalance in the candidate generation in this case The most effective approach is to apply both optimizations at the same time COMP-TREE The combined effect is suf\336cient to push the improvements in the 40 range in the multiple-processor case On 1 processor only hash tree balancing is bene\336cial since computation balancing only adds extra cost 5.4 Short-circuited Subset Checking Figure 6 shows the improvement due to the short-circuited subset checking optimization with respect to the unoptimized version The unoptimized version is the Apriori algorithm due to Agrawal et al 5 The results are presented for dif ferent number of processors across dif ferent databases The results indicate that while there is some improvement for databases with small transaction sizes the optimization is most effective when the transaction size is large In this case we get improvements of around 25 r the unoptimized version To gain further insight into this optimization consider 336gure 7 It shows the percentage improvement obtained per iteration on applying this optimization on the T20.I6.D100K database It shows results only for the uni-processor case r similar results were obtained on more processors We observe that as the iteration k increases there is more opportunity for shortcircuiting the subset checking and we get increasing bene\336ts of up to 60 The improvements start to fall off t the high end where the number of candidates becomes small resulting in a small hash tree and less opportunity for short-circuiting It becomes clear that is an extremely effective 15 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 T5.I2.D100K T10.I6.D800K T15.I4.D100K T20.I6.D100K procs across Databases 0 5 10 15 20 25 Improvement 1 2 4 8 Figure 6 Effect of Short-circuited Subset Checking 23456789101112 Iterations 0 10 20 30 40 50 60 improvement T20.I6.D100K Figure 7  Improvement per Iteration  proc   16 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


optimization for larger transaction sizes and in cases where there are large number of candidate k itemsets 6 Conclusions In this paper e presented a parallel implementation of the Apriori algorithm on the SGI Power Challenge shared memory multi-processor We also discussed a set of optimizations which include optimized join and pruning computation balancing for candidate generation hash tree balancing and short-circuited subset checking We then presented experimental results on each of these Improvements of more than 40 were obtained for the computation and hash tree balancing The short-circuiting optimization was found to be extremely effective for databases with large transaction sizes Finally we reported the parallel performance of the algorithm While we d good speed-up we observed a need for parallel I/O techniques for further performance gains References  R Agra wal T  Imielinski and A Swami Database mining A performance perspecti v e  I n IEEE Trans on Knowledge and Data Engg  pages 5\(6 1993  R Agra wal T  Imielinski and A Swami Mining association rules between sets of items in lar ge databases In Proc M SIGMOD Intl Conf Management of Data  May 1993  R Agra wal H Mannila R Srikant H T o i v onen and A I V erkamo F ast disco v ery of association rules In U F et al editor Advances in Knowledge Discovery and Data Mining  MIT Press 1996  R Agra wal and J Shafer  P arallel mining of association rules design implementation and e xperience Technical Report RJ10004 IBM Almaden Research Center San Jose CA 95120 Jan 1996  R Agra wal and R Srikant F ast algorithms for mining association rules In Proc 20th VLDB Conf  Sept 1994  M Cierniak W  Li and M J Zaki Loop scheduling for heterogeneity  I n 4th IEEE Intl Symposium on High-Performance Distributed Computing also as URCS-TR 540 CS Dept Univ f Rochester  Aug 1995  M Holsheimer  M  K ersten H Mannila and H T o i v onen A perspecti v e on databases and data mining In 1st Intl Conf Knowledge Discovery and Data Mining  Aug 1995  M Houtsma and A Swami Set-oriented mining of association rules In RJ 9567  IBM Almaden Oct 1993  H Mannila H T o i v onen and I V erkamo Ef 336cient algorithms for disco v ering association rules In AAAI Wkshp Knowledge Discovery in Databases  July 1994  J S P ark M Chen and P  S Y u  A n e f fecti v e hash based algorithm for mining association rules In Proc M SIGMOD Intl Conf Management of Data  May 1995 17 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 J S P ark M Chen and P  S Y u  E f 336cient parallel data mining for association rules T echnical Report RC20156 IBM T J Watson Research Center Aug 1995  G Piatetsk y-Shapiro Disco v ery  presentation and analysis of strong rules In G P S et al editor  KDD  AAAI Press 1991  A Sa v asere E Omiecinski and S Na v athe An ef 336cient algorithm for mining association rules in large databases In Proc 21st VLDB Conf  1995  M J Zaki M Ogihara S P arthasarathy  and W  Li P arallel data mining for association rules on shared-memory multi-processors Technical Report 618 Department of Computer Science University of Rochester 618 1996 18 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


