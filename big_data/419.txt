Database Support r 3D-Protein Data Set Analysis Alexander Hinneburg Institute of Computer Science University of Halle Germany hinneburg@informatik.uni-halle.de Wolfgang Lehner Database Technology Group Dresden University of Technology Germany lehner@inf.tu-dresden.de Abstract The ress in genome research demands for an adequate infrastructure to analyse the data sets Database systems re\337ect a key technology to organize data and speed up 
the analysis process This paper discusses the role of a relational database system based on the problem of 336nding frequent substructures in multi-dimensional protein databases The speci\336c problem consists of producing a set of association rules regarding frequent substructures with different lengths and gaps between the amino acid residues of a rotein From a database point of view the process of 336nding association rules building the base for a more in-depth analysis of the data material is split into two parts The 336rst part performs a discretization of the conformational angle space of a sin 
gle amino acid residue by computing the nearest neighbour of a given set of representatives The second part consists in adapting a well-known association rule algorithm to determine the frequent substructures Both steps within this comprehensive analysis task requires substantial support of the underlying database in order to reduce the ramming overhead at the application level 1 Introduction The progress in genome research generates a tremendous need for an adequate infrastructure to store and ef\336ciently analyse the underlying data sets Although most of 
the current data sets are stored in 337at 336les database technology may help to organize and speed up the overall analysis process by exploiting existing database functionality This paper focusses on the role of a relational database system referring to a project 336nding frequent substructures in protein data sets The motivation of the project stems from the observation that the number of known protein sequences grows very fast r the known three-dimensional structures of proteins are lower in the order of magnitudes than the number of known protein sequences because the 
underlying X-ray protein analysis is time consuming and ultimately very  Therefore there is a strong desire to derive the 3Dstructure directly from the protein sequence The standard technique protein homology modeling is limited to proteins for which proteins with known 3D-structures and similar sequences exist Unfortunately for most proteins with known sequences and unknown 3D-structures homology modeling is not possible so that the alternative y to learn about the behaviour and/or functionality of the proteins from the structure is based on the analysis of substructures The analysis process of our sample project applica 
tion consists of the two separate steps of discretization of the multi-dimensional dihedral angle space and the generation of frequent item sets Both steps need to be supported by the underlying database system in order to achieve an ef\336cient analysis process and increase the acceptance of database systems in the biotechnology research community Contribution of the Paper The paper is logically divided into two parts One thread of the paper addresses the modeling perspective of the speci\336c application and outlines the mapping of the protein structures based on a data model consisting of a sequence of vectors of dihedral angles to 
a relational scenario The second thread discusses the operational issue and focusses on the database optimization  The bottom line of the paper emphasizes two major issues on the one hand we strongly believe that the current relational database technology does not yet re\337ect a perfect data storage and data analysis platform On the other hand we propose extensions to a relational database engine which might be exploited by a huge variety of data mining or knowledge ry in general applications Structure of the Paper The following section outlines current techniques to analyse 3D protein data from the ap 
plication point of view Additionally our proposed representation of 3D protein structure information within the dihedral angle space model is presented Section 3 focusses on the 336rst step of the data analysis process to 336nd similar Proceedings of the 15th International Conference on Sci entific and Statistical Database Management \(SSDBM\22203 1099-3371/03 $17.00 \251 2003 IEEE  


substructures picking the nearest representative for each single amino acid residue Solutions using currently existing features of the relational database technique show that there is a demand for a more speci\336c database support The comparison of multiple methods illustrates that only minimal extensions may result in a huge bene\336t In the same vein we show that the generation of frequent item sets as the second step in performing the analysis process is not ef\336ciently implementable relying only on existing technology 2 Methods and Models for rotein Analysis This section outlines current methods for 3D protein data analysis as well as the dihedral angle space model to present protein information within our application project 2.1 Current Methods of 3D Protein Data Analysis In recent years a good number of high-resolution Xray structures of proteins stored in the Protein Data Bank PDB http://www.pdb.org have become available Statistical methods have been applied to the PDB to extract knowledge about the conformational behaviour 1 of the smallest protein substructures the amino acid residues Amino acid side chain conformations have been studied for example by 4 These studies led to side chain rotamer libraries which consist of a list of discrete conformations with a weight corresponding to their frequency in the PDB Since the PDB contains a multitude of high-resolution structures it s also possible to determine rotamer preferences depending on the backbone conformation A backbonedependent side chain rotamer library for example was developed by Based on this idea a number of weak correlations of rotamer distributions and secondary structures have been found by The ef fecti v eness of the backbonedependent rotamer libraries has been shown by for homology modeling and y for NMR and X-ray structure re\336nement Although the idea of using rotamer libraries has already been applied successfully in the past only a small fraction of their potential has been revealed The main limitation of the available rotamer libraries is the fact that they describe only correlations within the conformation of the smallest possible substructure of a protein i.e for a residue r for the better understanding of 3D structures it is highly desirable to examine larger substructures consisting of multiple residues so that the relationship of a residue to its neighbours in the sequence can be understood In the basic idea of 336nding those kinds of frequent substructures  1 Conformation of a protein or a substructure means its 3D-structure Figure 1 Sample representation of the amino acid Lysine with torsion and side chain angles  within a protein data set is explained thoroughly Based on this idea the requirements regarding the support of database technology are discussed in the remainder of the paper 2.2 The Dihedral Angle Model Within the backbone-dependent rotamer library developed by for each residue type a probability distrib ution of the side chain angle 001 1 is calculated for each node on an equidistant grid in the 2D  002 003  space The distributions of 001 2 001 3 and 001 4 only depend on the previous side chain dihedral angle Figure 1 shows the sample amino acid lysine with four torsion axes within its side chain and the associated dihedral angles  001 1 to 001 4  of the side chain From an analysis point of view the main problem is detecting global relationships consists in the derivation of a probability distribution based on more than one single angle In our application framework we transform the description of the conformation of amino acid residues into data points of a multi-dimensional dihedral angle space If P denotes a set of protein sequences and A is the set of all 20 natural amino acids a single sequence p 001 P may be formally described as a sequence of linked amino acid residues a  i.e p 001 P p  a 1 a 2 a l a i 001 A i 1 l The main bene\336t performing all analysis steps within the representation of the dihedral angle model is that a the 3D-structures of the conformations are fully re\337ected and b the representation is invariant against rotation and translation Formally a single protein p 001 P is represented in the dihedral angle model as a sequence of vectors of dihedral angles p 001 P D  p  s 1 s 2 s l  s i 001  212 180  180 d i i 1 l In this representation D re\337ects the mapping of the original 3D coordinates to dihedral angle values and d i is the number of dihedral angles for the associated amino acid residue Proceedings of the 15th International Conference on Sci entific and Statistical Database Management \(SSDBM\22203 1099-3371/03 $17.00 \251 2003 IEEE  


a i consisting of the 3D position denoted by 002  003  004 and the optional side chain angles 001 1 to 001 4  Since the backbone part of a residue is equal for all residue types the backbone angles  s 1 s 2 s 3  have to be present Depending on the speci\336c residue type the remaining angle values represent the optional side chain angles 001 1 to 001 4  s i  001  002 003 004  d i 3  002 003 004 001 1 001 d i 025 3 3 d i 002 7  r example the amino acid glycine is represented only by its backbone information without any additional side chain angles i.e d i 3  rgenine on the other hand exhibits four side chain angles so that d i results to 7  The corresponding relational mapping of the protein information consists of a single relational table Each tuple represents a single amino acid residue consisting of the 3letter identi\336er three mandatory i.e NOT NULL and d i 212 3 337oating number attributes An additional attribute denotes the dimensionality of the amino acid residue i.e re\337ecting the number of NOT NULL dihedral angle values Based on this relational representation the 336rst step in analysing the 3D protein structures in the introduced dihedral angle model consists in the discretization of the conformational angle space according to the observed data distribution After assigning a representative angle vector to each individual residue the second step encompasses the orderpreserving generation of frequent item sets The algorithmic procedures and the relational implementation will be discussed 3 Data Discretization The main goal of our application process is the detection of similar and frequent substructures While the generation of frequent item sets and the necessary extension of the underlying database system are discussed in the following this section focuses on the problem of 336nding similar amino acid residues From an application point of view we apply a cluster algorithm within the multi-dimensional dihedral angle space The clustering process results in each amino acid residue being assigned to a given prototype To achieve the highest degree of similarity the 323nearest\323 prototype is required to be the representative of a single residue r our scenario the prototypes are pre-determined either by random sampling i.e randomly picking a number of data points and using it s prototype or by applying more advanced algorithms like k means Further details can be found at 3.1 Nearest Neighbour Rule From the application point of view the conformational space of each of the 20 natural amino acid residues is Figure 2 Wrap-Around Effect in the Dihedral Angle Model mapped onto a set of prototypes within the discretization step From an implementational point of view the data points in the multi-dimensional dihedral space are mapped onto prede\336ned prototypes using the nearest neighbour rule In the context of the dihedral angle model the distance between two points in the multi-dimensional space is computed with the shortest path measures using the Euclidean distance Due to the continuous semantics of an angle space an adaptation to the regular distance computation is necessary because of the wrap-around effect at the point  212 180  180  Figure 2 illustrates the effect of the wraparound at the borders of a multi-dimensional angle space using a two-dimensional plane More formally the distance between two data points in an d dimensional angle space is computed by the following formula x y 001  212 180  180 d dist  x y  002 003 003 004  d 005 i 1 001  x i 212 y i  2   x i 212 y i 002 180 360 212 x i 212 y i   2  else In SQL the equation computing the Euclidian distance between two points in a multidimensional dihedral angle space may be easily d by using case statements to r the wrap-around effect and to deal with the variable number of angles i.e with the 337exible dimensionality of the amino acid residues r the sake of simplicity the scalar function edist\(x,y is introduced for a small sample scenario r a 336ve-dimensional angle space  002  003  004  001 1  001 2  the edist function would be de\336ned as follows CREATE FUNCTION edist x1 FLOAT x2 FLOAT x3 FLOAT x4 FLOAT x5 FLOAT y1 FLOAT y2 FLOAT y3 FLOAT y4 FLOAT y5 FLOAT RETURNS FLOAT AS CASE WHEN ABS\(x1-y1 THEN ABS\(x1-y1 Proceedings of the 15th International Conference on Sci entific and Statistical Database Management \(SSDBM\22203 1099-3371/03 $17.00 \251 2003 IEEE  


a Resolution 10 b Resolution 20 Figure 3 Discretizations of the conformational space of glycine with different resolutions ELSE ABS\(x1-y1 END  CASE WHEN ABS\(x2-y2 THEN ABS\(x2-y2 ELSE ABS\(x2-y2 END  CASE WHEN ABS\(x3-y3 THEN ABS\(x3-y3 ELSE ABS\(x3-y3 END  CASE WHEN x4 IS NOT NULL THEN CASE WHEN ABS\(x4-y4 THEN ABS\(x4-y4 ELSE ABS\(x4-y4 END ELSE 0 END  CASE WHEN x5 IS NOT NULL  analogously to x4 END AS dist The effect of the discretization is shown for the conformational space of glycine in 336gure 3 Figure 3\(a shows the discretization with resolution 10 and part b with a resolution of 20 prototypes All data points plotted in grey in the same cell are assigned to the black plotted prototype Note that because of the wrap-around effect the cells at a border are connected with the opposite part 3.2 Computing the Nearest Neighbor The most obvious way to compute the nearest neighbour for each conformation of the current amino acid residue is to iterate r the content of the database An inner loop r all potential prototypes is then required to identify the nearest prototype i.e the cluster to which the current amino acid residue belongs to Although this algorithm might be easily implemented at the application level each point of the multi-dimensional angle space must be d from the database compared with the potential prototypes and the result must be written back into the database i.e every tuple must be updated to record the associated prototype Another option would be exploiting the capabilities of the underlying database system and implementing the nearest neighbour search using SQL Since no data transfer between the database system and the application at the client is necessary this approach looks promising IF the database system is able to provide the necessary operational environment Based on the two tables PConformation  holding the raw data converted and imported directly from the PDB and PPrototypes  re\337ecting the set f prede\336ned prototypes we discuss three different methods computing the nearest neighbour directly inside the database system 3.3 The Pivot-Method The Pivot-Method is based on the idea that the set of prototypes is transformed so that the resulting table holds only one single tuple with n times the original set of columns where n is the number of prototypes Supposed we have three different prototypes within a 336ve-dimensional angle space  002  003  004  001 1  001 2  A view de\336ning the transformed table would be speci\336ed as follows CREATE VIEW PrototypesPivot AS SELECT p1.id AS id1 p1.phi AS phi1 p1.psi AS psi1 p1.omega S omega1 p1.chi1 AS chi11 p1.chi2 AS chi12 p2.id AS id2 p2.phi AS phi2 p2.psi AS psi2 p2.omega S omega2 p2.chi1 AS chi21 p2.chi2 AS chi22 p3.id AS id3 p3.phi AS phi3 p3.psi AS psi3,p3.omega AS omega3 p3.chi1 AS chi31 p3.chi2 AS chi32 FROM PPrototypes p1 PPrototypes p2 PPrototypes p3 WHERE p1.pid  1 AND p2.pi d=2AND p3.pid  3 Although pivoting the prototype table looks terribly inef\336cient the self-join of the prototypes addresses exactly a single tuple so that an existing index on the prototype ID reduces the overhead of the join to the concatenation of the prototype tuples The selection of the nearest neighbour is then expressed as the Cartesian product of the protein conformation table with the single tuple of the view PrototypesPivot followed by the case statement picking the prototype ID with the minimum Euclidean distance r the running example the statement would be as follows Proceedings of the 15th International Conference on Sci entific and Statistical Database Management \(SSDBM\22203 1099-3371/03 $17.00 \251 2003 IEEE  


SELECT p.id p.phi p.psi p.omega p.chi1 p.chi2 id of amino acid residue x.id x.mindist id of prototype with min distance FROM SELECT phi psi omega chi1 chi2 least\(edist\(phi psi omega chi1 chi2 phi1 psi1 omega1 chi11 chi12 edist\(phi psi omega chi1 chi2 phi2 psi2 omega2 chi21 chi22 edist\(phi psi omega chi1 chi2 phi3 psi3 omega3 chi31 chi32 as mindist FROM PConformations PrototypesPrivot x Prototypes p WHERE p.phi  x.phi AND p.psi  x.psi AND p.omega  x.omega AND p.chi1  x.chi1 AND p.chi2  x.chi2 It is worth mentioning here that the least  scalar function like the min  aggregation function produces the minimal value of the iven set of parameters t does not preserve the position of the minimal value so that a rejoin with the original Prototypes table is necessary to retrieve the ID of the nearest prototype for each tuple i.e amino acid residue produced by the inner view r the least  operator is not part of the SQL standard t provided by a huge number of database systems like Oracle or must be implemented as UDF Since the function is CPU-bound the execution cost may be neglected 3.4 The SelfJoin-Method The self-join method is basically equivalent to the t method it picks the minimal distance from prototypes stored vertically i.e as tuples within a table and not horizontally after performing the t operation Analogously to the t method a view is de\336ned as a shortcut in the core SQL statement to determine the nearest neighbour The view PrototypeAssign computes the Euclidean distance for each single amino acid residue and every possible prototype candidate It is worth mentioning here that no restriction in the where clause is feasible to reduce the size of the temporary result CREATE VIEW PrototypeAssign AS SELECT pc.id as pc_id pc.phi pc.psi pc.omega pc.chi1 pc.chi2 id of amino acid residue pt.id as pt_id edist\(pc.phi pc.psi pc.omega pc.chi1 pc.chi2 pt.phi pt.psi pt.omega pt.chi1 pt.chi2 AS dist id of prototype with distance FROM ProteinConformation pc Prototypes pt Picking the combination with the minimum distance may be accomplished by referring to the prede\336ned view in two separate phases Within an inner query for each amino acid residue the minimal distance is generated using a groupby by operator and the min  aggregation function Unfortunately the information which prototype i.e the prototype id is lost in this step and must be 323added\323 by a re-join in the outer query The re-join again requires the view de\336nition The correct prototype ID and the angle values are d by picking the minimal distance prototype for each amino acid residue SELECT pa.pc_id pa.phi pa.psi pa.omega pa.chi1 pa.chi2 id of amino acid residue pa.pt_id pa.dist id of prototype with min distance FROM SELECT pc_id min\(dist AS dist FROM PrototypeAssign GROUP BY pc_id pc each amino acid with min distance prototypeassignment pa WHERE pc.pc_id  pa.pc_id AND pc.dist  pa.dist 3.5 The MINPOS Method The self-join method would be very nice and intuitive if the problem of losing the position of the minimal values could be eliminated If an adequate operator were available the re-join could be avoided and the query could be cuted much more ef\336ciently As a consequence we propose an extension to the set of aggregate functions by introducing the minpos  and maxpos  function Both functions are associated to the min   max  function and return the value of a column P if the value of an aggregate column X holds the minimal/maximal value within an aggregate group If multiple tuples exhibit the minimal/maximal value the minpos   maxpos  function returns randomly one of the valid solutions r example consider the following table with three columns A  X  and P and six tuples AXP A151 A132 A173 A221 A282 A223 The application of minpos  and maxpos  can be illustrated using the following query SELECT A MIN\(X MINPOS\(X,P MAX\(X MAXPOS\(X,P FROM R table above GROUP BY A Obviously the query returns two s one for each group The minpos  function returns the values of column P of the tuple holding the smallest X value within each group i.e Proceedings of the 15th International Conference on Sci entific and Statistical Database Management \(SSDBM\22203 1099-3371/03 $17.00 \251 2003 IEEE  


A MIN\(X MINPOS\(X,P MAX\(X MAXPOS\(X,P A1 3 2 7 3 A2 2 3 8 2 Using the extension the discretization step could be ecuted more ef\336ciently by the following query based on the view PrototypeAssign  SELECT pc.id pc.phi pc.psi pc.omega pc.chi1 pc.chi2 id of amino acid residue pa.pt_id pa.dist id of prototype with min distance FROM SELECT pc_id MIN\(dist AS dist MINPOS\(dist pt_id AS pt_id FROM prototypeassignment GROUP BY pc_id pa each amino acid id with min distance and prototype d ProteinConformation pc WHERE pa.pc_id  pc.id It is worth mentioning here that the join with the ProteinConformations table can be avoided if the result does not require the individual angles of all amino acid residues 4 Generating Order-Preserving Frequent Item Sets Based on the original data set with the associated nearest neighbour e can focus on the derivation of association rules to r frequent substructures within the protein data set In a 336rst step transaction sets are generated so that the order of the amino acid residues is preserved A second step encompasses the generation of the frequent item sets applying well-known algorithms like APriori Again the database perspective will be discussed In this context a new operator supporting the generation process of the item sets will be introduced 4.1 Generating the Transaction Data Set After the discretization of the conformational spaces by assigning the nearest prototype to each amino acid residue the vector sequences describing the conformations f the protein structures p 001 P  are transformed into sequences r a discrete alphabet The basic idea of the approach is to replace each residue conformation by the prototype identi\336er which stands for a set of similar 3D conformations of the same residue type Formally the following mapping function C from the residue conformations into the set of prototype identi\336ers CI is given p 001 P D  p  s 1 s l p  003 j 001 1 l p   C  s j  c j c j 001 CI r a more convenient notation e write for p 001 P  C  D  p   C  s 1  C  s l p  c 1 c l p  The transformation of the sequences is mpli\336ed below using a short subsequence of the protein with the PDB code 1slf B  GLU 61 44 179 54 81 53  GLU66 ALA 54 51 177  ALA1 GLY 54 35 178  GLY71 ILE 77 37 175 65 176  ILE96 THR 62 129 177 62  THR168 GLY 153 166 178  GLY72 THR 105 137 177 59  THR164 TRP 135 154 175 61 6  TRP173 TYR 137 151 179 65 85  TYR184 ASN 107 178 174 74 8  ASN24 The naive application of algorithms 336nding frequent subsequences 13 is not feasible due to the follo wing tw o reasons 336rst of all the subsequences with gaps of different sizes between the elements residues are matched as equal This makes no sense in the context of protein 3D structures since the relative distances between the residues are in general important for the whole 3D structure Second the classical application of well-known algorithms like APriori to generate frequent item sets and derive association rules based on con\336dence and support 1 d o not obe y the order of the residues To make the APriori algorithm sensitive to the order of the residues we additionally consider the positions of the single amino acid residues and generate a ew set of transactions as the input for the APriori algorithm To generate the transactions a window of the maximum length of a frequent substructure is d r the sequences In each step the position inside the window is added to the letters consisting of residue type and prototype identi\336er This transformation is exempli\336ed in 336gure 4 for a window of four residues using the same sequence as in the previous example The resulting transaction data set is analyzed by the APriori algorithm generating interesting relationships based on the notion of frequent item sets In this context frequent denotes that an item set appears more than supp min times in the transaction set Each found frequent item set corresponds to a D substructure of multiple residues which appears at least supp min times in the n 3D protein sequences From the frequent item sets general association rules are derived which r unknown implications Association rules can be seen as a kind of logic rule which Proceedings of the 15th International Conference on Sci entific and Statistical Database Management \(SSDBM\22203 1099-3371/03 $17.00 \251 2003 IEEE  


GLU66 ALA1 GLY71 ILE96 THR168 GLY72 THR164 TRP173 TYR184 ASN24 T1 1GLU66 2ALA1 3GLY71 4ILE96 T2 1ALA1 2GLY71 3ILE96 4THR168 T3 1GLY71 2ILE96 3THR168 4GLY72 T4 1ILE96 2THR168 3GLY72 4THR164 T5 1THR168 2GLY72 3THR164 4TRP173 T6 1GLY72 2THR164 3TRP173 4TYR184 T7 1THR164 2TRP173 3TYR184 4ASN24  Figure 4 Example r the generation of transactions from a sequence is true with a certain probability To restrict the set of possible association rules a minimum con\336dence conf min is required Since the relative positions of the residues are directly encoded in each item only subsequences with the exactly same order of residues are matched This approach also allows gaps in the sequences However in contrast to general frequent sequences the lengths of the gaps in the matching subsequences all have the same size which is important in this application context Details regarding the process and experimental results without the use of an underlying database system can be found in 4.2 Generating Frequent Item Sets inside the Database The necessary prerequisite to ef\336ciently produce frequent item sets inside the database consists in the existence of adequate operators which n the one hand allow the user to easily specify application speci\336c tasks and n the other hand enable the system to apply internal optimization strategies In this section we show that the pure grouping functionality extended by the cube operator family is not suf 336cient to support the application of data mining algorithms The relational mapping of our sample protein conformation scenario is rather straightforward The generated transactions are stored within a single table with four columns denoting the position of the amino acid residues inside the sliding window de\336ning the substructure and a running number as the transaction ID TID A1 A2 A3 A4 T1 1GLU66 2ALA1 3GLY71 4ILE96 T2 1ALA1 2GLY71 3ILE96 4THR168 T3 1GLY71 2ILE96 3THR168 4GLY72 T4 1ILE96 2THR168 3GLY72 4THR164 T5 1THR168 2GLY72 3THR164 4TRP173 T6 1GLY72 2THR164 3TRP173 4TYR184 T7 1THR164 2TRP173 3TYR184 4ASN24  Computing item sets and weighting them with the necessary support and con\336dence is the main crucial operation in computing association rules r the n th generation an item set re\337ects all n combinations for a iven set of grouping attributes With the number of attributes reasonably low i.e short subsequences e may use the grouping sets clause to specify the necessary combinations within a single query For example with four attributes A 1  A 2  A 3  and A 4  e may issue the following grouping condition GROUP BY GROUPING SETS A1,A3 A1,A4 A2,A3 A2,A4 A3,A4 r larger subsequences i.e columns contributing to the computation of item sets the speci\336cation of all permutation combinations can be a tedious task Another alternative is to issue a cube operator r the n set of parameters and eliminate the unwanted grouping combinations in a having clause referring to the grouping columns For the ongoing example with four attributes we yield the following expression GROUP BY CUBE\(A1,A2,A3,A4 HAVING NOT exclude 0-cardinality combinations GROUPING\(A1  1 AND GROUPING\(a2 ND GROUPING\(a3   1 AND GROUPING\(a4  1 exclude 1-cardinality combinations OR GROUPING A1  1 AND GROUPING\(A2  1 AND GROUPING\(A3   OR GROUPING A1  1 AND GROUPING\(A2  1 AND GROUPING\(A4   OR GROUPING A1  1 AND GROUPING\(A3  1 AND GROUPING\(A4   OR GROUPING A2  1 AND GROUPING\(A3  1 AND GROUPING\(A4  1 exclude 3and 4-cardinality combinations  Although this would return the required 2-itemset combinations the speci\336cation becomes tedious with an increasing number of columns r the computation of all possible combinations is certainly not the most ef\336cient y of computing the required item sets Proceedings of the 15th International Conference on Sci entific and Statistical Database Management \(SSDBM\22203 1099-3371/03 $17.00 \251 2003 IEEE  


With this motivation as a background we propose the GROUPING COMBINATIONS operator generating all k item sets for a given set of n grouping columns The syntax integrates seamlessly into the SQL grouping extensions of cube  rollup  and grouping sets  GROUP BY GROUPING COMBINATIONS\(\(A1,A2  An k This expression may be seen as a shortcut for the grouping sets expression with k over n item sets each with a cardinality of k  i.e GROUP BY GROUPING SETS\(\(A1,A2,...,Ak A1,A2,...,Ak-1,Ak+1  The basic idea of the grouping combinations operator is generating all possible grouping combinations with a given cardinality of k  Special cases must be considered regarding the value of k and the number of attributes 200 For k  n  the grouping combinations operator returns a single set with all grouping columns n s a 336rst parameter e.g GROUP BY GROUPING COMBINATIONS\(\(A1,A2  An n is equal to GROUP BY GROUPING SETS\(\(A1,A2  An is equal to a egular GROUP BY A1,A2  An 200 For k 1  the operator corresponds semantically to a grouping sets with n single sets each consisting of exactly a single grouping column More formally GROUP BY GROUPING COMBINATIONS\(\(A1,A2 An 1 is equal to GROUP BY GROUPING SETS\(\(A1 A2  An 200 For k 0  the proposed grouping combinations operator produces a single grouping combination encompassing all tuples of the underlying table e.g GROUP BY GROUPING COMBINATIONS\(\(A1,A2 An 0 is equal to a query without any explicit group by clause but an aggregation function in the select clause The grouping combinations operator tends the set of group by operators proposed within the OLAP context The generation of frequent item sets for a iven generation i.e cardinality of the grouping combinations r is not supported by these operators 5 Cost Estimations This section analyses the different methods to compute the cluster and to 336nd the frequent item sets from a performance point of view In a 336rst step our underlying cost model is outlined followed by costing the different alters to assign the nearest prototype to each amino acid residue 5.1 General Cost Model To estimate the cost we rely on the linear cost model taking the size of the data stream between relational plan operators to compare the costs of different query plans The size of the data stream is the result of the number of attributes multiplied with the cardinality of the table To evalutate the selection predicates we consider a full table scan with the exception of a single tuple access ploiting the existence f an index structure r the join operator we may choose between a nested loop and a hash join The 336rst alternative implies a multiplication of the data stream cardinalities and is omitted in favour of a hash join r justifying this assumption we rely on the fact that a machine has enough capacity to keep the prototype table in main memory A hash join would read the smaller table during the build phase and the larger table during the probe phase so that we end up in adding the cardinalities of the data streams to compute the cost of a join operator Due to our 1:N-relationship of prototypes and conformations the cardinality of the resulting data stream after a join equals the cardinality of the larger table At last we consider the size of the input stream as the cost of a group by operator because every tuple has to be taken into account and assigned to the corresponding group With this assumption we again consider a hash-based implementation so that we may neglect the sorting cost in case of a sort-based group by implementation The return operator 336nally simulates the cost delivering the result to the client program or in detail storing the result set temporarly within the SQLDA of a database system In our example the PConformations table has 1 d attributes with d as the number of maximum angles and a cardinality of pc  Similarly the Prototypes table has the same number of attributes with a cardinality of pt  Based on this assumption the cost computing the following query would be computed s follows SELECT pc.phi pc.psi pc.omega pc.chi1 pc.chi2 pt.omega pt.chi1 pt.chi2 FROM PConformations pc prototypes pt WHERE pc.phi  pt.phi AND pc.psi  pt.psi The scan and the join of both tables would yield an rhead of pc 004 6 pt 004 6 with d 5  The return operator Proceedings of the 15th International Conference on Sci entific and Statistical Database Management \(SSDBM\22203 1099-3371/03 $17.00 \251 2003 IEEE  


a Computing view b query graph t f ivot method Figure 5 pivot method query graphs re\337ecting the produced columns of the select clause contributes with a value of pc 004 8 to the overall cost resulting in 14 004 pc 6 004 pt  5.2 Comparing different Methods The cost of computing the nearest neighbour using the t method may be split into the computation of the cost for the view de\336nition to perform the t of the prototype information and the core select statement using the t view As already mentioned the pt 212 1 ary join of the prototype table is easily optimized by the existence of an index of the prototype ID In this case each join partner has the size of 1 004 1 d  yielding pt 004 1 d  as the overall cost computing the view without any return operator The query itself joins the view with the PConformations table Reading the result of the view corresponds to one single tuple with pt 004 1  d  columns The access of the PConformations table has the size of pc 004 1  d   The outer query adds to the overall costs with reading the result of the inner query  pc 004 1  d  004  pt 1  and accessing the Prototypes table  pt 004 1  d   The return operator 336nally consumes a data stream of cardinality pc with d 3 attributes The cost of discretization using the self-join method can be computed in three steps The 336rst step considers the computation of the view P rototypeAssignment which requires the access to the two tables P roteinConf ormation  pc 004 1  d   and P rototypes  pt 004 1  d   The resulting data stream which has to be read for further processing yields due to the semantics of the Cartesian product to  pc 004 pt  004 1  d 2  The second step addresses the inner query consuming exactly the size of the view and producing a data stream of pc 004 2 for only two columns The outer query reads the result of the inner query and the result of the view   pc 004 pt  004 3  d   At last the return operator has costs the size of the join operator yielding pc 004  d 3  In a similar y the cost for the minpos  method can be computed Instead of the join with the P rototypeAssigment view in the outer query the P roteinConf ormation table with a cost of pc 004  d 1 a Computing view b query graph PrototypeAssignment of self join method Figure 6 self-join method query graphs Figure 7 cost reduction scenario is referenced Additionally the view must be executed only once further reducing the cution costs Table 1 summarizes the partial and total cost for all different methods computing the prototype for each amino acid residue Since this tabular and formular-based representation does not give any hint about the best strategy 336gure 7 gives a scenario with four different dimensions i.e d 1  4  7  10  and 5000 amino acid residues The scenario shows the resulting performance gain of the pivot method compared to minpos  and selfjoin method with 25 100 1000 and 2500 prototypes Within the proposed cost model the t method yields a slightly lower total cost than the minpos  method because the pt 212 1 ary selfjoin is considered extremely cheap r due to the dependency of the total cost from the number of prototypes the t method can not be considered a feasible solution for real applications with a reasonable high number of prototypes Compared to the self-join method the minpos  method yields a substantial cost reduction 6 Summary and Conclusion This paper introduces the problem of 336nding frequent substructures in protein data sets The analysis process is split into two parts The 336rst step consists in 336nding the Proceedings of the 15th International Conference on Sci entific and Statistical Database Management \(SSDBM\22203 1099-3371/03 $17.00 \251 2003 IEEE  


 t method view execution pt 001 1  d   f database operations inner query pt 001 1  d  pc 001 1  d   pt 1 joins outer query pc 001 1  d  001  pt 1 pt 001 1  d  pc 001  d 3 total cost pt 001 3  5 d  pc 001 5  3 d  pc 001 pt 001 1  d  self-join method view execution 2 001  pc 001 1  d  pt 001 1  d   f database operations inner query  pc 001 pt  001 3  d  1 join outer query pc 001 2 pc 001 pt  001 3  d  pc 001 3  d  2 cross product total cost pt 001 2  2 d  pc 001 7  3 d  pc 001 pt 001 6  2 d  1 group by minpos method view execution pc 001 1  d  pt 001 1  d   f database operations inner query  pc 001 pt  001 3  d  1 join outer query pc 001 2 pc 001 1  d  pc 001 3  d  1 cross product total cost pt 001 1  d  pc 001 7  3 d   pc 001 pt  001 3  d  1 group by Table 1 Cost comparison of the different methods nearest prototype in the multi-dimensional dihedral angle space To accomplish this task the data sets are brought into a relational schema and a method is proposed to compute the minimal distance considering the wrap-around effect in the angle space Three different methods to 336nd an associated prototype inside the database systems are compared A minimal SQL extension  minpos  maxpos  function results in much more ef\336cient query execution plans The second step of generating frequent item sets to detect frequent substructures within the amino acid sequences requires substantial SQL extension A ew operator as a new member of the OLAP grouping function operators is introduced This operator is a generic tool and may be ploited by a huge set of data mining applications To summarize a database system used to ef\336ciently analyse huge data volumes requires additional support from the technology  The required extension range from minimal UDFs like our proposed minpos  maxpos functions to more complex operators like our proposed grouping combinations operator f and only if the database community provides this kind of functionality the acceptance of database systems in the biotechnology community will increase in the near future References  R Agra w al T  Imielinski and A N Sw ami Mining association rules between sets of items in large databases In Proceedings of the International Conference on Management of Data  pages 207\320216 ACM Press 1993  S Bohl M Dink elack er  J  Griese and S Schrader  Highly adaptable amino acid side chain rotamer library in pdb coordinates In Workshop in Computational Biology at the Plant Biochemistry Department of the Albert-Ludwigs-Universitt Freiburg Germany  2002  M Bo wer  F  Cohen and R Dunbrack Homology modeling with a backbone-dependent rotamer library J Mol Biol  267:1268\3201282 1997  R Chandrasekaran and G Ramachandran Studies on the conformation of amino acids xi analysis of the observed side group conformations in proteins Int J Pept Prot Res  2:223\320233 1970  R Dunbrack and F  Cohen Bayesian statistical analysis of protein side-chain rotamer preferences Protein Sci  6:1661\320 1681 1997  J Gray  A  Bosw orth A Layman and H Pirahesh Data cube A relational aggregation operator generalizing groupby cross-tab and sub-total In Proceedings of the Twelfth International Conference on Data Engineering  pages 152\320 159 IEEE Computer Society 1996  A Hinneb ur g M Fischer  and F  Bahner  Finding frequent substructures in 3d-protein databases In Workshop on Bioinformatics at the 19th International Conference on Data Engineering  IEEE Computer Society 2003  M James and A Sielecki Structure and re\336nement of penicillo-pepsin at 1.8 a resolution J Mol Biol  125:299\320 361 1983  J K usze wski A Gronenborn and G Clore Impro ving the quality of nmr and crystallographic protein structures by means of conformational database potential derived from structure databases Protein Sci  5:1067\3201080 1996  S C Lo v ell J M W ord J S Richardson and D C Richardson The penultimate rotamer library Proteins Struct Funct Genet  40:389\320408 2000  M MCGre gor  S  Islam and M Sternber g Analysis of the relationship between side-chain conformation and secondary structure in globular proteins J Mol Biol  198:295\320310 1987  R Srikant and R Agra w al Mining generalized association rules In VLDB\32595 Proceedings of 21th International Conference on Very Large Data Bases Switzerland  pages 407\320 419 Morgan Kaufmann 1995  M J Zaki Ef 336cient enumeration of frequent sequences In Proceedings of the 1998 ACM CIKM International Conference on Information and Knowledge Management Bethesda Maryland USA November 3-7 1998  pages 68\32075 ACM 1998  M Zhang B Kao C L Y ip and D  W L Cheung Ffs an i/o-ef\336cient algorithm for mining frequent sequences In Knowledge Discovery and Data Mining PAKDD 2001 5th Paci\336c-Asia Conference Hong Kong China April 16-18 2001 Proceedings  volume 2035 of Lecture Notes in Computer Science  pages 294\320305 Springer 2001 Proceedings of the 15th International Conference on Sci entific and Statistical Database Management \(SSDBM\22203 1099-3371/03 $17.00 \251 2003 IEEE  


OM OM 006 OD8 01 012 014 016 018 02 022 False alarm demity Figure 9 Percentage of tracks lost within 200 seconds using three-scan assignment with PD  0.9 TI  O.ls Figure 11 T2  1.9s and T  Is ij  20 and 0  0.1 24 1 22  20  E fls 0  8l 16 0 n 14  12  0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 T1/12 PD Average track life of three-scan assignment with PD varying TI  0-ls T2  1.9s T  Is X  0.02 ij LO and   0.1 mareuvenng index Figure 12 Percentage of lost tracks of 4-D assipment in 200 seconds with maneuvering index varying X  0.01 Ti  0.1 T2  1.9s and T  IS PD  0.98 Figure 10 Percentage of lost tracks of 4-D assignment in 200 SeoDllCls with TI and T2 varying PD  0.98 X  0.02 q 20 and 0  0.1 4-1607 


Figure 13 Average gate size for Kalman filter Figure is relative as compared to nq and curves are parametrized by ij/r with unit-time between each pair of samples 1.2 Iy I 1.1 0.5 I A CRLB for he unifm samiina I  0.4 0.35 d 3 03 i7 3 0.25 0 0.M 0.04 0.06 008 0.1 0.12 0.14 0.16 0.18 0.2 False A!am DemW V I    Figure 14 CramerRao Lower Boundfor Mean Square Error of uniform and nonuniform sampling schemes with Ti  O.ls T2  1.9s T  IS PD  0.9 ij  5 and U  0.25 1 unifon sampling r-ls ked i non-uniform sampling loge inlewi I ti non-uniform sampling shod interva I 0.9 0.8 I Figure 15 MSE comparison of three-scan assignment with Ti and T2 varying I'D  1 X  0.01 ij  20 and U  0.1 4-1608 


Plenary Panel Session 30 XML Databases   Moderator: Michael Carey, IBM Almaden Research Center USA Panelists Adam Bosworth, Microsoft Corporation USA David De Witt University of Wisconsin-Madison, USA Alon Levy University of Washington USA Bruce Lindsay IBM Almaden Research Center USA Jennifer Widom Stanford University USA Demo Session 1 Web Query Optimizer  661 V Zadorozhny L Bright L Raschid T Urhan and M Vidal ReQueSS: Relational Querying of Semi-structured Data  664 R Sunderraman The IDEAL Approach to Internet-Based Negotiation for E-Business  666 J Hammer C Huang Y Huang C Pluempitiwiriyawej M Lee H Li L Wang Y Liu and S Su READY A High Performance Event Notification Service  668 R Gruber B Krishnamurthy, and E Panagos A Multimedia Information Server with Mixed Workload Scheduling  670 G Nerjes DISIMA An Object-Oriented Approach to Developing an Image Database System  672 V Oria T Ozsu P Iglinski B Xu and L Cheng Demo Session 2 The Collaboration Management Infrastructure  677 H Schuster D Baker A Cichocki D Georgakopoulos and M Rusinkiewicz Assisting the Integration of Taxonomic Data The LITCHI Toolkit  679 I Sutherland J Robinson S Brandt A Jones S Embury W Gray R White and F Bisby TheaterLoc: Using Information Integration Technology to Rapidly Build Virtual Applications  681 G. Barish Y.4 Chen D Dipasquo, C Knoblock S Minton I Muslea and C Shahabi Lineage Tracing in a Data Warehousing System  683 Y Cui and J Widom xiii 


The Mentor-Lite Prototype A Light-Weight Workflow Management System  685 J Weissenfels M Gillmann 0 Roth, G Shegalov and W Wonner Location Prediction and Queries for Tracking Moving Objects  687 0 Wolfson B Xu and S Chamberlain Semiorder Database for Complex Activity Recognition in Multi-Sensory Environments  689 S Bhonsle A Gupta S Santini and R Jain Tutorial 1 Web Information Retrieval  693 M Henzinger Tutorial 2 Mobile and Wireless Database Access for Pervasive Computing  694 P Chrysanthis and E Pitoura Tutorial 3 Data Mining with Decision Trees  696 J Gehrke Tutorial 4 Directories Managing Data for Networked Applications  697 D Srivastava Tutorial 5 Indexing High-Dimensional Spaces Database Support for Next Decade\222s Applications  698 S Berchtold and D Keim xiv 


 T5.I2.D100K T10.I4.D100K T15.I4.D100K T10.I6.D400K T10.I6.D800K T10.I6.D1600K Optimizations across Databases 5 0 5 10 15 20 25 30 35 40 45 Improvement COMP TREE COMP-TREE 1 2 4 8 1 2 4 8 1 2 4 8 2 4 8 2 4 8 1 2 4 8 Processors Databases Figure 5 Effect of Computation and Hash Tree Balancing good as the COMP optimization The reason that the hash tree balancing is not suf\336cient to offset inherent load imbalance in the candidate generation in this case The most effective approach is to apply both optimizations at the same time COMP-TREE The combined effect is suf\336cient to push the improvements in the 40 range in the multiple-processor case On 1 processor only hash tree balancing is bene\336cial since computation balancing only adds extra cost 5.4 Short-circuited Subset Checking Figure 6 shows the improvement due to the short-circuited subset checking optimization with respect to the unoptimized version The unoptimized version is the Apriori algorithm due to Agrawal et al 5 The results are presented for dif ferent number of processors across dif ferent databases The results indicate that while there is some improvement for databases with small transaction sizes the optimization is most effective when the transaction size is large In this case we get improvements of around 25 r the unoptimized version To gain further insight into this optimization consider 336gure 7 It shows the percentage improvement obtained per iteration on applying this optimization on the T20.I6.D100K database It shows results only for the uni-processor case r similar results were obtained on more processors We observe that as the iteration k increases there is more opportunity for shortcircuiting the subset checking and we get increasing bene\336ts of up to 60 The improvements start to fall off t the high end where the number of candidates becomes small resulting in a small hash tree and less opportunity for short-circuiting It becomes clear that is an extremely effective 15 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 T5.I2.D100K T10.I6.D800K T15.I4.D100K T20.I6.D100K procs across Databases 0 5 10 15 20 25 Improvement 1 2 4 8 Figure 6 Effect of Short-circuited Subset Checking 23456789101112 Iterations 0 10 20 30 40 50 60 improvement T20.I6.D100K Figure 7  Improvement per Iteration  proc   16 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


optimization for larger transaction sizes and in cases where there are large number of candidate k itemsets 6 Conclusions In this paper e presented a parallel implementation of the Apriori algorithm on the SGI Power Challenge shared memory multi-processor We also discussed a set of optimizations which include optimized join and pruning computation balancing for candidate generation hash tree balancing and short-circuited subset checking We then presented experimental results on each of these Improvements of more than 40 were obtained for the computation and hash tree balancing The short-circuiting optimization was found to be extremely effective for databases with large transaction sizes Finally we reported the parallel performance of the algorithm While we d good speed-up we observed a need for parallel I/O techniques for further performance gains References  R Agra wal T  Imielinski and A Swami Database mining A performance perspecti v e  I n IEEE Trans on Knowledge and Data Engg  pages 5\(6 1993  R Agra wal T  Imielinski and A Swami Mining association rules between sets of items in lar ge databases In Proc M SIGMOD Intl Conf Management of Data  May 1993  R Agra wal H Mannila R Srikant H T o i v onen and A I V erkamo F ast disco v ery of association rules In U F et al editor Advances in Knowledge Discovery and Data Mining  MIT Press 1996  R Agra wal and J Shafer  P arallel mining of association rules design implementation and e xperience Technical Report RJ10004 IBM Almaden Research Center San Jose CA 95120 Jan 1996  R Agra wal and R Srikant F ast algorithms for mining association rules In Proc 20th VLDB Conf  Sept 1994  M Cierniak W  Li and M J Zaki Loop scheduling for heterogeneity  I n 4th IEEE Intl Symposium on High-Performance Distributed Computing also as URCS-TR 540 CS Dept Univ f Rochester  Aug 1995  M Holsheimer  M  K ersten H Mannila and H T o i v onen A perspecti v e on databases and data mining In 1st Intl Conf Knowledge Discovery and Data Mining  Aug 1995  M Houtsma and A Swami Set-oriented mining of association rules In RJ 9567  IBM Almaden Oct 1993  H Mannila H T o i v onen and I V erkamo Ef 336cient algorithms for disco v ering association rules In AAAI Wkshp Knowledge Discovery in Databases  July 1994  J S P ark M Chen and P  S Y u  A n e f fecti v e hash based algorithm for mining association rules In Proc M SIGMOD Intl Conf Management of Data  May 1995 17 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


 J S P ark M Chen and P  S Y u  E f 336cient parallel data mining for association rules T echnical Report RC20156 IBM T J Watson Research Center Aug 1995  G Piatetsk y-Shapiro Disco v ery  presentation and analysis of strong rules In G P S et al editor  KDD  AAAI Press 1991  A Sa v asere E Omiecinski and S Na v athe An ef 336cient algorithm for mining association rules in large databases In Proc 21st VLDB Conf  1995  M J Zaki M Ogihara S P arthasarathy  and W  Li P arallel data mining for association rules on shared-memory multi-processors Technical Report 618 Department of Computer Science University of Rochester 618 1996 18 Proceedings of the 1996 ACM/IEEE Conference on Supercomputing \(SC\22296 0-89791-854-1/96 $ 10.00 ACM 


