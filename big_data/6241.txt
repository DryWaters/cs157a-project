MapReduce Join Strategies for Key-Value Storage Duong Van Hieu, Sucha Smanchat, and Phayung Meesad Faculty of Information Technology King Mongkut’s University of Technology North Bangkok Bangkok 10800, Thailand duongvanhieu@tgu.edu.vn, {suchas@kmutnb.ac.th,sucha.smanchat@acm.org}, pym@kmutnb.ac.th Abstract This paper analyses MapReduce join strategies used for big data analysis and mining known as map-side and reduce-side joins. The most used joins will be analysed in this paper, which are theta-join algorithms including all pair partition join, repartition join, broadcasting join, semi join, persplit semi join. This paper can be considered as a guideline for MapReduce application developers for the selection of join strategies. The analysis of several join strategies for big data analysis and mining is accompanied by comprehensive examples Keywords—MapReduce; join strategy; NoSQL I   I NTRODUCTION  With the continuous development of big data and cloud computing, it is believed that traditional database technologies are insufficient for data storage and access, and also performance and flexibility requirements. In the new era of big data, NoSQL databases are more appropriate than relational databases e y V alue st ore, a k i nd o f N o SQ L da t a bases, is an appropriate choice for applications that use MapReduce model for distributed processing. Key-Value stores offer only four underlying operators including inserting <key, value pairs to a data collection, updating values of existing pairs finding values associated with a specific key, and deleting pairs from a data collection   Joining two data collections to produce a new dataset based on joining fields is a responsibility of programmers or application developers rather than of database management systems. However, several join strategies existing, which have different advantages and disadvantages. To provide programmers a guideline to the selection of join strategies, this study analyses several joining strategies for big data analysis and mining accompanied comprehensive examples. The content of this paper is organised into four main sections Section 2 gives an overview of the MapReduce programming model, Section 3 explains MapReduce join strategies, and Section 4 is the conclusion of and comparison of join strategies used in MapReduce II M APREDUCE O VERVIEW MapReduce has been used at Google since February 2003 and was first introduced in 2004 by Dean and Ghemawat and in Communications of the ACM in s e d f o r  processing large datasets in a parallel or distributed computing environment. It is a combination of map processes and reduce processes. A map process is a function that processes a set of input <key, value> pairs that is a portion of a large input dataset to generate a set of intermediate <key, value> pairs. A reduce process with a reduce function merges all of intermediate values generated by the map processes associated with the same intermediate key to form a possibly smaller set of <key, value> pairs, called final output <key, value> pairs Fig. 1 is a simple word counting example. The input string data “Advanced Research Methodology, Advanced Information Modelling and Database, Advanced Network and Information Security, Advanced Database and Distributed Systems” is divided into four blocks corresponding to each subject name separated by commas. A Hash function mod\(code\(upper\(left\(key,1\1 is used for distributing intermediate <key, value> pairs into reduce tasks. The left\(key,1\ans taking the first letter of key, the upper\(x means changing x to upper case, the code \(x\means taking ASCII code of character x, and the mod\(m, k\ means returning the remainder after m is divided by k Input data Key Value Key Value Advanced Advanced 1 Database 1 key value pairs produced by Reduce processs Intermediate key,value pairs distribution R e d u c e 1 key value pairs  Block 1 Research Map 1 Research 1 Group 1 Database 1 Key Value Methodology Methodology 1 Distributed 1 Database 2 Key Value Key Value Distributed 1 Advanced Advanced 1 Advanced 1 Information Information 1 Advanced 1 Key Value Block 2 Modelling Map 2 Modelling 1 Advanced 1 Advanced 4 and and 1 Advanced 1 and 3 Database Database 1 Group 2 and 1 Reduce 2Information 2 Key Value and 1 Methodology 1 Advanced Advanced 1 and 1 Modelling 1 Network Network 1 Information 1 Block 3 and Map 3 and 1 Information 1 Key Value Information Information 1 Methodology 1 Network 1 R e d u c e 1 R e d u c e 3 Security Security 1 Modelling 1 Research 1 Key Value Key Value Advanced Advanced 1 Group 3Network 1 Key Value R e d u c e 4 R e d u c e 3 Database Database 1 Research 1 Security 1 Block 4 and Map 4and 1 Key Value Systems 1 Distributed Distributed 1 Group 4Security 1 Systems Systems 1 Systems 1 R e d u c e 4 Fig. 1. Map and reduce processes of a simple word counting example III M APREDUCE KEY JOIN STRATEGIES Physically, data in a Key-Value format can be stored in the form of a data structure such as B-Tree, Queue, and Hash table  i c a ll y eac h  re cor d  i n a Key-Va l ue store i s a single entry including a key and a value. To make it easy to understand, a set of <key, value> pairs, called data collection, can be 2014 11th International Joint Conference on Computer Science and Software Engineering \(JCSSE 164 


considered as a two-column table. The first column stores keys and the second one, which can be a combination of more than two columns, stores values associated with the keys Joins using MapReduce can be categorized as map-side join, reduce-side join, memory-backed join, join using Bloom Filter, and map-reduce merge However  this pa per follo ws the categories proposed by Tom White grouping int o  two types which are map-side joins and reduce-side joins Map-side joins are joins per-formed by mappers, used to join two large input datasets before feeding data to the map functions. Reduce-side joins are joins performed by reducers being more general than a map-side join because inputs do not need to be structured in any particular In some ca ses reduce-side joins are less efficient than map-side joins because datasets go through the MapReduce shuffle. For reduce-side joining, several components are involved. These are multiple inputs and secondary sorting [8   Multiple inputs mean inputs from different sources can have different formats or presentations. To deal with this situation, multiple inputs need to be parsed separately. This parsing is provided in Hadoop, called per-path Secondary sorting occurs when reducers obtain inputs from two sources and each of them can be sorted by different orders To solve this challenge, when the first dataset comes from source A sorted by key1, the second dataset comes from source B sorted by key2. The merged data should be sorted by a composite key \(key1, key2\before reducing A  Theta Joins Theta join is a kind of join that uses comparison operators such as <, <=, >, >=, =, <> in the join predicates. Among these equi-join is the most used join for joining two datasets to achieve the intersection between them. Fig. 2 is an example of equi-join. This join matches every record from table L to every record from table R which has the same value of the field join The results of joining can be projected to eliminate some redundant fields to produce only required fields Among join algorithms used in MapReduce literature listed in [11-15  i t is beli e v ed t h at equi j oi n strat e gies use d in  1 1   are more efficient than those used in Yahoo Pig, Facebook Hive, and IBM Jaql. This paper focuses on the theta-join implementation strategies proposed by Blanas et al and Okcan [1  Theta joi n al g o rit h m s will b e analysed in the  following sections SELECT  FROM L R WHERE L.Profs=R.Profs Stds Profs Stds Profs L.Stds L.Profs R.Stds R.Profs Aj PhMe Hin Sup Aj PhMe Jia PhMe Hiu PhMe Hiu Sup Aj PhMe Sul PhMe Lo PhMe Jia PhMe Hiu PhMe Jia PhMe Su Mar Ling Su Hiu PhMe Sul PhMe Suna Un Sul PhMe Lo PhMe Jia PhMe Lo PhMe Sul PhMe Table L Table R  Fig. 2. A simple equi- join example \(using equi-join on the field Profs B  All Pair Partition Joins Given table R having |R| records and table L having |L records, product of R and L is a set of |R|*|L| records. This traditional method takes a long time when joining two very large tables. To compute this product in MapReduce, table R and table L will be divided into u and v disjoin partitions respectively. |R|*|L| records can be obtained from u*v products u,  v can be processed by a map or a reduce function. This method is called all pairs partition join in MapReduce model [1 Fig. 3. All pairs partition join Each compound partition will be assigned to a map task Output of the map task is <compound key, tagged record pairs. A compound key is a combination of partition name 1, 3\dentify which record comes from which table, each record from table R or L will be tagged its table name, called tagged record. Each group of <compound key, tagged record> pairs will be passed to reducers. Before reducing data, this input data will be split into table R and L and they will join in the same way as the traditional joining method Table L Stds Profs Key Value lists Key Value lists Key Value lists Aj PhMe R',Hin,Sup R',Hin,Sup R',Jia  PhMe  Key Hiu PhMe R',Hiu,Sup R',Hiu,Sup R',Ling,Su empty R.Stds R.Profs L.Stds L.Profs Lo PhMe L',Aj PhMe L',Lo,PhMe L',Aj PhMe Ji a PhMe Aj PhMe Dit PhMe L',Hiu,PhMe L',Dit,PhMe L',Hiu,PhMe Jia PhMe Hiu PhMe Su Mar Jia PhMe Lo PhMe Sun Un Key Value lists Key Value lists Key Value lists Jia PhMe Dit PhMe Table R R',Hin,Sup R',Jia PhMe R',Jia PhMe  Stds Profs R',Hiu,Sup R',Li ng,Su R',Li ng,Su Pa rt 1 Hin Sup L',Su,Mar L',Su,Mar L',Lo,PhMe Hiu Sup L',Sun,Un L',Sun,Un L',Dit,PhMe Pa rt 2Jia PhMe Li ng Su Pa rt 1 Pa rt 2 Pa rt 3 1,3 2,3 2,2 Value lists 1,1 1,2 2,1 Fig. 4. An example of all pairs partition joins \(using equi-join on the field Profs 2014 11th International Joint Conference on Computer Science and Software Engineering \(JCSSE 165 


In Fig. 4, each record from table L and R will be added tag L’ and ‘R’, respectively. Those records are called tagged records. Only the composite key has records from both table L and R having the same join key are fed to reduce functions. In this example, only partition \(2, 1\, partition \(2, 2\ has shared join key records from table R and L, which will be used for joining. The remaining partitions will be ignored. Disadvantage of this joining is enumerating every pair may not be processed by reducers C  Repartition Join Repartition join is the most used join strategy in MapReduce. Datasets L and R are dynamically split into parts based on the join key and pairs of partitions from L and R will be joined [15  It has two ve rsi ons c a l l e d sta n da rd re partitio n  join and improved repartition join The standard version is the same as the partitioned sortmerge join that is used in parallel Rational Database Management System h e ma p pha s e  eac h m a p task  works on a block of either table L or table R. To identify which table an input record is from, the map function tags each record with its original table and produces the extracted join key and the tagged records. Output of the map function is a set of join_key, tagged_record> pairs. Join_key is the attribute used to join two tables, and tagged_record is a compound of table name and record. These outputs are then partitioned, sorted and merged. Then, all records for each join key are grouped together and fed to a reducer. In the reduce phase, for each join key, the reducer first separates and buffers the input records into two sets according to the table tagged, and then performs a cross-product between two sets. This following example uses hash function mod\(code\(upper\(left\(join key,1\,2 distributing intermediate <key, value> pairs to each reducer the similar has function used earlier T able L Intermediate output Stds Profs Join ke y Tagged Record key tagged record Table L Stds Profs Block1 Su Mar Map1 Mar L', Su, Mar Group 1PhMe L' , Aj, PhMe Aj PhMe Aj PhMe PhMe L', Aj, PhMe PhMe L' , Hiu, PhMe Reduce 1 Hiu PhMe Block2 Hiu PhMe Map2 PhMe L', Hiu, PhMe PhMe L' , Lo, PhMe Lo PhMe Lo PhMe PhMe L', Lo, PhMe PhMe R' , Jia, PhMe T able R Stds Profs L.Stds L.Profs R.Stds R.Profs Block3 Sun Un Map3 Un L', Sun, Un PhMe R' , Sul, PhMe Jia PhMe Aj PhMe Jia PhMe Table R SulPhMe AjPhMeSulPhMe Stds Profs key tagged record Table L Stds Profs Hiu PhMe Jia PhMe Jia P h M e P h M e  R Jia  P h M e  M a r  L   Su M a r  Su M a r H iu P h M e Sul P h M e Sul PhMe PhMe R', Sul, PhMe Su R' , Ling, Su Reduce 2 Sun Un Lo PhMe Jia PhMe Block2 Ling Su Map5 Su R', Ling, Su Sup R' , Hin, Sup Stds Profs Lo PhMe Sul PhMe H in Sup Sup  R H in  Sup  Sup  R  H iu Sup  T a ble R L in g Su Hiu Sup Sup R', Hiu, Sup Group 2 U n  L   Sun  U n  H in Sup Hiu Sup Final result from reduce process merging, sorting, and groupin Input of map functions Reduce process Block3 Block1 Map4 Map6  Fig. 5. An example of standard repartition joins \(using equi-join on the field Profs All records from table L and R will be buffered before joining and that may lead to insufficient memory problem, as encountered by Yahoo Pig and Facebook Hive [11, 17, 18  To deal with this, improved repartition join is proposed In the improved version, the map function is changed Output key of the map function is changed to a composite of join key and table tag. The table tags will be generated in a way that guarantees that records from table R will be stored ahead of those from table L on a given join key. Partition function is also customised so that hash code is computed from just the join key instead of composite key. Records are then grouped by just the join key instead of the composite key. Grouping function in the reducer which groups records on the join key and ensures that records from table R are stored ahead of those from table L for a given key. To decrease buffer size, only the record, that have composite key containing all table tags will be written into buffer Output of map functions Input of reduce functiom Stds Profs C omp. Ke y s Tagged Records Keys Lists of Values L.Stds L.Profs R.Stds R.Profs Jia P hMe P hMe   R  Ji a  P h M e  Keys Tagged Records Jiaja, PhMe AjPae, PhMe  A j P h M e J i a P h M e Sul PhMe PhMe, R  R   S u l  P h M e   M a r L   L  S u  M a r   J i a j a  P h Me  H i u  P h Me  A j P h M e S u l P h M e Block 2 Ling Su Su, R   R   L i n g   S u   P h M e   R R', Jia, PhMe Jiaja, PhMe  L o  P h Me  H i u P h M e J i a P h M e Hin Sup Sup, R  R   H i n  S u p  P h M e   R R', Sul, PhMe Sul,PhMe Aj P a e  P h M e   H i u P h M e S u l P h M e Hiu Sup Sup, R  R   H i u  S u p  P h M e  L   L   A j  P h M e   S u l  P h Me   H i u  P h Me  L o P h M e J i a P h M e PhMe, L L', Hiu, PhMe Sul, PhMe  Lo  P h M e  L o P h M e S u l P h M e Stds Profs C omp. Ke y s Tagged Records PhMe, L L', Lo, PhMe Keys Lists of Values Block 1 Su Mar Mar, L  L  S u  M a r S u  R   R   Li n g   S u   M a r _  L   _   S u  M a r Aj PhMe PhMe, L   L   Aj P h M e   S u p  R    R   Hi n  S u p   U n  _  L  _ S u n U n   Hiu PhMe PhMe, L   L   H i u  P h M e   S u p  R    R   H i u  S u p  S u  R   _   L i ng   S u   _ Lo PhMe PhMe  L  Lo  P h Me   U n  L  L  S u n  U n   H i n  S u p   _  Block 3 Sun Un Un  L  S u n  U n   H i u  S u p   _  Block 2 Block 1 Block 3 PhMe R Table L Final result from reducer Table R Sup, R, _ Intermediate Results M ap 1 Map 2 Map 3 Map 4 Map 6 Map 5 Fig. 6. Example of improved repartition joins \(using equi-join on the field Profs 2014 11th International Joint Conference on Computer Science and Software Engineering \(JCSSE 166 


D  Broadcasting Join Broadcast join is used when table R is much smaller than table L. Instead of passing both tables R and L across the network, the smaller table will be broadcasted to larger table This technique reduces sorting time and network traffic. At the beginning of each map function, broadcast join checks whether R is stored on the local file system or not. If not, it retrieves table R from the distributed file system, and splits R into partitions on the join key, and stores these partitions on the local file system. Hash table is built from table L or R depending on which one has smaller size If R is smaller than a partition of L, then all partitions of R will be loaded to memory to build the hash table. The map function then extracts join key value from each record from L and uses it to probe the hash table and to generate join output If R is bigger than a split of L, joining is not done at the map function. The map function will map each partition of L with each partition of R using other join strategies. Then, results from R and L will be joined at the end of the map process In Fig. 7 and Fig. 8, table R is smaller than a part of table L so it is broadcasted to each node. The map function loads all records from table R to build a hash table. For each record from a partition of table L, the map function finds its reference in the hash table, and outputs only those it has referenced. All unreferenced records from table L will be ignored Table R StdId subject Hash table Distributed function StdId mod 2\+1 55501 701 StdId Group 55501 371 55501 2 55502 555 55502 1 56701 511 56701 2 56702 814 56702 1 Table R is used to build hash table  Fig. 7. Building Hash table when R is smaller than any part of L Table L StdId Name L.StdId L.Name R.StdId R.subject 55701 Lo Map 1 56701 Dit 56701 511 55702 Mo 56702 Hiu 56702 814 L.StdId L.Name R.StdId R.subject 56700 Bo 55701 Hash table 56701 Hash table 55502 Sher 55502 555 56701 Dit 55702 Hash table 56703 Hash table Group 1 56702 Hiu 56702 814 56702 Hiu 56700 Hash table 56703 Cha L.StdId L.Name R.StdId R.subject 55501 Sul Map 2 L.StdId L.Name R.StdId R.subject 55501 Sul 55501 701 55502 Sher 55501 Sul 55501 701 Group 2 55501 Sul 55501 371 55503 Jia 55501 Sul 55501 371 56701 Dit 56701 511 55504 Dih 55502 Sher 55502 555 55505 Tha 55503 Hash table 55505 Hash table 56501 Ling 55504 Hash table 56501 Hash table Intermedia Results Join key is used to probe hash table Join key is used to probe hash table Split 1 Split 2 Fig. 8. Example of broadcasting joins when R is smaller than any part of L\(using equi-join In some cases, a large portion of table R may not be referenced by any record from table L. For example R is a table of users including millions of records while L is a table of activities that users act during an hour. In this situation, only a few of records from table R are referenced by records from table L. However, when joining based on broadcasting, a large amount of records of table R are shipped across network and loaded into the hash table. If these data are not referenced based on the join key, the network resource is wasted for the shipping E  Semi Join The semi-join proposed to solve the problem mentioned above is comprised of three phases as follows. The first phase runs as a full MapReduce job. In the map function, a main memory table of hash code is used for determining the set of unique join key values in a part of table L. By sending only unique key values to the map output, number of records that need to be sorted is reduced. The reduce function processes unique join key. In Fig. 9, all unique join keys will be consolidated by a reducer, result from this phase is a single file called L.uk  Table LHash table L1 StdId subject StdId output L.uk 55501 701 55501 StdId 55501 371 55502 55501 55502 555 Hash table L2 55502 56701 511 StdId 56701 56701 814 56701 56702 56702 814 56702 Split 1 Split 2 Fig. 9. Example of the first phase in Semi joins \(using equi-join The second phase, similar to the broadcast join, runs as a map job. Firstly L.uk will be loaded into a memory hash table the map function iterates each record from table R and outputs it if its join key can be found in the L.uk Each part of table R produces one file called Ri Output of this phase is a list of file Ri as shown in Fig. 10 The third phase, join all file Ri with table L using broadcast join as shown in Fig. 11. One challenge of semi join is that not every record in the Ri of R will join with a particular part Li of table L. To solve this issue, per-split semi join is proposed Table R Output R1 Table R Output R2 StdId Name Map 1 StdId Name StdId Name Map 2 StdId Name 55701 Lo Hash table 56701 Dit 55501 Sul Hash table 55501 Sul 55702 Mo StdId 56702 Hiu 55502 Sher StdId 55502 Sher 56700 Bo 55501 55701 Hash table 55503 Jia 55501 55503 Hash table 56701 Dit 55502 55702 Hash table 55504 Di 55502 55504 Hash table 56702 Hiu 56701 56700 Hash table 55505 Tha 56701 55505 Hash table 56703 Cha 56702 56703 Hash table 56501 Ling 56702 56501 Hash table Split 1Split 2 Fig. 10. Example of the second phase in Semi joins \(using equi-join 2014 11th International Joint Conference on Computer Science and Software Engineering \(JCSSE 167 


Table LTable LIntermediate results 2 StdId subject L.StdId L.Name R.StdId R.subject StdId subject L.StdId L.Name R.StdId R.subject 55501 701 Ma p 1 55501 R1 55501 701 Map 1 55501 Sul 55501 701 55501 371 55502 R1 55501 371 55501 Sul 55501 371 55502 555 55502 555 55502 Sher 55502 555 56701 511 Ma p 2 Intermediate results 1 56701 511 56701 814 L.StdId L.Name R.StdId R.subject 56701 814 Map 2 56702 814 56701 Dit 56701 511 56702 814 L.StdId L.Name R.StdId R.subject Output R1 56701 Dit 56701 814 Output R2 56701 R2 StdId Name 56702 Hiu 56702 814 StdId Name 56702 R2 56701 Dit 55501 Sul 56702 Hieu 55502 Sher Split 1 Split 2 R2 Split 1 Split 2 R1  Fig. 11. Example of the last phase in Semi joins \(using equi-join F  Per-Split Semi Join Per-split semi join consists of three phases. The first and the last phases are map jobs, and the second phase is a full map reduce job. The first phase is to generate the set of unique join keys in a split Li of table L, and stores them in the distributed file system, called Li.uk The second phase is to load all records from a split of table R into main memory hash table, and read the unique keys from file Li.uk and probe the hash table for matching records from R. Each matched record is outputted with a tag RLi which is used by reduce function to collect all records from table R that will join with Li In the last phase, the results of the second phase and Li are joined directly as shown in Fig. 12 and Fig. 13 Fig. 12. Example of the first phase and second phase in Per-Split Semi Join Output of R join Li.uk Tags StdId Name RL1 55501 Sul RL1 55502 Sher L.StdId L.Name R.StdId R.subject RL2 56701 Dit 55501 Sul 55501 701 RL2 56702 Hiu 55501 Sul 55501 371 Table L 55502 Sher 55502 555 StdId subject 56701 Dit 56701 511 55501 701 56701 Dit 56701 814 55501 371 56702 Hiu 56702 814 55502 555 56701 511 56701 814 56702 814 Output of final phase Fig. 13. Example of the last phase in Per-Split Semi Join \(using equi-join IV C ONCLUSION Many of big data mining problems can be solved by using MapReduce associated with Key-Value store. Based on advantages and drawbacks of those explained strategies in terms of time and network resources consumption, we provide a comparison of join strategies as shown in Table 1 T ABLE 1  C OMPARISION OF JOIN STRATEGIES  Strate gy Pros/Cons Su gg estion All pair partition join Easy to implement, all compound partition transferred to reducers may not be processed by reducers Used when two datasets have more data in common, be sorted by the same fields Standard repartition join Easy to implement, all records from both tables will be buffered before joining that may lead to insufficient memory problem Same with all pair partition join Improved repartition join To reduce buffer size implementation is more complex than the standard version Used when two joined datasets have few data in common be sorted by the same fields Broadcasting join Reduce sorting time and network traffic. May waste of network resource Used when one table is much smaller than the other table Semi-join Some records from parts of a table broadcasted to another table may not be joined Used when a large portion of a table may not be referenced by any record from the other table Per-split semi join Complicated implementation, more reading and writing operations Same with semijoin Which strategy should be used in any problem depends on nature of the data and available network resources. If two 2014 11th International Joint Conference on Computer Science and Software Engineering \(JCSSE 168 


joined tables have more data in common or having sufficient network resources, all pair partition join, repartition join should be used because its implementation is not as complex as the others. If two joined tables have few data in common or having inadequate network resources, broadcasting join, semi join per-split semi join should be used because it may reduce time and resources consumption Data in NoSQL database can be structured, semi-structured or unstructured; and can be stored in many types of data structures such as indexed table of relational database, B-Tree Queue, Hash table. Therefore, in addition to the consideration presented in this paper, selection of join strategies is also affected by data structures. MapReduce programmers may also need to consider data accessing time, data sorting time when selecting joining strategy. This issue is beyond the scope of this paper and is left for future research R EFERENCES  1  Mapanga, I. and P. Kadebu, Database Management Systems: A NoSQL Analysis. Interna-tional Journal of Modern Communication Technologies & Research \(IJMCTR\ 2013. 1: p. 12-18 2  Hecht, R. and S. Jablonski. NoSQL evaluation: A use case oriented survey. in Cloud and Service Computing \(CSC\, 2011 International Conference on. 2011 3  Dean, J. and S. Ghemawat, MapReduce: Simplified Data Processing on Large Clusters, in OSDI '04: Sixth Symposium on Operating Systems Design and Implementation. 2004, USENIX: San Francisco, California USA. p. 137–150 4  Dean, J. and S. Ghemawat, MapReduce: simplified data processing on large clusters, in Communications of the ACM - 50th anniversary issue 1958 - 2008. 2008. p. 107-113 5  Celko, J., Chapter 6.  Key–Value Stores, in Joe Celko's complete guide to NoSQL : what every SQL professional needs to know about nonrelational databases, A. Dierna and H. Scherer, Editors. 2014 Morgan Kaufmann, Elsevier: USA. p. 81-88 6  Oracle, Chapter 1. Introduction to Berkeley DB, in Oracle Berkeley DB Getting Started with Berkeley DB for C. 2013. p. 8-15 7  Jadhav, V., J. Aghav, and S. Dorwani, Join Algorithms Using MapReduce: A Survey, in International Conference on Electrical Engineering and Computer Science. 2013, IOAJ INDIA: Coimbatore Tamil Nadu, India. p. 40-44 8  White, T., Chapter 8. MapReuce Features, in Hadoop: The Definitive Guide, Second Edi-tion, M. Loukides, Editor. 2011, O'Reilly Media Inc.,: USA. p. 225-257 9  White, T., Chapter 8. MapReduce Features, in Hadoop: The Definitive Guide, Third Edition, M. Loukides and M. Blanchette, Editors. 2012 O'Reilly Media, Inc.,: USA. p. 259-295 10  White, T., Chapter 7. MapReduce Types and Formats, in Hadoop: The Definitive Guide, Third Edition, M. Loukides and M. Blanchette Editors. 2012, O'Reilly Media, Inc.: USA. p. 223-258 11  Blanas, S., et al., A comparison of join algorithms for log processing in MaPreduce, in Proceedings of the 2010 ACM SIGMOD International Conference on Management of data. 2010, ACM: Indianapolis, Indiana USA. p. 975-986 12  zsu, M.T. and P. Valduriez, Chapter 3. Distributed Database Design, in Principles of Dis-tributed Database Systems, Third Edition. 2011 Springer New York. p. 71-125 13  Bernstein, P.A., et al., Query processing in a system for distributed databases \(SDD-1\ ACM Trans. Database Syst., 1981. 6\(4\: p. 602-625 14  Lee, K.-H., et al., Parallel data processing with MapReduce: a survey SIGMOD Rec., 2012. 40\(4\: p. 11-20 15  Okcan, A. and M. Riedewald, Processing theta-joins using MapReduce in Proceedings of the 2011 ACM SIGMOD International Conference on Management of data. 2011, ACM: Athens, Greece. p. 949-960 16  Shim, K., MapReduce algorithms for big data analysis, in Proceedings of the VLDB En-dowment 2012, VLDB Endowment. p. 2018-2017 17  Olston, C., et al., Pig latin: a not-so-foreign language for data processing, in Proceedings of the 2008 ACM SIGMOD international conference on Management of data. 2008, ACM: Vancouver, Canada. p 1099-1110 18  Hive, A., Theta Join. 2013 2014 11th International Joint Conference on Computer Science and Software Engineering \(JCSSE 169 


Extreme Green and Energy Efficiency in Large Scale Distributed Systems ExtremeGreen Energy-Aware Profit Maximizing Scheduling Algorithm for Heterogeneous Computing Systems 595 Kyle M. Tarplee, Anthony A. Maciejewski, and Howard Jay Siegel Energy Consumption of Photo Sharing in Online Social Networks 604 Fatemeh Jalali, Chrispin Gray, Arun Vishwanath, Robert Ayre, Tansu Alpcan Kerry Hinton, and Rodney S. Tucker Power Consumption Evaluation of an MHD Simulation with CPU Power Capping 612 Keiichiro Fukazawa, Masatsugu Ueda, Mutsumi Aoyagi, Tomonori Tsuhata Kyohei Yoshida, Aruta Uehara, Masakazu Kuze, Yuichi Inadomi, and Koji Inoue A Game-Theoretic Approach to Coalition Formation in Green Cloud Federations 618 Marco Guazzone, Cosimo Anglano, and Matteo Sereno Energy-Aware Data Transfer Tuning 626 Ismail Alan, Engin Arslan, and Tevfik Kosar The Third Workshop on Data-Intensive Process Management in Large-Scale Sensor Systems \(DPMSS Fuzzy Assisted Event Driven Data Collection from Sensor Nodes in Sensor-Cloud Infrastructure 635 Suman Sankar Bhunia, Jayita Pal, and Nandini Mukherjee Cloud Supported Building Data Analytics 641 Ioan Petri, Omer Rana, Yacine Rezgui, Haijiang Li, Tom Beach, Mengsong Zou Javier Diaz-Montes, and Manish Parashar Enforcing Quality of Service on OpenNebula-Based Shared Clouds 651 Rafael Tolosana-Calasanz, José Ángel Bañares, Omer Rana, Congduc Pham Erotokritos Xydas, Charalampos Marmaras, Panagiotis Papadopoulos, and Liana Cipcigan A New Parallelism-Capable Clustering Algorithm for Wireless Sensor Networks 660 Alireza T. Boloorchi, M.H. Samadzadeh, and Nazanin Rahnavard An Evaluation Framework for Buildings-Oriented Wireless Sensor Networks 670 Antonio Guerrieri, Giancarlo Fortino, and Wilma Russo A Cloud-Based Framework for Supporting Effective and Efficient OLAP in Big Data Environments 680 Alfredo Cuzzocrea and Rim Moussa Multiobjective Communication Optimization for Cloud-Integrated Body Sensor Networks 685 Dung H. Phan, Junichi Suzuki, Shingo Omura, Katsuya Oba, and Athanasios Vasilakos First International Workshop on Cloud for Bio \(C4BIO 2014 From Scripted HPC-Based NGS Pipelines to Workflows on the Cloud 694 Jacek Ca a, Yaobo Xu, Eldarina Azfar Wijaya, and Paolo Missier 
xi 


A Survey of Approaches and Frameworks to Carry Out Genomic Data Analysis on the Cloud 701 Philip C. Church and Andrzej Goscinski Accelerating Comparative Genomics Workflows in a Distributed Environment with Optimized Data Partitioning 711 Olivia Choudhury, Nicholas L. Hazekamp, Douglas Thain, and Scott Emrich Integration of Clustering and Multidimensional Scaling to Determine Phylogenetic Trees as Spherical Phylograms Visualized in 3 Dimensions 720 Yang Ruan, Geoffrey L. House, Saliya Ekanayake, Ursel Schütte, James D. Bever Haixu Tang, and Geoffrey Fox A Performance Evaluation of Sequence Alignment Software in Virtualized Environments 730 Zachary J. Estrada, Zachary Stephens, Cuong Pham, Zbigniew Kalbarczyk and Ravishankar K. Iyer A Storage Policy for a Hybrid Federated Cloud platform: A Case Study for Bioinformatics 738 Deric Lima, Breno Moura, Gabriel Oliveira, Edward Ribeiro, Aleteia Araujo Maristela Holanda, Roberto Togawa, and Maria Emilia Walter Evaluation of the Feasibility of Making Large-Scale X-Ray Tomography Reconstructions on Clouds 748 Estefania Serrano, Guzman Bermejo, Javier Garcia Blas, and Jesus Carretero 2014 Workshop on Clusters, Clouds and Grids for Health \(CCGrid-Health Global Initiative for Sentinel e-Health Network on Grid \(GINSENG Integration and Semantic Developments for Epidemiology 755 Sébastien Cipière, Guillaume Ereteo, Alban Gaignard, Nouha Boujelben Sébastien Gaspard, Vincent Breton, Fréséric Cervenansky, David R.C. Hill Tristan Glatard, David Manset, Johan Montagnat, Jérôme Revillard, and Lydia Maigne Extending XNAT towards a Cloud-Based Quality Assessment Platform for Retinal Optical Coherence Tomographies 764 Jie Wu, Christoph Jansen, Maximilian Beier, Michael Witt, and Dagmar Krefting Distributed Detection of Cancer Cells in High-Throughput Cellular Spike Streams 774 Abdul Hafeez, M. Mustafa Rafique, and Ali R. Butt Second International Workshop on Assured Cloud Computing \(WACC 2014 A High Performance, QoS-Enabled, S3-Based Object Store 784 Yusuke Tanimura, Seiya Yanagita, and Takahiro Hamanishi Towards Cloud, Service and Tenant Classification for Cloud Computing 792 Sebastian Jeuk, Jakub Szefer, and Shi Zhou 
xii 


On the Evaluation of VM Provisioning Time in Cloud Platforms for Mission-Critical Infrastructures 802 Gabriella Carrozza, Luigi Battaglia, Vittorio Manetti, Antonio Marotta, Roberto Canonico and Stefano Avallone 2014 International Workshop on Data Vitalization and Universal Village Extended Version of Smart Cities \(DV&UV Pragmatic Oriented Data Interoperability for Smart Healthcare Information Systems 811 Shixiong Liu, Weizi Li, and Kecheng Liu Geospatial Sensor Web Resource Management System for Smart City: Design and Implementation 819 Jia Li and Nengcheng Chen A Robust and Fast Reconstruction Framework for Noisy and Large Point Cloud Data 828 Xiang Feng, Xiaoqing Yu, Wanggen Wan, Fabien Pfaënder, and J. Alfredo Sánchez A Survey on Workflow Management and Scheduling in Cloud Computing 837 Li Liu, Miao Zhang, Yuqing Lin, and Liangjuan Qin Intelligent Congestion Avoidance Algorithm and System—Application of Data Vitalization 847 Yan Huang, Hao Sheng, and Jiahui Chen Variable Window for Outlier Detection and Impulsive Noise Recognition in Range Images 857 Jian Wang, Lin Mei, Yi Li, Jian-Ye Li, Kun Zhao, and Yuan Yao Data Vitalization’s Perspective Towards Smart City: A Reference Model for Data Service Oriented Architecture 865 Zhang Xiong, Yanwei Zheng, and Chao Li First International Workshop on Scalable Computing for Real-Time Big Data Applications \(SCRAMBL Scalable Infrastructures for Data in Motion 875 David Ediger, Rob McColl, Jason Poovey, and Dan Campbell Towards In-Order and Exactly-Once Delivery Using Hierarchical Distributed Message Queues 883 Dharmit Patel, Faraj Khasib, Iman Sadooghi, and Ioan Raicu A Scalable System for Community Discovery in Twitter During Hurricane Sandy 893 Yin Huang, Han Dong, Yelena Yesha, and Shujia Zhou A Scalable Real-Time Photometric System for Automatic Astronomical Observations on Dome A 900 Ce Yu, Lianmeng Li, Jizhou Sun, Jian Xiao, Jiajun Li, and Zhaohui Shang 
xiii 


Cloud for Business, Industry and Enterprises \(C4BIE 2014 Improving Resource Matchmaking through Feedback Integration 906 Christian Haas, Ioan Petri, and Omer Rana MO-BIZZ: Fostering Mobile Business through Enhanced Cloud Solutions 915 Alexander Stanik, Odej Kao, Rui Martins, António Cruz, and Dimitrios Tektonidis A Comparitive Study of Predictive Models for Cloud Infrastructure Management 923 Mahesh Balaji, G. Subrahmanya VRK Rao, and Ch. Aswani Kumar SCALE Challenge V for Vicissitude: The Challenge of Scaling Complex Big Data Workflows 927 Bogdan Ghi Mihai Capotã, Tim Hegeman, Jan Hidders, Dick Epema, and Alexandru Iosup Emulation at Very Large Scale with Distem 933 Tomasz Buchert, Emmanuel Jeanvoine, and Lucas Nussbaum ToMaR—A Data Generator for Large Volumes of Content 937 Rainer Schmidt, Matthias Rella, and Sven Schlarb Exploring Infiniband Hardware Virtualization in OpenNebula towards Efficient High-Performance Computing 943 Tiago Pais Pitta De Lacerda Ruivo, Gerard Bernabeu Altayo, Gabriele Garzoglio Steven Timm, Hyun Woo Kim, Seo-Young Noh, and Ioan Raicu Author Index 949 
xiv 


 11  id e n tity  a n d  d e s c r ip tio n  T h e  I E E E  1 4 5 1  s ta n d a r d  p r o v id e s  good ba c kgr ound f or  c ons t r uc t i on of  xT E D S  ons  fr o m  d e fi n e d  T E D S  t e m p l a t e s  t a k i n g  a d v a n t a g e  o f  1451  co m m an d  s et s  an d  ar ch i t ect u r es   F i n al l y   em er g i n g  SO I S D V S st   ef f ect i v e  me t h o d s  f o r  ma n a g i n g  w i r e l e s s  n e t w o r k s  a n d  mo d u l e s   a s  w e l l  a s  w o r k  de f i ni ng a  C om m on D a t a  D i c t i ona r y f or  s pe c i f i c  a ppl i c a t i on dom a i ns   Th e  a p p r o a c h  i s  t o  u s e  t h e  a p p r o p r i a t e  e l e m e n t s  o f  e a c h  st a n d a r d  t o  c r e a t e  a  r e f e r e n c e  d e s ig n  T h is  is  s im ila r  to  a  ra p i d  p ro t o t y p i n g  a p p ro a c h   w h i c h  o f t e n  y i e l d s  t h e  b e s t  im p le m e n ta tio n  a t th e  lo w e s t c o s t b u t a t th e  e x p e n s e  o f  fu l l y  c o m p l y i n g  w i t h  t h e  s e l e c t e d  s t a n d a r d s   We  d i d  n o t  id e n tif y  a n y  b a s ic  p r o b le m s  in te g r a tin g  th e  v a r io u s  e le m e n ts  of  t he  c hos e n s t a nda r ds   but  a l s o s a w  t ha t  onl y c e r t a i n por t i ons  of  t he  s t a nda r ds  w e r e  t r ul y r e l e va nt  t o t he  in te g r a te d  t  W h ile  d e f in itio n  o f  s ta n d a r d s  is  o f te n  ap p r o ach ed  f r o m  t h e acad em i c p er s p ect i v e o f  i d en t i f y i n g  re q u i re m e n t s  a n d  f u n c t i o n s   t h e  ex p er i m en t al  ap p r o ach  o f  cr eat i n g  a r ef er en ce d es i g n  u s i n g  av ai l ab l e b u i l d i n g  b l o ck s  of t e n pr oduc e s  t he  m os t  opt i m a l  i m pl e m e nt a t i on  in  th e  sh o r t e st  t i m e  f r a m e   Pr i o r  w o r k  i d e n t i f i e d  sh o r t f a l l s o f  cu r r en t  W S N  t ech n o l o g y  e  ad d r es s ed  b y  u s i n g  S P A  f   s ig n if ic a n tly  in c r e a s e  u tility  T he  us e  of  xT E D S  a l l ow s  fl e x i b l e  s e n s o r  an d  act u at o r  d ef i n i t i o n s  an d  th e  in c o r p o r a tio n  o f  m u ltip le  ne t w or k a n d m odul e  pa r a m e t e r s  f or  W S N  m a na ge m e nt    us e  of  D D S  m i ddl e w a r e   l e  da t a  s t r e a m s  t o m ul t i pl e  a ppl i c a t i ons  pr ovi de s  a  f l e xi bl e  s t a nda r d fo r mo d e r n  s o f t w a r e  a r c h i t e c t u r e   T h e  u s e  o f  S P A  me s s a g i n g  al l o w s  i n t er o p er ab i l i t y  w i t h  o t h er  S P A  co m p o n en t s   in c r e a s in g  th e  b r e a d th  o f  a p p lic a b ility  an d  en ab l i n g  in te r o p e r a tib lity b e tw e e n v e n d o r p r o d u c ts   Tw o  b a s i c  a p p r o a c h e s  t o  S P A Z a r c h i t e c t u r e  w e r e   th e  u s e  o f  S P A  m e s s a g e s  e m b e d d e d  in  th e  Zi g B e e  ol  r  an d  i m p l em en t ed  i n  t h e m o d u l e fi r m w a r e   or  t he  us e  of  t he  A S I M  A da pt e r  a ppr oa c h  F or  sp a c e c r a f t  su b sy st e m s  i t  m a y  b e  b e t t e r  t o   em b ed  S P A  wi t h i n  t h e  e wi r e l e s s  n e t wo r k s   Th i s  a l l o w s  e a c h  wi r e l e s s  m o d u l e  t o  s t a n d al o n e w i t h i n  a S P A  s y s t em    DF I  a p p l i c a t i o n s   c o n s i s t i n g  o f  m a n y   wi r e l e s s  co m p o n en t s   t h e u s e o f  e  ro u t i n g  e s sc a l a b i l i t y  d  mo v e s  t h e  c o mp l i c a t e d  fu n c t i o n s  t o  t h e  A S I M  A d a p t e r   gr e a t l y re d u c i n g  re s o u rc e  d e m a n d s  o n  each  W S M   T h i s  re d u c e s  t h e  re s o u rc e s  n e e d e d  a t  t h e  s e n s o r m o d u l e s   lo w e r in g  s iz e  p o w e r  a n d  c o s t  Ho we v e r   o n l y  t h e  AS I M  Ad a p t e r  h o s t e d  i n  t h e  S P N c a n  i n t e r a c t  wi t h  o t h e r  S P A co m p o n en t s   Th i s  a r c h i t e c t u r e  i s  s i m i l a r t o  t h e  N C A P  a n d  co n f o r m s  t o  I E E E  1 4 5 1   n  is s u e  f o r  S P A Z c o n s i s t s o f u n d e r s t a n d i n g t h e b e s t  ap p r o ach  f o r  u s i n g  t h e u n d er l y i n g  P A N  an d  Zi g B e e   fu n c t i o n s  e ffe c t i v e l y  t o  im p le m e n t th e  r e f e r e n c e  d e s ig n t ap p ear s  t h at  u s i n g  t h e e  Ap p l i c a t i o n  S u p p o r t  L a y e r  t o  im p le m e n t th e  C A S  a d d r e s s in g  a n d  SPA  m e s s a g i n g  fu n c t i o n s  m a y  b e  t h e  m o s t  e ffe c t i v e  i n t e g r a t i o n  p a t h   T h i s  an d  t h e ad d i t i o n  o f  t h e x T E D S  t o  each  m o d u l e i m p l em en t s  th e  k e y  S P A  f u n c tio n a lity  n e e d e d  in  e a c h  w ir e le s s  m o d u le   Th e  o t h e r  i s s u e  i s  h o s t i n g  t h e  S P A  s e r v i c e s  w i t h i n  t h e  ove r a l l  s ys t e m  a r c hi t e c t ur e    is  de s i r a bl e  t o c r e a t e  a  s t a nda r d i m pl e m e nt a t i on f or  t he  en t i r e eco s y s t em  o f  d ev i ces  t h at  ar e u s ed  o n  a s p acecr af t  o r  sa t e l l i t e   Th e  C C S D S  S O I S  s t a n d a r d s  c o ul d he l p e s t a bl i s h th is  b y  c r e a tin g  c o m m o n  d e f in itio n s  a n d  m e s s a g e s   ar e s ev er al  co m m o n  co m p o n en t s  t h at  ar e ex p ect ed  t o  b e pr e s e nt  f or  na vi ga t i on  or i e nt a tio n  a n d  p o w e r  m a n a g e m e n t C re a t i n g  t ru e  P l u g d    de vi c e s  w he r e  co m m o n  r eq u es t s  an d  at t r i b u t es  ar e s p eci f i ed  in  th e  a r c h ite c tu r e  w o u ld  f u r th e r  s im p lif y  in te g r a tio n  be t w e e n m ul t i pl e  ve ndor s  a nd e nha nc e  t e s t a bi l i t y  It  i s  v e ry  i m p o rt a n t  t o  re d u c e  t h e  c o s t  an d  co m p l ex i t y   Ae r o s p a c e  v e h i c l e  i n t e g r a t i o n   a s  t h i s  t e n d s  t o  be  a  m a j or  co s t  d r i v er   T h e cap ab i l i t y  o f  u s i n g  s t an d ar d  s o f t w ar e in te r f a c e s  a llo w s  m u c h  o f  th e  a p p lic a tio n  s o f tw a r e  to  b e  re u s e d  f o r m u l t i p l e  p u rp o s e s   re d u c i n g  c o s t   b u t  a l s o  m a k i n g  a l ar g er  r an g e o f   so f t w a r e  a v a i l a b l e   sp a c e c r a f t  T h e  tr e nd f or  m ode r n ha r dw a r e  a nd s of t w a r e  i s  d hoc  dyna m i c a l l y c onf i gur e d ne t w or k s ys t e m s   wh i c h  b y  t h e i r  n a t u r e   c h a n g e  t h e  a p p r o a c h  u s e d  f o r  ap p l i cat i o n  s o f t w ar e im p le m e n ta tio n  T h e  te a m  h a s  f o u n d  th a t s u c h  d y n a m ic  s y s te m s  m u s t in c o r p o r a te  th e  me c h a n i s ms  s u p p o r t i n g  r e c o n f i g u r a t i o n  a t  ev er y  l ev el   sy st e m  fr o m  t h e  p h y s i c a l  i n t e r c o n n e c t  to  th e  a p p lic a tio n  so f w a r e  S P A  s ta n d a r d s  le a d  th e  w a y  to  a c h ie v in g  s u c h ad ap t ab l e i n t el l i g en t  s y s t em s  an d  in te g r a tio n  w ith  w ir e le s s  e  ne t w or ks  a ppe a r s  t o be  pos si b l e  a n d  d e si r a b l e   A CK NO W L E DG E M E NT S  Th e  a u t h o r s  w i s h  t o  t h a n k  D a n i e l  W i n t e r h a l t e r   N a n s  K u n z  Fe r n a n d o  Fi g u e r o a  an d  A n n  P at t er s o n  of  N A S A   th e ir  s u p p o r t o f  th is  w o r k  Al s o  t e c h n i c a l  c o n t r i b u t i o n s  f r o m  Mo b i t r u m  C o r p o r a t i o n  w o r k i n g  u n d e r  a  N A S A  S B I  we r e  u s e d  f o r  t h e  i n i t i a l  W S N p r o t o t y p e  e v a l u a t i o n  wo r k   Fi n a l l y   Pe t e  W i l s o n  p r o v i d e d  m u c h  s u p p o r t  f o r  e  ha r dw a r e  a nd s of t w a r e  i m pl e m e nt a t i on   


 12                0   1  2   3 4 52    xTEDS xmlns=http://www.interfacecontrol.com/SPA/xTEDS  xml ns:xsi="http://www.we.org/2001/XMLSchema instance    xsi:schemaLocation Schema/xTEDS02.xsd" name="thermistor.xTEDS.xml   version="2.5   Device componentKey name="Thermistor 1 kind="Thermistor description="Thermistor manufacturerId U.S.Sensor Thermistor     modelId="200 versionLetter="A serialNumber="2001 calibrationDate="1970 01 01 sensitivityAtReference="32650     referenceFrequency referenceTemperature="0 measurementRange 40 75 electricalOutput="1480 100000   Int erface id="1" name="Generic" description="generic device service interface   Request   CommandMsg id="1" name="DVS_GET_DEVICE_CLASS.request   Variable name="Request_ID" kind="linkToIndication" dataType="UINT16" units="none   V ariable name="Device_ID" kind="ID" dataType="UINT16" units="none   CommandMsg   DataReplyMsg id="1" name="DVS_GET_DEVICE_CLASS.indication   Variable name="Request_ID" kind="linkToIndication" dataType="UINT16" units="none   Variable name="Result" kind="indication" dataType="UINT16" units="none   Enumeration   Option name="No_Error value="1 description="Request was successful Variables returned are valid   Option name="Failure value 2 description="Request could not be fulfilled Variables returned are invalid   Enumeration   Variable   Variable name="Device_Class" kind="ID" dataType="UINT16" units="none   DataReplyMsg   Request   Reque st   CommandMsg id="2" name="DVS_GET_DEVICE_TYPE.request   Variable name="Request_ID" kind="linkToIndication" dataType="UINT16" units="none   Variable name="Device_ID" kind="ID" dataType="UINT16" units="none   CommandMsg   DataReplyMsg id="2" name="DVS_GET_DEVICE_TYPE.indication   Variable name="Request_ID" kind="linkToIndication" dataType="UINT16" units="none   Variable name="Result" kind="indication" dataType="UINT16" units="none   Enum eration   Option name="No_Error value="1 description="Request was successful Variables returned are valid   Option name="Failure value="2 description="Request could not be fulfilled Variables returned are invalid    Enumeration   Variable   Variable name="Device_Type" kind="ID" dataType="UINT16" units="none   DataReplyMsg   Request   Request   CommandMsg id="3" name="DVS_POWER_DEVICE.request   Variable name="Requ est_ID" kind="linkToIndication" dataType="UINT32" units="none   Variable name="Device_ID" kind="ID" dataType="UINT32" units="none   Variable name="On_Off_Flag" kind="powerStateRequest" dataType="UINT08" units="none   Enumerat ion   Option name="Off" value="1" description="No power is applied to the device   Option name="On" value="2" description="Power is applied to the device   Enumeration   Variable   CommandMsg   DataReplyMsg id="3" name="DVS_POWER_DEVICE.indication   Variable name="Request_ID" kind="linkToIndication" dataType="UINT32" units="none   Variable name="Result" kind="indication" dataType="UINT08" units="none   Enumeration   Option name="No_Error value="1 description="Request was successful Variables returned are valid   Option name="Failure value="2 description="Request could not be fulfilled Variables returned are invalid   Enu meration   Variable   Variable name="Device_Status" kind="powerStateIndication" dataType="UINT08" units="none   Enumeration   Option name="Off" value="1" description="No power is applied to the device  


 13    Option name="Initializing" value="2" description="Initialization is in progress   Option name="Initialized" value="3" description="Device is in operational or standby mode   Option name="Failed value="4 description="An int ernal check during power switch on has not passed   Enumeration   Variable   DataReplyMsg   Request   Request   CommandMsg id="4" name="DVS_RESET_DEVICE.request   Variable name="Request_ID" kind="linkTo Indication" dataType="UINT32" units="none   Variable name="Device_ID" kind="ID" dataType="UINT32" units="none   CommandMsg   DataReplyMsg id="4" name="DVS_RESET_DEVICE.indication   Variable name="Request_ID" kind="linkToIn dication" dataType="UINT32" units="none   Variable name="Result" kind="indication" dataType="UINT08" units="none   Enumeration   Option name="No_Error value="1 description="Request was successful Variables returned are v alid   Option name="Failure value="2 description="Request could not be fulfilled Variables returned are invalid   Enumeration   Variable   Variable name="Device_Status" kind="resetStateIndication" dataType UINT08" units="none   Enumeration   Option name="Not_Supported value="1 description="The device does not implement this function   Option name="Initializing" value="2" description="Initialization is in progress    Option name="Initialized" value="3" description="Device is in operational or standby mode   Option name="Failed value="4 description="An internal check during power switch on has not passed   Enumeration   Variable   DataReplyMsg   Request   Request   CommandMsg id="5" name="DVS_ARM_DEVICE.request   Variable name="Request_ID" kind="linkToIndication" dataType="UINT32" units="none   Variable name="Device_ID" kind="ID  dataType="UINT32" units="none   Variable name="Arm_Disarm_Flag" kind="armingStateRequest" dataType="UINT08" units="none   Enumeration   Option name="Arm" value="1" description="Arm the device   Option name Disarm" value="2" description="Disarm the device   Enumeration   Variable   CommandMsg   DataReplyMsg id="5" name="DVS_ARM_DEVICE.indication   Variable name="Request_ID" kind="linkToIndication" dataType="UINT32  units="none   Variable name="Result" kind="indication" dataType="UINT08" units="none   Enumeration   Option name="No_Error value="1 description="Request was successful Variables returned are valid   Optio n name="Failure value="2 description="Request could not be fulfilled Variables returned are invalid   Enumeration   Variable   Variable name="Device_Arming_Status" kind="armingStateIndication" dataType="UINT08" units="none    Enumeration   Option name="Not_Supported value="1 description="The device does not implement this function   Option name="Not_Armed" value="2" description="The device is not armed   Option name="Arm ed" value="3" description="The device is armed   Enumeration   Variable   DataReplyMsg   Request   Interface     Interface id="2" name ZigBee description ZigBee  wireless service interface   Request   C ommandMsg id="1" name="DVS_GET_ZB_STATUS.request   Variable name="Request_ID" kind="linkToIndication" dataType="UINT16" units="none   Variable name="Device_ID" kind="ID" dataType="UINT16" units="none   CommandMsg   DataRep lyMsg id="1" name="DVS_GET_ZB_STATUS.indication  


 14   Variable name="Request_ID" kind="linkToIndication" dataType="UINT16" units="none   Variable name="Result" kind="indication" dataType="UINT16" units="none   Enumeration    Option name="No_Error value="1 description Request was successful  are valid   Option name="Failure value="2 description Request could not be fulfilled  Variables returned are invalid   Enumeratio n   Variable   Variable name="Device_ID" kind="ID" dataType="UINT16" units="none    Variable name="RSSI" kind="signalStrength" dataType="UINT16" units="none    Variable name="Battery_Status" kind="batteryLife" dataType="UINT16" units none    Variable name="Architecture" kind="hardwareArchitecture" dataType="UINT08" units="none     Enumeration   Option name="cc2430" value="1" description="The device is a TI cc2430 board   Option name="cc2530" value="2 description="The device is a TI cc2530 board   Enumeration    Variable    Variable name="TIM_Type" kind="nodeType" dataType="UINT08" units="none     Enumeration   Option name="coordinator" value="1" description="The node is a cting as a ZigBee  coordinator   Option name="router" value="2" description="The node is acting as a ZigBee  router     name="end device value="3 description="The node is acting as a ZigBee  end device   Enumeration    Variable   DataReplyMsg   Request   Interface     Interface id="3" name="Thermistor" description="Thermistor service interface   Request   CommandMsg id="1" name="DVS_GET_TEMPERATURE.request   Variable name="Re quest_ID" kind="linkToIndication" dataType="UINT32" units="none   Variable name="Device_ID" kind="ID" dataType="UINT32" units="none   CommandMsg   DataReplyMsg id="1" name="DVS_GET_TEMPERATURE.indication   Variable name="R equest_ID" kind="linkToIndication" dataType="UINT32" units="none   Variable name="Result" kind="indication" dataType="UINT08" units="none   Enumeration   Option name="No_Error value="1 description="Request was successful  are valid   Option name="Failure value="2 description="Request could not be fulfilled  Variables returned are invalid   Enumeration   Variable   Variable name="Temperature kind="tempera ture dataType="FLOAT64 units="F rangeMin="0 rangeMax="100" accuracy="0.10   Variable name="Thermistor_Status" kind="thermistorStateIndication" dataType="UINT08" units="none   Enumeration   Option name="No_Error" value 1" description="The device has detected no errors   Option name="Error" value="2" description="The device has detected an error   Enumeration   Variable   DataReplyMsg   Request   Request   Command Msg id="2" name="DVS_GET_SENSOR_RATE.request   Variable name="Request_ID" kind="linkToIndication" dataType="UINT32" units="none   Variable name="Device_ID" kind="ID" dataType="UINT32" units="none   CommandMsg   DataReplyMs g id="2" name="DVS_GET_SENSOR_RATE.indication   Variable name="Request_ID" kind="linkToIndication" dataType="UINT32" units="none   Variable name="Result" kind="indication" dataType="UINT08" units="none   Enumeration    Option name="No_Error value="1 descr iption="Request was successful  are valid   Option name="Failure value="2 description Request could not be fulfilled  Variables returned are invalid   Enumeration   Variable   Variable name="Sensor_Publish_Rate" kind="duration" dataType="FLOAT64" units="s   DataReplyMsg   Request   Request  


 15   CommandMsg id="3" name="DVS_SET_SENSOR_RATE.request   Variable name="Request_ID kind="linkToIndication" dataType="UINT32" units="none   Variable name="Device_ID" kind="ID" dataType="UINT32" units="none    Variable name="Sensor_Publish_Rate" kind="rateChangeRequest" dataType="FLOAT64" units="s   CommandMsg    DataReplyMsg id="3" name="DVS_SET_SENSOR_RATE.indication   Variable name="Request_ID" kind="linkToIndication" dataType="UINT32" units="none   Variable name="Result" kind="indication" dataType="UINT08" units="none   Enumerat ion   Option name="No_Error value="1 descri ption="Request was successful Variables returned are valid   Option name="Failure value="2 description Request could not be fulfilled  Variables returned are invalid   Enumeration   Variable   Variable name="Sensor_Publish_Rate" kind="duration" dataType="FLOAT64" units="s    Variable name="Sensor_Publish_Rate_Status kind="PublishRateStateIndication dataType="UINT08 units="none   Enumer ation   Option name="Not_Supported value="1 description="The sensor device does not implement this rate   Option name="Rate_Changed value="2 description="The sensor device has updated its publish rate   Enumerat ion   Variable   DataReplyMsg   Request   Notification   DataMsg id="1" msgRate="1" msgArrival="PERIODIC" name="DVS_GET_TEMPERATURE_PERIODIC.indication   Variable name="Temperature kind="temperature dataType="FLOAT64  units="F rangeMin="0 rangeMax="100" accuracy="0.10   Variable name="Thermistor_Status" kind="thermistorStateIndication" dataType="UINT08" units="none   Enumeration   Option name="No_Error" value="1" description="The de vice has detected no errors   Option name="Error" value="2" description="The device has detected an error   Enumeration   Variable   DataMsg   Notification   Interface  xTEDS    


 16  ES   1 a   Gi l s t r a p    Ba l d w i n   S      Fa u l t  T o l e r a n c e  i n  e  Wi r e l e s s  S e n s o r  Ne t wo r k s    I E E E  Ae r o s p a c e   2 0 1 0  P 1 4 8 0 5  2 Al e n a   R  a  F  O s s e n f o r t  J  I nt e l l i ge nt  W i r e l e s s  Se n s o r  N e t w o r k s  f o r  Sp a c e c r a f t  H e a l t h  M o n i t o r i n g    AA  In fo t e c h  C o n fe re n c e  2 0 1 2  3 C om pl e t e  s t a nda r d doc um e nt s  a nd w hi t e  pa pe r s  a r e  av ai l ab l e at  t h e e o r g  w e b  p a g e   e o r g S ta n d a r d s  Zi g B e e Ne t wo r k De v i c e s  Ov e r vi e w  a s px  4 G 133 1 2013  S pa c e  P l ug d Pl a y  A r c h i t e c t u r e  St a n d a r d s  D e v e l o p m e n t G u id e b o o k P u b lis h e d 2 0 1 3  5 P l u g d Pl a y   Pn P  St r u c t u r e s  f o r  Sa t e l l i t e  A p p l i c a t i o n s   ht t p   w w w  a f s bi r s t t r  c om  P ubl i c a t i ons  D oc um e nt s  I nnov n 042309 Sp a c e W o r k s 6 pdf  6 I EEE  ht t p   w w w  ni s t  gov e l  i s d i e e e  i e e e 1451 c f m  7 Z a ck  r ef er en ce U R L   ht t p   v as t  u ccs  ed u  p r o j ect s  t r au m ag p s _ f i l es  d o cs  ch i p co n  Z k f   8 C C 2 530 R e f e r e nc e  U R L   www t i  c o m  l i t  d s  s y m l i n k  cc2 4 3 0 f   9 R ef er en ce A r ch i t ect u r e f o r  S p ace I n f o r m at i o n  Ma n a g e m e n t   C C S D S  3 1 2  0 G 0  Gr e e n  B o o k   M a r c h  2013  0 D DS  r e f e r e n c e  UR L   p o r t a l s  g  dds    1 A AC  M i c r o t e c  r e f e r e n c e  UR L   p p n p a a c m ic r o te c c o m in d e x p h p in tr o d u c tio n to ug d pl a y ht m l  2 D ig i r e f e r e n c e U R L  ht t p   w w w  di gi  c om  pr oduc t s  Zi g B e e   3 P B o o n m a a n d J S u z u k i  T o w ar d  I n t er o p er ab l e Pu b l i s h  Su b s c r i b e  C o m m u n i c a t i o n  b e t w e e n  W i r e l e s s  Se n s o r  N e t w o r k s  a n d  A c c e s s  Ne t wo r k s    I n  Pr o c   o f  IE E E  In t e r n a t i o n a l  W o r k s h o p  o n  In f o r m a t i o n  R e t r i e v a l  i n  Se ns or  N e t w or k s   I R SN  L a s V e g a s N V J a n u a r y 2 0 0 9   B IO G R A P H Y  Ri c h a r d  L   Al e n a  is  a   En g i n e e r  i n  t h e  I n t e l l i g e n t  S y s t e m s  Di v i s i o n  a t  NAS A Am e s   M r   Al e n a  wo r k e d  o n  t h e G r o u n d  D at a Sy s t e m  a n d  p e r f o r m e d  Co m m u n i c a t i o n s  A n a l y s i s  d u r i n g  ope r a t i ons  f or  t he  L C R O S S  L una r  Mi s s i o n  a n d  o n  a v i o n i c s  a n d  s o f t w a r e  a r c h i t e c t u r e s  f o r  Lu n a r  S u r f a c e  S y s t e m s  f o r  h u m a n  m i s s i o n s   H e  w a s  t h e  c o le a d  f o r  th e  A d v a n c e d  D ia g n o s tic  S y s te m s  f o r  I n l Sp a c e  St a t i o n   I SS  Pr o j e c t   d e v e l o p i n g  m o d e l d di a gnos t i c  t ool s  f or  s pa c e  ope r a t i ons   H e  w a s  t he  c hi e f  ar ch i t ect  o f  a f l i g h t  ex p er i m en t  co n d u ct ed  ab o ar d  S h u t t l e an d  M i r  u s i n g  l ap t o p  co m p u t er s   p er s o n al  d i g i t al  as s i s t an t s  an d  s er v er s  i n  a w ir e le s s  n e tw o r k  f o r  th e  I S S  H e  w a s  a ls o  th e  te c h n ic a l le a d  f o r  th e  D a ta b u s  A n a ly s is  T o o l f o r  In t e rn a t i o n a l  S p a c e  S t a t i o n  o n or bi t  di a gnos i s   H e  w a s  gr oup l e a d f or  I nt e l l i ge nt  M obi l e  T e c hnol ogi e s   de ve l opi ng pl a ne t a r y e xpl or a t i on s ys t e m s  f or  f i e l d s i m ul a t i  Al e n a  h o l d s  a n  M  S   i n  E l e c t r i c a l  E n g i n e e r i n g  a n d  Co m p u t e r  S c i e n c e  f r o m  t h e  U n i v e r s i t y  o f  Ca l i f o r n i a   Be r k e l e y   H e  i s  t h e  w i n n e r  o f  t h e  N A S A  S i l v e r  S n o o p y  Awa r d  i n  2 0 0 2   a  NAS A Gr o u p  Ac h i e v e m e n t  Awa r d  i n  1998 f or  hi s  w or k on t he  I S S  P ha s e  1 P r ogr a m T e a m a n d  a  Sp a c e  Fl i g h t  A w a r e n e s s  A w a r d  i n  1 9 9 7    Joh n  O s s e n f or t  is  a C om put e r  S ci en t i s t  an d  em p l o y ee o f     at  N A S A  A m es  R es ear ch  Ce n t e r    cu r r en t l y  w o r k i n g   th e  D is c o v e r y  a n d  S y s te m s  H e a lth  re s e a rc h  a re a  in te g r a tin g  f a u lt ma n a g e me n t  t e c h n ol ogi e s  w i t h ad v an ced  t es t i n g  an d  de m ons t r a t i on of  t he  O r i on M ul t i pur pos e  C r e w  V e hi c l e   I n  th e  p a s t h e  h a s  wo r k e d  i n  n e t wo r k i n g  a n d  s y s t e m s  ad m i n i s t r at i o n  o n  s ev er al  ex p l o r at i o n  p r o j ect s  an d  pa r t i c i pa t e d i n ous  fi e l d  s i m u l a t i o n s   a s s i s t i n g  i n  a l l  p ect s  o f  w i r ed  an d  w i r el es s  n et w o r k  d es i g n   d ep l o y m en t   tr o u b le s h o o tin g  a n d  m a in te n a n c e  J o h n  h a s  a  d u a l B A  de gr e e  i n A nt hr opol ogy a nd E a s t  A s i a n S t udi e s  f r om  Wa s h i n g t o n  U n i v e r s i t y  i n  S t   L o u i s    Th o m  S t o n e  is  a  S e n io r  C o m p u te r  Sc i e n t i s t  w i t h  C o m p u t e r  Sc i e n   h  Ba c h e l o r s  d e g r e e  a t  SU NY  St o n y  B r o o k   Mr   S t o n e  h a s  be e n a t  N A S A  A R C  e m pl oye d by va r i ous  c ont r a c t or s  s i nc e  1989  wo r k i n g  on a dva nc e d ne t w or ki ng  He  wa s  a n  e n g i n e e r  wi t h  t h e  NAS A Sc i e n c e  I n t e r n e t  p r o j e c t  o f f i c e  w h e r e  h e l ed  t h e p r o j ect  t h at  b r  re l i a b l e  In t e rn e t  c o n n e c t i o n s  t o  re m o t e  l o c a t i o n s  i n c l u d i n g  U  S   ba s e s  i n A nt a r c t i c a  i nc l udi ng M c M ur do S t a t i on a nd Am u n d s o n  S c o t t  S o u t h  P o l e  S t a t i o n   He  wa s  p r i n c i p a l  en g i n eer  f o r  co m m u n i cat i o n s  f o r  t h e N A S A  S ear ch  f o r  t er r es t r i al  I n t el l i g en ce  S E T I   p r o j ect  an d  w as  a s en i o r  en g i n eer  f o r  t h e S p ace S t at i o n  B i o l o g i cal  R es ear ch  P r o j ect   Be f o r e  h i s  i n v o l v e m e n t  w i t h  N A S A   S t o n e  w a s  e m p l o y e d  i n  th e  c o m p u te r  a n d  c o m m u n ic a tio n s  in d u s tr y  a n d  ta u g h t te le c o m m u n ic a tio n s a t th e u n d e r g ra d u a t e  l e v e l    


 17  Jar r e n  A   B al d w i n  is  a  Ch i c a g o  n a t i v e  a n d  c u r r e n t l y  se r v e s a s t h e  l e a d  E l e c t r i c a l  En g i n e e r  a t  B a y  A r e a  s t a r t u p   Oc u l e v e  I n c   He  g r a d u a t e d  fr o m  t h e  U n i v e r s i t y  o f Il l i n o i s  wi t h  a  B  S   i n  2 0 0 9  an d  r ecei v ed  an  M  S   i n  El e c t r i c a l  En g i n e e r i n g  f r  St a n f o r d  U n i v e r s i t y  i n  2 0 1 2   Ja r r e n  d e v e l o p e d  h a r d w a r e  a n d  so f t w a r e  sy st e m s f o r  a  w i d e  ra n g e  o f  f i e l d s   i n c l u d i n g  s p a c e  s c i e n c e  s y s t e m s  a n d  m e d i c a l  de vi c e s  a s  a N A S A  A m es  i nt e r n i n t he  In t e l l i g e n t  S y s t e m s     1  2  3   4   5   6   7   8   9   10   11   12   13   


                        


                           


   












































     2 8    b 4      1 8             1 2     1  8 2  


1 9    8      2 1       1     2    8    2 3\f        


     8 D 4 9  F  \b 1 8 #J 9 1     2 1   2 #-@ 1   2 9  E 1   1   2 9      6  


    8  8   1  D 1         1 F  \b0         2 D    F  \b 1 8  9  


  1 9  1   E 1  2 9     1 1 F  \b       1    18   F   1    1 #-$+  \b  2 2  


1 D     1 #-$+.B- 0/:% .0             9 1      18    1 6     1 2  1  1  


1   6      2    1 2 E 8 D 1      1 2   1   1 #-4  #-@E     2  1  1  1       


 8     1          2 F    6   F  2   8    2 C<CC/C N\bO 5      


CD    b$44NO F P Q 6   2 b$$$ ,=\b\bA  A N,O 2 C C  b$$4N  92 2   f  9-\b$$4 B N?O  !-    91  2 1 HH111-18-N+O    -1 :3%   2     0-4 


     b N4O 2   2- \f  C b$@$ \b# >\b\b$3\b$N@O  f :.% 9 /9 \f    1  6  f 2  4   A254 


Advantages of Our M ethod Advantages of Our M ethod Exploit the memory v ertical data format utilizes slidin g windows to g form a much larger database to analyze  Flexibility in Choosing what to choose  Choosing what to choose to build the rules Computational and memory efficiency We have a team working only on this aspect 45 Associative IDS for NextGen Frameworks Dr S Dua LA Tech 45 


Preliminary Results Intra transaction Relations Data rate simulator NH-134 Mb HOP PATH update \(Y/N Inference 11.5 Y Y 2 0.120 N N      Y   n 0.345 N NH134 Y/N   Inf 1 0.150 N N 2 0 120 Y N Inter transaction Relations 2 0  120 Y N       5 5.55 0.456 Y Relations  n 0.345 N N Nmap on DMRL nmap.org 


Anticipated Outcome Anticipated Outcome Develop algorithm capable of learning from a given heterogeneous diverse Develop algorithm capable of learning from a given heterogeneous diverse data ff Dynamic algorithmic f ramework designed to shi f t modalities and sampling rates based on complex logic Flexibility of integration into the Snort intrusion detection system 47 Associative IDS for NextGen Frameworks Dr S Dua LA Tech 47 


References References Aircraft Cockpit Image courtesy USAF http://www.faa.gov htt p   www.faa g ov  air traffic  technolo gy  p g  _ gy  Acharya R Dua S Du X Sree V Chua C K Automated Diagnosis of Glaucoma Using Texture and Higher Order Spectra Features To appear in IEEE Transactions on Information Technology in Biomedicine  Du X Dua S 2011 Cancer Prognosis Using Support Vector Regression in Imaging  Modality World Journal of Clinical Oncology 2  1   44 49 Du X Dua S 2010 Salient Frame Extraction Using Support Vector Regression and Motion Features pp 5 Proc of the National Aerospace and Electronics Conference July 14 16 2010 D M P D S 2010 Di i i ti Ft d Cl ifi ti Mthd f D essaue r  M  P  D ua S  2010  Di scr i m i na ti ve F ea t ures an d Cl ass ifi ca ti on M e th o d s f or Accurate Classification 1st ed vol 7704 pp 14 Bellingham WA Proceedings of SPIE Dessauer M P Dua S 2010 Low Resolution Vehicle Tracking using Dense and Reduced Local Gradient Features Maps 1st ed vol 7694 pp 8 Bellingham WA Proceedings of SPIE SPIE 


Acknowledgements Acknowledgements Fundin g A g encies  US 4 1 Million direct fundin g g g 4 g LA BoR NIH NSF AFRL AFOSR and NASA Research Team Samuel Kasimalla Brandy McKnight Dr Pradeep Chowriappa Connor Johnson Vasanth Nair Mihir Chowriappa  Connor Johnson  Vasanth Nair  Mihir Karnik Mohit Jain and Swadheen Songmen Associative IDS for NextGen Frameworks Dr S Dua LA Tech 49 All the respective Logos belong to their owners 


Rf d Rdi R e f erence d R ea di ngs Copyright of cover pages held by respective publishers 


Thank You Questions Thank You  Questions Dr Sumeet Dua E mail sdua@latech.edu Web http://dmrl.latech.edu Associative IDS for NextGen Frameworks Frameworks Dr S Dua LA Tech 51 Image Source roadtrafficsigns.com 


