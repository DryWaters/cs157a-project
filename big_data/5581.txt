Lucia 
002\003 004 006 
002\005 
002 002 
204 We are interested in scalable mining of a nonredundant set of signi\223cant recurrent rules from a sequence database Recurrent rules have the form 215whenever a series of precedent events occurs eventually a series of consequent events occurs\216 They are intuitive and characterize behaviors in many 
002 
davidlo@smu.edu.sg lucia.2009@phdis.smu.edu.sg bding3@uiuc.edu hanj@uiuc.edu 
 and Jiawei Han 
003 005 004 006 
Bidirectional Mining of Non-Redundant Recurrent Rules from a Sequence Database David Lo 
Abstract 
School of Information Systems Singapore Management University Department of Computer Science University of Illinois at Urbana-Champaign 
 Bolin Ding 
002 
domains An example is the domain of software speci\223cation in which the rules capture a family of properties bene\223cial to program veri\223cation and bug detection We enhance a past work on mining recurrent rules by Lo Khoo and Liu to perform mining more scalably We propose a new set of pruning properties embedded in a new mining algorithm Performance and case studies on benchmark synthetic and real datasets show that our approach is much more ef\223cient and outperforms the state-ofthe-art approach in mining recurrent rules by up to two orders of magnitude 
et al 
I I NTRODUCTION Data mining has been shown useful in various domains including 223nance marketing bioinformatics and recently software engineering e.g 2 Man y v aluable data sources are in sequential formats ranging from logs transaction histories medical histories program traces and many more To analyze sequential data Lo 
propose recurrent rules stating 215Whenever a series of events occurs eventually another series of events occurs\216 Recurrent rules capture 
within a sequence 
 This enables the rule to capture signi\223cant candidates for not only temporal shortdistance but also long-distance cause-and-effect relationships in a dataset There are many instance of recurrent rules in day-to-day settings 1 Resource Locking Protocol whenever a lock is acquired eventually it is released 2 Internet Banking whenever a connection is made and an authentication is completed and fund transfer command is issued eventually the fund is transferred 3 Network Protocol whenever an HDLC connection is made and an acknowledgement is received eventually a disconnection message is sent and an acknowledgement is received In software speci\223cation and veri\223cation domain recurrent rules correspond to a family of program properties useful for 
temporal constraints that repeat a substantial number of times both 
3 The rule format is general and is 
across multiple sequences not limited by look-ahead limit or window-width constraint 
and 
c.f c.f 
 The 223rst e xample gi v en abo v e is a program property Research in software veri\223cation addresses approaches checking the correctness of a software with respect to a formal speci\223cation that often corresponds to a set of properties  
program veri\223cation  
6  7    There are past studies on mining association rules from sets of items These studies are later e xtended to mine for sequential patterns and episodes that consider ordering among events in sequences 10 Rules can be formed from both sequential patterns and episodes 10 Dif ferent from a pattern a rule expresses a 
involving its premise   pre-condition and consequent  
i.e 
c.f constraint 
  Ho we v er  documented speci\223cations might often be outdated or missing due to software evolution reluctance in writing formal speci\223cations and short-time-tomarket cycle of software development  
states 215Whenever a window is a super-sequence of it will also be a super-sequence of 
002\005\006\007 002\005\006\007 002\005\006\007 002\005\006\007 
i.e 
216 As an illustration consider the following sequences 
002\003\004 002 002\003\004 002\003\004 002\003\004 002 002\003\004 002\003\004 
states 215Whenever a sequence is a super-sequence of concatenated with concatenated with 
 post-condition These constraints are needed for their potential usages in 223ltering erroneous sequences detecting outliers etc However rules generated from sequential patterns and episodes have different semantics from recurrent rules A sequential rule it will also be a super-sequence of 216 An episode rule 
  
Sequence     002 002  002 002\003\004\005 003 006\007\b 003 006\007\b 003 006\007\b 003 006\007\b 003 006\t\002\003\004\005 003    002 003  002 002\003\004\005 003 006\007\b 003 006\007\b 003 006\007\b 003 
Seq ID  
 From sequences 
006\007\b 003 006\t\002\003\004\005 003 002\003\004\005 003 002\003\004\005 003 b\n\013\f 003   
b 002 b 002 b 003 
with a 
t\005\n\013 t\005\n\013 
216 as the two events are 
separated by more than two events 
and 
 episode rule mining with a window size of two is not able to mine the rule 215 must be followed by must be followed by 
 sequential rule mining would report 215 
From sequence 
f\r\t\005\n\013 f\r\t\005\n\013 
con\223dence or likelihood i.e 2 out of 2 sequences despite the last two 
perfect 
b 003 b 002 b 003 
t\005\n\013 t\005\n\013 
multiple 
within a sequence and across multiple sequences 978-1-4244-8960-2/11/$26.00 002 2011 IEEE ICDE Conference 2011 1043 
and 
operations in are not paired with any subsequent operations Considering both  recurrent rule mining would report 215 is followed by 
in 2 out of 4 cases\216 Recurrent rules generalize sequential rules where for each rule occurrences of the rule\220s premise and consequent both 
f\r\t\005\n\013 f\r\t\005\n\013 


i.e f\r\t\005\n\013 n\t\005\006\004\016 Past Studies on Temporal Logics 005\002\004\r   t\005\n\013 to one another   Different from association rules recurrent rules express  3 often ha v e their associated events occur at some arbitrary distance away from one another in an execution trace Also we analyze a rules In Lo et al proposed iterati v e patterns to disco v er software speci\223cations which are de\223ned based on the semantics of Message Sequence Charts MSC In Ding et Also a set of sequences rather than a single sequence is considered during mining Furthermore rather than mining all rules we mine a 1044 e.g e.g Mining Frequent Itemsets  Association Rules Mining Patterns  Rules from Sequences arbitrary use relatively close 220s work to replace a 223xed-window size with a gap constraint between one event to the next in an episode Recurrent rules generalize rules formed from episodes by allowing precedent and consequent events to be separated by an arbitrary number of events This generalization is signi\223cant since precedent and consequent events might possibly be separated by an arbitrary number of events in sequences For example useful program properties such as 217acquiring of a lock  a more scalable algorithm the ordering of items is irrelevant et al frequent episodes within a sequence of events non-redundant ordering constraints among events in a sequence database sequence database non-redundant signi\223cant number of sequences et al et al sequence database mine multiple occurrences c.f set of rules Recurrent rules could be formalized in Linear Temporal Logic LTL L TL has been widely studied and used by many tools e.g 13 Model check er is one of them 5 It veri\223es correctness of safety critical systems based on the satisfaction of rules and properties formalized in LTL The new semantics of recurrent rules as compared to association sequential and episode rules necessitates new pruning strategies and algorithms that utilize these strategies to ef\223ciently mine for recurrent rules With the growth in the size of data currently available In this work we mine recurrent rules which is under the family of Linear Temporal Logic properties T emporal logics itself has been widely used for various purposes ranging from specifying communication protocols among agents or models of agents\220 behaviors modeling bio-molecular interactions 15 querying XML documents supporting historical databases 17 verifying correctness of systems etc Man y studies described above Association rule mining is 223rst proposed by Agrawal and Srikant in Association rule captures a relationship among items in a set where  Therefore pruning properties suitable mining algorithms and the notion of rule redundancy are different  A pattern is supported by a sequence if it is a sub-sequence of it To remove redundant patterns closed sequential pattern mining was proposed by Yan  is eventually closed  are considered Recurrent rules generalize episode rules by allowing precedent and consequent events to be separated by an number of events in a than the one proposed in is needed On larger datasets or lower support thresholds we 223nd the need to improve scalability This work 223lls this gap by proposing a more scalable algorithm that embeds new pruning properties to mine recurrent rules more ef\223ciently Our approach works in several steps 1 Mining pruned pre-conditions 2 Mining pruned post-conditions 3 Rule formation and 4 Redundant rules removal A number of new pruning strategies and a new data structure are employed for ef\223cient mining of a non-redundant set of recurrent rules Under a condition which holds in many cases the complexity of the proposed algorithm is smaller by an exponential factor than the complexity of the one proposed in see Section VID Performance study conducted on benchmark datasets both synthetic and real shows that runtime is improved by up to 134 times We also conducted a case study on a dataset of real software traces extracted from multiple user interactions with an instant messaging application The outline of this paper is as follows In Section II we discuss related work Section III presents recurrent rule semantics in Linear Temporal Logic LTL Section IV describes some notations and de\223nitions used in subsequent sections Section V presents various theorems and properties used to prune search spaces Section VI presents our algorithm and compares it with Section VII describes our performance study and case study Finally we conclude and describe future work in Section VIII II R ELATED W ORK In this section we discuss closely related past studies and compare them with our approach temporal logics to accomplish a particular task Different from these past studies our goal is to  and non-redundant association rules  they occur at the same window An episode is supported by a window if it is a sub-sequence of the series of events appearing in the window There are many extensions of the work Harms et al mine for constrained episode rules where the distance between the precedent and consequent of a rule is further limited by a value smaller than the overall window size Garrig a e xtends Mannila  or 217an opened 223le  Sequential pattern mining 20 disco v ers patterns that are supported by a and mine temporal logic expressions automatically from datasets  Association rules are generated by post-processing frequent itemsets Notions of support and con\223dence are used as measures to distinguish signi\223cant rules There are many work extending association rule mining of special interest are work on closed frequent itemsets   and impro v ed by W ang and Han 22 Spiliopoulou proposed the generation of sequential rules from sequential patterns Recurrent rules generalize sequential rules by considering of the premise and consequent events within a sequence and across multiple sequences in the database This generalization is signi\223cant since the precedent and consequent events of a rule can potentially appear repeatedly in a sequence Considering program execution traces due to loops and recursion it is common to see program properties observed repeatedly in a trace Mannila performed episode mining to discover  An episode is de\223ned as a series of events occurring  is eventually followed by its release  


unlock unlock unlock unlock i.e i.e lock lock end 021\031\031\031\021\004 002\003\004 021\031\031\031\021\004 003 013\f\r\004 003\004\005\006\007\b 003\004\005\006\007\b 003\004\005\006\007\b 003\004\005\006\007\b 007\021 017 016\004\017 f\021 020 f\021 020 alsosaidtobethe 005\006\007\b 005\006\007\b in is a is a if they are not equal Each is referred to as the 002 003 004 002 005 002 006 004 003 004 002\003 004 002 002 006 003 004 002 002 002 006 003 004 002 Meaning From the next event onwards eventually 021\b 022 b b 022 b 030 004 005 032 032 032 032 032 032 032 032 032 004 032 032 034 034 007\b\002 034 007\t\n\013 034 007\t\n\013 034 002 002 002 002 004 003 004 f\006\004 007   006 007   006 007 006 006 006 006 006 006 006 006 006 005 006 006 005 003 007 b t 003 004 003 004 n n f t\005\n\013 t\005\n\013 t\005\n\013 t\005\n\013 004\002 021 031\031\031\021 b 003 002\003\004\005\006 003 021 031\031\031\021 004 004 006 t\002 t\002 t\n t\002 t\002 t\002\020 t\n t\002\007 t\002 t\002\007 t\n t\002 t\002\017 007\b\t\n 003\f\t\004\006 is satis\223ed This is the case since the second occurrence of 007\007   007\007\007\007 007\007\007\007\007 017 022 b 004 030 032 032 032 032 032 004 004 004 021 004 004 027 026 004 004 005 002 004 004 004 005 003 004 003 004 004 005 002 032 032 034 007\t\n\013 034 007\b\002 034 007\b\002 020\n f f 020 n f 020 n f 020 007 021 003 021 004 021 005 021 003 021 006 021 005 021 006 022 004  021 005 021 003 021 004 021 002 021 004 021 006 021 005 021 003 021 006 007\n 002 n n f f 022 003  013\013\013 033\027 004\002\003 021\004 021\004 033 031\031\031 033 027 003 002\003 020\021 007 or eventually in one of the subsequent events in a sequence The operator 217X\220 speci\223es that a property holds at the where the 217b\220s refer to is the property denoted as  We de\223ne a to be a series of events We use of  A pattern  if there exists integers   of the rule while or  002\005\006\007 002\005\006\007 002\005\006\007 002\005\006\007 f\006\004 Meaning Eventually 002\003\004\002\005\006\007 002\003\004\002\005\006\007 002\003\004\002\005\006\007 026\017\027\r\021 t\005\n\013\021 f\006\004\021 f\r\t\005\n\013\021 t\005\n\013\021 004\r\016 026\017\027\r\021 t\005\n\013\021 f\006\004 026\017\027\r\021 t\005\n\013 f\r\t\005\n\013\021 004\r\016 f\r\t\005\n\013\021 004\r\016 004 004 004 004 f\r\t\005\n\013 f\r\t\005\n\013 f\r\t\005\n\013 020\021 020 004\023\004\r\007 004\023\004\r\007 004\023\004\r\007 004\023\004\r\007 004\r\016 004\r\016 004\r\016 004\r\016 026\017\027\r 026\017\027\r 002\003\004 024\022 024\025 024\025 024\025 024\022 024\025 024\025 024\022 024\022 024\025 024\025 006 005 006 006 007 007 b b 005 005 002 005 005 005 pattern 004\002\003 backward extension sub-pattern premise 003\003 003\003\003\003\003 003\003 003\003 003\003\003 or 004\005 004\005 004\005 002 002 002 002 002 002 003 002 003 002 002 002 002 002 003 002 002 002 002 002 004\002\003 is called  is called  is called  are called TABLE II R ULES AND THEIR LTL E QUIVALENCES Notation LTL Notation  al proposed an approach to mine for repetitive sub-sequences Our work could be viewed as an extension of their approaches to mine for repetitive rules following the semantics of Linear Temporal Logics In the software domain LTL but not MSC is one of the most widely-used formalism for program veri\223cation  event Some examples are listed in Table I Our mined rules state whenever a series of precedent events occurs eventually another series of consequent events also occurs A mined rule denoted as  Note however the property corresponding to be a set of distinct considered The input to our mining problem is a  Each sequence is an ordered list of events denoted as where  of another pattern such that In this subsection we discuss various concepts and de\223nitions and de\223ne our problem statement We use the database in Table III as our running example throughout this paper TABLE III E XAMPLE S EQUENCE D ATABASE 205 002\003\004\005\006   Seq ID  Sequence     TABLE I LTL E XPRESSIONS AND THEIR M EANINGS 013\f\t\n 002 002 002 003 002 002 002 005 002 002 005 003 002 004    003 002 004   1045 Meaning Globally whenever is called then from the next event onwards eventually Meaning Globally whenever followed by followed by  ensuring correctness of a software system Since the underlying target formalisms and semantics are different both the search space pruning strategies and the mining algorithm needed to ef\223ciently mine recurrent rules are different from those used in the past studies in and 25 Mining recurrent rules is 223rst proposed in In this work we speed up the mining process further We propose new pruning strategies and a new algorithm that embed the strategies into an effective approach to prune search space Under a condition which holds in many cases the complexity of our approach is exponentially better than the complexity of the approach in see Section VI-D Furthermore our empirical evaluation shows that our approach is able to outperform by up to 2 orders of magnitude III R ULE S EMANTICS IN LTL Our mined rules can be expressed in Linear Temporal Logic LTL L TL is a logic that speci\223es properties of a sequence i.e a series of events Among LTL operators we are only interested in the operators 217G\220,\217F\220 and 217X\220 The operator 217G\220 speci\223es that for every event in a sequence a certain property holds The operator 217F\220 speci\223es that a property holds either at the current event or  The set of LTL expressions corresponding to the set of recurrent rules and are minable by our mining framework is shown in Backus-Naur Form BNF as follows   To illustrate the semantics of recurrent rules consider a sequence  IV N OTATIONS D EFINITIONS This section presents some preliminary notations and de\223nitions pertinent to mining recurrent rules Many of these are taken from     two patterns is referred to as the 003 003 003 004 003 004 003 004 003 003 004 003 004 004 003 003 003 004 003 004 003 002 004 002\003\004\005\006 next  can be mapped to its corresponding LTL expression Examples of such correspondences are shown in Table II Note that although the operator 217X\220 might seem redundant it is needed to specify rules such as as the second occurrence of and Let and and of or of and or of A Basic Notations pre-condition main globally 223nally forward extension super-pattern recurrent rule post-condition denotes the concatenation of patterns denoted as different occurrences of 217b\220 Example 1 events sequence database subsequence consequent B Concepts and Problem Statement are called then from the next event onwards eventually The LTL property corresponding to the rule  This property is violated by is not eventually followed by  which is immediately before is not followed by a to denote the 223rst and last event of respectively A pattern or has the form are two series of events  


002\036 002\036 002\036 002\036 002\036 i.e i.e i.e i.e i.e 027\021 006\036 027\021 006\036 Temporal Points  Pre\223xes  Suf\223xes Occurrences  Instances Projection  Sequence Support Support  Con\223dence of Rule 007\005\003 006\036 006\036 t\017\006\007 t\017\006\007 is the in in in is iff it is the shortest one in 21  capturing series of e v ents occurring after the 223rst in in w.r.t in 002\003\004\005\006 in 002\003\004\005\006 in Table III and a recurrent rule 021\031\031\031\021\017 021 031\031\031\021\017 021\031\031\031\021\017 is the in Table III  is the shortest pre\223x of in Table III contain it so t\r\016 and 007\b\t 007\b\b 002 023\021 002\003\004\005\006 003 005 007 007 034\021 002\003\004\005\006 034\021 002\003\004\005\006 034\021 002\003\004\005\006 034\021 002\003\004\005\006 034\021 002\003\004\005\006 034\021 002\003\004\005\006 034\021 002\003\004\005\006 007\005 t\r\016 007\005 t\r\016 007\b\b 007\005 t\r\016 004 003 003 003 004 007 003 003 003 005 002\003\004\005\006 002 002 003 f 005 005 005 005 005 005 005 020 003 020 003 006 006 007 b b 006 007 007 b b 006 007 006 007 005 006 006 007 006 007 b b 006 006 b b 007 006 006 b b 007 006 007 006 006 007  t\r\016 007\b\b 006 007 006 007 006 007 006 007 006 All-Projection  Instance Support an 017\021 020  Reference to the database is omitted if it is clear from the context in 002\003\004\005\006 n 002\003\004\005\006 thelast 003 f 003 r r f 003 004 003 003 003 003 004 007\005 005\f 032\021 002\003\004\005\006 013\033\035 Itisde\223ned to be the ratio of two quantities t\r\016 007\b\b 004 004 004 003 003 004 b 003 004 004 004 007 005 t 002\003\004\005\006 b 007 005 t 002\003\004\005\006 b 004 003 004 005 002\003\004\005\006 005 003 004 005 003 004 003 004 006 002 006 002  starting from e.g  the 223rst  Given a pattern of   Each of such  is indexed by  of    For a pattern  002\003\004\005\006   For a pattern in Table III From the support notations we have t\r\016 re\224ects the number of occurrences of supporting of   or t\r\016 007\b\b of is omitted if it is clear from the context The con\223dence of  017\020\021\022 205 the number of times that Consider a sequence database 002\003\004\005\006   In 007\b\t 002 023\021 002\003\004\005\006 003 All events in 016\017\017 r 016\017\017 r 016\017\017 016\017\017 021 003\004\005 016\017\017 021 003\004\005 005 005\003 has just occurred at a point in time i.e a temporal point instances c.f De\223nition 4.3  De\223nition 4.4  all-projected support con\223dence con\223dence 002 003 004 005 003 006 005 006 002 003 002 003 004 005 003 002 003 002 003 002 003 002 003 002 003 006 002 003 005 006 021\017 b b b b 035 035 b 035 035 b 032 b 032 b 035 035 b 032 035 b 032 032 b 013 b 032 032 b 032 b 032 032 b b 032 032 032 032 b 032 032 032 032 034 034 034 034 034 034 034 034 034 034 034 021 002\003\004\005\006 021 002\003\004\005\006 034 021 002\003\004\005\006 021 002\003\004\005\006 034 034 034 021 002\003\004\005\006 034 021 002\003\004\005\006 034 034 034 034 b b retwoseries of events patterns expresses that whenever 005\003 Both 017 b 017 035 017 017 032 b 035 032 032 035 021 021 021 021 021 021 021 021 021 021 021 021 021 021 b b 032 032 b b 032 021 021 021 002\003\004\005\006 021 021 002\003\004\005\006 034 034 034 034 034 034 021 t\r\016 007\b\b 034 034 031 034 034 031 002\003\004\005\006 034 034 021 021 021 021 021 034 004\002\003 occurrence Example 2 occurrences each temporal point projected Example 3 Example 4 temporal points in pre\223x suf\223x instance temporal point sequence support t\r\016 pre-condition sequence support De\223nition 4.1  De\223nition 4.2  minimum instance support t\r\016 007\b\b recurrent rule post-condition De\223nition 4.5  instance support 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 The current de\223nition of 007\b\t   are A database  satisfying  and   satisfying  t\r\016 007\b\b  TABLE IV P ROJECTION AND A LL P ROJECTION      From the above notions of temporal points projected databases and supports of patterns we de\223ne the  The or 1  t\r\016   follows typical de\223nitions of support in association rule mining and sequential rule mining 1046 t\003\n 002 007 t n 007 003 013 006 005 006 005 of of and a sequence and and and  and and t\r\016 007\b\b  and and The  is de\223ned to be the ratio 017\020\021\022  and t\r\016 occurs after and  eventually another series of events occurs\216 From the above semantics to generate recurrent rules we need to 215peek\216 at interesting temporal points and 215see\216 what series of events are likely to occur next We will 223rst formalize the notion of temporal points and occurrences events events pre\223x of is a supersequence of  An instance of  there is no such that pre\223x of is an instance of  and the corresponding  where the instance is the minimum one De\223nition 4.3 is a standard database projection   De\223nition 4.4 captures series of events occurring after is de\223ned as 002\003\004\005\006 containing containing A database is de\223ned as 002\003\004\005\006 is an instance of The two projection methods associated notions of t\r\016  where Consider a recurrent rule  can be interpreted as the likelihood of happening after occurs in 002\003\004\005\006 is the number of sequences in 002\003\004\005\006 containing or being a super-sequence of the concatenation of precondition and post-condition  The instance support 1 We standardize de\223nitions of 007\b\t 002 023\021 002\003\004\005\006 003 Consider a sequence  For a temporal point is de\223ned to be a temporal point  such that the of the pattern  it is a super-sequence of and the sequence  we de\223ne the  we de\223ne the in all sequences of 002\003\004\005\006 rather than the number of sequences in 002\003\004\005\006 are long and occurs at a temporal point  denoted as t\r\016  denoted as 017\020\021\022 205the number of times that  The sequence support of Each recurrent rule we mine expresses 215Whenever a series of events of the form are indexed by their positions in  These positions are called pre\223xes is said to be an Consider a pattern  Temporal points are the introduced in on a pattern is the minimum instance of to be the size of 002\003\004\005\006 or equivalently the number of sequences in 002\003\004\005\006  Reference to the database is omitted if it is clear from the context on a pattern to be the size of 002\003\004\005\006 or equivalently the total number of instances of To illustrate the above concepts we list the projected and all-projected database 002\003\004\005\006 Projection 002\003\004\005\006 003 002 002 003 004     002\004 021 003 004 021 005 021 003 021 006 021 005 021 006 004 003    002\005 021 003 004 021 002 021 004 021 006 021 005 021 003 021 006 004 003     All-Projection 002\003\004\005\006 003\004\004 003 002 002 003 004     002\004 021 003 004 021 005 021 003 021 006 021 005 021 006 004 003    002\004 021 003 006 021 005 021 006 004 003    002\005 021 003 004 021 002 021 004 021 006 021 005 021 003 021 006 004 003    002\005 021 003 006 004 003   are different Speci\223cally t\r\016 007\b\b  They would differ a lot if sequences in 002\003\004\005\006 repeats multiple times in single sequences Each  in the form of likely occurs after  is de\223ned to be the sequence support or instance support of is de\223ned as 007\b\t 002 023 005\006\007 021 002\003\004\005\006 003 while 007\b\t 007\b\b 002 023\021 002\003\004\005\006 003 is de\223ned as 007\b\t 007\b\b 002 023 005\006\007 006 006 023 005\b\t\n 021 002\003\004\005\006 003 


redundant 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\036 027\021 002\036 002\036 027\021 006\036 027\003\006\007 signi\223cant rule De\223nition 4.6  Rule Redundancy all-projection suf-projection suf-projection the minimum suf\223x the minimum suf\223x 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 occurrences temporal point et al Example 5 pre\223x projection A Suf\223x Projection and Pre\223x Projection suf\223x projection Example 6 006\036 006\036 006\036 006\036 006\036 006\036 006\036 006\036  So  To reduce the number of rules and improve ef\223ciency while not to lose much information in Lo  which project sequences to the minimum suf\223xes containing a pattern and the complementary pre\223xes respectively Using the two new types of projections we will introduce the antimonotonicity property of con\223dence Section V-B and the strategies for pruning redundant rules Section V-C 007\005\r in in the form of is is is is iff no suf\223x shorter than is We still use sufprojection the w.r.t in s.t  2 both rules have the same support and con\223dence values 3 in the case that the concatenations are the same  w.r.t a pattern in Table III to illustrate the above concepts Consider pattern 020 003 020 003 022 002 f r 005 005 005 005 005 005 005 005 005 007\005 005 005  of   Mining Recurrent Rules with suf\223cient supports and con\223dence In a sequence database  given threshold  and de\223ne a notion of rule redundancy based on among rules having the same support and con\223dence values This is similar to the notion of patterns applied to sequential patterns 22     In this work we mine non-redundant signi\223cant rules V P RUNING P ROPERTIES FOR S CALABLE M INING OF R ECURRENT R ULES The basic idea of our algorithm for mining non-redundant recurrent rules is 223rst we 223nd a candidate set of preconditions and a candidate set of post-conditions then we pair two elements one from each candidate set to form a recurrent rules For the scalable mining of rules we study the anti-monotonicity property of con\223dence used to speed up the pairing procedure and propose strategies for shrinking the two candidate sets and pruning redundant rules in advance This section is organized as follows The anti-monotonicity property of con\223dence and pruning strategies rely on two other types of projections called and  which are introduced in Section V-A The antimonotonicity property of con\223dence is presented in Section VB The strategies for shrinking candidate sets and pruning redundant rules are described in Section V-C The description of the complete algorithm and its analysis are deferred to Section VI Recall De\223nition 4.3 and De\223nition 4.4 essentially project sequences to their suf\223xes after the instances of a pattern Differently here we introduce   The   The   shorter than  Consider a recurrent rule in the form  In this subsection we discuss how to utilize  We also present the antimonotonicity property of con\223dence Suppose we have the con\223dence  This rule implies that in the database the consequence 007\005\r 004\002\003 pre\223x projection De\223nition 5.1  Suf\223x Projection and Pre\223x Projection 007\b\b 007\b\b 007\b\b 007\b\b 007\b\b 007\b\b signi\223cant rules super-sequence relationship closed suf\223x projection projection pre-projection pre-projection B Anti-Monotonicity Property of Con\223dence 006 006 006 006 006 006 007 006 007 006 007 b b b b b b 005 b b 007 b b 007 b b 002 b\006 006 006 002 b\006 003 t\n 006 006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 004\002 003 034 034 037 034 034 034 034 034 034 034 034 034 035 006\007 035 006\007 b 032 032 b 032 b 032 032 035 006\007 b 032 032 032 034  034  034 034 034 b 034 034 007\005\f 007\005\r 002 003 005 006 002 003 005 006 002 003 006 005 006 002 003 005 006 002 003 002 003 005 006 002 003 002 003 005 006 005 006 005 006 034\021 034\021 034\021 t\r\016 t\r\016 t\r\016 t\r\016 t\r\016 t\r\016 t\r\016 t\r\016 t\r\016 t\r\016 016\017\017 016\017\017 Suf-Projection 002\003\004\005\006 t\013\f 005 004 003 005 002 006 004     002\004 021 003 005 021 003 021 006 021 005 021 006 004 003    002\005 021 003 005 021 003 021 004 021 002 021 004 021 006 021 005 021 003 021 006 004 003     023\024\021  023\024\021  023\024\021  023\024\021  023\024\021  023\024\021  006 002 006 002 005 We aim to mine 021 021 021 034 021 021 021 021 021 021 021 021 021 021 021 021 021 034 034 034 034 034 034 034 034 034 034 034 034 034 034 021 021 021 032 b b b b 032 035 021 021 034 034 034 034 034 004\002\003 Arule 003 003 003 003 003 002 002 002 003 003 002 004 003 004 003 004 004 004 004 004 003 004 003 004 r r r 003 004 003 004 007 005 t b 007 005 t b 016 004 004 t 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 002 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 i.e i.e i.e 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 r 007\b\002 007\b\002 021 003\006\007\b 007\b\002 007\b\002 007\b\002 n\023\024 sthe likelihood of 007\005 The 002\007 006\007    The con\223dence of the rule      w.r.t a pattern  satisfying  satisfying iff no suf\223x starting with Suf-Projection 002\003\004\005\006 t\013\f 005 003 003 005 002 006 004     002\004 021 003 005 021 006 004 003    002\005 021 003 005 021 003 021 006 004 003     f 005 005 006 005 006 005 007 007 of and  and The of  and of of  and of and can appear one or more times in a sequence is the number of occurring after each in Table IV there is an occurrence of after each of the 223rst three occurrences of such that 1 is a sub-sequence of  and 2 holds to break the tie we de\223ne the one with longer pre-condition as being redundant  is redundant in  because another rule has the same sequence  instance supports and con\223dence as containing is de\223ned as containing  minimum suf\223x of containing minimum suf\223x of containing of the occurrences of the premise of the rule Note both which are not followed by an occurrence of contribute negatively to the con\223dence of the rule On the other hand those followed by one or more occurrence of for sequence support threshold for con\223dence our goal is to 223nd all rules is de\223ned as contains  and longer than the  contains here The  Occurrences of premise 007 007 004 004 004 004 004 004 004 004 004 of pattern  Refer to for instance support and threshold if there is another rule  we wish to retain the rule with a shorter pre-condition and a longer post-condition Following Example 4 a rule minimum suf\223x containing suf-projection and the pre-projection of are shown in Table V TABLE V S UF P ROJECTION AND P RE P ROJECTION   Pre-Projection 002\003\004\005\006 005\006\007 003 005 002 006 004     002\004 021 003 002 021 003 021 004 021 005 021 003 021 006 004 003    002\005 021 003 002 021 005 021 003 021 004 021 002 021 004 021 006 004 003   to calculate of the rule appears after a fraction contribute positively to the con\223dence 1047 


before the last occurrence Example 7 Example 8 after the last occurrence Proof C Strategies for Eliminating Redundant Rules Proposition 1 Proposition 2 027\021 002\036 002\036 027\021 002\036 027\021 002\036 004 002\036 002\036 004 004\023\006 004\023\006 017\021 020 017\021 020 004\021 n\021 016 017\021 020 n\021 016 Theorem 1  Anti-Monotonicity Property of Con\223dence Theorem 2  Pruning Redundant Pre-Conds 002\005\006\007 002\005\006\007 002\005\006\007 002\005\006\007 t\r\016 t\r\016 t\r\016 t\r\016 t\r\016 t\r\016 t\r\016 t\r\016 t\r\016 t\r\016 in is equal to in two in w.r.t  with in in in   s.t i i.e i.e 021\032 004 1  Table III in the way suggested by the above proposition is listed in Table V It is easy to see there are three instances of  obtaining the same result as in Example 4 Proposition 1 also suggests the anti-monotonicity property of  from the pre\223x projections w.r.t  respectively Suppose they are Consider two rules  In other words if In a sequence database while  for some event  and ii 006 007 006 007 006 007 006 006 007  006 007 006 006 006 006 007 006 007 006 005 005 006 006 006 007 006 005 006 007 006 007  006 006 006 005 005 b b 006 006 006 005 005 005 b b 006 b b b b b b 006 b b 005 020 006 007 020 006 007 020 006 007 005 020 006 007 020 005 020 006 007 020 006 007 020 005 020 006 007 Wehave f\005 007\b\b 007\b\b 007\b\b 007\b\b 007\b\b 007\b\b 007\b\b 007\b\b 007\b\b 004\002 003 003 004 004 003 004 t t r t t r 003 003 003 004 003 004 n 003 r 002 002 002 006\002 006\003 023\024\021  for any any 034 b 034 034 034 021 034 034 021 021 034 034 034 021 021 034 b 003 b 004 037 034 034 021 034 034 004 034 004 034 004 004 b 034 034 004 034 004 034 034 004 021 021 034 034 004 021 021 037 034 034 004 034 004 034 034 004 034 034 004 034 004 004 032 003 034 034 007\005\003 007\005 004\002\003 007\005\r in 2 016\017\017 021 wemust have 002 003 005 006 002 003 002 003 002 003 002 005 003 004 002 002 003 004 004 004 034 034 034 034 034 034 031 021 021 021 021 021 034 034 004 034 034 034 034 004 034 030 034 034 004 004 034 002\036 002\036 004 034 034 004 021 021 021 021 021 034 004 037 034 021 034 034 004 034 034 004 034 034 033 034 032 003 004 032 004 034 032 003 032 004 034 032 034 032 034 032 034 032 034 004 032 003\006\007\b 003\006\007\b 003\006\007\b 003\006\007\b 003\006\007\b 003\006\007\b 003\006\007\b 003\006\007\b 003\006\007\b 003\006\007\b 003\006\007\b 004\002\003 for each as 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 034\021 As can be veri\223ed each sequence in 007\b\002 021 007\b\002 007\b\002 007\b\002 021 007\b\002 007\b\002 007\b\002 021 007\b\002 007\b\002 007\b\002 021 007\b\002 007\b\002 006 005 007\b\002 006 005 007\b\002 006 005 007\b\002 021 007\b\002 021 007\b\002 007\b\002 021 007\b\002 007\b\002 007\b\002 021 007\b\002 021 002 007\b\002 007\b\002 007\b\002 007\b\002 021 007\b\002 007\b\002 021 002 007\b\002 006 005 007\b\002 006 004 007\b\002 006 005 007\b\002 006 004 007\b\002 006 002\020\025\020\004 007 007\b\002 007\b\002 007\b\002 007\b\002 003 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 Of importance is the portion of each sequence before the last occurrences of the consequent 205this portion of sequences is exactly formulated as the pre\223x projection appearing such occurrences of Consider a rule Using the same setting as that of Example 4 now we compute the con\223dence of recurrent rule  Therefore we have  According to Equation 1 we have decrease We formulate this as Proposition 2 and illustrate it in Example 8 Consider two rules for some event is a super-sequence of Consider two rules in the sequence database is a supersequence of the corresponding sequence in in a sequence database is not either Proposition 2 directly leads to Theorem 1 Theorem 1 can be utilized to speed up the pairing of pre-condition candidates and post-condition candidates by avoiding generating rules with insuf\223cient con\223dence The basic idea is that when we try to pair a pre-condition candidate with a post-condition candidate to form a rule if the con\223dence of the resulting rule is lower than the threshold we no longer try to pair the same precondition with any backward extension of the post-condition Details are deferred to Section VI  consider a pre-condition candidate  If there is a pre-condition candidate post-condition candidate is redundant Theorem 2 implies that there is no need to put is redundant because there is a longer rule therule 007\005 r  For each contribute positively to the con\223dence because there is at least one instance of afterwards There are totally  as stated in the following proposition We omit its proof due to the space limit  shrinks the border shifts to the left Table III Recall  with forward extension or its forward extension satis\223es the stated properties ii The intuition is that 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 021 021 002 003\004\005 003\004\005 003\004\005 f 007 b b 007 b b 007 007 007 b b 005 005 007 007 f r 007 007 007 007 007 b b b b b b 007 006 007 006 007 007 of of and one in and and and and and and and  and we can calculate and and  then and 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006  occurrences of  On the other hand those appearing  and thus the con\223dence of a rule can be also de\223ned using pre-projection via  and a sequence database  the pre\223x in a sequence database  Then we have Consider any two pre\223xes of the same sequence  Since as the ones of is not con\223dent enough  and nonempty contribute negatively to the con\223dence Formally we can prove that  in the form of grows  becomes shorter Thus  Therefore there are at least as many occurrences of  This implies the following which completes the proof shown in Table V contains two elements since  where is an arbitrary series of events Then we have Aside from early detection of rules with low con\223dence we also desire to detect redundant rules see De\223nition 4.6 early A rule is redundant if there exists another rule which is a super-sequence and has the same support and con\223dence Our goal is to detect the redundancy early in the pre-condition and post-condition candidates so as to prune the pre-conditions and post-conditions which de\223nitely lead to the formation of redundant rules We still need to test whether a rule generated from pre/post-condition candidates is redundant afterwards but our pruning strategies can reduce the number of pre/postcondition candidates by a lot Two strategies are introduced in Theorem 2 and Theorem 3 for pruning redundant pre-conditions and post-conditions respectively Theorem 2 is borrowed from into the pre-condition candidate set if with the same support and con\223dence As Theorem 2 has been presented and proved in  thus in the following part of this subsection we focus on how to prune post-conditions Theorem 3 In another theorem to prune redundant post-condition is given however applying that theorem requires performing one mining operation on the projected database for every single pre-condition candidate which is not ef\223cient enough for large datasets We 223rst discuss when a post-condition candidate is redundant w.r.t con\223dence Lemma 1 and then discuss when it is redundant w.r.t support Lemma 2 Finally we combine them as our pruning strategy for post-conditions Theorem 3 1048 


Theorem 3  Pruning Redundant Post-Conds 002\003\004 002\003\004 002 002\003\004 002 002\003\004 002\003\004 002 002\003\004 002 002\003\004 002\003\004 002\036 002\003\004 002\036 002\003\004 002\003\004 002\003\004 002\036 002\036 002\036 002\036 002\003\004 002\003\004 002 020\021 n 004 020\021 n 004 n\021 016 004 n\021 016 004 support-closed minimum A Algorithm Framework suf\223cient supports and con\223dence Proof Proof signi\223cant Lemma 1 con\223dence-closed Lemma 2 for any Example 9 t\r\016 t\r\016 t\r\016 007\b\b t\r\016 007\b\b t\r\016 t\r\016 t\r\016 007\b\b t\r\016 007\b\b t\r\016 t\r\016 t\r\016 007\b\b t\r\016 007\b\b t\r\016 t\r\016 t\r\016 007\b\b t\r\016 007\b\b t\r\016 t\r\016 007\b\b t\r\016 t\r\016 t\r\016 007\b\b t\r\016 007\b\b t\r\016 t\r\016  forsome event forsome event is w.r.t 003 s.t i s.t s.t i s.t   From iii for each satisfying satisfying 003 004 003 004 003 004 003 004 003 004 003 004 003 003 032\034 032#\b 007\005 007\005 007\005 005 005 005 005 005 005 004 005 005 004 005 005 004 004 004 004 if 007\005 005 005 005 007 006 006 007 005 006 006 005 005 005 007 006 006 006 006 007 006 006 006 006 006 006 b b b b 006 007 t 005 b b b b 006 006 b b b b b b 006 007 t 005 b b 006 005 007 005 003 005 003 006 006 006 006 006 006 006 006 006 003 003 027\021 006\036 027\021 006\036 027\021 006\036 007\005 Let for any any for any any any In fact from ii 020\021 n\021 016 004 003 003 007\005 004 004 004 004 004 004 004 004 004 004 004 004 004 004 004 004 004 004 004 004 f 004 004 f 004 004 004 004 004 004 004 004 004 004 004 therule therule 007\005\003 007\005 007\005 023\024\021  023\024\021  023\024\021  023\024\021  023\024\021  023\024\021  023\024\021  023\024\021  006\036 006\036 006\036 006\036 006\036 006\036 007\005\r therule w.r.t it then any backward extension of this post-condition can only generate redundant rules  consider a postcondition candidate while backward extension  consider a postcondition candidate while  iii 017   002 002 002 002 003  then backward extension Similar to the proof of Lemma 2 we prove the existence of    otherwise neither is true To prove    Suppose the shortest pre\223x of  Consider  From iv  consider a post-condition candidate is shown in Table V Choosing  we can easily verify that   idirectiO  with support  and con\223dence  non-redundant ones output 205 Theorem 1 is used to speed up the pairing procedure The algorithm is as follows 1 Mining Pruned Pre-Conditions Mine a set of precondition candidates 007\005\003 007\005 013 013 f 016\017\017 021 016\017\017 021 002 002\003\004\005\006 002\003\004\005\006 021\034 n\023\024 n\023\024 n\023\024 n\023\024 n\023\024 n\023\024 n\023\024 n\023\024 n\023\024 n\023\024 034 034 034 004 032 032 032 034 034 034 034 034 034 034 034 004 032 032 032 034 034 034 034 034 b 034 034 b 034 f 034 b 034 b b b 035 035 b 034 034 034 b 034 034 032 034 032 034 034 034 034 034 037 021 021 034 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 017\020\021\022 003\006\007\b 003\006\007\b 003\006\007\b 003\006\007\b 003\006\007\b 003\006\007\b 003\006\007\b 004 003\006\007\b 002 002 002 002 003\006\007\b 004 003\006\007\b 002 002 002 002 003\006\007\b 003\006\007\b 003\006\007\b 003\006\007\b 003\006\007\b 003\006\007\b 034 032 004 032 034 032 032 034 032 034 034 034 034 032 034 034 034 034 032 004 032 034 032 032 035 035 034 032 034 034 034 034 034 034 032 034 034 034 034 034 034 034 034 f b 032 034 b b 032 034 b 032 f b b 034 034 034 032 034 032 034 032 002\036 034 032 034 034 n 004 n 004 017 004\002\003 017 004\002\003 034 034 034 034 034 034 034 034 034 034 007\005 Let i.e i.e i.e i.e f 021 f 021 002 f 021 f 021 002 005 t 005 005 005 005 021 021 002 005 005 005 005 t 005 005 f 021 f 021 002 005 f 002 021 f 002 021 002 005 005 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 sin 007\005 Lemma 1 and 2 state that if for a post-condition candidate inserting some event in the middle does not change the preprojection and suf-projection of In a sequence database pre-condition candidate is not  We construct and Equation 1 in Proposition 1 we directly get In a sequence database pre-condition candidate is not  And again we construct and only need to prove  we only need to prove for each sequence  if and only if  we only need to show for each sequence  have the same number of instances in containing has the same number of instances in has in has the same number of instances in does  pre-condition candidate backward extension is redundant Theorem 3 directly follows from Lemma 1 and 2 and it implies that there is no need to put or its backward extension Consider a post-condition candidate in the sequence database for example consider the rule is redundant because we have nal pruning-B  Recall the goal of our mining algorithm is given a sequence database and three thresholds  we want to 223nd all the rules  instance support  then       we know  into the post-candidate set if iv in Lemma 1 and 2 are satis\223ed Table III Recall the sufprojection and pre-projection of  Theorem 2 and 3 discard preand post-condition candidates that are generating redundant rules before we try to pair them These theorems are early-stop conditions in the pattern-growth generation of preand post-condition candidates In the next section we will utilize the pruning strategies namely Theorem 1 2 and 3 in a holistic mining algorithm VI A LGORITHM In this section we 223rst introduce our framework to mine non-redundant rules in Section VI-A Two stages of our mining framework are detailed in Section VI-B and VI-C We analyze our algorithm in Section VI-D We call our framework B   Our mining algorithm consists of two major stages In the 223rst stage we use a pattern-growth algorithm to 223nd a candidate set of pre-conditions and a candidate set of postconditions strategies introduced by Theorem 2 and 3 are used to prune candidates for mining non-redundant rules In the second stage pre-conditions and post-conditions are paired to form rules with the  b b b b b b b b 005 006 b b 007 005 006 b b 007 b b b b b b 005 002 002 002 002 003 b b 005 006 b b 007 007 005 006 b b 007 007 007 b b b b 005 007 b b b b 005 007 t 005 b b b b 006 b b b b 005 003 005 003 r 007 007 007  and ii and of  and iv 017 and of and and and  and and as  So as and and  and and  Candidates are pruned based on Theorem 3 1049  If there is a post-condition candidate  there exists another rule To prove this lemma it suf\223ces to prove the existence of  If there is a post-condition candidate  there exists another rule to complete the proof To prove that satis\223es  If the properties iv in Lemma 1 and 2 are satis\223ed then here satis\223es properties iv in Lemma 1 and 2 So from Theorem 3 any backward extension of 003 ased recurrent rule mining algorithm BOB no less than no less than no less than 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 f 007\t\n\013 f 007\t\n\013 007\t\n\013 f 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013  subsequences  and nonempty  which completes the proof   and subsequences and nonempty  Suppose  then we have both and let be the In a sequence database can only generate redundant rules Take the backward extension 003  Candidates are pruned based on Theorem 2 2 Mining Pruned Post-Conditions Mine a set of postcondition candidates 007\b\002 021 007\b\002 021 002 007\b\002 021 007\b\002 021 002 


into into to form a rule in some order Test whether a rule is signi\223cant suf\223cient supports and con\223dence and keep all signi\223cant rules in a set is grown to into 017\020\021\022 017\020\021\022 017\020\021\022 1 3 6 7 8 10 11 12 13 15  and thus we utilize the projections of 4 5 Let 021\031\031\031\021\b 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006  if if else if if else if w.r.t w.r.t in 032\021 032\021 032\021 030 004 032 032 032 032 032 004 032 032 032 032 032 004 034 032 034 034 004 032 032 020 005 020 005 020 t t t t 002 002 r f r 003 005 005 005 005 026 r r r r r r r r 002\003\004\005\006 002\003\004\005\006 002\003\004\005\006 r\021\027 r\030\031\032 r\030\031\032 007\b\002 r 007\b\002 r 007\b\002 r 007\b\002 r 007\b\002 002 016\017\017 r 007\b\002 r b 030 032 032 032 004 032 004 034 033 034 033 032 n\023\024 005 004 002\003\004\005\006\004\007\b\004\003\005 002\003\004\005\006\004\007\b\004\003\005 return return 032\034 032#\b 032\034"\021\032#\b 032\034 032#\b 032\034 032\003\004 032\003\004 032#\b 032\005\006\007 032\005\006\007 032\034 032#\b 032\034 032#\b 032\034 032#\b 032\034 032 032#\b 032 032\034 032 032\034 032#\b 032\034 032#\b 032\034 032#\b 1050 021\007 021\007 034 b 034 b 034 b 034 b 034 b  007 b 020 t b b Objective then then Objective then then then Algorithm 2 Representation of Projected Databases 002\005\006\007 002\005\006\007 002\005\006\007 002\005\006\007 002\003\004\005\006\004\007\b\004\003\005 002\003\004\005\006\004\007\b\004\003\005  threshold pre-/post-condition candidates  2  4  5 add pre-condition candidates with pre\223x satis\223es ii in Theorem 2 prune  9 event  add post-condition candidates with suf\223x satis\223es iv in Theorem 3 prune  14 event    The difference is to mine preconditions patterns are grown forward  projected to the suf\223xes on the other hand to mine post-condition candidates  pre-/post-condition candidates  and projected to the pre\223xes The subroutine   This subsection describes Step 3-4 of our algorithm framework i.e 005\r 005\r 005 006 006 006 006 006 006 006 006 023\024\021  023\024\021  023\024\021  023\024\021  023\024\021  023\024\021  023\024\021  023\024\021  004\021 004\021 004\021 002\003\004 002\003\004 002\003\004 t\006\n\013\005\006\004\007\b\004\003\005 t\006\n\013\005\006\004\007\b\004\003\005 t\006\n\013\b\004\003\005 t\006\n\013\005\006\004\007\b\004\003\005 007 007 007 b b 007 007 b b 007 b b 007 007 b b and or and  and and and sequence database  and output the rest Step 1 and 2 above belong to the 223rst stage which will be elaborated in Section VI-B Step 3 and 4 belong to the second stage which will be described in more detail in Section VI-C B Stage I Mining Pruned Candidates Signi\223cant and non-redundant rules 1 Store  because Theorem 2\(3 states that any of its forward\(backward extension can only lead to redundant rules The remaining question is how to represent projected databases Mining Pruned Candidates  all events appearing in and projected database and pre-projected database  Theorem 1 is used to speed up the pairing  4 Removing Redundant Rules Remove the remaining redundant rules De\223nition 4.6 in  and post-condition   candidates The algorithm for mining pruned candidates is outlined in Algorithm 1 It is important to note that both the mining of pre-condition candidates and the mining of post-condition candidates are done using pattern-growth i.e depth-\223rst search of the pattern space Forming Rules from Candidates   thresholds implement the forward and backward pattern growth strategy respectively The reason for differentiating mining pre-conditions from mining post-conditions is to facilitate the pruning strategies presented in Theorem 2 and 3 Line 6 and 11 utilize the anti-monotonicity property of support longer patterns cannot have higher sequence supports Line 7 and 12 apply the pruning strategies in Theorem 2 and 3 respectively It should be noted that once a pattern used in Theorem 2 and 3 which are referred to in Algorithm 1 It is not spaceef\223cient to store them explicitly Interestingly all the projected databases are either pre\223xes or suf\223xes of the original sequences Therefore we only need to store the ending/starting positions of pre\223xes/suf\223xes in the original sequences instead of explicitly storing the pre\223xes/suf\223xes C Stage II Forming Rules obtained in Step 1-2 The basic idea is to pair each pre-condition from appearing in appearing in 3 Forming Rules For each We propose a new pattern-growth algorithm to 223nd precondition  in a Pre\223x Hash Tree in a Pre\223x Hash Tree in DFS order be the rule skip the subtree below patterns are grown backward   and thus we utilized the pre-projections of is pruned we stop growing from  how to form signi\223cant non-redundant rules from the two candidate sets with each post-condition from to form a rule and then test whether its supports and con\223dence are high enough and whether it is redundant Since the strategies in Theorem 2 and 3 line 7 and 12 in Algorithm 1 could not prune all of redundant rules the redundancy test is still needed The main purpose of Theorem 2 and 3 is to shrink the candidate sets and thus speed up the mining and pairing of candidates This stage is outlined in Algorithm 2 There are four remaining questions i how to organize t\r\016 t\r\016 t\r\016 t\r\016 t\r\016 007\b\b t\r\016 t\r\016 021\b for each do for each do for each do for each do for each do Algorithm 1 Input Output Input Input Input Output 002 Subroutine Subroutine    pattern pattern  pair it with each    2 Store  3  6  7 Add  8 Eliminate redundant rules in  9 


020\021 n 020\021 n r\021\027 r\030\031\032 r\021\027 r\030\031\032 r\021\027 r\030\031\032 002\003\004 002\003\004 C  002\005\006\007 006\f\002 Proj. DBs of <A,B  Proj. DBs of <A,B,C   its supports and con\223dence can be computed from the projected databases w.r.t in is is neither in Seq ID  Statistics PHT Fig 1  line 6 in Algorithm 2 for any with 022\005 A  C        Proj. DBs of <A,C                                             i.e i.e i.e r 021 002 003\004\005 003\004\005 D Algorithm Comparative Analysis 016\017\017 r 016\017\017 021 016\017\017 016\017\017 007\b\002 005 005 016\017\017 007\b\002 004 004 004 003 004 003 004 004 004 005 005 005 005 005 005 005 005 005 005 005 005 005 005 005 005 005 007 007 007 002 003 003 002 006 007 007 033 033 033 033 033 033 033 033 033 B  034 034 034 034 034 034 034 034 034 034 034 034 034 034 034 034 034 n 034 034 034 034  013 032 032 013  t\r\016 t\r\016 007\b\b  b\004 b\004 b\004 b\004 b\004 b\f\002 b\004 b b b\004 b\004 b\004 b 002\003\004\005\006 006 006 006 b b 006 006 006   and       yet the pre-condition  The worst case complexity of mining frequent patterns of length at most is O  The complexity of our approach is at most O       The 223rst term of the 223rst formula i.e 007\b\002 r 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 007\b\002 021 007\b\002 007\b\002 021 007\b\002 007\b\002 021 007\b\002 007\b\002 007\b\002 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 007\t\n\013 intoa bucket using 034 021 021 021 021 034 034 034 034 034 034 034 034 020 017 020 017 n 034 021 034 021 034  032     034   034    034  e.g 007\007 017\020\021\022 017\020\021\022 017\020\021\022 003\006\007\b 003\006\007\b 003\006\007\b Pre\223x Hash Tree 034 b  034 b  034 b  We store Eliminating Redundant Rules 004\002\003 004\002\003 t t t t 002 003 003 002 002 004 003 003 003 003 004 005 005 005 005 005 005 005 005 005 1051 032\034 032#\b 032\034 032#\b 032#\b 032#\b 032#\b 032\034 032\034 032#\b 032 032 032 032\034 032#\b 032 032 032 032 weuse the formula de\223ned in Proposition 1 and use the projected database Pre\223x Hash-Tree PHT Data Structure Embedding the Anti-Monotonicity Property Sequence     002 002  002 r 003 016 003 016 003 004 003    002 003  002 r 003 016 003 016 003 004 003   002\003  iii how to compute the supports and con\223dence of a rule iv how to test whether a rule is redundant  For  all patterns are stored in the PHT in reverse order Each node in this tree represents a pattern obtained by following the path from root to this node and is associated with its corresponding projected databases We store both stored in the PHTs To compute   the same triple  and 3 Composition of premises and consequents to form non-redundant rules Let us also assume that both the premises and consequents have a maximum length of 003 002 003 005 002 005 and  if we 223nd has a low support or con\223dence we can skip scanning  and continue to and and and nor and and and 002\003\004\005\006 002\003\004\005\006 with each  For example in Figure 1 suppose it is the PHT of post-condition candidates for some pre-condition candidate we compare to all occurrences of  is the size of  For these cases we need to re-scan the database to 223nd the instance support of has a sequence support instance support and con\223dence of 2 2 and 100 These are the same as those of rule  Although subsumes is not considered redundant due to by Theorem 2 Similarly is not considered redundant due to 220s with the same supports and con\223dence  a hash table Then for each bucket we want to remove the redundant rules   the ones with their super-pattern in the same bucket Consider a database containing a set of sequences with events coming from an alphabet  database scan operations Consider a set of patterns and works in two steps 1 Mine a pruned set of pre-conditions obeying minimum sequence support threshold and Theorem 2 from  2 For each pre-condition mine a set of post-conditions obeying the minimum con\223dence and minimum instance support thresholds At the end of the 223rst step for each pre-condition  LKL08 constructs a projected database  Another mining operation is then performed on this projected database The complexity is thus O  once a rule has a low support or low con\223dence we can skip scanning the whole subtree below and look for common sequences where the premise  For computing by Theorem 3 We map rules  and the last is due to the composition of premises and consequents to form rules Remember many rules can be constructed without requiring any additional database scan operation Some however require the re-scanning of the database to compute their instance support values see Section VI-C The algorithm in LKL08 tak es as input a s equence database Computing Supports and Con\223dence to facilitate the pairing procedure ii in what order to pair each We use a pre\223x hash-tree PHT data structure to organize the set of candidates  Each projected database is stored implicitly discussed in Section VI-B Each node has a hash table to quickly locate one of its child in a constant lookup operation given an event Figure 1 shows an example of a PHT  in a PHT in reverse order and scan in DFS order By following the DFS order to visit nodes in the PHT a post-condition is always scanned earlier than its backward extensions This feature enables us to embed the anti-monotonicity properties of con\223dence Theorem 1 and sequence support into the pairing algorithm  in PHTs For a rule occurs 223rst before  The ratio of the occurrences of which is usually in the PHTs However there are cases where is a signi\223cant rule while In line 8 of Algorithm 2 we want to remove redundant rules Some redundant rules have been pruned early in stage I But to eliminate all redundant rules this step is needed To illustrate the need for this stepafter applying Theorem 2 and 3 consider the following database    The rule from such a database is O  the worst case complexity of constructing from patterns in  database scan operations In our analysis we use database scan as the unit of operation We ignore the time needed to eliminate redundant rules since no database scan operation is involved In BOB we perform 1 two mining operations on the original sequence database to obtain the set of  2 construction of  is due to the mining of the premises the second is due to the mining of the consequents the third and fourth are due to the construction of  Notice that if 


006 006 016\017\017 007\b\002 007\b\002 r conf=50 In Figure 4 and 5 we plot the runtime needed and the number of rules mined from the D10C10N10R0.5 dataset when varying the minimum sequence support threshold and the minimum con\223dence threshold respectively Again BOB is up to 10 times faster than LKL08 and the gap between Datasets 022\005 1052 034   034 b  Environment and Pattern Miners 005 005 033 033   we store summary information e.g Rules right for D5C20N10R0.5 dataset when varying min  Results 005 005 005 all pruning properties do not work In the worst case all possible rules up to a particular length are signi\223cant and none of them is redundant The following points summarize reasons behind the superiority of our approach as compared to 1 We employ two new pruning strategies described by Theorem 1 and 3 These strategies are embedded into our new mining algorithm to remove search space not pruned before by the approach in 2 The projected database created in could be v ery lar ge especially if patterns 002\003\004 002\003\004 b b\004 b\004 b\004 b\004 b\004  032 016\017\017 r especially in cases where the number of repetitions of Fig 2 Runtime left  i.e and worst case is not large the complexity of our approach is smaller by an exponential factor than that of LKL08 In the worst case in a sequence many times For a premise  the projected database could be larger than the original  for each pattern In Figure 2 and 3 we plot the runtime needed and the number of rules mined from D5C20N10R0.5 when varying the minimum sequence support threshold and the minimum con\223dence threshold respectively For simplicity sake we set the minimum instance support threshold to be equal to the minimum sequence support threshold Each of the runtime graphs has two lines corresponding to the two algorithms\220 runtime at various thresholds We note that BOB is up to one order of magnitude i.e 10 times faster than LKL08 BOB pruning strategy is also effective in reducing required runtime when the minimum con\223dence threshold is raised from 50 to 90 On the other hand no signi\223cant performance change could be noticed in LKL08 case though However in frequent pattern mining worst case analysis is often not interesting This is so as in the recur within each sequence containing it is high Also projecting w.r.t a premise can produce a very localized dataset i.e a single sequence is split into its many suf\223xes resulting in hard-to-mine dense dataset with a large number of frequent patterns even at a high support threshold 3 During the mining of premises and consequents from  This information is used to immediately prune insigni\223cant rules not satisfying minimum sequence support and con\223dence thresholds see Section VI-C For this pruning we do not need to re-scan the database rather only the summary information needs to be analyzed The algorithm in can only perform database scan operations to prune candidate rules To compare effectiveness of various pruning strategies experiments on various datasets are needed We perform this empirical evaluation in Section VII VII E MPIRICAL E VA L UAT I O N Experiments have been performed to evaluate the scalability of our approach A case study on analyzing traces from an instant messaging application has also been conducted All experiments are performed on a Pentium Core 2 Duo 3.17GHz PC with 3GB main memory running Windows XP Professional Algorithms are written in Visual C#.Net We compare the approach presented in with our approach W e refer to the tw o approaches as LKL08 and BOB respectively To reduce the threat of external validity i.e the generalizability of our result we investigate a variety of datasets Four datasets two synthetic and two real are studied IBM synthetic data generator is used It is modi\223ed to produce sequences of events rather than sequences of sets of events The generator accepts a set of parameters We focus on four parameters D C N and R They correspond to the number of sequences in 1000s the average number of events per sequence the number of different events in 1000s and the repetition level range 0 to 1 respectively All other parameters of the synthetic data generator are set to their default values We experiment with two synthetic datasets D5C20N10R0.5 and D10C10N10R0.5 Dataset D5C20N10R0.5 contains sequences with an average length of 64.4 and a maximum length of 275 Dataset D10C10N10R0.5 contains sequences with an average length of 31.2 and a maximum length of 133 D5C20N10R0.5 has less sequences of longer lengths On the other hand D10C10N10R0.5 has more sequences of shorter lengths We also experiment on a click stream dataset   Gazelle dataset from KDDCup 2000 which has also been used to evaluate frequent sequential pattern miners i.e CloSpan and BIDE The dataset contains 29,369 sequences with an average length of 3 and a maximum length of 651 Compared to the two synthetic datasets this real data has a lower average length but contains sequences of longer lengths The gap in the lengths of long and short sequences is also wider To evaluate our algorithm performance on mining from program traces we generate traces from TotInfo program in the Siemens Test Suite The test suite comes with 893 correct test cases We run these test cases to obtain 893 traces Each trace is a sequence of events where every event is a method invocation We refer this dataset as the TotInfo dataset The TotInfo dataset contains sequences with an average length of 12.1 and a maximum length of 136 s-sup at min  


Rules right for D5C20N10R0.5 dataset when varying min  conf at min  s-sup 2.4 the performance of BOB and LKL08 is increased when the minimum con\223dence threshold is raised from 50 to 90 We do not experiment mining at lower con\223dence thresholds as low con\223dence rules have little use and are likely to only capture noises Rules right for D10C10N10R0.5 dataset when varying min  Rules right for D10C10N10R0.5 dataset when varying min  conf at min  s-sup 0.5 In Figure 6 and 7 we plot the runtime needed and the number of rules mined from the Gazelle dataset when varying the minimum sequence support threshold and the minimum con\223dence threshold respectively We notice that BOB improves the performance of LKL08 by two orders of magnitude i.e more than 100x faster At support level 0.020 LKL08 is not able to 223nish within 8 hours Thus BOB can successfully mine rules at a lower support threshold that is not minable by LKL08 in a reasonable amount of time Rules s-sup at min  Rules right for for Gazelle dataset when varying min  Rules right for TotInfo dataset when varying min  s-sup at min  Rules right for TotInfo dataset when varying min  s-sup 5.6 LKL08 is not able to run 006 006 006 006 006 006 006 006 006 006 006 006 006 006 conf=50 conf=50 sup=0.034 In Figure 8 and 9 we plot the runtime needed and the number of rules mined from the TotInfo dataset when varying the minimum sequence support threshold and the minimum con\223dence threshold respectively At all support levels shown in Figure 8 and 50 minimum con\223dence threshold LKL08 is not able to run due to an out of memory exception while BOB is able to 223nish in less than 2 minutes When we decrease the minimum con\223dence threshold we see an exponential increase in the runtime of LKL08 BOB runtime on the other hand remains the same LKL08 performs a pattern mining operation for every projected database of each mined pre-conditions this causes the high runtime values  conf=50 Fig 3 Runtime left  Fig 4 Runtime left  Fig 5 Runtime left  Fig 6 Runtime left  Fig 7 Runtime left  conf\(at min  Fig 8 Runtime left  Fig 9 Runtime left  conf at min  In past studies recurrent rules either in full or restricted form have been mined from various software datasets 27 Mined rules correspond to interesting temporal properties extracted from execution traces of programs In Lo et al mined rules from e x ecution traces generated by running test cases of JBoss Application Server In in a study within Microsoft Lo et al mined a restricted form of two-event recurrent rules with quanti\223cation from Windows device drivers and other Windows applications In this study we consider another trace data obtained from user interactions with a drawing utility of an instant messaging application Many systems like the one that we analyze do not 1053 Case Study s-sup at min  right for Gazelle dataset when varying min  


Handbook of Statistics Int Conf on Data Eng Int Conf on Tools and Algo for the Constr and Ana of Sys Knowledge and Info Sys Int Conf on Data Eng Int Conf on Data Eng Int Conf on Data Eng Int Conf on Database Sys for Adv App Int Conf on Soft Eng Model Checking Soft Product Line Conf Euro Conf on Soft Maintenance and Re-Eng Data Mining and Knowledge Disco Data Mining and Knowledge Disco SIAM Int Conf on Data Mining Int Conf on Soft Eng  getMyJID  Cambridge 2004  H K ugler  D Harel A Pnueli Y  Lu and Y  Bontemps 215T emporal logic for scenario-based speci\223cations,\216 in  2006  D Lo S.-C Khoo and C Liu 215Ef 223cient mining of iterati v e patterns for software speci\223cation discovery.\216 in  2007  204\204 215Ef 223cient mining of recurrent rules from a sequence database 216 in  2008  M Dwyer  G A vrunin and J Corbett 215P atterns in property speci\223cations for 223nite-state veri\223cation.\216 in  1999  E Clark e O Grumber g and D Peled  2004  R Capilla and J Duenas 215Light-weight product-lines for e v olution and maintenance of web sites,\216 in  2003  R Agra w al and R Srikant 215F ast algorithms for mining association rules,\216 in  1994  204\204 215Mining sequential patterns 216 in  1995  H Mannila H T oi v onen and A V erkamo 215Disco v ery of frequent episodes in event sequences,\216  1999  M Huth and M Ryan  2005  W  Jamroga 215 A temporal logic for stochastic multi-agent systems 216 in  2008  P  Monteiro D Ropers R Mateescu A Freitas and H de Jong 215Temporal logic patterns for querying dynamic models of cellular interaction networks,\216  2008  M Arenas P  Barcelo and L Libkin 215Combining temporal logics for querying xml documents,\216 in  2007  S Zhang 215 A temporal logic for supporting historical databases 216  2000  N P asquier  Y  Bastide R T aouil and L Lakhal 215Disco v ering frequent closed itemsets for association rules,\216 in  1999  M Zaki 215Mining non-redundant association rules 216  2004  J Pei J Han B Mortaza vi-Asl H Pinto Q Chen U Dayal and M.C Hsu 215Pre\223xspan Mining sequential patterns ef\223ciently by pre\223xprojected pattern growth.\216 in  2001  X Y an J Han and R Afhar  215CloSpan Mining closed sequential patterns in large datasets.\216 in  2003  J W ang and J Han 215BIDE Ef 223cient mining of frequent closed sequences.\216 in  2004  S Harms J Deogun and T  T adesse 215Disco v ering sequential association rules with constraints and time lags in multiple sequences.\216 in  2002  G Garriga 215Disco v ering unbounded episodes in sequential data 216 in  2003  B Ding D Lo J Han and S.-C Khoo 215Ef 223cient mining of closed repetitive gapped subsequences from a sequence database.\216 in  2009  M Hutchins H F oster  T  Goradia and T  Ostrand 215Experiments on the effectiveness of data\224owand control-\224ow-based test adequacy criteria,\216 in  1994  D Lo G Ramalingam V P  R anganath and K V asw ani 215Mining quanti\223ed temporal rules Formalism algorithms and evaluation.\216 in  2009  215Jeti V ersion 0.7.6 Oct 2006 http://jeti.sourcefor ge.net 1054 PictureChat showWindow PictureChat PictureHistory      vol 1 pp 259\205289 1997  M Spiliopoulou 215Managing interesting rules in sequence mining 216 in method This identi\223er is later af\223xed to the object drawn Finally the canvas records the operation in a object VIII C ONCLUSION This work proposes a new approach to mine recurrent rules in the form of 215Whenever a series of events occurs another series of events also occurs\216 The proposed approach is more scalable than the previous approach in Rather than performing a mining operation for each non-redundant pre-condition as proposed in our ne w approach emplo ys a number of new pruning strategies embedded in a new mining algorithm that requires only two mining and some additional database scanning operations Under a condition which holds in many cases the complexity of the proposed algorithm is smaller by an exponential factor than the complexity of the one proposed in W e ha v e e xperimented on v arious datasets synthetic and real Experiments have shown that the new algorithm improves the runtime of the previous algorithm by up to two orders of magnitude In the future we are looking into more applications of the mining algorithm and opportunities to further speed up the mining process R EFERENCES  M Gupta and S Ray  215Sequence pattern disco v ery with applications to understanding gene regulation and vaccine design.\216 in PC-  nu.fw.jeti.plugins.drawing.shapes.PictureChat PH -  nu.fw.jeti.plugins.drawing.shapes.PictureHistory Fig 10 Jeti Instant Messaging Application Drawing Scenario We use Jeti a popular instant messaging application which supports many features We record 30 interactions with the drawing tool of Jeti application and collect 30 traces The traces have an average length of 1,430 and a maximum length of 11,838 events Each event is a method call The purpose of this case study is to show the usefulness of the mined rules by discovering frequent and signi\223cant rules describing behaviors of the drawing sub-component of Jeti Using minimum sequence support and instance support of 25 traces/instances and a minimum con\223dence threshold of 90 BOB could complete in 57 seconds while LKL08 is only able to complete in 2844 seconds A total of 19 rules are collected after applying the following post-processing steps 1 Density Only report a mined rule iff the number of its unique events is more than 80 of its length 2 Ranking Order mined rules according to their lengths and support values A sample mined rule is shown in Figure 10 The rule captures the scenario when a user draws an object e.g a rectangle a line etc to a canvas First a resource i.e a Map object is created by a KDD Int Conf on Very Large Data Bases Paci\223c Rim Int Conf on Multi-Agents Int Symp on Intel Sys Euro Conf on Prin and Prac of Knowledge Disco in Databases come with suf\223cient test cases We ask a student who is not involved in this study to interact with the system  MIT Press 1999  S Deelstra M Sinnema and J Bosch 215Experiences in softw are product families Problems and issues during product derivation,\216 in Euro Conf on Prin and Prac of Knowledge Disco in Databases Bioinformatics ICDT Legend Consequent Map PC.createWritersMap void PC.showWindow void PC.unselect void PC.showWindow JID PC.getMyJID void PC.draw\(Shape  PH.addShapeDrawnByMe\(\203 Premise Logic in Computer Science ICDT Working Conf on Reverse Eng method are made by different callers When the application starts an empty window is 223rst shown or displayed After an object is drawn the drawn object i.e rectangle line etc would request the canvas i.e object Next multiple invocations of object to 215unselect\216 and redraw itself The system next retrieves the identi\223er of the user that draws the object by the invocation of 


TABLE II.     SUMMARY OF METRICS COLLECTED FOR DS2 Load Generator Processor Time Orders/minute Network Bytes Sent/sec Network Bytes Received/Sec Tomcat Processor Time Threads Virtual Bytes Private Bytes MySQL Processor Time Private Bytes Bytes written to disk/sec Context Switches/sec Page Reads/sec Page Writes/sec Committed Bytes In Use Disk Reads/sec Disk Writes/sec I/O Reads Bytes/sec I/O Writes Bytes/sec TABLE I.   AVERAGE PRECISION AND RECALL of Test Scenarios Duration per Test hours Size of Data per Test Avg Precision Avg Recall DS2 4 1 360 KB 100% 52 JPetStore 2 0.5 92 KB 75% 67 Enterprise System 13 8 4.5 MB 93% N/A  


37  Analysis of Test B: The goal of this experiment is to show that the rules generated by our approach are stable under normal system operation. Since Test B shares the same configuration and same load as Test A, ideally our approach should not flag any metric Our prototype did not report any problematic metric in Test B. The output is as expected, since Test B uses the same configuration as Test A and no performance bug was injected Analysis of Test C: In test C, we injected a databaserelated bug to simulate the effect of an implementation error This bug affects the product browsing logic in DS2. Every time a customer performs a search on the website, the same query will be repeated numerous times, causing extra workload for the backend database and Tomcat server Our approach flagged a database related metric \(# Disk Reads/sec Threads and # private bytes signaling that the metrics are violated during the whole test The result agrees with the nature of the injected fault: each browsing action generates additional queries to the database As a result, an increase in database transaction leads to an increase of # Disk Reads/sec. When the result of the query returns, the application server uses additional memory to extract the results. Furthermore, since each request would take longer to complete due to the extra queries, more threads are created in the Tomcat server to handle the otherwise normal workload. Since 3 out of 6 expected problematic metrics are detected, the precision and recall of our approach in Test C are 100% and 50% respectively Analysis of Test D: We injected a configuration bug into the load driver to simulate that a wrongly configured workload is delivered to the system. This type of fault can either be caused by a malfunctioning load generator or by a performance analyst when preparing for a performance regression test [14 In the case where a faulty load is used to test a new version of the system, the assessment derived by the performance analyst may not depict the actual performance of the system under test In Test D, we double the visitor arrival rate in the load driver. Furthermore, each visitor is set to perform additional browsing for each purchase. Figure 7 below shows the violated 


metrics reported by our prototype. The result is consistent with the nature of the fault. Additional threads and memory are required in the Tomcat server to handle the increased demand Furthermore, the additional browsing and purchases lead to an increase in the number of database reads and writes. The extra demand on the database leads to additional CPU utilization Because of the extra connections made to the database caused by the increased number of visitors, we would expect the # context switch metric in the database to be high throughout the test. To investigate the reason for the low severity of a databases context switch rate \(0.03 examined the rules flagged the # context switch metric. We found that the premises of most rules that flagged the context switch metric also contain other metrics that were flagged with high severity. Consequently, the premises of the rules that flagged # context switch are seldom satisfied resulting in the low detection rates of the # context switch metrics. Since 7 out of 13 expected metrics are detected, the precision and recall of our approach in this test are 100% and 54% respectively B. Studied System: JPetStore System description: JPetStore [1] is a larger and more complex e-commerce application than DS2. JPetStore is a reimplementation of Sun's original J2EE Pet Store and shares the same functionality as DS2. Since JPetStore does not ship with a load generator, we use a web testing tool to record and replay a scenario of a user logging in and browsing items on the site Data collection: In this case study, we have conducted two one-hour performance regression tests \(A and B performance signatures are extracted from Test A during which caches are enabled. Test B is injected with a configuration bug in MySQL. Unlike the DS2 case study where the configuration bug is injected in the load generator, the bug used in Test B simulates a performance analysts mistake to accidentally disable all caching features in the MySQL database. Because of the nature of the fault, we expect the following metrics of the database machine to be affected: CPU utilization, # threads context switches, # private bytes, and # I/O read and write bytes/sec Analysis of Test B: Our approach detected a decrease in memory footprint \(# private bytes sec in the database, and increase in # disk reads/sec and 


threads in the database. The I/O metrics include reading and writing data to network, file, and device. These observations align with the injected fault: Since the caching feature is turned off in the database, less memory is used during the execution of the test. In exchange, the database needs to read from the disk for every query submitted. The extra workload in the database  Figure 7. Performance Regression Report for DS2 Test 4 \(Increased Load TABLE III.     SUMMARY OF INJECTED FAULTS FOR DS2 Test Fault Injected Expected Problematic metric A No fault N/A B No fault No problem should be observed C Busy loop injected in the code responsible for displaying  item search results Increase in # I/O reads bytes /sec, and disk read/sec in database Increase in # threads, # private and virtual bytes, and CPU utilization in the Tomcat server D Heavier load applied to simulate error in load test configuration Increase in CPU utilization, # threads private and virtual bytes in the Tomcat server Increase in database CPU utilization disk reads, writes and I/O read bytes per second, and # context switches Increase in # orders/minute and network activities in the load generator 38 translates to a delay between when a query is received and the result is sent back, leading to a decrease in # IO write bytes/sec to the network Instead of an increase, an unexpected drop of the # threads was detected in the database. Upon verifying with the raw data for both tests, we found that the thread count in Test A \(with cache without cache 


and 21 respectively. Upon inspecting the data manually, we do not find that the decrease of one in thread count constitutes a performance problem and this is therefore a false positive Finally, throughout the test, there is no significant degradation in the average response time. Since 4 out of 6 expected problems are detected, our performance regression report has a precision of 75% and recall of 67 C. Studied System: A Large Enterprise System System description: Our third case study is conducted on a large distributed enterprise system. This system is designed to support thousands of concurrent requests. Thus, performance of this system is a top priority for the organization. For each build of the software, performance analysts must conduct a series of performance regression tests to uncover performance regressions and to file bug reports accordingly. Each test is run with the same workload, and usually spans from a few hours to a few days. After the test, a performance analyst will upload the metric data to an internal website to generate a time series plot for each metric. This internal site also serves the purpose of storing the test data for future reference. Performance analysts then manually evaluate each plot to uncover performance issues. To ensure correctness, a reviewer must sign off the performance analysts analysis before the test can be concluded. Unfortunately, we are bounded by a NonDisclosure Agreement and cannot give more details about the commercial system Data collection: In this case study, we selected thirteen 8hour performance regression tests from the organizations performance regression testing repository. These tests were conducted for a minor maintenance release of the software. The same workload was applied to all tests. In each test, over 2000 metrics were collected Out of the pool of 13 tests, 10 tests have received a pass status from the performance analysts and are used to derive performance signatures. We evaluated the performance of the 3 remaining tests \(A, B and C the performance analysts assessment \(summarized in table 4 In the following sections, we will discuss our analysis on each target test \(A, B and C Analysis of Test A: Using the history of 10 tests, our approach flagged all throughput and arrival rate metrics in the system. The rules produced in the report imply that throughputs 


and arrival rates should fall under the same range. For example component A and B should have similar request rate and throughput. However, our report indicates that half of the arrival rates and throughput metrics are high, while the other half is low. Our approach has successfully uncovered problems associated with the arrival rate and throughput in Test A that were not mentioned in the performance analysts report. We have verified our finding with a performance analyst. Our performance regression report has a precision of 100 Analysis of Test B: Our approach flagged two arrival rate metrics, two job queue metrics \(each represents one subprocess consulting with the time-series plots for each flagged metric as well as the historic range, we found that the # database scans/sec metric has three spikes during the test. These spikes are likely the cause of the rule violations. Upon discussing with a performance analyst, we find that the spikes are caused by the systems periodic maintenance and do not constitute a performance problem. Therefore, the # database scans/sec metric is a false positive. Our performance analysis report has a precision of 80 Analysis of Test C: Our approach did not flag any rule violation for this test. Upon inspection of the historical value for the metrics noted by the performance analyst, we notice that the increase of # database transactions/sec observed in Test C actually falls within the metric historical value range. Upon discussing with the Performance Engineering team, we conclude that the increase does not represent a performance problem. In this test, we show that our approach of using a historical dataset of prior tests is more resistant to fluctuations of metric values. Our approach achieves a precision of 100 The case studies show that our approach is able to detect problems in metrics when the faults are present in the systems Our approach detects problematic metrics with high precisions in all three case studies. In our case studies with the two open source systems, our approach is able to cover 50% and 67% of the expected problematic metrics VI. DISCUSSION AND FUTURE WORK A. Quantitive Techniques Although there are existing techniques [10, 11] to correlate anomalies with performance metrics by mining the raw performance data without discretization, these techniques 


usually assume the presence of Service Level Objectives \(SLO that can be used to determine precisely when an anomaly occurs. As a result, classifiers that predict the state of SLO can be induced from the raw performance data augmented with the SLO state information. Unfortunately, SLOs rarely exist during development. Furthermore, automated assignment of SLO states by analyzing metric deviations is also challenging as there could be phase shifts in the performance tests, e.g., the spikes do not align. These limitations prevent us from using classifier based techniques to detect performance regression TABLE IV.      SUMMARY OF ANALYSIS FOR THE ENTERPRISE SYSTEM Test Performance Analysts Report Our Findings A No performance problem found Our approach identified abnormal behaviors in system arrival rate and throughput metrics B Arrival rates from two load generators differ significantly Abnormally high database transaction rate High spikes in job queue Our approach flagged the same metrics as the performance analysts analysis with one false positive C Slight elevation of database transactions/sec. No metric flagged  39 B. Sampling period and Metric Discretization We choose the size of time interval for metric discretization based on how often the original data is sampled. For example an interval of 200 seconds is used to discretize data of the enterprise system, which was originally sampled approximately every 3 minutes. The extra 20 second gap is used because there was a mismatch in sampling frequencies for some metrics. We also experimented with different interval lengths. We found that less metrics are flagged as the length of the interval increases, while precision is not affected 


In our case studies, we found that the false negatives metrics that were expected to show performance regressions but were not detected by our approach no rule containing the problematic metrics was extracted by the Apriori algorithm. This was caused by our discretization technique sometimes putting all values of a metric that had large standard deviation into a single level. Candidate rules containing those metrics would exhibit low confidence and were thus pruned. In the future, we will experiment on other discretization techniques, such as Equal Width Interval Binning C. Performance Regression Testing Our approach is limited to detecting performance regressions. Functional failures that do not have noticeable effect on the performance of the system will not be detected Furthermore, problems that span across the historical dataset and the new test will not be detected by our approach. For example, no problem will be detected if both the historical dataset and the new test show the same memory leak. Our approach will only register when the memory leak worsens or improves D. Passed Tests The historical dataset from which the association rules are generated should contain tests that have the same workload configuration, preferably same hardware, and exhibit correct behavior. Using tests that contain performance problems will decrease the number of frequent item sets extracted, making our approach less effective in detecting problems in the new test. In our case study with the enterprise system, we applied the following measure to avoid adding problematic tests to our historical dataset We selected a list of tests from the repository that have received a pass status from the performance analyst We manually examined the performance metrics that are normally used by a performance analyst in each test from the list of past test to ensure no abnormal behavior was found E. System Evolution and Size of Training Data The system is often updated to support new environments or requirements. These updates may lead to changes in performance. A large variability in metric values will negatively affect the confidence of association rules generated 


in our approach. Therefore, it is necessary to update the set of tests included in the historical dataset. We are currently studying the effect of using a sliding window to select prior tests to include in the historical dataset. A sliding window allows us to automatically discard outdated tests that no longer reflect the current systems performance. However, the optimal size of the sliding window will likely be project-dependent since each project has different release frequency Alternatively, the historical dataset can also be derived from within the run. For example, the first hour of the current test can be used to derive performance signatures. Assuming that the system runs correctly during the first hour, the performance signature generated from this historical dataset will be useful to assess the stability of the system F. Hardware Differences In practice, performance regression tests of a system can be carried out on different hardware. Furthermore, third party components may change in between tests. In the future, we plan to improve our learning algorithm so that, given a new test, our tool will automatically select the tests from the repository with similar configurations G. Automated Diagnosis Our approach automatically flags metrics by using association rules that show high deviations in confidence between the new tests and the historical dataset. These deviations represent possible performance regressions or improvements and are valuable to performance analysts in assessing the system under test. Performance analysts can adjust the deviation threshold to restrict the number of rules used and, thus, limit the number of metrics flagged. Alongside with the flagged metrics, our tool also displays the list of rules that the metric violated. Performance analysts can inspect these rules to understand the relations among metrics. From our case study, we notice that some of the rules produced are highly similar. In the future, we will research for ways to merge similar rules to further condense information for performance analysts to analyze The association rules presented in our performance regression report represent metric correlations rather than causality. Performance analysts can make use of these correlations to manually derive the cause of a given problem VII. RELATED WORK 


Our goal in this work is to detect performance problems in a new test using historical data. Existing approaches monitor or analyze a system through one of two sources of historical data execution logs and performance metrics A. Analyzing Execution Logs Reynolds el al. [18] and Aguilera et al. [22] developed various algorithms for performance debugging on distributed systems. Their approach analyzes message trace of system components to infer the dominant causal paths and identify the components that account for a significant fraction of the systems latency. Unfortunately, the accuracy of the inferred paths decreases as the degree of parallelism increases, leading to low precision in identifying problematic components. Our approach is different from Reynoldss and Aguileras in that we pinpoint performance issues on the metric level rather than locating the system components that contribute significantly to system latency. Jiang et al. introduce a technique [14] to 40 identify functional problems in a load test from execution logs The authors extended this approach to analyze performance in scenarios as well as in the steps of each scenario [13]. Chen et al. proposed Pinpoint [21] to locate the subset of system components that are likely to be the cause of failures. Our work is different from Pinpoint in that Pinpoint focuses on identifying system fault rather than performance regression which can occur even when the system functions correctly In contrast to the above studies, which analyze execution logs, our approach analyzes performance metrics to identify performance problems B. Analyzing Performance Metrics Bondi [9] presented a technique to automatically identify warm-up and cool-down transients from measurements of a load test. While Bondis technique can be used to determine if a system ever reaches a stable state in the test, our approach can detect performance problems at the metric level Cohen et al. [11, 12] applied supervised machine learning techniques to induce models on performance metrics that are likely to correlate with observed faults. Bodik et al. improved Cohens work [8] by using logistic regression. Our approach is different from the above work as we do not require knowledge of violations of Service Level Objectives Jiang et al. proposed an approach [16] for fault detection 


using correlations of two system metrics. A fault is suspected when the portion of all derived models that report outliers exceeds a predefined threshold. Our approach is based on frequent item sets that can output correlations of more than two metrics. Performance analysts can leverage these metric correlations to better understand the cause of a fault. Jiang et al 15] proposed an approach to identify clusters of correlated metrics with Normalized Mutual Information as similarity measure. The authors were able to detect 77% of the injected faults and the faulty subsystems, without any false positives While the approach in [15] can output only the faulty subsystems, our approach can detect and report details about performance problems, including metrics that deviate from the expected behaviors VIII. CONCLUSIONS It is difficult for performance analysts to manually analyze performance regression testing results due to time pressure large volumes of data, and undocumented baselines Furthermore, subjectivity of individual analysts may lead to incorrect performance regressions being filed. In this paper, we explored the use of performance regression testing repositories to support performance regression analysis. Our approach automatically compares new performance regression tests to a set of association rules extracted from past tests. Potential performance regressions of system metrics are presented in a performance regression report ordered by severity. Our case studies shows that our approach is easy to adopt and can scale well to large enterprise system high precision ACKNOWLEDGMENT We are grateful to Research In Motion \(RIM access to the enterprise application used in our case study. The findings and opinions expressed in this paper are those of the authors and do not necessarily represent or reflect those of RIM and/or its subsidiaries and affiliates. Moreover, our results do not in any way reflect the quality of RIMs products REFERENCES 1] iBATIS JPetStore, http://sourceforge.net/projects/ibatisjpetstore 2] MMB3, http://technet.microsoft.com/enus/library/cc164328%28EXCHG.65%29.aspx 3] The Dell DVD Store, http://linux.dell.com/dvdstore 4] The R Project for Statistical Computing. http://www.r-project.org 5] R. Agrawal, R.Srikant, Fast Algorithms for Mining Association Rules 


in Large Databases, Proc. of 20th Intl Conf. Very Large Data Bases 1994 6] A. Avritzer and B. Larson, Load testing software using deterministic state testing, Proc. of Intl Symp. on Software Testing and Analysis 1993 7] A. Avritzer, E. J. Weyuker, The automatic generation of load test suites and the assessment of the resulting software, IEEE Trans. Softw. Eng 21\(9 8] P. Bodik, M. Goldszmidt, A. Fox, HiLighter: Automatically Building Robust Signatures of Performance Behavior for Small- and Large-Scale Systems, Proc. of the  3rd SysML, Dec 2007 9] A. B. Bondi, Automating the Analysis of Load Test Results to Assess the Scalability and Stability of a Component, Proc. of 33rd Intl CMG Conf., San Diego, CA, USA, Dec. 2-7, 2007 10] L.  Bulej, T.  Kalibera, P. Tuma, Regression Benchmarking with Simple Middleware Benchmarks,  Proc. of the 2004 IPCCC, 2004 11] I. Cohen, M. Goldszmidt, T. Kelly, J. Symons, J. S. Chase, Correlating instrumentation data to system states: A building block for automated diagnosis and control, Proc. of 6th OSDI, Dec. 2004 12] I. Cohen, S. Zhang, M. Goldszmidt, J. Symons, T. Kelly, A. Fox Capturing, indexing, clustering, and retrieving system history Proc. of the 20th ACM Symp. on Operating Systems principles, 2005 13] Z. M. Jiang, A. E. Hassan, G. Hamann, P. Flora, Automated Performance Analysis of Load Tests, Proc. of the 25th ICSM, Sept 09 14] Z. M. Jiang, A. E. Hassan, P. Flora, G. Hamann, Automatic Identification of Load Testing Problems, Proc. of the 24th Intl Conf on Softw. Maintenance, Sept 2008 15] M. Jiang, M. A. Munawar, T.  Reidemeister, P A.S. Ward, Automatic Fault Detection and Diagnosis in Complex Software Systems by Information-Theoretic Monitoring, Proc. DSN, Jun 2009 16] M. Jiang, M. A. Munawar, T. Reidemeister, P. A. S. Ward System Monitoring with Metric-Correlation Models: Problems and Solutions Proc. of the 6th Intl Conf. on Autonomic Computing, 2009 17] T. Kalibera, L. Bulej, P. Tuma, Automated Detection of Performance Regressions: The Mono Experience, 13th MASCOTS, 2005 18]  P. Reynolds, J. L. Wiener, J.C. Mogul, M. K. Aguilera, A. Vahdat WAP5: Black-box Performance Debugging for Wide-Area Systems Proc. of the 15th Intl World Wide Web Conf.s, 2006 19] E. J. Weyuker, F. I. Vokolos, Experience with performance testing of software systems: Issues, an approach, andcase study, IEEE Trans Softw. Eng., 26\(12 20] I. H. Witten, E. Frank, Data Mining: Practical Machine Learning Tools 


and Techniques, Morgan Kaufmann, June 2005 21] M. Y. Chen , E. Kiciman , E. Fratkin , A. Fox , E. Brewer, Pinpoint Problem Determination in Large, Dynamic Internet Services, Proc. of the 2002 Intl Conf. on Dependable Systems and Networks, June  2002 22] M. K. Aguilera , J. C. Mogul , J. L. Wiener , P. Reynolds , A Muthitacharoen, Performance debugging for distributed systems of black boxes, Proc. of the 19th ACM Symp. on Operating systems principles, Oct 2003 41 


DMITAR, Datasets Used Stock Data Stock Data Daily stock information provided by Yahoo finance Wth Dt W ea th er D a t a Provided by the US Department of Commerce and National Climactic Data Center for 700 locations across US Synthetic Data Provided by a CRU weather generator that uses a Markov chain model to generate simulated weather data for 11 UK sites Associative IDS for NextGen Frameworks Dr S Dua LA Tech 26 


DMITAR Results 1/5 Varying Support DMITAR Results 1/5 Stock Database Support FITI ITPMine PROWL DMITAR 14 6424.7s 132.39s 3.03s 5.556s 16 2348.9s 67.14s 2.14s 4.015s 18 861.92s 34.62s 1.55s 2.89s 20 334.51s 18.89s 1.12s 2.07s 22 143 84s 10 87s 0 87s 1 45s 22 143  84s 10  87s 0  87s 1  45s 24 63.62s 7.15s 0.671s 1.04s Weather Database Support FITI ITPMine PROWL DMITAR 14 36362.6s 893.1094s 5.843s 19.8281s 36362.6s 893.1094s 5.843s 19.8281s 16 11913.04s 378.2188s 3.8906s 13.4375s 18 4116s 170.3438s 2.75s 9.1406s 20 1507s 86.5781s 2.14s 6.203s 22 859.2813s 63.3438s 1.7969s 5.7656s 24 378.5313s 36.1875s 1.4375s 3.5625s Synthetic Dataset Support FITI ITPMine PROWL DMITAR 14 1651.6s 199.843s 3.1406s 17.015s 16 574 32 119 32 2 0938 10 875 16 574  32 s 119  32 s 2  0938 s 10  875 s 18 416.109s 95.31s 1.6094s 7.39s 20 370.25s 83.31s 1.453s 5.8438s 22 265.78s 66.3438s 1.3594s 4.75s 24 133.96s 43.0781s 0.9219s 3.5781s 


DMITAR Rlt  DMITAR  R esu lt s 2  5 Rules Formed Associative IDS for NextGen Frameworks Dr S Dua LA Tech 28 


DMITAR Rl  Varying Maxspan DMITAR  R esu l ts 3  5 Varying Maxspan Associative IDS for NextGen Frameworks Dr S Dua LA Tech 29 


DMITAR Res lts 4/5 Vig Di i DMITAR  Res u lts  4/5 V ary i n g Di mens i ons Associative IDS for NextGen Frameworks Dr S Dua LA Tech 30 


DMITAR Rl  Varying Number of Transactions DMITAR  R esu l ts 5  5 Varying Number of Transactions Associative IDS for NextGen Frameworks Dr S Dua LA Tech 31 


N/C t Rh N ew C urren t R esearc h Problem Domain Problem Statement and Challenges Associative Mining based IDS Associative Mining based IDS Introduction to data mining ii lid ii Assoc i at i on ru l e i n d ata m i n i ng DMITAR Algorithm  ARD h New Researc h Associative IDS for NextGen Frameworks Dr S Dua LA Tech 32 


Further Research Further Research Objectives of Our Intrusion Detection System Development Objectives of Our Intrusion Detection System Development 1 Refine and scale the DMITAR algorithm to suit our application 2 Develop methods for dynamically altering the sensor parameters Our Focus is Securing the NextGen Frameworks with New Technology Technology Associative IDS for NextGen Frameworks Dr S Dua LA Tech 33 


Simulated Sensing Environment Simulated Sensing Environment Screenshots of Data C ollected from S ynthetic Sensors Screenshots of Data C ollected from S ynthetic Sensors Simulated in Our Laboratory Three Steps Slides Collect data Collect data from all sources  all attributes  Select Select the source and their hierarchical attributes attributes to be monitored and Select Select the source and their hierarchical attributes attributes to be monitored  and Sample Sample them at different rates different rates and process them Associative IDS for NextGen Frameworks Dr S Dua LA Tech 34 


Data Collection Simultaneous collection of data screen from ENTITIES aircrafts Associative IDS for NextGen Frameworks Dr S Dua LA Tech 35 Source PRTG Network Monitor software screen shot Demo info www.paessler.com 


Parameter Selection Selection of an ENTITY/aircraft and monitoring its parameters and sensor readings Associative IDS for NextGen Frameworks Dr S Dua LA Tech 36 Source PRTG Network Monitor software screen shot Demo info www.paessler.com 


Sensor Sampling Selecting one sensor/probe and reading it at different resolutions or sampling rates Associative IDS for NextGen Frameworks Dr S Dua LA Tech 37 Source PRTG Network Monitor software screen shot Demo info www.paessler.com 


Si l ti Nt k Si mu l a ti on on N e t wor k Most scenarios can be simulated on a computer or computer network network  The aircrafts and sensors are simulated on a computer network bllb b y ana l ogica l su b stitutions Sensors provide information at different rates Sensors provide information at different rates Need Based Sensor Prioritization NSP and Dynamic Sensing Rate Sampling Associative IDS for NextGen Frameworks Dr S Dua LA Tech 38 


Vulnerability Search Scan 39 Sample UQA script with Nmap performed in DMRL Associative IDS for NextGen Frameworks Dr S Dua LA Tech 39 Source Nmap screenshot with a pearl script  Find Namp on Nmap.org 


Modality Aspect Modality Aspect A Multimodal distribution is a continuous probability distribution with two or more modes of underlying data Mltil d i M u lti p l e mo d es i n our model Associative IDS for NextGen Frameworks Dr S Dua LA Tech 40 Source http://en.wikipedia.org/wiki/File:Bimodal bivariate small.png 


Multi Modality Modality Fusion 41 SENSITIVE  UNCLASSIFIED For Official Use Only Associative IDS for NextGen Frameworks Dr S Dua LA Tech 41 


Emphasis Emphasis Our approach emphasizes on pre empting the attack Our intent is NOT to perform an autopsy to discover attacks Instead we aim to detect and prevent in attacks in real time Associative IDS for NextGen Frameworks Dr S Dua LA Tech 42 


Techniques for Discriminative Rules Techniques for Discriminative Rules Resolution Analysis Features Analyzed at Different Depths Anti Monotonic Principle Modality Aspect Treading into Unexplored Feature spaces Associative IDS for NextGen Frameworks Dr S Dua LA Tech 43 


Representative Outcomes Representative Outcomes Illustration of the Final Analysis Our method shifts between modalities and sampling rates for optimization The blue parallelograms are actual intrusions 44 The blue parallelograms are actual intrusions The Red Green Blue Plots are response of system Associative IDS for NextGen Frameworks Dr S Dua LA Tech 44 


Advantages of Our M ethod Advantages of Our M ethod Exploit the memory v ertical data format utilizes slidin g windows to g form a much larger database to analyze  Flexibility in Choosing what to choose  Choosing what to choose to build the rules Computational and memory efficiency We have a team working only on this aspect 45 Associative IDS for NextGen Frameworks Dr S Dua LA Tech 45 


Preliminary Results Intra transaction Relations Data rate simulator NH-134 Mb HOP PATH update \(Y/N Inference 11.5 Y Y 2 0.120 N N      Y   n 0.345 N NH134 Y/N   Inf 1 0.150 N N 2 0 120 Y N Inter transaction Relations 2 0  120 Y N       5 5.55 0.456 Y Relations  n 0.345 N N Nmap on DMRL nmap.org 


Anticipated Outcome Anticipated Outcome Develop algorithm capable of learning from a given heterogeneous diverse Develop algorithm capable of learning from a given heterogeneous diverse data ff Dynamic algorithmic f ramework designed to shi f t modalities and sampling rates based on complex logic Flexibility of integration into the Snort intrusion detection system 47 Associative IDS for NextGen Frameworks Dr S Dua LA Tech 47 


References References Aircraft Cockpit Image courtesy USAF http://www.faa.gov htt p   www.faa g ov  air traffic  technolo gy  p g  _ gy  Acharya R Dua S Du X Sree V Chua C K Automated Diagnosis of Glaucoma Using Texture and Higher Order Spectra Features To appear in IEEE Transactions on Information Technology in Biomedicine  Du X Dua S 2011 Cancer Prognosis Using Support Vector Regression in Imaging  Modality World Journal of Clinical Oncology 2  1   44 49 Du X Dua S 2010 Salient Frame Extraction Using Support Vector Regression and Motion Features pp 5 Proc of the National Aerospace and Electronics Conference July 14 16 2010 D M P D S 2010 Di i i ti Ft d Cl ifi ti Mthd f D essaue r  M  P  D ua S  2010  Di scr i m i na ti ve F ea t ures an d Cl ass ifi ca ti on M e th o d s f or Accurate Classification 1st ed vol 7704 pp 14 Bellingham WA Proceedings of SPIE Dessauer M P Dua S 2010 Low Resolution Vehicle Tracking using Dense and Reduced Local Gradient Features Maps 1st ed vol 7694 pp 8 Bellingham WA Proceedings of SPIE SPIE 


Acknowledgements Acknowledgements Fundin g A g encies  US 4 1 Million direct fundin g g g 4 g LA BoR NIH NSF AFRL AFOSR and NASA Research Team Samuel Kasimalla Brandy McKnight Dr Pradeep Chowriappa Connor Johnson Vasanth Nair Mihir Chowriappa  Connor Johnson  Vasanth Nair  Mihir Karnik Mohit Jain and Swadheen Songmen Associative IDS for NextGen Frameworks Dr S Dua LA Tech 49 All the respective Logos belong to their owners 


Rf d Rdi R e f erence d R ea di ngs Copyright of cover pages held by respective publishers 


Thank You Questions Thank You  Questions Dr Sumeet Dua E mail sdua@latech.edu Web http://dmrl.latech.edu Associative IDS for NextGen Frameworks Frameworks Dr S Dua LA Tech 51 Image Source roadtrafficsigns.com 


