Ef\002cient Apriori Based Algorithms for Privacy Preserving Frequent Itemset Mining Adri 264 an Csisz 264 arik Szilvia Lesty 264 an Andr 264 as Luk 264 acs csadrian@cs.elte.hu szilvia.lestyan@gmail.com lukacs@cs.elte.hu Inter-University Centre for Telecommunications and Informatics E 250 otv 250 os Lor 264 and University Institute of Mathematics Abstract 227Frequent Itemset Mining as one of the principal routine of data analysis and a basic tool of large scale information aggregation also bears a serous interest in Privacy Preserving Data Mining In this paper Apriori based distributed privacy preserving Frequent Itemset Mining algorithms are considered Our secure algorithms are designed to 002t in the Secure Multiparty Computation model of privacy preserving computation I I NTRODUCTION 
An important and emerging tool of collective knowledge is the distributed data mining i.e building uni\002ed models based on data sets possessed by different owners This type of knowledge sharing become productive if one can also handle the privacy demands of the data owners A typical requirement can be that during the model building the inhouse data sets should be kept secret for other participant than the owner Solutions of this type of problems lead to intracognitive communications assuming a similar computational power and data structure at the parties Assessing the other dimension of cognitive infocommunications one see that privacy preserving distributed data mining is a special example of sensor-bridging and representation-bridging communication  About t he emer ging concept and recent application of cognitive infocommunications see also and 3 Several models and algorithms have been already transformed into the privacy preserving data mining settings but much less attention was dedicated to their ef\002ciency optimising the computational and communicational volume 
of the privacy preserving processes Our contribution emphases this point of view in the case of privacy preserving Frequent Itemset Mining Frequent Itemset Mining as one of the principal routine of data analysis and a basic tool of large scale information aggregation In this paper Apriori based distributed privacy preserving Frequent Itemset Mining algorithms are considered Our secure algorithms are designed to 002t in the Secure Multiparty Computation model of privacy preserving computation The paper is organized as follows Section 2 introduces the concept of Frequent Itemset Mining and the well-known Apriori algorithm Section 3 discuss the Secure Multiparty Computations the model used here for privacy preserving calculations This section also cover the necessary SMC primitives Section 4 contains our main contribution the improvement of the basic privacy preserving Apriori algorithm In the 002nal section we present our measurement based analysis of the suggested algorithms II F REQUENT I TEMSET M 
INING First a few concepts of Frequent Itemset Mining are reviewed For a more detailed introduction we refer to and Let I  f i 1  i 2   i d g be the set of all items  Let T  f t 1  t 2   t N g be a transaction or market database  where a uniquely labeled transaction t i contains a subset of items chosen from I  A collection of zero or more items is termed an itemset  An itemset containing k items is called a k itemset A transaction t j is said to contain an itemset 
X if X is a subset of t j  The width of a transaction is de\002ned as the number of items contained A central property of an itemset X is its support count 033  X   which counts the number of transactions that contain itemset X  i.e 033  X   jf t i j X 022 t i  t i 2 T gj  The relative support of X is supp  X   033  X   j T j  Given a transaction database 
T and a minimum support min supp  an itemset X has supp  X  025 min supp is called frequent itemsets  A Apriori algorithm In general a data set that contains k items can potentially generate up to 2 k 1 frequent itemsets excluding the null set To reduce this we can reduce the number of candidate itemsets i.e eliminate some of the candidate itemsets without counting their support value Apriori is the 002rst association rule mining algorithm that pioneered the use of support-based pruning to systematically control the exponential growth of candidate itemsets The use of support for pruning candidate itemsets is guided by the Apriori Principle 
 This follows from the antimonotonicity of the support as set function namely if an itemset is frequent then all of its subsets must also be frequent The pseudo-code for the frequent itemset generation part of the Apriori algorithm is shown in Algorithm 1 At step 5 of Algorithm 1 candidate generation is being executed There are several functions existing to satisfy this step Here we show one possible solution for this problem the F k 000 1 002 F k 000 1 Method  The candidate generation procedure in the apriori-gen function merges a pair of frequent  k 1 itemsets only if their 002rst k 000 2 items are identical Let A  f a 1  a 2   a k 000 1 g and B 
 f b 1  b 2   b k 000 1 g be a pair of frequent  k 1 A and B are merged if they satisfy the following conditions a i  b i  f or i  1  2   k 000 2 and a k 000 1 6  b k 000 1  431 CogInfoCom 2014 € 5th IEEE International Conference on Cognitive Infocom\munications € November 5-7, 2014, Vietri sul Mare, Italy 978-1-4799-7280-7/14/$31.00 ©2014 IEEE 


Algorithm 1 Frequent itemset generation of the Apriori algorithm Let C k denote the set of candidate k itemsets and F k denote the set of frequent k itemsets 1 k  1  2 F k  f i j i 2 I  033  f i g  025 N 002 minsup g  f Find all frequent 1-itemsets g 3 repeat 4 k  k  1 5 C k  apriori-gen  F k 000 1   f Generate candidate itemsets g 6 for each transaction t 2 T do 7 C t  subset  C k  t   f Identify all candidates that belong to t g 8 for each candidate itemset c 2 C t do 9 033  c   033  c   1  f Increment support count g 10 F k  f c j c 2 C k  033  c  025 N 002 minsup g  f Extract the frequent k-itemsets g 11 until F k   12 Result  S F k  II I P RIVACY P RESERVING C ALCULATIONS Our view of privacy preserving data mining and computational model derived from a multi-party approach For a survey of privacy preserving data mining see e.g and 4 and on general multi-party computation see and 9 The basic idea of Secure Multiparty Computation SMC is that a computation is secure if at the end of the computation no party knows anything except its own input and the results  privacy  One way to view this is to imagine a trusted third party everyone gives their input to the trusted party who performs the computation and sends the results to the participants But this is not likely to happen in real-world applications thus we use and create algorithms where the same result can be achieved without using a trusted party Besides privacy security requires and not de\002ned by the followings as well correctness each party is guaranteed that the output that it receives is correct independence of inputs corrupted parties must choose their inputs independently of the honest parties inputs guaranteed output delivery corrupted parties should not be able to prevent honest parties from receiving their output fairness corrupted parties should receive their outputs if and only if the honest parties also receive their outputs Another parameter that must be de\002ned relates to the actions that corrupted parties are allowed to take There are two main types of adversaries semi honest adversaries even corrupted parties correctly follow the protocol speci\002cation however could attempt to derive as much additional information as possible from internal states and/or the result malicious adversaries the corrupted parties can arbitrarily deviate from the protocol speci\002cation In the followings we shall work in the semi-honest model A Privacy Preserving Apriori Algorithm The privacy preserving version for p 025 3 parties has been reviewed in here we w ould lik e to gi v e an outline of previous works Before we go on to the main algorithm we need to introduce the Secure Union and the Secure Sum SMC protocols Secure Union Let p 025 3 be the number of participants they all hold onto some sets denote their respective sets by H i for i  1 p  We would like to determine the union of all sets without revealing any of them First every participant has to choose a commutative encryption function An encryption algorithm is commutative if given encryption keys K 1   K n 2 K  for any m in domain M  and for any permutation i j  the following two equations hold 1 E K i 1  E K i n  M     E K j 1  E K j n  M    8 M 1  M 2 2 M such that M 1 6  M 2 and for given k 017  1 s k  2  E K i 1  E K i n  M     E K j 1  E K j n  M     017 Now all participants encrypt their items one-by-one and send it to an other party who encrypts the received encrypted items with his own encryption function and sends it again They iterate it until each party encrypts the items of the remaining parties All parties send their r-times encrypted functions to one party from now on referred to as Main Party who removes the duplicates Now this global set is passed around each site decrypting its items The union is obtained Secure Sum Now each participant holds onto a number of their own and they would like to privately compute the sum of their inputs Main Party generates a random number R  adds to its local value and sends it to the next party All participants add their local value to the received number At last Main Party receives the sum subtracts R from the result and broadcasts the result Now we are ready to put together the privacy preserving apriori algorithm Let denote the i th party by P i  the number of parties is p  P M is the Main Party Each participant has a private transaction database DB i  We are given a support threshold s  The goal is to discover all globally frequent itemsets i.e the ones satisfying the support threshold in the united database Furthermore no party should be able to learn contents of a transaction basket or any speci\002c value of support at any other party unless that information is revealed by the knowledge of one's own data and the 002nal result For example if a rule is supported globally but not at one participant's own database we can deduce that at least one other party supports the itemset 1 Identify all the candidate itemsets Secure Union 2 Repeat until no more frequent itemsets are produced 3 Verify if each item\(set satis\002es the support threshold Secure Sum if yes store as frequent 4 PM generates the new candidate itemsets same way as in the non-multi-party case 5 PM broadcasts all frequent itemsets IV I MPROVING THE PRIVACY PRESERVING A PRIORI Our main contributions are improvements on the original privacy preserving Apriori algorithm to reduce the computational and communication costs involved in the distributed privacy-preserving setting In this section we present three new algorithms Though the classic Apriori algorithm one and multi-party case as well has already reduced the number of itemsets we need to check for support the number of candidates could be still exponential In practice 227 as our experiments and previous results on real datasets show 227 the large number of 2-itemset candidates causes a major bottleneck in real-life A. Csiszárik et al. € Efficient Apriori Based Algorithms for Privacy Pre\serving Frequent Itemset Mining 432 


applications T oivonen's algorithm with the P artition trick is one way to further reduce the number of candidates Our algorithms build on the Partition trick which greatly speeds up the basic one-party case Apriori algorithm A The Partition trick The main idea behind the Partition trick is to reduce the number of candidates by partitioning the dataset The method is based on the fact that if one itemset is frequent in a database then after partitioning the database that itemset must be frequent in at least one of the partitions as well In other words no other itemset besides the locally frequent ones can be globally frequent hence it is necessary to check the global support only for these itemsets The one-party Apriori with the Partition trick then proceeds as follows 1 Partition the database 2 Find locally frequent itemsets in each partition 3 Check the global support for only the locally frequent itemsets Our 002rst approach carries out the Partition trick in the distributed privacy preserving setting with the SMC framework and drastically reduces the communication costs compared to the original algorithm To further improve the ef\002ciency our second approach introduces a positive 002ltration method in addition to our 002rst algorithm The third method is a variation of the above that allows us to stop the algorithm at a given level of the iterations Each of the three algorithm gives the same frequent itemset results but one can choose which to use according to the circumstances and the set question B The Improved Privacy Preserving Partitioned Apriori Naturally determining frequent itemsets between p participants has value only if the participants share the same universe of items Thus in the multi-party case the different databases at different parties can be viewed as one giant partitioned database If we treat them this way we gain the following algorithm 1 The participants agree on a minimum support threshold 2 Each and every P i participant determines his own locally frequent itemsets denoted by Loc  P i   3 Apply Secure Union only on all Loc  P i   this gives us the one and only candidate set at PM 4 PM starts the Secure Sum protocol to verify the support of each candidate 5 PM broadcast the results i.e the candidate itemsets with higher support than the threshold Notice that this modi\002ed algorithm requires only one Secure Union and one Secure Sum protocols while in the previous Apriori algorithm as many as k  the size of the largest found frequent itemset was needed C Positive Filtration Remember the fact that if one itemset is frequent in a database that itemset must be frequent in at least one of the classes as well This implies that if an itemset is frequent in all classes it has to be frequent in the whole database too Based on this observation we can slightly modify our partitioning algorithm to reduce even further the number of candidate itemsets Up until now during the Secure union phase when all locally frequent itemsets have already arrived to PM he discarded the duplicates Lets change it now let PM count the number of occurrences of each candidate itemset and after this he can get rid of the copies Now he selects the ones which are frequent at all participant and starts the Secure sum protocol only for the rest He can send the selected ones now or later at the broadcasting stage It does not make any difference since it did not appear among the true candidates list during the Secure sum thus anyone can deduce from the 002nal result which itemsets were locally frequent everywhere Naturally this approach shall be useful only if we do not mind that the everywhere frequent itemsets will be known to everyone or if the cost of the communication could be reduced so drastically that we are ready to pay its price We will consider it further in the next section D A variation of the Privacy Preserving Partitioned Apriori Our previous algorithm has found all the frequent itemsets at once but what can we do if we do not need all of them only some with a speci\002c size or some up until a speci\002c size The original algorithm proceeds level by level k itemsets after  k 1 so we can stop anytime we want to But we shall not forget that this algorithm is way too slow especially compared to our new one Here we introduce one more algorithm which is halfway in-between these last two and has the advantages of either kind it is faster than the 002rst one and we can also gain any frequent k itemset without determining all of them Our variation is the following Let assume that we require the frequent itemsets until size k  so iterate for i  1 k  1 Each participant determines the frequent k itemsets of his own database 2 Apply Secure union on the local frequent k itemsets 3 PM starts a Secure sum regarding the achieved union 4 PM determines the global frequent k itemsets and broadcasts them 5 The achieved itemsets are now the basis of the next candidate generation for the next round the participants own candidates are generated only from these itemsets So their locally frequent k  1 itemsets are determined from the previous iteration's result V A NALYSIS A Communication Complexity In this section we consider the cost of the communication and make a comparison between our three algorithms regarding their communication First notice that in our partitioning algorithm the second phase i.e counting the secure sum depends only on the 002rst phase After determining 433 CogInfoCom 2014 € 5th IEEE International Conference on Cognitive Infocom\munications € November 5-7, 2014, Vietri sul Mare, Italy 


the global candidate item-sets by a secure union we make only a single secure sum where no additional item-sets appear Thus we need to view the communicated item-sets during the secure union Counting only the number of item-sets does not suf\002ce since it is possible to have plenty large sets as well which enlarge the amount of communication needed by several times The following number is a true representation of the required amount m 003  X P i 2 1 r X S ij 2 Loc  P i  j S ij j Where P i is a party Loc  P i  is the local frequent item-sets set at party P i  and S j is one local frequent item-set at that party so m 003 gives us the total length of all the local frequent item-sets Although in our case we need somewhat more in the secure union we send this number r times because all local item-sets need to be encrypted by every party so m 003 gives us only the sum when everyone sends exactly one message to its neighbour synchronously Thus when every party's own message has done a full round we have C  r 001 m 003  We shall not forget that the cost of the representation is not included these are raw numbers we chose them to create a pure representation for the communication The size of m 003 depends on the followings 1 the data sets of the baskets 2 the minimum support we choose 3 the number of participants and also 4 the method we use for the distribution of the data set Naturally number 4 interesting only in case we have one giant data set what we distribute among the participants B Comparison Figure 1-4 represent the relationship for 4 different support counts between the original baseline and our new more ef\002cient algorithms We can see the expected drop in the total input length in items of secure sum or secure union protocols which is mainly due to the fact that the baseline algorithm takes into consideration a great number of the smaller-size itemsets which for example for the 2 size itemsets can be up to 022 n 2 023 031 n 2 In other words the baseline 224A\224 algorithm works with a great number of false candidates includes them in the communication and later eliminates them and this leaves a huge impact on the cost of the communication On the other hand it is clearly visible that our new algorithms use less unwanted pseudo-frequent itemsets even from the very beginning All those nowhere frequent itemsets using the partition trick which have frequent subset\(s are not considered during the execution in the new algorithms in contrast with the baseline Apriori where this is untrue i.e all itemsets generated from frequent ones are considered thus the high communication cost concludes We also considered the method used for the distribution of the data set if that is needed According to the given circumstances different distributions can be applied Figure 58 show us only our new algorithms twice once where we applied consecutive cuts and the other one is with random distribution We can see on the 002gures that randomly distributing the main data set gives us better result at the selecting stage than applying consecutive cuts thus we are able to further lower the size of the communicated dictionary in the secure sum As expected all the three above method reduced the running time of the original privacy preserving Apriori algorithm The positive 002ltration is the fastest among all three Fig 1 Comparsion of total input lengths of secure protokols The used dataset is retail 10k  minimal support is 0.10 Fig 2 Comparsion of total input lengths of secure protokols The used dataset is retail 10k  minimal support is 0.05 Fig 3 Comparsion of total input lengths of secure protokols The used dataset is retail 10k  minimal support is 0.02 A. Csiszárik et al. € Efficient Apriori Based Algorithms for Privacy Pre\serving Frequent Itemset Mining 434 


Fig 4 Comparsion of total input lengths of secure protokols The used dataset is retail 10k  minimal support is 0.01 Fig 5 Comparsion of total input lengths of secure protokols The used dataset is retail  minimal support is 0.10 Fig 6 Simulation Results A CKNOWLEDGMENT This research was supported by the grant TAMOP 4.2.2.C11/1/KONV-2012-0001 and the action line Privacy Security and Trust of the EIT ICT Labs Budapest Associate Partner Group R EFERENCES  P  Baran yi and A Csap 223De\002nition and syner gies of cogniti v e infocommunications,\224 Acta Polytechnica Hungarica  vol 9 no 1 pp 67\22683 2012 Fig 7 Simulation Results Fig 8 Simulation Results  G Salla i 223The cradle of cogniti v e infocommunications 224 Acta Polytechnica Hungarica  vol 9 no 1 pp 171\226181 2012  P  Baran yi A Csap and P  Vrlaki 223 An o v ervie w of research trends in coginfocom,\224 in IEEE International Conference on Intelligent Engineering Systems Tihany Hungary 2014  2014 pp 181\226186  C C Agg arw al and S Y  Phi lip A general survey of privacy-preserving data mining models and algorithms  Springer 2008  J Han M Kamber  and J Pei Data Mining Concepts and Techniques  3rd ed San Francisco CA USA Morgan Kaufmann Publishers Inc 2011  P N T an M Steinbach and V  K umar  Introduction to Data Mining First Edition  Boston MA USA Addison-Wesley Longman Publishing Co Inc 2005  C Clifton M Kantarcioglu J V aidya X Lin and M Y  Zhu 223Tools for privacy preserving distributed data mining,\224 ACM SIGKDD Explorations Newsletter  vol 4 no 2 pp 28\22634 2002  Y  Lindell and B Pinkas 223Secure multiparty computation for pri v ac ypreserving data mining,\224 Journal of Privacy and Con\002dentiality  vol 1 no 1 p 5 2009  A C Y ao 223Protocols for secure computations 224 in 2013 IEEE 54th Annual Symposium on Foundations of Computer Science  IEEE 1982 pp 160\226164  L Kissner and D Song 223Pri v ac y-preserving set operations 224 in Advances in Cryptology\226CRYPTO 2005  Springer 2005 pp 241\226257  M Kantarcioglu C Clifton et al  223Privacy-preserving distributed mining of association rules on horizontally partitioned data,\224 IEEE Transactions on Knowledge and Data Engineering  vol 16 no 9 pp 1026\2261037 2004  H T oi v onen et al  223Sampling large databases for association rules,\224 in VLDB  vol 96 1996 pp 134\226145 435 CogInfoCom 2014 € 5th IEEE International Conference on Cognitive Infocom\munications € November 5-7, 2014, Vietri sul Mare, Italy 


730 


                   


       


