An Exploratory Study of Macro Co-changes Fehmi Jaafar 1  Yann-Ga el Gu eh eneuc 1  Sylvie Hamel 2  and Giuliano Antoniol 1 1 P TIDEJ Team SOCCER Lab DGIGL  Ecole Polytechnique de Montr eal QC Canada 2 LBIT Team DIRO Universit edeMontr eal QC Canada E-Mails  jaafarfe,hamelsyl  iro.umontreal.ca yann-gael.gueheneuc@polymtl.ca antoniol@ieee.org Abstract The literature describes several approaches to identify the artefacts of programs that change together to reveal the hidden dependencies among these artefacts These 
approaches analyse historical data mined from version control systems and report co-changing artefacts which hint at the causes consequences and actors of the changes We introduce the novel concepts of macro co-changes MCC i.e  of artefacts that co-change within a large time interval and of dephase macro co-changes DMCC i.e  macro co-changes that always happen with the same shifts in time We describe typical scenarios of MCC and DMCC and we use the Hamming distance to detect approximate occurrences of MCC and DMCC We present our approach Macocha to identify these concepts in large programs We apply Macocha and compare it in 
terms of precision and recall with UMLDiff 036le stability and association rules co-changing 036les on four systems ArgoUML FreeBSD SIP and XalanC We also use external information to validate the approximate MCC and DMCC found by Macocha We thus answer two research questions showing the existence and usefulness of theses concepts and explaining scenarios of hidden dependencies among artefacts Keywords Co-changes stability bit vectors I I NTRODUCTION Developers must continually change their software programs to meet new requirements and user needs else their programs become progressively unsatisfactory 1 and eventually become obsolete to the point of disappearing The literature describes many approaches to extract and 
analyse the changes undergone by software artefacts and to infer patterns that describe these changes to help program comprehension and evolution Several of these approaches identify co-changes among artefacts e.g 2  3  w h i c h represent the often implicit dependencies or logical couplings among artefacts that have been observed to frequently change together 4 T w o a rt ef act s a re co-changi ng i f t h e y were changed by the same author and with the same log message in a time-window of less than 200 ms 3  M ockus et al 5 d e\036 ned t he proxi mi t y i n t i m e o f c hecki n s b y t he check-in time of adjacent 036les that differ by less than three minutes Other studies  e.g  6 and  7   d es cribed is s u es about identifying atomic change sets and reported that in 
all cases they differed by few minutes Artefacts can be source code 036les classes in objectoriented programs speci\036cations and so on In this paper as in previous work e.g  3   8   a nd 9  for t he s a k e of simplicity we focus on C C and Java source 036les c cpp and java as they are among the most common and popular programming languages Previous co-changes are intrinsically limited in time They cannot express patterns of changes between long time intervals For example in the Bugzilla of ArgoUML the bug ID 5378 1 states in relation to ArgoDiagram.java thatan ArgoDiagram should provide constructor arguments for the concrete classes to create which relates to 
ModeCreateAssociationClass.java  The bug report thus con\036rms that these two 036les are related However no previous approach can detect that these 036les co-changed because they were maintained by the same developper bobtarling but their changes were separated by few hours Yet Knowing the dependency among theses 036les is useful to a new developer that must change ArgoDiagram.java  she must assess ModeCreateAssociationClass.java for change In general this scenario happens when a developer is in charge of a subset of a large program composed of among others 036les F1 and F2  She may change and commit these two 036les in the same day but with a few hours between each commit as illustrated in Figure 2 This scenario may repeat 
for years and would be undetected using a sliding window of few minutes Yet it contains important information both for the developer and her colleagues changes to F1 must likely propagate to F2  As another example in ArgoUML we found that the developers mvw and tfmorris contributed with some patches that contains NotationUtilityJava.java and ModelElementNameNotationUml.java 2 and the bug ID 2926 3 con\036rms that the two 036les are related see Section IV for details No previous approach can detect that these 036les co-changed because  during the 11 years of development of ArgoUML these two 036les were never changed 
by the same developer at the same time but were changed by developers mvw and tfmorris in two consecutive change periods 036rst NotationUtilityJava.java and subsequently after one period of change ModelElementNameNotationUml.java  pointing out dependency among 1 http://argouml.tigris.org/issues/show bug.cgi?id=4604 2 http://argouml.tigris.org/issues/showattachment.cgi/2118/20101116patch-notation.txt 3 http://argouml.tigris.org/issues/show bug.cgi?id=2926 
2011 18th Working Conference on Reverse Engineering 1095-1350/11 $26.00 © 2011 IEEE DOI 10.1109/WCRE.2011.47 325 


these two 036les In fact this scenario can happen when a developer D2 is always reminded to change 036le F2 after one or two days by developer D1 whenever D1 changed 036le F1 as shown in Figure 1 Previous work e.g    3  10  does not consider co-changed 036les if they were changed by two different authors in the same period Thus we present the 036rst approach  to the best of our knowledge to detect and to report co-changed 036les maintained by different developers Thus we introduce the novel concepts of macro cochanges MCC and dephase macro co-changes DMCC inspired from co-changes and using the concept of change periods as de\036ned in Section II The MCC describe a set of 036les that always change together in the same periods of time The DMCC describes a set of 036les that always change together with some shift in time in their periods of change We also consider approximate MCC and DMCC when cochanges occur almost all the time using the Hamming distance and by dividing the MCC respectively DMCC set into two sets the S MCC respectively S DMCC etthat contains 036les that have exactly the same dephase pro\036le and the S MCCH respectively S DMCCH  set that contains approximate dephase macro co-changing 036les We also present Macocha an approach to identify MCC and DMCC in the evolution of programs which relates to 036le stability and co-changes and perform two types of empirical studies Quantitatively  we compare the stability analysis of Macocha with that of UMLDiff 11 a n d th e co-change analysis of Macocha with association rules 3 W e compare t he res u l t s of t h e t hree approaches on four different programs ArgoUML FreeBSD SIP and XalanC developed with three differe nt programming languages C C and Java Qualitatively  we use external information provided by bugs reports mailing lists and requirement descriptions to validate the MCC and DMCC not found using association rules and to show that these MCC and DMCC explain real evolution phenomena Thus the contributions of this paper are 1 the de\036nitions of the two novel concepts of MCC and DMCC 2 an ef\036cient approach to identify such co-changes not identi\036ed by previous work in large programs  3 empirical studies showing the existence and usefulness of approximate MCC and DMCC among 036les Section II presents Macocha Section III describes our empirical study while Section IV reports and discusses its results as well as threats to its validity Section VI discusses related work Section VII concludes with future work II O UR A PPROACH M ACOCHA We propose Macocha to mine version-control systems CVS and SVN to identify the change periods in a program to group source 036les accordin g to their stability through the change periods and to identify among changed 036les Figure 1 Files F1 and F2 are changed by different developers and in two consecutive periods of time Figure 2 Two changes performed by one developer are sequential in time after few hours F1 and F2 are macro co-changing those that have similar co-changes pattern i.e are macro cochanging or dephase macro co-changing We now present the concepts of our approach using examples from ArgoUML A Deﬁnitions 1 Change Period We draw inspiration and extend the classical sliding window approach to consider that two subsequent changes by any author and with any log message are part of one change period if we do not detect an interrupt between these two s ubsequent changes We de\036ne an interrupt as a continuous duration without a change Hatton 12 p res e nt ed an empi ri cal s t udy t o es t i m at e t he time for a particular maintenance requests also known as change requests or CRs The author showed that the average duration of a CR is 5.17 hours and that the largest duration was less than 40 hours Thus in Macocha the largest duration of a change period is less than 40 hours Let t be the number of hours of an interrupt between two change periods In Macocha we choose t 5  17 hours e.g  if the interrupt between two subsequent changes is more than t 5  17 hours we assume that theses two subsequent changes belong to two different change periods 
326 


Figure 3 Pro\036les showing 036le Stability Figure 4 Files F1 and F2 were in macro co-change Figure 5 Three different bit vectors showing dephase macro co-change Figure 6 Three different bit vectors showing approximate macro cochange In ArgoUML  We 036nd 2,843 change periods in 11 years of maintenance By comparing the result of Macocha on cochange with association rules 2 3 w e 036 nd that t 5  17 hours is a good trade-off between precision and recall see Section IV for details 2 Proﬁle We de\036ne a pro\036le as a bit vector that describes if a 036le changed or not during each of the change periods of a program The length n of this bit vector is the number of change periods We indicate that a 036le has changed in the i th period by putting the i th bit to one zero otherwise 3 File Stability Macocha groups 036les according to their stability idle and changed as shown in Figure 3 Each group is a set of pro\036les with similar stability Idle les do not change in any change period after their introduction into the system i.e  their pro\036les mostly contain zeroes while changed les are 036les that changed after their introduction into program Macocha use this group to identify 036les having similar co-changes pattern In ArgoUML  Macocha identi\036es 202 idle 036les and 2,946 changed 036les 4 Macro Co-changes Similar changed pro\036les grouped together represent MCCs and DMCCs A S MCC is two or more changed 036les that change together i.e thathave identical pro\036les during the life cycle of a program as illustrated in Figure 4 Given a 036le F1 a S DMCC is the set composed of F1 and one or more 036les F2  FM such that F2  FM always macro co-change with the same shift in time s 002 0 n   with respect to F1 during the evolution of a program Figure 5 illustrate that F1 and F2 are in dephase macro co-change with s 1  F2 and F3 are in a DMCC with s 2  and F1 and F3 are in a DMCC with s 3 In this paper we limit our study to s 1  Macocha considers both identical and similar pro\036les with or without shifts in time to account for cases where the 036les did not change exactly at the same times in terms of change periods We use the Hamming distance D H to measure the amount of differences between two change pro\036les i.e  the number of positions at which the corresponding bits are different After analysing several values of D H between two pro\036les in different system we found that D H  3 is the best trade-off between precision and recall as shown in Figure 9  Thus in this paper we consider that two pro\036le are similar if the Hamming distance between them is less then three D H  3 Figure 6 illustrate that F1 and F2 are in approximate macro co-change with D H  3 F2 and F3 are in a approximate MCC with D H  3 and F1 and F3 are in a approximate MCC with D H  5 B Data Model Implementation and Outputs Figure 7 describes the data used by Macocha A change contains several attributes the changed 036le names the dates of changes the developers having committed the changes Using this data Figure 8 illustrates the concrete process of Macocha Macocha takes as input a CVS/SVN change log It creates a pro\036le that describes the evolution of each 036le in each change period It uses these pro\036les to compute the stability of the 036les and then identify MCC and DMCC Macocha returns the following sets of dephase macro co-changing 036les and their pro\036les S MCC thesetof macro co-changing 036les with identical pro\036les in a program and S DMCC  the set of dephase macro co-changing 036les identi\036ed when shifting pro\036les by s change periods S MCCH  the set of approximate macro co-changing 036les with similar pro\036les in a program by using the Hamming distance 0  D H  3 and S DMCCH  the set of approximate dephase macro co-changing 036l es identi\036ed when shifting pro\036les by s change periods III E MPIRICAL STUDY Following GQM 13  t he goal o f our s t udy i s t o s h o w t h at our approach can identify MCC and DMMC and that they describe interesting evolution phenomena Our purpose is to bring generalisable quantitative evidence on the existence of MCC and DMCC The quality focus is that changing one 036le may impact the 036les that dephase macro co-change with it The perspective is that of both researchers and practitioners who should be aware of the hidden dependencies among 036les to make informed changes The context of our study is both the comprehension and the maintenance of programs A Research Questions We formulate two research questions RQ1 How does Macocha compare to previous work in term of precision 
327 


Figure 7 Meta-model of our data Figure 8 Analysis-process and recall RQ2 Are there approximate dephase macro co-changes among 036les and what is their usefulness B Analyses To answer RQ1 and RQ2 we apply Macocha to different object programs and collect the different sets of MCC and DMCC We then perform two types of empirical studies Quantitatively on the one hand we compare the results of Macocha with those of UMLDiff for 036le stability We thus show that Macocha can identif y the same idle and changed 036les as UMLDiff using only data from change logs It does not produce as detailed information as UMLDiff but this information is suf\036cient for our needs Idles 036les do not change in any change period after their introduction into the program Thus we discard this group of 036les because they are not useful for the co-change analysis due to their rare evolution On the other hand we compare the results of Macocha with those of the association rules approach 3 f or cochanging 036les We also thus show that the set S MCC produced by Macocha includes the same co-changing 036les as reported using association rules plus new co-changing 036les Qualitatively we con\036rm that each MCC found by Macocha but not association rules approach 3 i s i ndeed a dependency link using external information from bugreports requirement descriptions and mailing lists We also select typical examples of MCCs and DMCCs and show their usefulness using external sources of information We thus report a quantitative analysis in accordance with the state of the art and a qualitative analysis in accordance with external information We also report and discuss the cardinalities of the MCC and DMCC sets We do not report performance because using a standard computer with a Intel Core i7-740QM 1.73 2.93GHz 6GB RAM and 1GB VRAM Macocha identi\036es dephase macro co-changes in FreeBSD the largest program in terms of number of 036les and of changes in less than ten minutes C Objects We choose four programs developed with three different programming languages ArgoUML 4  FreeBSD 4 SIP 4 and XalanC 4  We use these programs because they are open source have been used in previous work 10 14   a re of different domains and in different programming languages span several years and versions and underwent between thousands and hundreds of thousands of changes Table I summarises some programs statistics ArgoUML is an UML diagramming program written in Java and released under the open-source BSD License We analyse the evolution of this program for a period of 11 years from 1998-01-26 to 2009-01-29 In this period ArgoUML has gone through over 13 major versions from the 036rst published version to version 0.26.2 in November 2008 and many more minor versions FreeBSD is a free Unix operating system written in C and released under the open-source BSD License We analyse the evolution of this program for a period of 15 years from 1994-05-25 to 2009-02-11 In this period FreeBSD has gone through eight major versions from the 036rst published version to version 7.0 on February 2008 SIP Communicator is an audio/video Internet phone and instant messenger that supports some of the most popular VoIP and instant messaging protocols such as SIP Jabber AIM/ICQ MSN SIP is open source and freely available under the GNU Lesser General Public License It is written in Java We analyse the evolution of this program for a period of 036ve years from 2005-07-21 to 2010-12-09 XalanC is an open-source software library from the Apache Software Foundation written in C We analyse the evolution of this library for a period of 11 years from 1999-12-18 to 2009-01-17 In this period XalanC has gone through over 20 major versions from the 036rst published version to version 1.10 in November 2008 IV S TUDY R ESULTS AND D ISCUSSIONS We now present the results of our empirical study Table II summarises the sets obtained by applying Macocha A Data Preprocessing and Identifying changed les Before 036nding patterns in the change history Macocha detects in each program the set of changed 036les The preprocessing step involves eliminating idles 036les because they 4 http://argouml.tigris.org http www.freebsd.org http://www.sipcommunicator.org and http://xml.apache.org/xalan-c 
328 


ArgoUML FreeBSD SIP XalanC Languages Java C Java C Versions 30 8 2 21 Files 3,148 3,603 2,790 529 Changes 16,727 186,959 8,046 397,052 Start Dates 98-01-26 94-05-25 05-07-21 99-12-18 End Dates 09-01-29 09-02-11 10-12-09 09-01-17 CPs 2,843 1,121 1,553 924 Table I D ESCRIPTIVE STATISTICS OF THE OBJECT PROGRAMS CP S  NUMBERS OF CHANGE PERIODS  ArgoUML FreeBSD SIP XalanC Idle 036les 202 1,856 963 7 Changed 036les 2,946 1,747 1,827 522 ofS MCC 166 121 142 36 Max#\036les 35 24 15 17 Min  036les 2 2 2 2 ofS MCCH 196 163 182 85 Max#\036les 46 44 32 22 Min  036les 2 2 2 2 ofS DMCC 11 1 6 1 Max#\036les 4 2 3 2 Min  036les 2 2 2 2 ofS MCCH 53 63 36 4 Max#\036les 6 8 5 2 Min  036les 2 2 2 2 Table II C ARDINALITIES OF THE SETS OBTAINED IN THE EMPIRICAL STUDY Idle Groups Changed Groups ArgoUML Idle Clusters 202 0 Short-lived Clusters 0 1,390 Active Clusters 0 1,556 SIP Idle Clusters 963 0 Short-lived Clusters 0 997 Active Clusters 0 830 XalanC Idle Clusters 7 0 Short-lived Clusters 0 291 Active Clusters 0 231 Table III C ARDINALITY OF M ACOCHA SETS IN COMPARISON TO UMLD IFF 11 do not change in any change period after their introduction into the program Thus they do not participate in co-change patterns Table III reports the number of idle short-lived and active 036les found by UMLDiff in the object-oriented object programs ArgoUML SIP and XalanC and their categorisation by Macocha Because we want to distinguish idle from changed 036les Macocha groups together the 036les identi\036ed as short-lived and active by UMLDiff and compare the sets provided by UMLDiff and by Macocha and 036nd that they are identical For example Macocha 036nds 2,946 changed 036les in ArgoUML identical to the UMLDiff 1  390  1  556  2  946 short-lived and active 036les In addition Macocha computes 036le stability in few minutes because unlike UMLDiff which takes few hours 15 because it does not create UML-like representations of the programs before performing its analysis Macocha can analyse 036le stability for any program unlike UMLDiff providing that CVS/SVN repositories are available In ArgoUML  We detect 202 idle 036les For example the 036les ModeChangeEvent.java and GoModelToClassifiers.java were modi\036ed in only one change period in 11 years.Using UMLDiff we con\036rm that these 036les belong to an idle cluster We detect 2,946 changed 036les For example the 036les TestProject.java and NotationUtilityUml.java were modi\036ed 20 times during the evolution of ArgoUML Thus these 036les belong to the changed group Using UMLDiff we con\036rm that these 036les belong to an active cluster In FreeBSD  We 036nd 1,856 idle 036les For example hdtimer.c and hddebug.c were modi\036ed in one change period in 15 years We detect 1,747 changed 036les The 036les subrclist.c and stallion.c were modi\036ed in 15 change periods during the evolution of FreeBSD We cannot use UMLDiff to verify this result because UMLDiff can not analyse programs written in C In SIP  We obtain 963 idle 036les For example SelectImagePanel.java and ImageSourceStream.java were modi\036ed in one change period in 036ve years With UMLDiff these 036les belong to an idle cluster Macocha detect 1,827 changed 036les The 036les DefaultTreeContactList.java and TreeContactList.java were modi\036ed 15 times during the evolution of the program In XalanC  Our approach detect seven idle 036les For example XLocator.cpp and Cloneable.cpp were modi\036ed in one change period in nine years Using UMLDiff we con\036rm that these 036les belong to an idle cluster Macocha detect 522 changed 036les The 036les TopLevelArg.cpp and XalanEXSLTSet.cpp were modi\036ed in 30 changes periods during the evolution of the program Using UMLDiff we con\036rm that these 036les belong to an active cluster B How does Macocha compare to previous work in term of precision and recall For each program Macocha detect 036les that have identical or similar pro\036les the MCCs sets and report them Quantitatively  We compare the S MCC found by Macocha with the co-changing 036les found by an approach based on association rules 3  s e e a l s o  10  w h i c h u s e s t he Apriori algorithm 16 t o c omput e a s s o ci at i o n r ul es  T he Apriori algorithm takes a minimum support and a minimum con\036dence and then computes the set of all association rules To obtain a comprehensive set of rules we consider as valid rules those achieving a minimum con\036dence of 0.9 as in previous work 3 a nd a m i n i m um s upport o f 2 t o compare association rules and our approach We thus perform an internal evaluation similar to that of Zimmermann et al s Given snapshots S i  i 002 1   n   we build two equal sets T train   S 1  S t  and T test  
329 


Figure 9 The mean of Precision and Recall achieved by Macocha with different values of D H for the four programs Association Rules Macocha Precision Recall Precision Recall ArgoUML 15 66 20 75 FreeBSD 22 100 24 100 SIP 18 89 24 91 XalanC 16 100 22 100 Table IV A SSOCIATION RULES  S APPROACH 3 VS M ACOCHA  S t 1  S n  Weuse T train to build association rules and compare the co-changing 036les in T train with those in T test  For the four programs we 036nd that Macocha improve precision and recall over the approach based on association rules as shown in Table IV For example for ArgoUML results indicate that the precision and the recall of Macocha respectively 20 and 75  are better than those of association rules respectively 15 and 66  The rationale of an internal evaluation is that no expert and no pre-existing groups of co-changing 036les are available Precision and recall are measured for the testing sets by considering for each 036le the groups resulting from the training sets as oracles Such an internal validation have some limits 17  1 8    1  Files c o ch an g i n g f r eq u e n tly in the past training set but not recently test set will be considered wrongly as false negatives 2 Files co-changing frequently recently test set but not in the past training set will be considered wrongly as false positive 3 If the training set contained false positives or negatives they cannot be detected using the testing set Qualitatively  To overcome these limits and to validate the S MCC not found using association rules we also perform an external evaluation of Macocha by considering the results of the association rules as an oracle and by manually comparing them with those of Macocha In fact for each set returned by Macocha if an identical se t is returned by association rules it is considered a true positive If the two sets are not identical we use external information to validate missing 036les and to decide if they present a true positive a false negative or a false positive For example In XalanC all the sets detected by association rules are detected by Macocha except three sets We validated these three sets using two messages in the mailing list and one bug in the Bugzilla Table V reports under the External Information header Association Rules External Information Precision Recall Precision Recall ArgoUML 86 98 100 99 FreeBSD 98 100 100 100 SIP 85 96 100 98 XalanC 90 100 100 100 Table V E XTERNAL EVALUATION OF M ACOCHA WHEN USING THE RESULTS OF A SSOCIATION RULES et al  S APPROACH 3 AS ORACLE AND AFTER MANUAL VALIDATION USING EXTERNAL INFORMATION the precision and recall values of Macocha after manual validation which show that Macocha is able to detect S MCC missed and co-changes wrongly reported by association rules We do not obtain 100 recall because of our choice of t 5  17 hours A smaller value of t would yield a higher recall but a lower precision We thus con\036rm Hattonís study 12 and r eport t hat t 5  17 hours is a good trade-off between precision and recall Table V also reports under the Association Rules header the precision and recall of Macocha with respect to the approach based on association rules It shows that Macocha detects the majority of co-changing 036les detected by association rules in the four object programs In addition Macocha detects other S MCC not detected by association rules For example In ArgoUML  ClassifierRole.java and MessageDirectionKind.java were in approximate MCC In fact in the Bugzilla of ArgoUML the bug ID 881 5 states that when classi\036er assigned to an object  Ar goUML stops responding in relation with these two 036les These two 036le were changed by different authors in a time-window of more than few minutes Thus by applying the association rule approach described in 3  w e c annot 036 n d t hat t hes e 036les are co-changing In SIP  StatusIcon.java and ContactPanel.java were in MCC As con\036rmed in the Bugzilla of SIP by the bug ID 497 6  This bug describes on an Status noti\036cations for a choosen contact relating these two 036les These two 036les were changed by the same developer yanas 036ve times in a time-window of more than few minutes Thus by applying the association rule approach described in  we could not 036nd that these 036les are co-changing C Are there approximate dephase macro co-changes among les and what is their usefulness To the best of our knowledge no previous approach can detect 036les maintained with similar trends and some given shifts in time We validate the usefulness of DMCCs using external information For the lack of space we cannot illustrate all DMCCs so we only report representative examples In ArgoUML  When developers changed ActionAlign.java  developers changed ForwardingComponent.java in the following change period Thus these two 036les 5 http://argouml.tigris.org/issues/show bug.cgi?id=881 6 http://java.net/jira/browse/JITSI-134 
330 


are in DMCC In fact in the Bugzilla of ArgoUML the bug ID 1957 7 relates the two 036les Each label text is a few pixels too high for its component They should be positioned such that the label text is vertically aligned with the text in the labeled component In FreeBSD  We 036nd that ah-core.c and hpfs-alsubr.c are in approximate DMCC In the mailing list of FreeBSD the Message-ID 200906011106.n51B62Da020139@freefall.freebsd.org states that the two 036les are related in a lengthy the message from bugmaster  FreeBSD.org on June 1 2009 about Current problem reports In SIP  We 036nd that MuteDataSource.java and CallPeerActionMenuBar.java were changed systemically with one shift change period in 036ve years In fact These two 036les implement the same feature 8  Audio-Calls In XalanC  We 036nd that Cloneable.cpp and XLocator.cpp are in approximate DMCC In the XSLT syntax and semantic speci\036cation 9  these 036les are related A single template  can pull s tring values out of arbitrary locations in the source tree it can generate structures that are repeated according to the occurrence of elements In the following scenarios we summarise the usefulness of DMCCs reported by Macocha 1 Management of Development Teams If two classes are in approximate dephase macro co-change they should ideally be maintained by the same team of developers to minimise the risks of introducing bugs in the future The team of developers most likely possesses a wealth of unwritten knowledge about the design and implementation choices that they made for these classes which would help them to prevent introducing bugs 19  Consequently a team leader should rede\036ne the organisation of the maintenance team according to the DMCCs links among 036les so that her team does not introduce bugs because of the absence of info rmation or lack of communication among developers For example in ArgoUML when we analysed changes made in three 10 11 12 dephase macro co-changing 036les that have generated bugs we found that these changes have been made with one shift in time in their periods of change and by different developers  Thus such co-changes can not be detected by previous work Thanks to DMCCs a team leader should ensure that team who will maintain these 036les in each change period have the necessary knowledge to maintain the dependency among these 036les 2 Bug and Change Propagation Knowing that two 036les are in DMCCs implies the existence of hidden dependencies between these two 036les If these dependencies 7 http://argouml.tigris.org/issues/show bug.cgi?id=1957 8 http://www.jitsi.org/index.php/Main/Features 9 http://www.w3.org/TR/xslt 10 http://argouml.tigris.org/issues/show bug.cgi?id=1957 11 http://argouml.tigris.org/issues/show bug.cgi?id=2926 12 http://argouml.tigris.org/issues/show bug.cgi?id=4604 are not properly maintained they can introduce bugs in a program With our approach for each program studied we detected 036les in dephase macro co-changes By using external information we con\036rmed our observation and that these 036les indeed participate to bugs For example in SIP we detected seven bugs in relation with dephase macro cochanging 036les By applying the association rule approach described in 3  w e c annot 036 n d t hat t hes e 036 l es are c ochanging Thus by knowing 036les that are in DMMCs we could explain and possibly prevent bugs we plan to study in future work the bug prediction using approximate dephase macro co-changes 3 Traceability Analysis The change history represents one of sources of information available for recovering traceability links that are manually created and maintained by developers The version history may reveal hidden links that relate 036les and would be suf\036cient to attract the developers attention For example in SIP we detect traceability links between four approximate dephase macro co-changing 036les By applying the association rule approach described in we cannot 036nd that these 036les are co-changing Due to the distributed collaborative nature of open-source development version-control systems are the primary location of 036les and the primary means of coordination and archival The requirements of open-source programs are typically implied by communication among project participants and through test cases However such traces of requirements are lost in time Thus by knowing classes there are in approximate dephase macro co-change we could detect potentially traceability links between them which we plan to concretely study in future work V D ISCUSSIONS With our approach we detect 036les in MCCs or in DMCCs in four different programs belonging to different domains and with different sizes histories and programming languages However we do not detect MCCs and DMCCs with the same proportion in each program We observe that the numbers of MCCs and DMCCs found in the programs developed in Java ArgoUML and SIP are greater than the number of MCCs and DMCCs found in program developed in C or C see Table II We explain this 036nding by the fact that on the one hand the majority of FreeBSD 036les are idle and that on the other hand XalanC is the smallest program analysed Thus we also apply our approach to detect dephase macro co-changes on fewer C and C  036les than Java 036les less than 529 036les thus explaining the lower numbers of MCCs and DMCCs In future work we will conduct studies on other programs in these languages to con\036rm this observation and to assess the numbers of MCCs and DMCCs according to the programming languages A Threats to the Study Validity Some threats limit the validity of our empirical study 
331 


Construct Validity  Construct validity threats concern the relation between theory and obs ervations In this study they could be due to implementation errors They could also be due to a mistaken relation between changes in 036les We believe that this threat is mitigated by the facts that many authors discussed this relation that this relation seems rational and that the results of our analysis shows that indeed MCCs and DMCCs exist and are corroborated by external sources of information bug reports and others Actually we apply static analysis to detect MCCs and DMCCs because co-change analysis is known to be more useful when combined with static analysis 23  As previous work detected co-changes committed by the same author in a short time window relaxing these constraints may also lead to false positives The results of our empirical study show that Macocha improves precision and recall with respect to the state of the art in four different programs However we cannot claim that our approach will give similar results for any program Internal Validity  Internal validity is the validity of causal inferences in studies based on experiments The internal validity of our study is not threatened because we have not manipulate a variable the independent variable to see its effect on a second variable the dependent variable Reliability Validity  Reliability validity threats concern the possibility of replicating this study We attempted to provide all the necessary details to re-implement our approach and replicate our empirical study The change logs and the changed 036les of the four programs analysed with their pro\036les to obtain our observations are on-line at http://www.ptidej.net/downloads/experiments/wcre11b External Validity  We performed our study on four different real programs belonging to different domains and with different sizes histories programming languages Yet we cannot assert that our results and observations are generalisable to any other pr ograms and the fact that all the analysed programs are open source may reduce this generability future work includes replicating our study in other contexts and with other programs VI R ELATED W ORK The concepts of MCCs and DMCCs relate our work to that on 036le stability co-change and change propagation A File Stability Many approaches exist to group 036les based on their relative stability th roughout the software development life cycle For example Kpodjedo et al 20 propos ed t o i d ent i f y all 036les that do not change in the history of a program using an Error Tolerant Graph Matching algorithm They studied the evolution of the Mozilla class diagram by collecting 144 Mozilla snapshots over six years reverse-engineering their class diagrams and recovering traceability links between subsequent class diagrams Their approach identi\036ed evolving classes that maintain a stable structure of relations association inheritance and aggregation and thus that likely constitute the stable backbone of Mozilla As other example UMLDiff 11 compares and d etects the differences between the contents of two object-oriented program versions A fact extractor parses each version to extract models of their design Next a heuristic-differencing algorithm UMLDiff extracts the history of the program evolution in terms of the additions removals moves renamings and signature-changes of design entities such as packages classes interfaces and their 036elds and methods UMLDiff then assigns a stability to each class short-lived classes that exist only in a few versions of the program and then disappear idle classes that rarely undergo changes after their introduction in the program and active classes that keep being modi\036ed over their whole lifespan The Error Tolerant Graph Matching algorithm and UMLDiff take few hours to analyse 036le stability for the four programs analysed in this paper because they require parsing and comparing AST-like representations of the programs before performing their analyses Macocha computes stability in few minutes using the change periods of a program which depend on how the developers of the program organise their work and group changes through the life cycle of the program B Co-changing Files Ying et al 2 a nd Zi mmermann et al 3 a p p lied a sso ciation rules to identify co-changing 036les Their hypothesis is that past co-changed 036les can be used to recommend source code 036les potentially relevant to a change request An association-rule algorithm extracts frequently co-changing 036les of a transaction into sets that are regarded as change patterns to guide future changes Such algorithm uses co-change history in CVS and avoids the source code dependency parsing process However it only computes the frequency of co-changed 036les in the past and omits many other cases e.g  036les that co-change with always the same period of time between changes In Section IV we showed that approaches based on association rules cannot detect all occurrences of MCCs and any occurrences of DMCCs because by their very de\036nition they do not integrate the analysis of 036les that are maintained by different developers andñor with some shift in time which could lead to missed co-changing 036les German 7 u sed t h e in f o r m atio n i n t h e CVS t o v isu a lize what 036les are changed at the same time and who are the people who tend to modify certain 036les He presented SoftChange a tool that uses a heuristic based on a sliding window algorithm to rebuild the Modi\036cation Record MRs based on 036le revisions In Softchange a 036le revision is included in a given MR if all the 036le revisions in the MR and the candidate 036le revision were created by the same author and have the same log Thus Softchange can not detect co-changed 036le maintained in the same time by 
332 


different developers Ceccarelli et al 21 and C anfora et al 10 propos ed t h e u s e of a v ect or aut o re gres s i on model  a generalisation of univariate auto-regression models to capture the evolution and the inter-dependencies between multiple time series representing changes to 036les They used the bivariate Granger causality test to identify if the changes to some 036les are useful to forecasting the changes to other 036les They concluded that the Granger test is a viable approach to change impact anal ysis and that it complements existing approaches like association rules to capture cochanges If the authors integrate the analysis of 036les that are maintained by different developers in periods of time of more than few minutes their approach could then detect typical examples of MCCs and DMCCs Antoniol et al 8 p res e nt ed an approach t o det ect s i mi larities in evolutions of 036les starting from past maintenance notwithstanding their temporal distortions They applied the LPC/Cepstrum technique which models a time evolving signal as an ordered set of coef\036cients representing the signal spectral envelope to identify in version-control systems the 036les that evolved in the same or similar ways Their approach can 036nd 036les having very similar maintenance evolution history but they did not present a tool to detect MCCs and DMCCs It used cepstral distance to assess series similarity if two cepstra series are clos e the original signals have a similar evolution in time with which we can not distinguish between the occurrences of MCCs and DMCCs C Change Propagation The development and maintenance of a program involves handling a large number of 036les These 036les are logically related to each other and a change to one 036le may imply a large number of changes to various other 036les Change propagation analyses how changes made to one 036le propagate to others Law and Rothermel 22 presented an approach for change propagation analysis based on whole-path pro\036ling Path pro\036ling is a technique to capture and represent a program dynamic control 037ow Unlike other path-pro\036ling techniques which record intraprocedural or acyclic paths whole-path pro\036ling produces a single compact description of a program control 037ow including loops iteration and inter-procedural paths Law et al s approach builds a representation of a program behavior and estimates change propagation using three dependencybased change-propagation ana lysis techniques call graphbased analysis static program slicing and dynamic program slicing Hassan and Holt 23 in v e stig ated se v e r a l h eu r i stics to predict change propagation among source code 036les They de\036ned change propagation as the changes that a 036le must undergo to ensure the consistency of the program when another 036le changed They proposed a model of change propagation and several heuristics to generate the set of 036les that must change in response to a changed 036le Zhou et al 24 pres ent e d a change propagat i o n a nal y s i s b as ed on Bayesian networks that incorporates static source code dependencies as well as different features extracted from the history of a program such as change comments and author information They used the Evolizer system that retrieves all modi\036cation reports from a CVS and uses a sliding window algorithm to group them Canfora and Cerulo 25 proposed an approach to derive the set of 036les impacted by a proposed change request A user submits a new change request to a Bugzilla database The new change request is then assigned to a developer for resolution who must understand the request and determine the 036les of the source code that will be impacted by the requested change Their approach exploits information retrieval algorithms to link the change request descriptions and the set of historical source 036le revisions impacted by similar past change requests Theses approaches detect change propagation among 036les Their change-propagation model can be used to predict future change couplings and may involve several 036les that are in MCCs or in DMCCs but they do not allow to differentiate between these two concepts All these approaches grouped change couplings created by the same author and have the same log message thus they can not detect approximate MCCs andñor DMCCs Ambros et al 18 pres ented t he Ev olution R adar  a n approach to integrate and visualise module-level and 036lelevel logical couplings which is useful to answer questions about the evolution of a program the impact of changes at different levels of abstraction and the need for restructuring Beyer and Hassan 26 i nt roduced t h e e v o l u t i o n s t o ryboard a new concept for animated visualisations of historical information about the program structure and the storyboard panel which highlights structural differences between two versions of a program They also formulated guidelines for the usage of their visualisation by non-experts and to make their evaluations repeatable on other programs However Xing and Stroulia 27  r eport e d t hat t hes e visualisations are limited in their applicability because they assume a substantial interpretation effort of their users and they do not scale well they become unreadable for large systems with numerous components VII C ONCLUSION AND F UTURE W ORK We introduced the novel concepts of macro co-changes and dephase macro co-changes to describe that two 036les were changed by developers within same change periods with possible shifts in time We describe Macocha an approach to detect dephase macro co-changes using 036le pro\036les and their stability in time Macocha relates to 036le stability and co-changes We therefore performed two types of empirical studies Quantitatively we compared Macocha with UMLDiff 11 a nd an as sociation rules approach 3 b y a ppl yi ng and c ompari ng t h e results of the three approaches on four different programs 
333 


ArgoUML FreeBSD SIP and XalanC and showed that Macocha can identify the same idle/changed 036les as UMLDiff and that Macocha has a better precision and recall than the approach based on association rules Qualitatively we used external information provided by bugs reports mailing lists and requirement descriptions to show that detected MCCs and DMCCs explain real important evolution phenomena We also showed that dephase macro co-changes do exist and can help in explaining bugs managing development teams and traceability analysis We are currently 1 replicating our studies with other programs 2 performing a comprehensive study of the number of MCCs and DMCCs with varying values of t and s especially dependent on the analysed programs 3 identifying other scenarios in which dephase macro cochanges help and 4 relating MCCs and DMCCs with static analysis and external software characteristics such as change proneness Future work also includes a comparative study of the different sets computed by Macocha and associations rules with different value of con\036dence and support other than the values reported in 3  A CKNOWLEDGMENT This work has been partly funded by a FQRNT team grant the Canada Research Ch air in Software Patterns and Patterns of Software and the Tunisian Ministry of Higher Education and Scienti\036c Research We gratefully thank Massimiliano Di Penta and Daniel M German for their generous comments R EFERENCES  M  M  L ehm a n a nd L  Belady  E ds   Program evolution processes of software change  Academic Press Professional Inc 1985  A  T  T  Y ing G C Murphy  R  N g and M  C  C hu-Carroll Predicting source code changes by mining change history Transactions on Software Engineering  IEEE Computer Society Press 2004 vol 30 no 9 pp 574ñ586 3 T  Z im m e r m ann P  W e is ger b er  S  D iehl a nd A  Z e ller  M ining version histories to guide software changes in Proceedings of the 26th International Conference on Software Engineering  IEEE Computer Society 2004 pp 563ñ572  H  G all K  H a jek and M  J azayer i Detection of logical coupling based on product release history in Proceedings of the International Conference on Software Maintenance  IEEE Computer Society 1998 pp 190  A  M ockus  R  T  F ielding and J  D  H erbs leb T w o cas e s tudies of open source software development Apache and mozilla ACM Trans Softw Eng Methodol ACM July 2002 vol 11 pp 309 346  M  F is cher  M  P inzger  a nd H Gall Populating a releas e h is tory database from version control and bug tracking systems in Proceedings of the International Conference on Software Maintenance  IEEE Computer Society 2003 pp 23  D  M  G erm a n  A n e m p irical s t udy of 036ne-grained s oftw are m odi\036cations Empirical Softw Engg Kluwer Academic Publishers September 2006 vol 11  G  A ntoniol V  F  R ollo a nd G V e nturi L inear predicti v e coding and cepstrum coef\036cients for mining time variant information from software repositories in Proceedings of the International Workshop on Mining software repositories  ACM Press 2005 pp 1ñ5  S  B oukt i f  Y  G Gu  eh eneuc and G Antoniol Extracting changepatterns from cvs repositories in Proceedings of the 13th Working Conference on Reverse Engineering  IEEE Computer Society 2006 pp 221ñ230  G  Canf or a M  Ceccar elli L  Cer u lo a nd M  D i P e nta U s i ng multivariate time series and association rules to detect logical change coupling An empirical study in Proceedings of the 2010 IEEE International Conference on Software Maintenance  IEEE Computer Society Press pp 1ñ10 1 Z  X i ng and E  S tr oulia  A n alyz ing the evolutionary history of the logical design of object-oriented software Transactions on Software Engineering  IEEE Computer Society Press 2005 vol 31 pp 850 868 1 L  H a tton H o w accur a tely do engineer s p r e dict s o f t w a r e m a intenance tasks Computer  IEEE Computer Society Press 2007 vol 40  V  R Bas ili and D  M  W eis s   A m ethodology for c ollecting v alid software engineering data Software  IEEE Computer Society Press 1984 vol 10 no 6 pp 728ñ738  T  Z i m m e rm ann S Breu C  L indi g and B Livshits Mining additions of method calls in argouml in Proceedings of the International Workshop on Mining Software Repositories  ACM Press 2006  Z  X i ng and E  S tr oulia  U m ldif f  an algor ithm f or objecto r i ented design differencing in Proceedings of the 20th International Conference on Automated Software Engineering  ACM Press 2005 1 R A g r a w a l a nd R S r ikant F as t a lgor ithm s f o r m ining a s s ociation rules in large databases in Proceedings of the 20th International Conference on Very Large Data Bases  Morgan Kaufmann Publishers Inc 1994 1 A  V a n y a S  K l us ener  N  v an Rooijen and H  v an V liet Char acterizing evolutionary clusters in Proceedings of the 16th Working Conference on Reverse Engineering  IEEE Computer Society 2009  M DíAm bros  M  L anza and M  L ungu V is ualizing c o-change information with the evolution radar Transactions on Software Engineering  IEEE Computer Society Press 2009 vol 35 no 5 pp 720ñ735 1 B W  Rebecca W i r f s B r o ck and L  W iener  E d s   Designing ObjectOriented Software  Prentice Hall 1990  S  K podjedo F  Ricca P  G a linier  and G Antoniol Recovering the evolution stable part using an ecgm algorithm Is there a tunnel in mozilla in CSMR  2009 pp 179ñ188 2 M  Ceccar elli L  Cer u lo G  C anf o r a  a nd M  D i P e nta  A n eclectic approach for change impact analysis in Proceedings of the 32nd International Conference on Software Engineering ACMPress 2010 pp 163ñ166  J  L a w a nd G Rotherm e l W hole p rogram path-bas ed dynam i c impact analysis in Proceedings of the 25th International Conference on Software Engineering  IEEE Computer Society 2003 pp 308 318  A E  Ha ssa n a nd R  C  Hol t   P re dicting change propagation in software systems in Proceedings of the 20th IEEE International Conference on Software Maintenance  IEEE Computer Society 2004 pp 284ñ293  Y  Z h ou M  W  ursch E Giger H C Gall and J L  u A bayesian network based approach for change coupling prediction in Proceedings of the 15th Working Conference on Reverse Engineering  IEEE Computer Society 2008 pp 27ñ36  G Canfora a nd L  Cerulo  Im pact analys is by m i ning s o ftw a re and change request repositories in Proceedings of the 11th IEEE International Software Metrics Symposium  IEEE Computer Society Press 2005 p 29  D  Be yer a nd A  E  H a s s an  A n im ated vis u alization o f s of tw ar e history using evolution storyboards in Proceedings of the 13 th Working Conference on Reverse Engineering  IEEE Computer Society Press 2006  Z  Xing and E  S troulia  Bottom up des i gn e v olution c oncern discovery and analysis Tech Rep 2007 
334 


relate approximately the 34% of the events, which enables the forecast of new events that are the same type as those contained in the rules. In a similar way to the presented case we analyzed 62 different measurement points with a total of 6300 events occurred in the distribution network over 2 years TABLE VI ASSOCIATION RULES AND THEIR CONFIDENCE rule conf  1]? [1? 5] 0.750 9]? [9? 9] 0.5294 139 Fig. 2. Complete sequence and their frequent serial episodes TABLE VII COMMON RULES FOUND IN DIFFERENT MEASUREMENT POINTS rule number of measurement points 1] ? [1? 1] 16 1] ? [1? 5] 10 6] ? [6? 9] 8 9] ? [9? 9] 5 14] ? [14? 15] 11 15] ? [15? 15] 19 1? 1] ? [1? 1? 1] 18 The rules commonly found in most of the measurement points are shown in Table VII. The parameters used to extract the association rules are win = 5, min fr = 0.15 and min conf = 0.5. The summary showed in Table VII indicates that the ranges of occurrence of events in each measurement point presents different behaviours and, therefore, it is necessary to examine separately the sequences of each measurement point for a successful development of a valid prediction. The results show that it is possible to build rules to relate time spans between successive events which give an estimate of time lag for the appearance of a new event. Although it is not possible to relate all the events of the sequence, the knowledge of network behavior is improved, and takes advantage of power system information available in databases. Finally, different values of win min fr and min conf were tested to find frequent episodes 


and association rules. The result show that increasing win larger episodes can be found, while increasing min fr and min conf the amount of frequent episodes and rules will be minor, since the requirement for selection increases Similarly, it was found that using WINEPI methodology, the frequency of an episode is proportional to the width of the window. The appropriate values of min conf and min fr are defined taking into account criteria such as sequence length, type events frequency and the confidence threshold that the user wishes to assume. It is advisable to test different values of min conf and min fr V. CONCLUSIONS AND FUTURE WORKS The proposed methodology suggests a new approach for failure analysis in power distribution system. The aim of the solution is the forecast of faults, which is analyzed in the domain of temporal data mining and, in particular, the discovery of patterns starting from the registers of events The proposed solution is able to extract useful information about the behaviour and evolution of the faults in the electrical system, as a first step in the exploitation of event sequences recorded in power distribution systems, for the prediction of future failures Future work should continue with the search of episodes in sequences of events to discovery patterns related with failures in components and to exploit other information contained in the events recorded besides the elapse times between events e.g., the depth of voltage sags during the fault, etc. Next use this information from a predicting point of view, to anticipate future failures VI. ACKNOWLEDGMENTS This research has been developed within the eXiT, Control Engineering and Intelligent Systems, research group of the Institute of Informatics and Applications \(University of Girona Decision Support Systems \(AEDS with a consolidated distinction \(2009 SGR 523 2012 period in the Consolidated Research Group \(SGR project of the Generalitat de Catalunya The work has been supported by the research project Moniorizacion Inteligente de la Calidad de la Energ?a Electrica DPI2009-07891 vacion \(Spain 


scholarship \(2009FI-A00452 per a Universitats i Recerca del Departament dInnovacio Universitats i Empresa of the Generalitat de Catalunya and also the European Social Fund REFERENCES 1] Math H.J Bollen. Understanding power quality problems, voltage sags and interruptions. IEEE press series on power engineering, 1999 2] Carl L. Benner and B. Don Russell. Distribution incipient faults and abnormal events: Case studies from recorded field data. In 57th Annual Conference for Protective Relay Engineers, 2004 3] K. C. P Wong, H. M. Ryan, and J. Tindle. Power system fault prediction using artificial neural networks. In International Conference on Neural Information Processing, 1996 4] Bach Quoc Khanh, Dong-Jun Won, and Seung-Il Moon. Fault distribution modeling using stochastic bivariate models for prediction of voltage sag in distribution systems. IEEE Transactions on Power Delivery, 23:347354, 2008 5] J. A. Martinez-Velasco and J. Martin-Arnedo. Stochastic prediction of voltage dips using an electromagnetic transient program. In 14th PSCC, Sevilla, Spain, 2002 6] Heikki Mannila, Hannu Toitoven, and A. Inkeri Verkamo. Discovery of frequent episodes in event sequences. Data Mining and Knowledge Discovery, 1:259289, 1997 7] Rakesh Agrawal and Ramakrishnan Srikant. Fast algorithms for mining association rules. In Int. Conf. Very Large Data Bases VLDB94 8] Charles J. Kim, Lee Seung-Jae, and Kang Sang-Hee. Evaluation of feeder monitoring parameters for incipient fault detection using laplace trend statistic. IEEE Transactions on Industry Applications, 40:1718 1724, 2004 9] Z.W. Liao, G. Wang, Q.H. Ye, and Y.M. Sun. A novel fault diagnosis system for transmission line system based on sequence of events. In 6th International Conference on Advances in Power System Control Operation and Management APSCOM 2003, pages 440445, 2003 140 10] Srivatsan Laxman and P. Shanti Sastry. A survey of temporal data mining. SADHANA Academy Proceedings in Engineering Sciences 31:173198, 2006 11] Rakesh Agrawal and Ramakrishnan Srikant. Mining sequential patterns. In Int. Conf. Data Engineering \(ICDE95 12] Srivatsan Laxman, P. Shanti Sastry, and K. P. Unnikrishnan. Fast algorithms for frequent episode discovery in event sequences. Technical 


report, CL-2004-04/MSR, GM R&D Center, Warren, 2004 13] K. P. Unnikrishnan, Debprakash Patnaik, and P.S. Sastry. Discovering patterns in multi-neuronal spike trains using the frequent episode method. Technical report, General Motors R&D Center, Warren, 2007 14] Kuo-Yu Huang and Chia-Hui Chang. Efficient mining of frequent episodes from complex sequences. Information Systems, 33:96114 2008 15] Gregory Piatetsky-Shapiro and William Frawley. Knowledge Discovery in Databases. AAAI/MIT Press, 1991 141 


