Efﬁcient Processing of Skyline Queries Using MapReduce Yoonjae Park Jun-Ki Min and Kyuseok Shim Abstract The skyline operator has attracted considerable attention recently due to its broad applications However computing a skyline is challenging today since we have to deal with big data For data-intensive applications the MapReduce framework has been widely used recently In this paper we propose the efﬁcient parallel algorithm SKY-MR  for processing skyline queries using MapReduce We rst build a quadtree-based histogram for space partitioning by deciding whether to split each leaf node judiciously based on the beneﬁt of splitting in terms of the estimated execution time In addition we apply the dominance power ltering method to effectively prune non-skyline points in advance We next partition data based on the regions divided by the quadtree and compute candidate skyline points for each partition using MapReduce Finally we check whether each skyline candidate point is actually a skyline point in every partition using MapReduce We also develop the workload balancing methods to make the estimated execution times of all available machines to be similar We did experiments to compare SKY-MR  with the state-of-the-art algorithms using MapReduce and conﬁrmed the effectiveness as well as the scalability of SKY-MR   Index Terms Skyline queries MapReduce algorithms distributed and parallel algorithms  1I NTRODUCTION T HE skyline operator and its variants 2 3 have attracted considerable attention recently due to their broad applications such as product recommendations review evaluations with user ratings querying wireless sensor networks and graph analysis 7 However computing a skyline is challenging today since we have to deal with big data For data-intensive applications including similarity joins and topk substring matching the  framework has been considered as a de facto standard Thus several skyline processing algorithms  13 14 using MapReduce have been proposed MR-GPMRS in consists of the partitioning and global skyline phases The partitioning phase of MR-GPMRS divides the data space into grid partitions and prunes the partitions that cannot contain any skyline point by utilizing the dominance relationships between grid partitions In the global skyline phase in every unpruned partition P  the points which are located in other unpruned partitions and may dominate a point in P are rst collected and each point in the partition P is compared with the collected points to determine whether it is a global skyline point in parallel To compute the skyline efﬁciently an additional local skyline phase is involved between the partitioning and global skyline phases in MR-BNL  PPF-PGPS  and SKY-MR  They compute the local skyline for each partition and use them to compute the skyline in the global skyline phase The beneﬁt of the additional phase is that the overheads of computing the skyline as well as distributing the points via the network in the global skyline phase are reduced since the number of local skyline points in each partition is much less than that of all points in the partition In the local skyline phase while MR-BNL computes the local skylines blindly PPF-PGPS and SKY-MR prune points in advance by utilizing partition-aware ltering techniques Thus PPF-PGPS and SKY-MR outperform MR-BNL as reported in 14 In addition while MR-BNL and PPFPGPS utilize only a single machine to compute the global skyline SKY-MR calculates the global skyline in parallel and thus shows better scalability than PPF-PGPS and MR-BNL  Furthermore since SKY-MR prunes non-skyline points by the additional local skyline phase it is generally more efﬁcient than MR-GPMRS which consists of two phases While SKY-MR is the state-of-the-art algorithm for computing skylines using MapReduce it has the following drawbacks To split the data effectively SKY-MR builds a sky-quadtree  from a sample of data based on the userdeﬁned parameter split threshold which is the maximum number of points in every leaf node Thus the performance of SKY-MR suffers when a reasonable split threshold is not provided Furthermore since the skyline algorithms using MapReduce 12 13 14 including SKY-MR ignore workload balancing of available machines their performances degrade with increasing the number of machines To alleviate the problems mentioned above we propose the MapReduce algorithm SKY-MR  to compute skylines efﬁciently in this paper The contributions of our work are summarized as follows Adaptive Quadtree Building Our SKY-MR  uses an adaptive quadtree building technique which splits each node judiciously depending on whether splitting the node is beneﬁcial or not in terms of the estimated execution time SKY-MR splits a leaf node of a sky-quadtree in 002 Y Park and K Shim are with the Department of Electrical and Computer Engineering Seoul National University Kwanak P.O Box 34 Seoul 151600 Korea E-mail yjpark shim}@kdd.snu.ac.kr 002 J.-K Min is with the School of Computer Science and Engineering Korea University of Technology and Education Byeongcheon-myeon Cheonan Chungnam 330-708 Korea E-mail jkmin@koreatech.ac.kr Manuscript received 29 Mar 2016 revised 28 Nov 2016 accepted 7 Jan 2017 Date of publication 17 Jan 2017 date of current version 30 Mar 2017 Recommended for acceptance by F Li For information on obtaining reprints of this article please send e-mail to reprints@ieee.org and reference the Digital Object Identiﬁer below Digital Object Identiﬁer no 10.1109/TKDE.2017.2654459 IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING VOL 29 NO 5 MAY 2017 1031 1041-4347 001 2017 IEEE Personal use is permitted but republication/redistribution requires IEEE permission See http://www.ieee.org/publications_standards/publications/rights/index.html for more information 


a d dimensional space into 2 d child nodes whose regions are equi-sized However,our SKY-MR  divides a leaf node into 2 d child nodes with respect to a skyline point located in the region of the leaf node since one of its child nodes can always be pruned Furthermore among theskylinepointsintheregionoftheleafnode,we select the one such that the estimated number of checking dominance relationships between the pairs of points in the region is the smallest Effective Workload Balancing To balance the workloads of available machines in the local and global skyline phases we propose the workload balancing techniques to make the estimated execution times of all machines to be similar Since our workload balancing problem is the same as the multiprocessor scheduling problem  which is NP-Hard we use an effective approximation algorithm in Efﬁcient Local Skyline Computation Before computing the local skyline points it is desirable to remove as many nonskyline points as possible to decrease the local skyline computation overhead Thus we adapt the dominance-power ltering technique which maintains a set of dominating points that are expected to dominate many other points and we prune the points dominated by a dominating point To demonstrate the efﬁciency and scalability of our SKYMR   we compared SKY-MR  to MR-GPMRS  MR-BNL  PPF-PGPS and SKY-MR by implementing them as well as conducting extensive performance study on Hadoop Our experimental results conﬁrm that SKY-MR  is very efﬁcient and scalable compared to the other existing MapReduce algorithms including the state-of-the-art SKY-MR  2R ELATED W ORK After skyline processing was introduced in several serial algorithms for computing skylines and its variants were introduced in 3 18 19 20 21 22 23 24 25 However existing serial skyline algorithms utilizing centralized indexing structures such as B  trees and R 003 trees are not suitable to be parallelized using MapReduce since the MapReduce framework does not provide the functionality for building and accessing centralized indexing structures Although we focus on computing the skyline using MapReduce we still need a serial skyline algorithm to calculate the local skyline for each partition Thus among the serial skyline algorithms 18 24 25 without using centralized indexes we adopt the state-of-the-art algorithm BSkyTree-P  To split the data space into 2 d partitions BSkyTree-P rst selects a pivot point Then every point dominated by the pivot point is removed and BSkyTree-P recursively divides the partitions into sub-partitions until each partition contains at most one point It next merges the partitions and computes the local skyline of the merged partition repeatedly until there is a single partition and then the global skyline is obtained Recently skyline processing algorithms in distributed environments such as MapReduce 12 13 14 sensor networks and other distributed systems 26 27  29 have been proposed The MapReduce algorithms for probabilistic skyline queries 30 and subspace skyline queries are also proposed Among the above works we next illustrate MR-GPMRS  MR-BNL  PPF-PGPS  and SKY-MR  brieﬂy since they are the most relevant works to ours The details of the state-of-the-art algorithm SKY-MR will be presented in Section 3.3 While MR-GPMRS  consists of the partitioning and global skyline phases only MR-BNL  PPF-PGPS  and SKY-MR  are composed of the partitioning local skyline and global skyline phases In the partitioning phase the space is split into partitions by using sky-quadtree partitioning in SKY-MR  angle-based partitioning in PPFPGPS or grid partitioning in MR-GPMRS and MR-BNL In contrast to MR-GPMRS using two phases MR-BNL  PPFPGPS and SKY-MR compute the local skyline for each partition in the additional local skyline phase Then in the global skyline phase MR-GPMRS  MR-BNL  PPF-PGPS and SKYMR compute the global skyline Since MR-BNL uses only up to 2 d machines in the local skyline phase where d is the number of dimensions the machines participating in the MapReduce framework could not be fully utilized In addition since a single machine computes the global skyline MR-BNL is inefﬁcient when a large number of local skyline points are produced On the contrary SKY-MR utilizes all available machines at the local and global skyline phases Furthermore in the local skyline phase SKY-MR performs additional pruning by utilizing the dominance relationships between partitions It is shown in that SKY-MR outperforms MR-BNL  Since PPF-PGPS uses a single machine to compute the global skyline SKY-MR also shows better performance than PPF-PGPS  In addition SKY-MR is generally more efﬁcient than MR-GPMRS since MR-GPMRS does not have the local skyline phase Although the works in and 28 are not proposed for MapReduce since they can be processed with MapReduce we present them here The one-step and two-step algorithms in split the data space into grid partitions They next prune the partitions with no skyline point and compute the global skyline for every unpruned partition in parallel While both algorithms in split the data space into a xed number of grids SKY-MR varies the number of partitions adaptively based on the data distribution The algorithm PPPS in for multi-core machines utilizes the angle-based space partitioning PPPS recursively splits each partition into two partitions until the number of the partitions becomes the desired number of CPU cores c  The local skyline is next computed for every partition in parallel Finally PPPS performs a bottom-up merge in O  log  c  iterations until there remains a single partition only Since PPPS can utilize c 2 i cores only in the i th merging iteration multi-cores are not fully utilized However SKY-MR computes the global skyline by considering each partition independently and utilizing all available machines simultaneously As expected it is shown in  that SKY-MR is superior to the MapReduce implementations of the algorithms in and 28 3P RELIMINARIES 3.1 The Skyline Consider a d dimensional data set D f p 1 p 2   p j D j g A point p i is represented by h p i  1  p i  2    p i  d i where p i  k  is the k th coordinate of p i  A point p i dominates another point p j  denoted as p i 004 p j  if the following two conditions hold 1 for every k with 1 005 k 005 d  we have p i  k 005 p j  k  and 2 there exists k with 1 005 k 005 d such that p i  k  p j  k  holds We also denote that a point p i does not dominate another point p j as p i 6 004 p j  The skyline of D  represented by SL  D   is a subset of D where every point in SL  D  is not 1032 IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING VOL 29 NO 5 MAY 2017 


dominated by every other point in D  In other words SL  D f p i 2 D j  p j 2 D such that p j 004 p i g  The points in SL  D  are called the skyline points of D  Some notations used in this paper are summarized in Table 1 Example 3.1 Consider a bicycle data set D with the price and weight attributes in Fig 1a We plot every point in D into a 2-dimensional space in Fig 1b where x and y axes indicate the price and weight  respectively Since p 1  1  p 16  1  and p 1  2  p 16  2   p 1 dominates p 16 In addition p 1 is a skyline point since p 1 is not dominated by the other points In Fig 1b we plot every point in SL  D f p 1 p 3 p 5 p 7 p 12 g with a black circle 3.2 The MapReduce Framework MapReduce 1 or it s op en s ou rc e eq ui va le nt H ad oo p 1 7 is a widely used framework for data-intensive parallel computation in shared-nothing clusters of machines In Hadoop data is represented as key-value pairs Hadoop divides the input data to a MapReduce job into xed-size pieces called chunks and spawns a mapper task for each chunk The mapper task invokes a map function for each key-value pair in the chunk and the map function may output several key-value pairs The key-value pairs emitted by all map functions are grouped by keys in the shufﬂing phase and passed to reducer tasks to generate the nal output Users can control which key goes to which reducer task by modifying a Partitioner class For each distinct key the reduce task invokes a reduce function with the key and the list of all values sharing the key as input A reduce function may generate several key-value pairs Each mapper or reducer task can execute a setup function before invoking map or reduce functions and a cleanup function after executing all map or reduce functions Hadoop executes the main function on a single master machine 3.3 SKY-MR The State-of-the-Art Algorithm In this section we present the details of SKY-MR  which works with the three phases as follows 1 Sky-quadtree building phase SKY-MR builds a sky-quadtree with a sample of data to split the data space into several partitions The d dimensional data space is subdivided recursively into 2 d equi-sized sub-regions each of which is associated with a node of the sky-quadtree until each subregion contains at most a predeﬁned number of points r called the split threshold  According to the dominance relationships between the regions represented by nodes every node without any skyline point is marked as pruned 2 Local skyline phase For each unpruned leaf node n of the sky-quadtree  the local skyline of P  n   denoted by SL  P  n   is computed where P  n  is all points in the region represented by n  To reduce the number of checking dominance relationships between points in the next phase virtual max points and sky-ﬁlter points are computed after the local skylines are obtained The virtual max point vp n of a leaf node n is an artiﬁcial d dimensional point such that vp n  k  max p 2 SL  P  n  p  k  with 1 005 k 005 d  In each leaf node n  we also select a single local skyline point called a sky-ﬁlter point  which has the minimum value for every dimension 3 Global skyline phase Each local skyline point in every unpruned leaf node is checked whether it is a global skyline point or not by comparing it with the local skyline points in the region of the other unpruned leaf nodes When the total number of local skyline points is less than the size threshold d  a single machine is used to speed up SKY-MR rst collects all virtual max and sky-ﬁlter points of every leaf node If a local skyline point p located in the region of a leaf node is dominated by any sky-ﬁlter point p is discarded without comparing to the local skyline points of the other unpruned leaf nodes The number of checking dominance relationships between a pair of points can be even more reduced by utilizing the virtual max points  For an unpruned leaf node n  it is shown in that if a local skyline point p 0 in another leaf node n 0 does not dominate the virtual max point of the leaf node n i.e p 0 6 004 vp n  the point p 0 does not dominate every local skyline point in SL  P  n   Thus in every unpruned leaf node n  each local skyline point p in the region of n becomes a skyline point if p is not dominated by every local skyline point p 0 which dominates vp n and is in the region of the other unpruned leaf nodes Drawbacks of SKY-MR SKY-MR builds a sky-quadtree from a sample of data based on the user-deﬁned parameter split threshold which is the maximum number of points in each leaf node As the split threshold decreases the number of leaf nodes in the quadtree tends to increase and more points are allowed to be pruned by the dominance relationships between leaf nodes in the local skyline phase In contrast decreasing split threshold has an adverse effect on the network overhead by transmitting more duplicates of local skyline points to other leaf nodes in the global skyline phase Since there is a trade-off between the costs of the local and global skyline phases when a reasonable split threshold is not provided its performance suffers Furthermore since SKY-MR as well as the other MapReduce skyline algorithms 1  1 2  1 3 do no t co n si de r w or k lo ad b al an ci ng  th e pe r formances of the algorithms could degrade Finally there is TABLE 1 List of Notations Notation Description S A sample of d dimensional data D i.e S 006 D  SL  P  The skyline of a set of points P  vp n The virtual max point of a node n of sky-qtree  s or sky-quadtrees  region  n  The region covered by a node n of sky-qtree  s or sky-quadtrees  P  n  The set of points p 2 D located in region  n   S  n  The set of sampled points p 2 S located in region  n   C  n  The set of candidate split points p 2 SL  S  located in region  n  i.e C  n  SL  S  S  n   R  n  The set of all local skyline points which dominate vp n of a leaf node n and are located in the other leaf nodes i.e S n 0 6  n f p 0 2 SL  P  n 0 j p 0 004 vp n g  b t  Q  The estimated execution time of SKY-MR  with a sky-qtree  Q  Fig 1 An example of a skyline PARK ET AL EFFICIENT PROCESSING OF SKYLINE QUERIES USING MAPREDUCE 1033 


still a lot of room for improvement to reduce the communication and computation costs of the local skyline phase 4E FFICIENT P ARALLEL S KYLINE P ROCESSING To alleviate the weak points of SKY-MR mentioned previously we propose the parallel algorithm SKY-MR  to compute skylines using MapReduce efﬁciently as follows Adaptive Quadtree Building We develop an adaptive quadtree building algorithm which splits a node of a quadtree based on minimizing the estimated execution time of computing the local and global skyline points Effective Workload Balancing We propose the workload balancing algorithms for both local and global skyline phases to make the execution times of all available machines to be similar Efﬁcient Local Skyline Computation To remove as many non-skyline points as possible to decrease the local skyline computation overhead we adapt the dominance-power ltering  which maintains a set of dominating points that are expected to dominate many other points 4.1 Adaptive Quadtree Building The algorithm SKY-MR  utilizes an extension of a skyquadtree  called a sky-qtree   to partition and prune points Similar to a sky-quadtree  a region is represented by a node of a sky-qtree   When SKY-MR splits a leaf node of a sky-quadtree in a d dimensional space into 2 d child nodes whose regions are equi-sized  at most a single child node can be pruned by comparing the dominance relationships between every pair of its child nodes On the contrary our SKY-MR  splits a leaf node into 2 d child nodes with respect to a skyline point located in the region of the leaf node Let region  n  be the region represented by a node n of a sky-qtree   Consider a node n of a sky-qtree  whose region is region  n h n:min  1   n:max  1 007     n:min  d   n:max  d 007i where  n:min  k   n:max  k 007 is the k th dimensional range Let n:min and n:max be h n:min  1     n:min  d i and h n:max  1     n:max  d i  respectively After splitting n with respect to a skyline point p  there is a child node n r of n which represents the region region  n r h p  1   n:max  1 007     p  d   n:max  d 007i i.e n r min  p  Since all points located in region  n r  are dominated by p  every point in region  n r  is not a skyline point Thus by splitting a leaf node into 2 d child nodes with respect to a skyline point SKY-MR  can always prune the child node n r among its 2 d child nodes In contrast to a sky-quadtree  the user-deﬁned parameter split threshold is not required to build a sky-qtree   When we build a sky-qtree   we have to consider two aspects for splitting a leaf node 1 which skyline point in the sample to select in the leaf node and 2 whether to split the leaf node or not To decide whether a leaf node n is to be split or not we rst select a split point based on the number of checking dominance relationships between pairs of points in region  n  locally After a split point p in region  n  is decided we evaluate the global effect of splitting region  n  with respect to p based on the estimated execution times of the local and global skyline phases in SKY-MR   If splitting n by p is beneﬁcial we split the node n  We next discuss each aspect in more details and present how to build a sky-qtree   Selecting a Split Point As mentioned earlier for a leaf node n  we select a skyline point located in region  n  as the split point of n  Since we build a sky-qtree  from a sample S of D  we select a split point among the skyline points in S  Given a node n of a sky-qtree   let S  n  and C  n  be the set of sampled points in region  n  and the set of skyline points among the sampled points in region  n   respectively We consider each skyline point in C  n  as a candidate split point of n  Selecting a split point among the skyline points in C  n  affects the performance of SKY-MR   To minimize the computational overhead of building a sky-qtree   we select the skyline point p 2 C  n  which minimizes the number of checking dominance relationships between pairs of points in S  n   If we compute the exact number of checking dominance relationships between pairs of points in D after splitting n by p  it is expensive Thus we estimate how many checking dominance relationships between pairs of the points in S  n  can be avoided by splitting n by p  Recall that as presented in Section 3.3 we do not check the dominance relationships between a local skyline point p 0 of a node n 0 and every local skyline point of another node n if p 0 does not dominate the virtual max point of n i.e p 0 6 004 vp n  In addition since every point in a node n 00 marked as pruned cannot be a skyline point we do not check the dominance relationships between each point of n 00 and every other point in D  To nd the split point of a node n  we rst split n into child nodes with respect to p  for each candidate split point p 2 C  n   Then for each child node n c of n  we compute the sample virtual max point  denoted by  vp n c  where  vp n c  k  max p 0 2 C  n c  p 0  k  with 1 005 k 005 d  The estimated number of checking dominance relationships reduced by splitting n with respect to p  denoted by comp  n p   is computed as comp  n p  X p 0 2 S  n  X n c 2 n:child 010f n r g  n c 6  n  p 0  p 0 6 004  vp n c j S  n c j j S  n r j 011 j S  n j 010 1    1  where n:child is the set of the child nodes of n split by p  n  p 0  is the child node of n whose region contains p 0 and n r is the pruned child node of n i.e n r min  p  The rst term of comp  n p  adds the number of points in each unpruned node n c 2 n:child 010f n r g such that n c 6  n  p 0  for every point p 0 2 S  n  which does not dominate  vp n c  The second term of comp  n p  denotes the number of checking dominance relationships between each point of the pruned node n r satisfying n r min  p and every other point Finally the point with the maximum comp  n p  among the points in C  n  is selected as the split point of n which is denoted by sp  n  i.e sp  n  arg max p 2 C  n  comp  n p   Example 4.1 Suppose that a sample S f p 2 p 4 p 6 p 8 p 10  p 12 p 14 p 16 g of data D in Fig 1a is inserted into the root node n 0 of a sky-qtree   The sample points in the region of n 0 are plotted in Fig 2a The skyline of S is SL  S  f p 2 p 4 p 8 p 10 p 12 p 14 g and the skyline points become the candidate split points of n 0 i.e SL  S  C  n 0   If n 0 is split with respect to p 4 into n 1  n 2  n 3 and n 4  S is split into S  n 1 f p 4 g  S  n 2 f p 2 p 10 p 14 p 16 g  S  n 3 f p 8 p 12 g and S  n 4 f p 6 g as shown in Fig 2b Since C  n 2  f p 2 p 10 p 14 g  the sample virtual max point of n 2 is  vp n 2  h 5  9 i  We do not check whether p 4 dominates the points in S  n 2  because p 4 does not dominate  vp n 2  Thus we save 4  j S  n 2 j comparisons For every sample point except p 6  since p 6 is located in the pruned node n 4 wedo not check whether it dominates p 6  Since comp  n 0 p 4  42 012 comp  n 0 p i  holds for every p i 2 C  n 0   we select p 4 as the split point of n 0  1034 IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING VOL 29 NO 5 MAY 2017 


Splitting a Node Similar to SKY-MR  when the number of the leaf nodes in a sky-qtree  becomes large our SKY-MR  prunes more points in the local skyline phase However since the virtual max  sky-ﬁlter and local skyline points of an unpruned node should be sent to the machines which compute the global skyline points of the other unpruned leaf nodes a large number of leaf nodes result in large network overhead While constructing a sky-qtree  recursively we thus determine to split a leaf node n or not judiciously based on the estimated execution time of the local and global skyline phases in SKY-MR   We denote the estimated execution time of both phases in SKY-MR  with a sky-qtree  Q as b t  Q   How to calculate b t  Q  will be presented in the Section 4.2.4 For a leaf node n  let Q and Q 0 be the sky-qtree  s before splitting n and after splitting n by its split point sp  n   respectively If splitting the leaf node n by sp  n  is beneﬁcial i.e b t  Q   b t  Q 0   we split n by sp  n   Building a sky-qtree   We initially generate a sky-qtree  with a root node n 0 only and insert a sample S of D into the root node We next compute the candidate split points of n 0 i.e C  n 0  SL  S   and annotate them with the root node We also produce a max-heap consisting of the root node with the number of points in S  n 0  i.e j S  n 0 j  as its key We maintain the max-heap with the leaf nodes to split where the number of the sampled points i.e j S  n j  serves as the key of each leaf node n  We repeatedly select a node to split and split the node if the estimated execution time of the local as well as global skyline phases in SKY-MR  with the current sky-qtree  is larger than that with the expanded sky-qtree  by splitting the node Since the execution times of the local and global skyline computations with the points belonging to the region of a leaf node n i.e P  n   is likely to be proportional to j P  n j  if the node whose region contains a large number of points is split into leaf nodes we have a high chance of having similar numbers of points in all leaf nodes and thus the workload of every machine can be more balanced Thus to select a leaf node to be split we choose the leaf node among available leaf nodes whose region contains the maximum number of the sampled points To nd such a leaf node quickly we extract the leaf node from the root of the max-heap When splitting a node n  we select a point p with the maximum comp  n p  deﬁned by Equation 1 among the points in C  n  as the split point sp  n  and split the node into 2 d nodes based on the split point p  Among its 2 d child nodes the child node n r such that n r min  p is marked as pruned since every point in region  n r  is dominated by p  Furthermore we distribute C  n  and S  n  into its 2 d child nodes based on their covered regions For each unpruned child node n c of n if j C  n c j  0 or n c max  p note that it is not n c min  we do not split the node n c anymore since there is no candidate split point in region  n c   Otherwise we insert n c into the max-heap to check later whether splitting n c is beneﬁcial or not We repeatedly conduct the above steps until there is not any leaf node in the max-heap In other words when there is not any leaf node which improves the estimated execution time by splitting we stop splitting a leaf node and terminate the generation of the sky-qtree   Example 4.2 Recall that the point p 4 was the split point of the root node n 0 of the sky-qtree  in Example 4.1 Assume that splitting n 0 with respect to p 4 is better than no splitting n 0 based on the estimated execution time of the local and global skyline phases in SKY-MR   Then we split n 0 into its child nodes n 1  n 2  n 3 and n 4 as shown in Fig 2b Since n 4 min  p 4 h 6  3 i  we mark n 4 as pruned Furthermore since n 2 has more sampled points in its region than n 1 and n 3 i.e S  n 2 012 S  n 3 012 S  n 1   we choose p 14 as the split point of n 2 because it has the maximum comp  n 2 p  among candidate split points p in C  n 2   Suppose that splitting n 2 by its split point p 14 reduces the estimated execution time of the local and global skyline phases than no splitting n 2  Then we split n 2 with respect to p 14  For each n of unpruned leaf nodes assume that splitting n by sp  n  is always worse than no splitting Then the nal sky-qtree  becomes the one shown in Fig 2c 4.2 Effective Workload Balancing Since the local and global skyline phases of SKY-MR  utilize MapReduce we next develop the workload balancing techniques to minimize the execution times of both phases 4.2.1 Estimating the Number of Skyline Points Before we estimate the execution times of computing the local and global skyline points we rst estimate the number of the local skyline points in the region of each leaf node in a sky-qtree  by utilizing the skyline cardinality estimation method based on the log sampling technique It assumes that the number of skyline points in D is A log B j D j where A and B are constants To nd the proper values of A and B  we utilize the sample S used to build the skyqtree   As suggested in we rst divide S into S 1 and S 2  and next calculate their skylines SL  S 1  and SL  S 2   Since we have two equations j SL  S 1 j  A log B j S 1 j and j SL  S 2 j  A log B j S 2 j  the values of the constants A and B are calculated as follows B  log j SL  S 2 j 010 log j SL  S 1 j log  log j S 2 j 010 log  log j S 1 j A  j SL  S 1 j log B j S 1 j   2  For a leaf node n  let S  n  and P  n  be the sets of sampled points in S and data points in D belonging to region  n   respectively By assuming j P  n j  j S  n j j D j j S j  we estimate the number of the local skyline points contained in region  n  as A log B j P  n j  Example 4.3 Assume that the sample S in Example 4.1 is split into S 1 f p 4 p 6 p 8 p 10 p 14 p 16 g and S 2 f p 2 p 12 g  Then SL  S 1 f p 4 p 8 p 10 p 14 g and SL  S 2 f p 2 p 12 g  Since j S 1 j 6  j S 2 j 2  j SL  S 1 j  4 and j SL  S 2 j  2 we have B  log  2  010 log  4    log  log  2 010 log  log  6   0  72 and A  4  log 0  72  6  4  8 according to Equation 2 Thus for the data D in Fig 1a the estimated size of the skyline j SL  D j becomes A log B j D j  5  5  We next discuss how to balance the workloads of available machines for both local and global skyline phases   Fig 2 An example of building a sky-qtree   PARK ET AL EFFICIENT PROCESSING OF SKYLINE QUERIES USING MAPREDUCE 1035 


4.2.2 Workload Balancing for the Local Skyline Phase Inthelocalskylinephase,foreachunprunedleafnode n of the sky-qtree   a reduce function is called with n and the set of data points in D belonging to region  n  i.e P  n   We next compute the local skyline of P  n  i.e SL  P  n   Execution Time of the Local Skyline Phase Since the execution time of computing the local skyline of P  n  tends to grow as the number of points in P  n  as well as the number of local skyline points in SL  P  n  increase we estimate the execution time of a reduce function by j SL  P  n j 011 j P  n j for computing the local skyline Assume that there are m machines and a set of leaf nodes L i f n i 1 n i 2   n i j L i j g is assigned to the i th machine to compute the local skyline SL  P  n i j  for every n i j 2 L i  The execution time of the machine is proportional to the value of P n 2 L i j SL  P  n j 011 j P  n j  Since every machine computes the local skylines in the regions of its assigned nodes independently in parallel the execution time of the local skyline phase is equal to the longest execution time of the machines i.e max m i  1  P n 2 L i j SL  P  n j 011 j P  n j  Balancing Workloads of All Machines To minimize the estimated execution time of the local skyline phase by utilizing j SL  P  n j  A log B j P  n j and j P  n j  j S  n j j D j j S j in Section 4.2.1 we deﬁne the following problem Deﬁnition 4.4 Local Workload Balancing Problem Let N  Q f n 1   n j N  Q j g be the set of all unpruned leaf nodes of a sky-qtree  Q and m be the number of machines available By letting j SL  P  n j  A log B j P  n j and j P  n j  j S  n j j D j j S j  the problem is to nd a set of disjoint leaf node groups L  Q f L 1  Q    L m  Q g such that L 1  Q 011\011\011 L m  Q  N  Q  and max m i  1  P n 2 L i  Q  j SL  P  n j 011 j P  n j is minimized This problem is equivalent to the well-known multiprocessor scheduling problem which is NP-Hard Since the longest processing time LPT algorithm is an approximation algorithm running in linearithmic i.e O j N  Q j log j N  Q j  time for this problem we adapt LPT algorithm to solve our local workload balancing problem In our modiﬁed LPT algorithm every machine is initially not associated with any leaf node The estimated execution time of a machine is calculated as the sum of those of all leaf nodes assigned to the machine Thus the estimated execution time of every machine is initially set to zero We next sort the unpruned leaf nodes n by the decreasing order of their estimated execution times computed by j SL  P  n j 011 j P  n j We next examine each leaf node in the sorted list one by one While examining each leaf node we assign it to the machine with the smallest estimated execution time In 1  th e approximation ratio of LPT algorithm is shown to be 4  3 010 1   3 m  where m is the number of machines available 4.2.3 Workload Balancing for the Global Skyline Phase Similar to SKY-MR  in the global skyline phase when the total number of local skyline points is small SKY-MR  utilizes a serial algorithm to compute the global skyline on a single machine When the total number of local skyline points is large SKY-MR  computes the global skyline using MapReduce and thus the workload balancing is required Execution Time of the Global Skyline Phase In the global skyline phase a reduce function is called for each unpruned leaf node n 2 N  Q  where N  Q  is the set of all unpruned leaf nodes of a sky-qtree  Q  The input of the reduce function consists of two types of points 1 the local skyline points in the region of n i.e SL  P  n   and 2 the local skyline points which not only are in other leaf nodes but also dominate the virtual max point of n  We denote the point set of the second type as R  n  i.e R  n  S n 0 2 N  Q  n 0 6  n f p 0 2 SL  P  n 0 j p 0 004 vp n g  Each reduce function requires O j SL  P  n j 011 j R  n j time to check whether each local skyline point p in SL  P  n  is a global skyline point based on the dominance relationship between p and every local skyline point p 0 in R  n  Thus,we estimate the execution time of each reduce function called with a leaf node n as j SL  P  n j 011 j R  n j  To estimate the execution time of the local skyline phase since SL  P  n  of every leaf node n is not known before the local skyline phase we utilized the estimated value of j SL  P  n j  A log B j P  n j previously However to estimate the execution time of the global skyline phase we can utilize the exact values of j SL  P  n j s by counting the number of the local skyline points for every leaf node n in the local skyline phase However to compute j R  n j in the local skyline phase we have to examine every local skyline point p in the region of other leaf nodes to check whether p dominates vp n  Since such counting is very expensive we estimate j R  n j with the upper bound of j R  n j by using the following deﬁnition and lemma Deﬁnition 4.5 A point p i is said to strongly dominate another point p j  denoted as p i 004 004 p j  if and only if p i  k  p j  k  holds for 1 005 k 005 d  Lemma 4.6 Given a set of all unpruned leaf nodes N  Q  of a sky-qtree  Q and a leaf node n 2 N  Q   if we let up j R  n j  X n 0 2 N  Q  n 0 6  n;n 0 min 004 004 n:max j SL  P  n 0 j  we have up j R  n j 012 j R  n j  Proof When a point p 0 is in the region of a leaf node n 0 we have n 0 min  k  p 0  k 005 n 0 max  k  for every dimension k  1   d by the deﬁnitions of n 0 min and n 0 max in Section 4.1 If the point p 0 dominates vp n  we have n 0 min  k  p 0  k 005 vp n  k 005 n:max  k  for every dimension k and n 0 min strongly dominates n:max  Thus we obtain  n 0 2 N  Q  n 0 6  n n 0 min 004 n:max SL  P  n 0  013  n 0 2 N  Q  n 0 6  n f p 0 2 SL  P  n 0 j p 0 004 vp n g  From the above relationship and the fact that SL  P  n 0  s are disjoint for every leaf node n 0  we have up j R  n j  X n 0 2 N  Q  n 0 6  n n 0 min 004 004 n:max j SL  P  n 0 j 012 j R  n j  t u Similar to the local skyline phase the execution time of the global skyline phase is the longest execution time of the machines i.e max m i  1  P n 2 G i  Q  j SL  P  n j 011 up j R  n j  Balancing Workloads of All Machines We next deﬁne the workload balancing problem of the global skyline phase Deﬁnition 4.7 Global Workload Balancing Problem Let N  Q f n 1   n j N  Q j g be the set of all unpruned leaf 1036 IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING VOL 29 NO 5 MAY 2017 


nodes of a sky-qtree  Q and m be the number of machines available The problem is to nd a set of disjoint leaf node groups G  Q f G 1  Q    G m  Q g such that G 1  Q 011\011\011 G m  Q  N  Q  and max m i  1  P n 2 G i  Q  j SL  P  n j 011 up j R  n j is minimized To balance the workloads of machines in the global skyline phase the main function collects the number of the local skyline points in each unpruned leaf node n i.e j SL  P  n j  and computes up  R  n   After estimating the workload of each machine we adapt LPT algorithm again Since our approximation algorithm for the global skyline phase is the same as that for the local skyline phase except that j P  n j is substituted by up j R  n j  we omit the details of applying LPT algorithm here for the global skyline phase 4.2.4 Estimating the Execution Times of the Local and Global Skyline Phases for the Sky-qtree  Building Phase While building a sky-qtree  recursively we determine to split a leaf node n or not judiciously based on the estimated execution time of the local and global skyline phases in SKY-MR   Given a sky-qtree  Q and m available machines we deﬁne the estimated execution time of processing both local and global skyline phases of SKY-MR   denoted by b t  Q  as b t  Q  max i  1   m X n 2 L i  Q  j SL  P  n j 011 j P  n j 0  1 A  max i  1   m X n 2 G i  Q  j SL  P  n j 011 up j R  n j 0  1 A   3  where the former and latter terms represent the estimated execution times of the local and global skyline phases presented in Sections 4.2.2 and 4.2.3 respectively While we build a sky-qtree  in the rst phase since the exact value of j SL  P  n j for each leaf node n is not known we utilize the approximation of j SL  P  n j  A log B j P  n j to estimate the execution time of the global skyline phase as we did for workload balancing of the local skyline phase previously We now show how to decide whether splitting a node is beneﬁcial or not in terms of the estimated execution time Example 4.8 Consider again Example 4.1 in which p 4 is the split point of the root node n 0 of the sky-qtree  in Fig 2a Assume that we have two machines i.e m  2  When n 0 is not split the estimated execution time of the local skyline phase is 88 since the estimated size of P  n 0  is j S  n 0 j 011 j D j  j S j 16 and j SL  P  n 0 j is estimated as A log B j P  n 0 j  5  5 by using A  4  8 and B  0  72 computed in Example 4.3 The estimated execution time of the global skyline phase is j SL  P  n 0 j 011 up j R  n 0 j  0 since there is a single leaf node i.e the root node n 0  and up j R  n 0 j is 0 by the deﬁnition Thus the total estimated execution time of both phases is 88 Meanwhile when n 0 is split with p 4 as shown in Fig 2b the estimated execution times of computing the local skylines of the unpruned leaf nodes n 1  n 2 and n 3 are 4 36 and 13.2 respectively Then by LPT algorithm the task of computing the local skyline of n 2 is assigned to a machine while those of both n 1 and n 3 are allocated to the other machine Thus the estimated execution time of the local skyline phase is max  36  4  13  2  36  The values of up j R  n 1 j  up j R  n 2 j and up j R  n 3 j are 0 2 and 2 respectively since n 1 min strongly dominates n 2 max and n 3 max as well as j SL  P  n 1 j  2  Thus the estimated execution times of computing the global skyline i.e j SL  P  n j 011 up j R  n j f n 1  n 2 and n 3 become 0 9 and 6.6 respectively because j SL  P  n 1 j  A log B j P  n 1 j  2  j SL  P  n 2 j  4  5 and j SL  P  n 3 j  3  3 where A  4  8 and B  0  72  By utilizing LPT algorithm again the estimated execution time of the global skyline phase becomes max  9  0  6  6  9 and thus the estimated total execution time of the local and global skyline phases is 43 Since the estimatedtotalexecutiontimewiththeexpanded skyqtree  is less than that with the current sky-qtree  we split n 0 by p 4  4.3 Dominance Power Filtering Although the dominance power ltering  is proposed for computing probabilistic skylines we adapt it to our skyline computation problem The dominance power of a point is the volume of the region dominated by the point Since a point p is likely to dominate more points than another point q if the volume of the region dominated by p is larger than that of q  the dominance power of a point p is an effective measure to represent the number of points dominated by p  Deﬁnition 4.9 Consider a d dimensional space h 0 b  1 007     0 b  d 007i where  0 b  k 007 is its range of the k th dimension For a point p h p  1    p  d i  the dominance power of p is dom  p  Q d i  1  b  i 010 p  i   In the local skyline phase each mapper task M i keeps a dominating point set F i with k points to check whether every point p in data D i  014 D  assigned to the mapper task M i is dominated by the points in F i If p is dominated by a point in F i  p is not a skyline point Otherwise p is inserted into the unpruned point list U i which keeps unpruned points in D i by the mapper task M i  To maintain the k points in F i with the largest dominating powers and identify non-skyline points at the same time in each mapper task M i  we utilize a min-heap H i to store the dominating points of F i where their dominance powers serve as their keys The setup function of each mapper task M i initializes the min-heap H i and the unpruned point list U i  Then the map function invoked with a point p 2 D i checks if p is dominated by a point q in H i  Whenever q 004 p holds the map function stops immediately since p is not a skyline point Otherwise we insert p into U i and update H i according to the dominance power of p  When H i is updated with p  if the number of points in H i is less than k  we insert p into H i If H i is full i.e j H i j k  and the dominance power of p is greater than that of the point q 0 in the root of min-heap H i i.e dom  p   dom  q 0   q 0 is deleted from H i and p is inserted into H i with dom  p  as its key Example 4.10 Consider the data D in Fig 1a and assume that the mapper task M i processes D i f p 1 p 2 p 3 p 4 g and the maximum size of the dominating point set is 2 In the local skyline phase the setup function rst initializes an empty min-heap H i and the unpruned point list U i  Then the map function called with p 1 inserts p 1 into H i with dom  p 1  18 as its key as well as U i  A map function is next called with p 2  Since p 1 6 004 p 2 holds and H i is not full p 2 is also appended into U i and inserted into H i with dom  p 2  25 as its key PARK ET AL EFFICIENT PROCESSING OF SKYLINE QUERIES USING MAPREDUCE 1037 


Since every non-skyline point identiﬁed by computing the skyline points in U i cannot be a global skyline point after all map functions are nished each mapper task M i computes the skyline SL  U i  of U i independently In the reduce phase we compute the local skyline of every unpruned leaf n in parallel by considering all points in S i SL  U i  which belongs to the region of n  Note that using SL  U i  s only in the reduce phase decreases not only local skyline computation but also the network overhead between the map and reduce phases of the local skyline phase 4.4 SKY-MR Our Skyline Computation Algorithm By utilizing the proposed techniques in Sections 4.1 4.2 and 4.3 we develop the MapReduce algorithm SKY-MR  whose pseudocode is in Fig 3 Similar to SKY-MR  SKY-MR  consists of the sky-qtree  building lines 1-2 in Fig 3 local skyline lines 3-5 and global skyline phases lines 6-12 Sky-qtree  Building Phase After producing a sample S from data D line 1 in Fig 3 we invoke the procedure SKYQTREE  with the sample S and the number of machines m line 2 to build a sky-qtree  as described in Section 4.1 The pseudocode of SKY-QTREE  is presented in Fig 4 After calculating the parameters A and B by Equation 2 line 1 in Fig 4 it initializes a sky-qtree  Q and a max-heap M lines 2-6 Every node n of the sky-qtree  has two attributes S and C to keep the sample points and the candidate split points in region  n   respectively The candidate split points of the root node n is set to the skyline of S by invoking BSkyTree-P  line 4 By Equation 3 it next computes the estimated total execution time b t  Q  of the local and global skyline phases line 7 For each leaf node n extracted from the max heap M we check whether n is to be split or not lines 9-13 The candidate split point s in C  n  with the number of checking dominance relationships reduced the most by splitting n by s is selected as the split point line 10 Let Q and Q 0 be the skyqtree  s before splitting n and after splitting n by s  respectively If b t  Q 0 012 b t  Q   we decide not to split n  Otherwise i.e b t  Q 0   b t  Q   the node n is split lines 14-16 After splitting n  for each n s child node n c if region  n c  min  s  we mark n c as pruned Otherwise if j C  n c j 6  0 and region  n c  max 6  s  we insert n c into the heap M to be considered later lines 17-24 When the max heap is empty the sky-qtree  Q is returned Local Skyline Phase By calling the procedure LocalBalance  SKY-MR  assigns each leaf node to a machine by our workload balancing algorithm in Section 4.2.2 line 3 in Fig 3 After the sky-qtree  Q and leaf node assignment A L are broadcast the MapReduce algorithm L-SKY-MR  nds the local skyline for all unpruned leaf nodes of Q lines 4-5 The pseudocode of L-SKY-MR  is given in Fig 5 The setup function of each mapper task M i initializes a minheap H i for the dominance power ltering and a list U i to store the points not pruned by the dominance power ltering The sky-qtree  Q and the workload assignment A L broadcast by SKY-MR  are also loaded into the main memory lines 1-4 of L-SKY-MR  setup Then each map function is called with a point p If p belongs to the region of an unpruned leaf node n p of Q and p is not dominated by every dominating point in H i  p is added into U i and H i is updated with p lines 1-4 of L-SKY-MR  map After all map functions are nished the cleanup function of M i computes the skyline SL  U i  of U i by utilizing BSkyTree-P  line 1 of L-SKY-MR  cleanup It next emits the key-value pair h m id n p  p i for each skyline point p 2 SL  U i  to get the local skyline of the region of n p where n p is the leaf node containing p and m id is the id of the machine allocated by the assignment A L lines 2-5 By modifying the Partitioner class in Hadoop in the shufﬂing phase the key-value pairs with the same m id emitted by all mapper tasks are gathered in the same machine For each distinct machine id m id  a reduce function is next invoked to output the local skyline SL  n  computed by calling BSkyTree-P with every leaf node n assigned to the machine with id m id lines 1-2 of L-SKY-MR  reduce The virtual max point and the sky-ﬁlter points for pruning in the global skyline phase are obtained by invoking the procedures VirtualMax and SkyFilter  respectively and output to the les in HDFS The number of local skyline points is also emitted to the le in HDFS to use for the workload balancing of the global skyline phase lines 3-5 Example 4.11 Consider the data D in Fig 1a and the skyqtree  in Fig 2c Figs 6a 6b and 6c show an example of the data ow in the local skyline phase of SKY-MR   By applying the workload balancing the tasks to compute the local skylines of all unpruned leaf nodes in the sky-qtree  are assigned to the machines as shown on top of Fig 6b Assume that D consists of two chunks Fig 3 The SKY-MR  algorithm Fig 4 The SKY-QTREE  algorithm 1038 IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING VOL 29 NO 5 MAY 2017 


D 1 f p 1   p 8 g and D 2 f p 9   p 16 g  Suppose that only p 4 is pruned by the dominance power ltering among the points in D 1 Thepoint p 6 is removed since p 6 belongs to the pruned leaf node n 4 of the sky-qtree   The point p 2 and p 8 are removed by the local skyline computationinthecleanupfunctionofthemapper task for D 1  Similarly we obtain  p 9  p 10  p 12  p 15 as the skyline of the chunk D 2  The key-value pairs output by each mapper task and shufﬂing phase are shown in Figs 6a and 6b respectively After the shufﬂing phase for each unpruned leaf node n areduce functioncomputesthelocalskylinein region  n  For example the reduce function with the key  2 n 6  outputs the local skyline f p 1 g Fig.6cshowstheoutputs ofthereducefunctions.Forsimplicity,thesky-ﬁlter points are not shown Global Skyline Phase If the total number of local skyline points is small less than a size threshold d  we utilize a single machine algorithm G-SKY to compute the global skyline line 7 in Fig 3 Otherwise the procedure GlobalBalance groups the leaf nodes for workload balancing as explained in Section 4.2.3 After broadcasting the sky-qtree   leaf node assignment virtual max points and sky-ﬁlter points we nally calculate the global skyline by invoking the MapReduce procedure G-SKY-MR  lines 9-12 We provide the pseudocode of G-SKY-MR  in Fig 7 The setup function loads the sky-qtree   leaf node assignment virtual max points and sky-ﬁlter points into main memory lines 1-4 of G-SKY-MR  setup Then each map function called with a local skyline point p discards p if p is dominated by any sky-ﬁlter point line 1 in G-SKY-MR  map Otherwise the key-value pair h m id   C n p p i is emitted where n p is the leaf node containing p  m id is the id of the machine assigned to compute the global skyline located in region  n p  and the symbol C represents that p is the local skyline point in region  n p  lines 2-4 The map function next checks whether p is required to compute the global skyline points belonging to the regions of other leaf nodes n  except n p If p dominates the virtual max point of another leaf node n   p is required to compute the global skyline points belonging to the region of n  and thus the key-value pair h m 0 id   D n p p i is emitted where m 0 id is the id of the machine to calculate the global skyline of n  and the symbol D indicates that p may dominate the local skyline points in region  n   If p dominates the virtual max points of several leaf nodes allocated to the same machine with id m 0 id  since the local skyline point p can be shared for such leaf nodes assigned to the machine we emit the key-value pair h m 0 id   D n p p i once for the set of such leaf nodes dedicated to the machine lines 6-11 Similar to the local skyline phase by overriding Partitioner class all key-value pairs with the same m id are grouped together in the shufﬂing phase A reduce function is called for each m id and its value list L consisting of two types of local skyline points 1 the local skyline points in the region of every leaf node allocated to the machine m id i.e marked as C and 2 the local skyline points in leaf nodes which dominate the virtual max point of the leaf node assigned to the machine i.e marked as D The reduce function invoked with m id splits its value list L into two lists L C and L D containing the local skyline points marked as C and D respectively line 1 in G-SKYMR  reduce Let G m id  Q f g 1   g j G m id  Q j g be the set of the leaf nodes of the sky-qtree  Q handled by the machine with id m id  The reduce function further splits L C into L N C  g 1    L N C  g j G m id  Q j  where L N C  g i f p 2 L C j p 2 region  g i g  For the set of all unpruned leaf nodes of Q denoted by N  Q f n 1   n j N  Q j g  we similarly divide L D into L N D  n 1    L N D  n j N  Q j  where L N D  n i f p 2 L D j p 2 region  n i g lines 2-3 Recall that a local skyline point p in L N C  g i  of a leaf node g i 2 G m id  Q  is a global skyline point if it is not dominated Fig 5 The L-SKY-MR  algorithm Fig 6 An example of the data ow in the local and global skyline phases of SKY-MR   PARK ET AL EFFICIENT PROCESSING OF SKYLINE QUERIES USING MAPREDUCE 1039 


by every point in L N D  n 0  of all other leaf nodes n 0 2 N  Q   To avoid unnecessary dominance relationship checks between every pair of points in L N C  g i  and L N D  n 0   we use the virtual max point vp g i of L N C  g i   More speciﬁcally if a point p 0 in L N D  n 0  does not dominate vp g i  since p 0 cannot dominate every point p 2 L N C  g i   we can skip the dominance relationship checks with all points in L N C  g i  for the point p 0 line 8 After eliminating non-skyline points in L N C  g i  by comparing with all points in L N D  n 0   we update the virtual max point vp g i with the remaining points in L N C  g i  to avoid the dominance relationship checks even further line 11 After we evaluate every pair of points in L N C  g i  and L N D  n 0  for all other leaf nodes n 0  we obtain the global skyline point in L N C  g i  lines 4-13 Example 4.12 Reconsider the outputs of the local skyline phase in Example 4.11 Figs 6d 6e and6f illustrate an example data ow in the global skyline phase of SKYMR   The main function assigns each leaf node with at least a local skyline point to a machine based on the estimated execution time of calculating the global skyline The estimated execution time of computing the global skyline of n 6 is j SL  P  n 6 j 015 j SL  P  n 1 j  j SL  P  n 5 j  3 since n 1 min and n 5 min strongly dominate n 6 max  Similarly those of n 1  n 3 and n 5 are 0 4 and 2 respectively LPT algorithm allocates n 1 and n 3 to the same machine while assigning n 5 and n 6 to the other machine Each map function checks whether a local skyline point is dominated by any sky-ﬁlter point Since p 15 is dominated by the sky-ﬁlter point p 5  the point p 15 is discarded The map function called with p 5 emits the keyvalue pair h 1   C n 1 p 5 i because p 5 is in region  n 1  and n 1 is assigned to the machine with id 1 Since p 5 dominates the virtual max point of n 3 assigned to the machine with id 1 it also emits h 1   D n 1 p 5 i  The key-value pairs after the shufﬂing phase are shown in Fig 6e After every reduce function calculates the global skyline among the points marked as C we obtain the skyline f p 1 p 3 p 5 p 7 p 12 g  5E XPERIMENTS In this section we present the performance of our algorithm SKY-MR  by comparison with the existing algorithms  13 14 27 28 5.1 Experimental Environments We empirically evaluated the performance of the tested algorithms using the parameters as summarized in Table 2 One machine with Intel Xeon E5-2407 2.2 GHz CPU and 8 GB of memory served as the master node while 40 machines with Intel i3 3.3 GHz CPU and 4 GB of memory were the slave nodes The implementations of all algorithms presented in Table 3 were compiled by Javac 1.7 and we used Hadoop 1.2.1 for MapReduce We got the source code of MRGPMRS used in and rewrote the code with a minor optimization We also got the source code of BSkyTree-P used in  and adopt it to compute the local skyline s in SKY-MR  as mentioned in Section 4.4 In our experiments we do not report the execution times which exceed 10 hours Data Sets For our experimental study we evaluate the algorithms on synthetic data sets as well as a real-life data set We randomly generated the synthetic data sets by anticorrelated  independent and correlated distributions referred Fig 7 The G-SKY-MR  algorithm TABLE 2 Parameters Parameter Range Default value No of samples  j S j  100 016 10  000 400 for SKY-MR  200 for SKY-MR No of dominating points  k  10 016 1  000 100 for SKY-MR  Split threshold  r  10 016 40 10 for SKY-MR No of points  j D j  10 7 016 4 015 10 9 2 015 10 8 No of dimensions  d  2 016 12 6 No of machines  m  10 016 40 20 TABLE 3 Implemented Skyline Algorithms Algorithm Description SKY-MR  Our proposed algorithm adaptively selects G-SKY-MR  or G-SKY with respect to the number of local skyline points If it is less than 3 015 10 5  G-SKY is selected i.e d  3 015 10 5  SKY-MR  KD SKY-MR  utilizing a k-d tree instead of a sky-qtree   SKY-MR The state-of-the-art using MapReduce in MR-GPMRS The MapReduce algorithm in MR-BML The MapReduce algorithm in PPF-PGPS The MapReduce algorithm in STEP-1-MR The MapReduce implementation of the 1-step algorithm in STEP-2-MR The MapReduce implementation of the 2-step algorithm in PPPS-MR The MapReduce implementation of PPPS algorithm in 1040 IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING VOL 29 NO 5 MAY 2017 


to as ANTI  IND and COR respectively which are typically used to evaluate the performance of the skyline algorithms 12 13 14 The sizes of the resulting synthetic data sets are varied from 76 MB to 295 GB depending on the number of points  j D j  and the number of dimensions  d  We reported the number of skyline points with varying the number of dimension  d  for each data set when j D j 2 015 10 8 in Table 4 As d increases the number of skyline points increases exponentially for ANTI and IND data sets However for COR data set the number of skyline points increases linearly We also utilized HEPMASS available from http://archive.ics.uci.edu/ml datasets/HEPMASS to check the performance of the algorithms on real-life data HEPMASS data set contains 10.5 M points with the 27 normalized features of particle collisions to detect a new particle of unknown mass 5.2 Performance Analysis We rst present the experimental results with the synthetic data sets and next provide those with the real-life data set 5.2.1 Synthetic Data Sets Default Values of j S j  k and r  To nd the proper values of a sample size j S j for our SKY-MR  and the state-of-the-art SKY-MR  we ran both algorithms with varying j S j from 100 to 10,000 Since the number of dominating points k and the split threshold r are additionally required for SKY-MR  and SKY-MR  respectively we also varied k from 10 to 1,000 and r from 10 to 40 The average execution times of SKYMR  and SKY-MR over the three data sets with the other default values are shown in Figs 8a and 8b respectively Recall that by utilizing a sample S  we construct a skyqtree  and estimate the execution time of SKY-MR  for workload balancing When the sample size j S j decreases the performance of SKY-MR  degrades since a small sample could not reﬂect the data distribution precisely and thus the workloads of machines maybe skewed due to the inaccurate estimated execution time On the other hand the execution time of building a sky-qtree  grows with increasing j S j since the costs of computing SL  S  and nding the split points of every node of the sky-qtree  increase As the size of the dominating point set k grows the number of points removed by the dominating point set as well as the cost of maintaining the dominating point set increase Thus selecting either a small value or a large value of k is not effective As plotted in Fig 8a SKY-MR  showed the best performance when j S j 400 and k  100  Thus we select 400 and 100 as the default values of j S j and k  respectively As illustrated in Fig 8b SKY-MR shows a similar pattern of SKY-MR  with increasing j S j  For SKY-MR  we choose 200 and 10 as the default values of j S j and r  respectively We would like to emphasize that SKY-MR  is less affected by changing the parameter values than SKY-MR  Varying d  The execution times with varying the number of dimensions d from 2 to 12 were reported in Fig 9 For ANTI and IND data sets the execution times in the graphs are plotted in log scale As listed in Table 4 the number of the skyline points increases with increasing the number of dimensions d  The execution times of all algorithms increase as d grows since the number of checking dominance relationships between points to verify whether each point is a skyline point becomes large and thetimecomplexityofcheck ing the dominance relationship is O  d   The algorithms on COR data set see Fig 9c are faster than those on ANTI and IND data sets see Figs 9a and 9b since the number of skyline points of COR data set is much smaller than those of ANTI and IND data sets As plotted in Figs 9a 9b and 9c for every case SKY-MR  is superior to the other algorithms due to adaptive sky-qtree  building effective pruning of non-skyline points and workload balancing for the local and global skyline phases For the experiment with ANTI data set see Fig 9a when d is large  d 012 6  MR-GPMRS with two phases shows the worst performance since MR-GPMRS does not beneﬁt from the local skyline phase that decreases the overheads of computing the skyline and distributing the points over the network in the global skyline phase We could not plot the execution times of MR-GPMRS when d is 8 10 and 12 since it did not nish in 10 hours Meanwhile when d is small  d 6  the performances of GRID-1-MR and GRID-2-MR are worse than those of the other algorithms due to the overhead of grid partitioning and pruning the grids As d grows GRID-1-MR and GRID-2-MR become better than PPPS-MR  PPF-PGPS and TABLE 4 The Number of Skyline Points  j SL  D j  When j D j 2 015 10 8 Dimension d ANTI IND COR 2292214 4 3,154 1,368 104 6 62,265 27,485 213 8 441,984 248,029 571 10 1,792,231 1,456,457 666 12 4,988,259 5,616,015 996         Fig 8 Varying parameters for SKY-MR  and SKY-MR                       Fig 9 Varying the number of dimensions  d  PARK ET AL EFFICIENT PROCESSING OF SKYLINE QUERIES USING MAPREDUCE 1041 


MR-BNL since PPPS-MR  PPF-PGPS and MR-BNL utilize a single machine to compute the global skyline Furthermore although the state-of-the-art algorithm SKY-MR is faster than the other algorithms except SKY-MR   SKY-MR still takes more than 10 hours when d  12  On the other hand our SKYMR  nished within one hour and a half For IND and COR data sets the algorithms show similar patterns with ANTI data set Thus in Figs 9b and 9c we report the execution times of the representative algorithms the proposed algorithm SKY-MR   the state-of-the-art algorithm SKY-MR  the angle-based partitioning algorithm PPFPGPS and the grid partitioning algorithm MR-GPMRS with two phases only To show the effectiveness of splitting space based on a sky-qtree   we also implemented an algorithm SKY-MR  KD that is the same as SKY-MR  except using a k-d tree instead of a sky-qtree   After splitting a node n of a sky-qtree   there is at least a child node pruned by the split point of n  However other data structures such as k-d trees have no such property Thus the experimental results when d is larger than 6 with IND data sets show that SKY-MR  is superior to SKY-MR  KD  Varying j D j  We plotted the running times of SKY-MR   SKY-MR  MR-GPMRS and PPF-PGPS with varying the number of points j D j from 10 7 to 4 015 10 9 in Fig 10 The execution times in the graphs are plotted in log scale We did not plot the execution times of GRID-1/2-MR  PPPS-MR and MR-BNL since they show similar patterns shown in and they are slower than SKY-MR  in our experiments The execution times of the representative algorithms on COR data set are less than those on the other data sets since the number of skyline points is small and non-skyline points are removed by checking dominance relationships with a few dominating points Furthermore as j D j increases the number of skyline points grows and the execution times of all algorithms increase Similar to the previous experiments SKY-MR  is the best performer for every data set Varying m  We next experimented with varying the number of machines m from 10 to 40 In this experiment we measured the average execution time of each algorithm running on ANTI  IND and COR data sets For each algorithm we calculated the relative speed which is the ratio between the average execution time with 10 machines and that with the current number of machines For example if the average execution times of SKY-MR  with 10 and 40 machines are T 10 and T 40  respectively the relative speed becomes T 10 T 40 for m  40  In an ideal case if the number of machines increases by 4 times from 10 to 40 the speed will be 4 times faster We plot the relative speed of algorithms with the default-sized data sets  j D j 2 015 10 8  mediumsized data sets  j D j 10 9  and large data sets  j D j 4 015 10 9  in Fig 11 We only present the relative speeds of the top-5 scalable algorithms  SKY-MR   SKY-MR  GRID-1-MR  MRGPMRS and PPF-PGPS  and the ideal speedup curve The algorithms show sub-linear speedups when the size of the data set is small i.e j D j 2 015 10 8  since the overhead of using MapReduce offsets the speedup of short execution times However when the size of the data set becomes large i.e j D j 10 9 and j D j 4 015 10 9  SKY-MR  shows a linear speedup due to the effective workload-balancing algorithms Furthermore as the size of data set increases the speed up of SKY-MR  becomes more linear The Effects of Optimization Techniques In Table 5 we reported the execution times in seconds of SKY-MR  with the dominance power ltering only D SKY-MR  with the workload balancing only B SKY-MR  with both techniques ALL and SKY-MR  without both techniques NONE when the numbers of dimensions are 6 and 12 When workload balancing is not adopted for SKY-MR  we rely on the default partitioning by Hadoop Thus we estimate the execution times of the local and global skyline phases with the default partitioning to build a sky-qtree   For all data sets since the dominance power ltering prunes non-skyline points in the local skyline phase resulting in the reduced overheads of computing the skylines and distributing the points via the network it reduces the execution times of both phases As reported in Table 4 when d is small or COR data set is used the number of skyline points is small In such cases since the execution times of computing the local as well as global skylines are short and the deviation of the workloads of machines is not large the effect of the workload balancing becomes marginal as presented in Table 5 In contrast our workload balancing techniques become more effective as the size of the skyline grows i.e for ANTI and IND data sets with d  12  since the longest execution time of the machines is reduced by balancing the             Fig 10 Varying the number of points  j D j                    Fig 11 Relative speed with varying the number of machines  m  1042 IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING VOL 29 NO 5 MAY 2017 


workloads of available machines Thus SKY-MR  with both techniques is the best performer Proportionality between Actual and Estimated Execution Times In Section 4.2 we assumed that the execution time of computing the local and global skyline of a leaf node n is proportional to j SL  P  n j 011 j P  n j and j SL  P  n j 011 up j R  n j  respectively Although we do not know the proportionality constant  we can balance the workloads of both skyline phases if there is a correlation between the estimated and actual execution times To show the correlation between estimated and actual execution times we measure Pearson correlation coefﬁcient PCC and Kendall’s t coefﬁcient  For the local skyline phase average PCC over IND  COR and ANTI data sets is 0.37 which represents weak correlation Meanwhile the average PCC for the global skyline phase is 0.74 which means strong correlation Kendall’s t coefﬁcients are 0.33 i.e weak correlation and 0.57 i.e moderate correlation for the local and global skyline phases respectively To estimate the execution times of the local skyline phase we also estimate j SL  P  n j using a sample of D as explained in Section 4.2.1 However since we estimate the execution times of the global skyline phase based on the actual sizes of j SL  P  n j  the estimated execution times of the global skyline phase show stronger correlation than those of the local skyline phase 5.2.2 Real-Life Data Set Since the data distribution and statistics of the real-life data set are xed we can vary only a few parameters for the real-life data set HEPMASS Default Values of j S j  k and r  With the rst 10 features of HEPMASS i.e d  10 and j D j 1  05 015 10 7  we ran our SKY-MR  and SKY-MR with varying j S j from 100 to 10,000 We also varied k for SKY-MR  from 10 to 1,000 and r for SKY-MR from 10 to 40 The execution times of both algorithms are shown in Fig 12 As we expected SKY-MR  is less affected by the parameter values than SKY-MR since SKY-MR  not only builds a sky-qtree  adaptively based on the estimated execution times but also applies the workload balancing techniques Since SKY-MR  showed the best performance when j S j 100 and k  10  we select 100 and 10 as the default values of j S j and k respectively Similarly for SKY-MR  we choose 100 and 20 as the default values of j S j and r respectively Varying d and j D j  With the rst d features of HEPMASS where 2 005 d 005 14  we reported the execution times of the algorithms SKY-MR   SKY-MR  PPF-PGPS and GRID-2-MR in Fig 13a We could not plot the execution times of MRGPMRS with d 012 10 and GRID-1-MR with d  14 since they did not nish in 10 hours We also plotted the running times with varying the number of points j D j from 5 015 10 6 to 1  05 015 10 7 where the rst 10 features are used i.e d  10  in Fig 13b SKY-MR  is also the best performer on the reallife data set since it adaptively splits data space according to the data distribution and balances workloads 6C ONCLUSION We study the parallel skyline computation using MapReduce and develop the algorithm SKY-MR   We rst build a sky-qtree  with an adaptive quadtree building technique to utilize the dominance relationships between regions and apply the dominance power ltering method to effectively prune out non-skyline points in advance SKY-MR  partitions the data based on the regions split by the sky-qtree  and computes the candidate skyline points independently for each partition Finally we check whether each skyline candidate point is actually a skyline point in every partition independently To make the estimated execution times of all available machines to be similar we develop workload balancing techniques Our experimental results conﬁrm the effectiveness and scalability of SKY-MR   A CKNOWLEDGMENTS This research was supported by the Next-Generation Information Computing Development Program through the National Research Foundation of Korea NRF funded by the Ministry of Science ICT  Future Planning NRF2012M3C4A7033342 and supported by ITRC Program under the supervision of IITP IITP-2016-H8501-16-1013 This research was also supported by the Basic Science Research Program through the National Research Foundation of Korea NRF funded by the Ministry of Education 2015R1D1A1A01058909 R EFERENCES  S B  orzs  onyi D Kossmann and K Stocker The skyline operator in Proc 17th Int Conf Data Eng  2001 pp 421–430  D Papadias Y Tao G Fu and B Seeger An optimal and progressive algorithm for skyline queries in Proc ACM SIGMOD Int Conf Manage Data  2003 pp 467–478  E Dellis and B Seeger Efﬁcient computation of reverse skyline queries in Proc 33rd Int Conf Very Large Data Bases  2007 pp 291–302 TABLE 5 Effects of the Dominance Power Filtering and Workload Balancing Sec Dimension d 612 Distribution ANTI IND COR ANTI IND COR SKY-MR  ALL 94 72 57 4,092 4,443 73 SKY-MR  D 97 73 57 4,468 4,980 74 SKY-MR  B 104 77 58 4,304 4,995 74 SKY-MR  NONE 109 77 59 4,968 5,207 76         Fig 12 Varying parameters with HEPMASS dataset                 Fig 13 Execution times of algorithms with HEPMASS dataset PARK ET AL EFFICIENT PROCESSING OF SKYLINE QUERIES USING MAPREDUCE 1043 


 J Lee S won Hwang Z Nie and J.-R Wen Navigation system for product search in Proc IEEE 26th Int Conf Data Eng  2010 pp 1113–1116  T Lappas and D Gunopulos  Efﬁcient conﬁdent search in large review corpora in Proc Eur Conf Mach Learn Knowl Discovery Databases  2010 pp 195–210  G Wang J Xin L Chen and Y Liu Energy-e fﬁcient reverse skyline query processing over wireless sensor networks IEEE Trans Knowl Data Eng  vol 24 no 7 pp 1259–1275 Jul 2012  L Zou L Chen M T  Ozsu and D Zhao Dynamic skyline queries in large graphs in Proc 15th Int Conf Database Syst Adv Appl  2010 pp 62–78  C Kim and K Shim Suppor ting set-valued joins in NoSQL using MapReduce Inf Syst  vol 49 pp 52–64 2015  Y Kim and K Shim Efﬁcient top-k algorithms for approximate substring matching in Proc ACM SIGMOD Int Conf Manage Data  2013 pp 385–396  J D ea n an d S  Gh e ma wa t M ap Re du ce  S im pl i e d da ta pr o ce s si n g on large clusters Commun ACM  vol 51 no 1 pp 107–113 2008  K Mullesg aard J L Pedersen H Lu and Y Zhou Efﬁcient skyline computation in MapReduce in Proc 17th Int Conf Extending Database Technol  2014 pp 37–48  B Zhang S Zhou and J Guan Adapting skyline computation to the MapReduce framework Algorithms and experiments in Proc Int Conf Database Syst Adv Appl  2011 pp 403–414  J Zhang X Jiang W S Ku and X Qin Efﬁcient parallel skyline evaluation using MapReduce IEEE Trans Parallel Distrib Syst  vol 27 no 7 pp 1996–2009 Jul 2016  Y Park J.-K Min and K Shim Parallel computa tion of skyline and reverse skyline queries using MapReduce Proc VLDB Endowment  vol 6 no 14 pp 2002–2013 2013  R L Graham Bounds on multiprocessi ng timing anomal ies SIAM J Appl Math  vol 17 no 2 pp 416–429 1969  Y Park J.-K Min and K Shim Processing of probabilistic skyline queries using MapReduce Proc VLDB Endowment  vol 8 no 12 2015  Ap a ch e ha d o op  2 0 0 6  O n li n e  Av a i la b le  h tt p  h a do o p ap a ch e org  J Chomicki P Godfrey J Gryz and D Liang Skyline with presorting in Proc 19th Int Conf Data Eng  2003 pp 717–719  D Kossmann F Ramsak and S Rost Shooting stars in the sky An online algorithm for skyline queries in Proc 28th Int Conf Very Large Data Bases  2002 pp 275–286  K.-L Tan P.-K Eng and B C Ooi Efﬁcient progressive skyline computation in Proc 27th Int Conf Very Large Data Bases  2001 pp 301–310  I Bartolini P Ciaccia and M Patella Efﬁcient sort-bas ed skyline evaluation ACM Trans Database Syst  vol 33 no 4 2008 Art no 31  Y Tao and D Papadia s Maintaining sliding window skylines on data streams IEEE Trans Knowl Data Eng  vol 18 no 2 pp 377–391 Mar 2006  X Lin Y Zhang W Zhang and M A Cheema Stoch astic skyline operator in Proc IEEE 27th Int Conf Data Eng  2011 pp 721–732  J Lee and S.-W Hwan g Scala ble skyl ine computa tion using a balanced pivot selection technique Inf Syst  vol 39 pp 1–21 2014  I Bartolini P Ciaccia and M Patella SaLSa Computing the skyline without scanning the whole sky in Proc 15th ACM Int Conf Inf Knowl Manage  2006 pp 405–414  Z Huang C S Jensen H Lu and B C Ooi Skyline queries against mobile lightweight devices in MANETs in Proc 22nd Int Conf Data Eng  2006 pp 66–66  F N Afrati P Koutris D Suciu and J D Ullman Parallel skyline queries in Proc 15th Int Conf Database Theory  2012 pp 274–284  H K  ohler J Yang and X Zhou Efﬁcient parallel skyline processing using hyperplane projections in Proc ACM SIGMOD Int Conf Manage Data  2011 pp 85–96  L Zhu Y Tao and S Zhou Distribute d skyline retrieval with low bandwidth consumption IEEE Trans Knowl Data Eng  vol 21 no 3 pp 384–400 Mar 2009  L Ding G Wang J Xin and Y Yuan Efﬁcient probabi listic skyline query processing in MapReduce in Proc IEEE Congr Big Data  2013 pp 203–210  Y Li Z Li M Dong W Qu C Ji and J Wu Efﬁcient subspace skyline query based on user preference using MapReduce Ad Hoc Netw  vol 35 pp 105–115 2015  A Vlachou C Doulker idis and Y Kotidis Angle-base d space partitioning for efﬁcient parallel skyline computation in Proc ACM SIGMOD Int Conf Manage Data  2008 pp 227–238  Z Zhang Y Yang R Cai D Papadias  and A Tung Kernelbased skyline cardinality estimation in Proc ACM SIGMOD Int Conf Manage Data  2009 pp 509–522  K Pearson Note on regression and inheritance in the case of two parents Proc Roy Soc London  vol 58 pp 240–242 1895  M G Kendall A new measure of rank correlation Biometrika  vol 30 no 1/2 pp 81–93 1938 Yoonjae Park received the BS degree in electrical engineering and computer science from Seoul National University in 2011 He is currently working toward the PhD degree at Seoul National University His research is focused on frequent pattern mining and parallel query processing Jun-Ki Min received the BS degree in computer science from SoongSil University in 1995 and the MS and PhD degrees in computer science and electrical engineering from the Korea Advanced Institute of Science and Technology KAIST in 1998 and 2002 respectively He is currently a professor with the Korea University of Technology and Education KoreaTech Korea Before that he was a member of senior researcher in the Electronics and Telecommunications Research Institute ETRI He also served as a PC member for VLDB ICDE and WWW conferences He has written and published several articles in international journals and conference proceedings His current research interests include query processing and optimization sensor data management and stream data processing XML and parallel query processing Kyuseok Shim received the PhD degree in computer science from the University of Maryland College Park in 1993 He is currently a professor in the Electrical and Computer Engineering Department Seoul National University Korea Before that he was an assistant professor in the Computer Science Department KAIST and a member of technical staff for the Serendip Data Mining Project at Bell Laboratories He was also a member of the Quest Data Mining Project IBM Almaden Research Center and has visited Microsoft Research Redmond Washington several times as a visiting scientist He was named an ACM fellow for his contributions to scalable data mining and query processing research in 2013 He has been working in the area of databases focusing on data mining recommendation systems MapReduce algorithms query processing and query optimization His writings were published in a number of professional conferences and journals including ACM VLDB and IEEE publications He served as a program committee member for SIGKDD SIGMOD ICDE ICDM EDBT VLDB and WWW conferences He also served as a program committee co-chair for PAKDD 2003 WWW 2014 ICDE 2015 and APWeb 2016 He was previously on the editorial boards of VLDB as well as the IEEE Transactions on Knowledge and Data Engineering and is currently a member of the VLDB Endowment Board of Trustees  For more information on this or any other computing topic please visit our Digital Library at www.computer.org/publications/dlib 1044 IEEE TRANSACTIONS ON KNOWLEDGE AND DATA ENGINEERING VOL 29 NO 5 MAY 2017 


LI et al  PRIVACY-PRESERVING-OUTSOURCED ASSOCIATION RULE MINING ON VERTICALLY PARTITIONED DATABASES 1861 22 FIPS Publication 180-1 Secure Hash Standard  Nat Inst Standards Technol Gaithersburg MD USA 1995 23 FIPS Publication 180-2 Secure Hash Standard  Nat Inst Standards Technol Gaithersburg MD USA 2002  T  E l Gam a l  A public k e y c ryptos ystem and a signature scheme based on discrete logarithms IEEE Trans Inf Theory  vol 31 no 4 pp 469–472 Jul 1985 O A v a ilable http://dx doi o r g 10 1109 TIT.1985.1057074  N  Cour tois  A  K lim o v  J  P atar in a nd A  S h am ir   E f  c ient algor ithm s for solving overdeﬁned systems of multivariate polynomial equations in Proc EUROCRYPT  2000 pp 392–407  P  F ournier V iger  Real-life Datasets in SPMF Format  accessed on Apr 6 2016 O A v a ilable http://w w w  philippe-fournier viger.com/spmf/index.php?link=datasets.php  P  F ournier V iger  A  G om ariz T  G ueniche A Soltani C  W  W u and V S Tseng SPMF A Java opensource pattern mining library J Mach.Learn.Res  vol 15 no 1 pp 3389–3393 2014  J  V a idya and C  C lif ton S ecur e s e t i nter s ection car dinality w ith application to association rule mining J Comput Secur  vol 13 no 4 pp 593–622 2005  X Ge L  Y an J  Z hu and W  S hi  Pri v ac y-pres erving dis t rib u ted association rule mining based on the secret sharing technique in Proc SEDM  Jun 2010 pp 345–350  R K h ar at M  K um bhar  and P  B ham r e E f  cient p r i v a c y pr es er ving distributed association rule mining protocol based on random number in Intelligent Computing Networking and Informatics  Raipur Chhattisgarh India Springer 2014 pp 827–836  C Dong and L  C hen  A f a s t s ecure dot product p rotocol with application to privacy preserving association rule mining in Proc 18th Paciﬁc-Asia Conf Adv Knowl Discovery Data Mining PAKDD  Tainan Taiwan May 2014 pp 606–617 Available http://dx.doi.o rg/10.1007/978-3-319-06608-0_50  J  L a i Y  L i  R  H  D eng J  W e ng C Guan a nd Q Y a n T o w ards semantically secure outsourcing of association rule mining on categorical data Inf Sci  vol 267 pp 267–286 May 2014  T  F ukas a w a  J  W ang T  T a kata a nd M  M i yazaki  A n e f f ecti v e distributed privacy-preserving data mining algorithm in Proc 5th Int Conf IDEAL  2004 pp 320–325  C Su and K  S akurai  A d is trib ut ed privacy-preserving association rules mining scheme using frequent-pattern tree in Proc ADMA  2008 pp 170–181  M  G  K a os ar  R  P aulet and X  Y i S ecur e tw opar t y a s s o ciation r ule mining in Proc ACSW-AISC  2011 pp 15–22  J  L  L in and J  Y  C L i u Pri v a c y pres erving item s et m i ning through fake transactions in Proc ACM Symp Appl Comput SAC  Seoul South Korea Mar 2007 pp 375–379 A v a ilable http://doi.acm.org/10.1145/1244002.1244092  B N K e s h a v am urthy  A M Khan a nd D T o s hniw a l Pri v a c y preserving association rule mining over distributed databases using genetic algorithm Neural Comput Appl  vol 22 no 1 pp 351–364 2013 Lichun Li received the bachelor’s degree in information engineering from the Beijing University of Posts and Telecommunications in 2002 the master’s degree in communication and information systems from the China Academy of Telecommunication Technology in 2006 and the Ph.D degree in computer science from the Beijing University of Posts and Telecommunications in 2009 He is currently a Postdoctoral Research Fellow with the INFINITUS Laboratory School of Electrical and Electronic Engineering Nanyang Technological University Singapore His research interests include privacy and security in cloud and big data Rongxing Lu S’09–M’11–SM’15 received the Ph.D degree in computer science from Shanghai Jiao Tong University Shanghai China in 2006 and the Ph.D degree in electrical and computer engineering from the University of Waterloo Waterloo ON Canada in 2012 From 2012 to 2013 he was a Postdoctoral Fellow with the University of Waterloo Since 2013 he has been an Assistant Professor with the School of Electrical and Electronic Engineering Nanyang Technological University Singapore His research interests include computer network security mobile and wireless communication security and applied cryptography He was a recipient of the Ca nada Governor General Gold Metal Kim-Kwang Raymond Choo SM’15 received the Ph.D degree in information security from the Queensland University of Technology Australia in 2006 He is currently a Cloud Technology Endowed Associate Professor with the University of Texas at San Antonio an Associate Professor with the University of South Australia and a Guest Professor with the China University of Geosciences He was named one of 10 Emerging Leaders in the Innovation category of The Weekend Australian Magazine Microsoft’s Next 100 series in 2009 and is a recipient of the ESORICS 2015 Best Research Paper Award the 2015 Winning Team of Germany’s University of Erlangen-Nuremberg Digital Forensics Research Challenge the 2014 Australia New Zealand Policing Advisory Agency’s Highly Commende d Award the 2010 Australian Capital Territory Pearcey Award the Fulbright Scholarship in 2009 the 2008 Australia Day Achievement Medallion and the British Computer Society’s Wilkes Award Anwitaman Datta is an Associate Professor with the School of Computer Science and Engineering NTU Singapore He lead s the Self and Algorithmic aspects of Networked Distributed Systems Research Group at NTU Jun Shao received the Ph.D degree from Shanghai Jiao Tong University Shanghai China in 2008 He was a Postdoctoral Fellow with the School of Information Sciences and Technology Pennsylvania State University State College PA USA from 2008 to 2010 He is currently a Full Professor with the Department of Information Security Zhejiang Gongshang University Hangzhou China His research interests include network security and applied cryptography 


