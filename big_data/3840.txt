 Boyu Hao Fan Jiang 
Constrained Frequent Itemset Mining from Uncertain Data Streams Carson Kai-Sang Leung 
Abstract 
1 1 
kleung@cs.umanitoba.ca 
Department of Computer Science The University of Manitoba Winnipeg MB Canada 
227 Frequent itemset mining is a common data mining task for many real-life applications The mined frequent itemsets can be served as building blocks for various patterns including association rules and frequent sequences Many existing algorithms mine for frequent itemsets from traditional static transaction databases in which the contents of each transaction namely items are de\036nitely known and precise However there are many situations in which ones are uncertain about the 
constrained mining uncertain 
To deal with all these situations we propose tree-based algorithms to ef\036ciently mine 
streams 
 
contents of transactions This calls for the 
I I NTRODUCTION 
of 
data for frequent itemsets that satisfy user-speci\036ed 
mining of data streams 
constraints 
mining of uncertain data 
 Moreover there are also situations in which users are interested in only some portions of the mined frequent itemsets i.e itemsets satisfying user-speci\036ed constraints which express the user interest This leads to  Furthermore due to advances in technology a 037ood of data can be produced in many situations This calls for the 
Frequent itemset mining 3 18    23  a i m s t o s e a r c h for implicit previously unknown and potentially useful sets of items aka itemsets that are frequently co-occurring The mined frequent itemsets FIs can be used in as building blocks of various patterns e.g association rules correlation sequences episodes maximal patterns closed patterns for many real-life applications This explains why the problem of mining FIs has been the subject of numerous studies since its introduction 2  I n t he e a r l y da ys  m a n y of t he algorithms proposed were Apriori-based They depend on a generate-and-test paradigm They 336nd FIs from the transaction database DB by 336rst generating candidates and then checking their support i.e their occurrences against the DB Han et al 14 i mp r o v e d e f 336 ci en c y o f t h e m i n i n g p r o ces s b y 
proposing the FP-growth algorithm which uses a restricted test-only approach i.e does not generate candidates and only tests for support This algorithm constructs an extended pre\336x-tree called Frequent Pattern tree FP-tree to capture the contents of the DB The above algorithms mine traditional static DBs e.g DBs of market basket transactions Web logs containing 
precise 
data When mining these precise data users de\336nitely know whether an item or an event is present in or is absent from a transaction in the static DBs However there are situations e.g medical diagnosis environmental surveillance quantitative economics/survey research in which users are uncertain about the presence or absence of some items or 
represents a potential disease and is associated with an existential probability expressing the likelihood of a patient having that disease in  For instance in 
represents a patient s visit to a physician s of\336ce Each item within 
events 6 15    16  27   T o e l a bora t e  l e t u s c ons i d e r a situation where a physician highly suspects but cannot guarantee that a patient suffers from the H1N1 337u The uncertainty of such suspicion can be expressed in terms of existential probability In this uncertain DB of patient records each transaction 
t t t t 
 the patient has a 90 likelihood of having the H1N1 337u and a 30 likelihood of having a seasonal 337u regardless 
i i i i 
 5 29  i s i n de m a nd some algorithms e.g U-Apriori 7  U F gro w t h 22   h a v e recently been designed to 336nd 
of catching the H1N1 or not With this notion each item in a transaction 
FIs from uncertain data Note that there are real-life situations in which users may have some particular phenomena in mind on which to focus the mining For example a store manager may want to 336nd groups of customers having an average age older than 65 or sets of popular merchandise items having a total price ex 
t t 
As 
i i 
mining of uncertain data all 
in traditional DBs containing precise data can be viewed as an item with a 100 likelihood of being present in 
 13   w hi c h a i m s t o 336 n d onl y the FIs that satisfy the user-speci\336ed constraints DCF 17  CAP 24 a nd 
may be interesting to users This leads to 
 a r e s om e a l gori t hm s t ha t m i ne s t a t i c DBs of precise data for constrained FIs Constrained frequent itemset mining is not con\336ned to precise data it can also be applied to uncertain data To elaborate having some particular phenomena in mind on which to focus the mining while users are uncertain about the presence or absence of items in a DB is not unusual For instance when 
ceeds 500 Without user focus the user often needs to wait for a long period of time for numerous FIs out of which 
FIC 
only a tiny fraction constrained frequent itemset mining 
analyzing laboratory test data there are some known factors e.g human reaction time measuring errors contributing to the uncertainty of the data Analysts may be interested in only the data belonging to patients observed to have abnormal blood cell counts rather than all the patient data Hence algorithms e.g U-FPS 19  f or m i ni ng c ons t r a i ne d F Is from unc e r t a i n data are in need The automation of measurements and data collection has produced tremendously huge amounts of data in many reallife application areas The recent development and increasing 
2010 IEEE ICDE Workshops 2010 120 
978-1-4244-6523-1/10/$26.00 002 


all all data streams uncertain data Our proposed and a transaction and that of transactions in a TDB Hence the is considered is at least for FIs that satisfy user-speci\336ed 212 212 Stream mining precise where where of an item in a transaction and ii the possible world is in the TDB can be computed by summing the support of in possible world in in  The probability of to be the true world denoted by if its expected support equals or ex ceeds the user-speci\336ed s upport threshold says that the minimum white blood cell count of all patients in says that the maximum red blood cell count of all patients in is at least 6.1 million cells per microlitre of blood For another domain meteorological records collected by wireless sensors says that the average hourly temperature in B Constraints  002  FIC n i i i i i j j j j j j j j j j n i x 002 t i y 003\002 t i i x 002 X TABLE I O UR PROPOSED ALGORITHMS VERSUS THEIR MOST RELEVANT ALGORITHMS 1 004 003 1 006 007 to be the true world over all possible worlds 005\212 1             5 004   The existential probability being present in To express their interest in 336nding FIs that satisfy certain criteria users can specify SQL-style constraints 17  24 s u ch as ag g r e g at e co n s t r ai n t s 200mm Here for medical laboratory test results constraint in in UF-streaming UF-streaming CAP 24 When compared with precise data each uncertain data transaction contains items and their y t 002 003\002 212 327 prob 327 003 004 005 004 005 327 004 004 005 P x t x t x t W x W x W P W n X X W W W  W X W X W W X X C C C C C X C X C X C X max avg use of a large number of sensors has added to this situation Consequently these advances in technology have led to a 337ood of data We are now drowning in streams of precise or uncertain data but starving for knowledge 26   28  In orde r to make sense of these dynamic streaming data algorithms for  denoting the support of data but they 336nd indicates the likelihood of  Although it is uncertain which of these two worlds be the true world the probability of be the true world is in possible world  can be computed by counting the number of transactions contain are independent Equation 1 can be simpli\336ed 10 to b e c o m e th e f o llo w in g  is at least 10,000 cells per microlitre of blood and  uncertain A Uncertain Data  can be computed by 003 U-FPS Usingthe t t P X X W X W P P X P  265  handle data streams The FP-streaming algorithm was designed for mining streams of precise data the UF-streaming algorithm was designed for mining streams of uncertain data However both 336nd sup sup sum 265  9  11    21  a re i n de m a nd FP-streaming 12 a n d U F s t r eami n g  2 0  a r e s o me e x amp l es of algorithms that mine FIs from data streams Among the above algorithms see Table I the CAP DCF and 1 where 2 With this setting an itemset   of uncertain data 22 there are two possible worlds for an item data Both U-Apriori and UF-growth mine of  i the possible world  In general there are many items in each of the  When items within FIC 12 25 algorithms all 336nd constrained FIs but they mine unconstrained FIs The U-FPS algorithm mines uncertain data for FIs satisfying constraints but it does FP-streaming UF-streaming  UF-growth 22  FIs instead of only those satisfying the constraints Hence a natural question to ask is Is it possible to mine streams of uncertain data for only those FIs that satisfy user-speci\336ed constraints In response to this question we propose three tree-based algorithms for mining streams of uncertain data for FIs that satisfy user-speci\336ed constraints Here our of this paper is the non-trivial integration of i mining uncertain data ii constrained mining and iii stream mining The resulting tree-based algorithms avoid the candidate generate-and-test paradigm when mining constrained FIs from uncertain data streams On the surface the three pr oposed algorithms may appear to handle a very specialized situation as they were designed for mining constrained FIs from uncertain data streams However it is important to realize that these algorithms are not con\336ned to this situation They can be serve as alternatives to algorithms for mining constrained or unconstrained FIs from precise or uncertain data in the traditional DB or data streams e.g mining unconstrained FIs from traditional DBs containing uncertain data Thus in terms of applicability the proposed algorithms can be used in a suitably broad range of real-life applications This paper is organized as follows The next section provides background and related work In Sections III\320V we describe our algorithms for mining constrained FIs from streams of uncertain data Section VI shows experimental results Finally conclusions are presented in Section VII II B ACKGROUND AND R ELATED W ORK In this section we provide background on topics related to mining 6 i i i W j i W j i n 002 i mining data streams not key contribution constraints 223possible world\224 interpretation expected support frequent minsup says that the total rainfall of all records in   005 existential probabilities 002 002 002 of an itemset is at least 200mm 121 X WBC X RBC X Tempera ture X Rainfall Mining uncertain data expSup expSup L L 002 C and C and 10000 10 002 002 002 002 002 002 002 min   CUF-streaming 1 2 1 2 1 2 3 4 1 2 3 4 1 x t x t x t x t x t               b 6 1 5 004 prob U-Apriori 7  DCF 17 Constrained mining while taking in account the probability of 


x t x t  FP-streaming uses because whenever also violate because whenever in the UF-tree A key difference between this UF-tree and the usual FP-tree is that each tree node in the latter consists of two components\321namely an item and its actual support\321whereas each node in the UF-tree contains an extra component\321i.e its appears in a transaction appears in occurs once in instead of the usual  we better keep  In this structure each path represents a 322frequent\323 expected support values one for each batch of streaming transactions As users are often interested in recent data than older data the UF-stream structure focuses on capturing only the sup mines 322frequent\323 itemsets from the UF-tree in a depth-\336rst divide-and-conquer manner The algorithm 336rst 336nds 322frequent\323 domain items UF-stream also satisfy  An itemset a possibly frequent itemset UF-streaming    As a result UF-streaming preMinsup UF-tree preMinsup C Data Streams itself and its  005 006 005       i i i i   This mining process is repeated for all other 322frequent\323 domain items e.g i.e the maximum RBC count will not lower the maximum RBC count i i 1 1 1 2 2 2 1 1 1 1 1 1 2 2 3  Common items in itemsets share the tree path in a similar fashion as in the FP-tree or the UF-tree However each node in this UF-stream structure contains i the item and ii a window table containing a list of expSup expSup  x x x   For precise data the actual support of an item is the same as its occurrence count If an item with the actual support of with the expected support of and its extensions to 336nd 322frequent\323 itemsets containing expected support of each node in the UF-stream structure so as to ensure that it always captures the contents of the most recent batches of transactions in the stream So when a new batch of transactions 337ows in the window slides and the expected support of each node in the UF-stream structure also shifts The above mining procedure is repeated for each subsequent batch of transactions in the uncertain data streams In other words for each batch our pr oposed UF-streaming   before handling the next batch of streaming transactions It is important to note that while the FP-streaming algorithm 336nds 322frequent\323 itemsets from dynamic streams of precise data it neither handles uncertain data nor does it explore constraints III UFSTREAMING support Note that although we are interested in truly frequent itemsets i.e itemsets with support    item M INING C ONSTRAINED F REQUENT I TEMSETS FROM U NCERTAIN D ATA S TREAMS Inspired by FP-streaming we propose in this section an algorithm\321called FP-streaming algorithm itemset C X C  X C X C X C  X C X  X X x t t x x t P t x P X X X X X X x x x x x x w w w w 327 x most recent batches of transactions in uncertain data streams As a post-processing step the   Once the UF-tree is constructed our proposed UF-streaming is currently infrequent but may become frequent later so 6 L all supersets of to 336nd 322frequent\323 itemsets Let us call this lower threshold is 322frequent\323 if a frequent itemset in the current window As data streams are continuous and unbounded we can no longer go back to the current batch and reconsider  Afterwards the algorithm forms projected DBs for    is not pruned by FP-streaming Once the 322frequent\323 itemsets are found the FP-streaming algorithm stores and maintains these itemsets in another tree structure called  It then forms projected DBs for found all the 322frequent\323 itemsets It then stores and maintains them in another tree structure called as adding more patients to as adding more patients to captures the contents of transactions in the 336rst batch of dynamic occurs once in projected DBs to 336nd 322frequent\323 itemsets containing streams of uncertain data 265 violates  For an incoming batch of transactions in a data stream FP-streaming calls the FP-growth algorithm 14 w i t h a t hre s hol d t ha t i s l o w e r t ha n t he us ua l minimum support threshold having 321for mining constrained FIs from uncertain data streams When the uncertain data stream 337ows in our proposed algorithm applies the UF-growth mining technique to the 336rst batch of transactions in the stream Recall that UF-growth captures the contents of a static DB of uncertain data in a tree structure called userspeci\336ed threshold Here UF-streaming equals 1 For uncertain data if equals once we moved to subsequent batches Consequently if algorithm i 336nds 322frequent\323 itemsets and ii stores the mined 322frequent\323 itemsets in the UF-stream structure by sliding the window and shifting the In order to ef\336ciently 336nd FIs that satisfy these constraints we better explore properties e.g anti-monotonicity monotonicity 18  t ha t a re pos s e s s e d by t he s e c ons t r a i nt s  N ot e t ha t is will not increase the minimum WBC count is satis\336es When compared with traditional static data streams are continuous and unbounded Moreover data in the streams are not necessarily uniformly distributed Their distributions are usually changing with time Hence we no longer have the luxury of performing multiple data scans Once the streams 337ow through we lose them Moreover a currently infrequent itemset may become frequent in the future and vice versa We have to be careful not to prune infrequent itemsets too early otherwise we may not be able to get complete information such as the support values of some itemsets as it is impossible to recall the pruned itemsets To mine FIs from data streams Giannella et al 12 d e signed the  Then an itemset is 322frequent\323 if its actual support is no less than in attempt to avoid pruning an itemset too early An itemset in addition to the with existential probability that is infrequent in the current batch may be frequent in subsequent batches in the current sliding window which may make is currently slightly lower than and its extensions e.g 267\267\267 267\267\267 10000 10 FP-stream 122   UF-streaming 265 algorithm mines 322frequent\323 itemsets from this tree using x x x x x x x anti-monotone monotone minsup preMinsup preMinsup minsup preMinsup minsup support preMinsup minsup preMinsup minsup  Otherwise we may miss i.e the minimum WBC count   1 L all supersets of 6      2 3 4 2 2 3 4   x X X X expected expected occurrence count  and tries to 336nd itemsets having   Recall that data in the streams are not necessarily uniformly distributed an itemset 005 


third say  It then recursively mines 322frequent\323 itemsets from this tree with 1.4 It extracts from two tree paths\321namely i are inserted as a new branch because the node  and as follows It starts with item that occurs once with  projected database Then and and and are and and Contents L and forms the second Batch Consider the following uncertain data stream 11.0 10.5 9.5 9.0 0.9 is incremented to 2 and the remainder of  Afterwards the contents of are infrequent as with their corresponding expected support of 1.8 1.35 1.17 1.6 1.5 0.98 0.9 and 1.4 WBC 3 t b c e t c e d e c d t c c d c t c d c d a be set to 1.2 and let the user-speci\336ed constraint be          0.98   e:0.1 d:0.9 b:0.9 a:0.9 e:0.7 c:0.8 e:0.6 c:0.7 b:0.7         Example 1 minsup preMinsup minsup preMinsup preMinsup preMinsup preMinsup preMinsup preMinsup preMinsup truly frequent 1 Here each transaction contains items and their corres ponding existential probabilities e.g the existential probability of item a e a c a e a c a c a c a The UF-tree for transactions in the 336rst batch       a a t b t b a t b t a b t a b c d e 0.9 can be shared So the occurrence count for the node           327 10 min  0.9\1 cannot be shared with the node  projected database and 336nds no 322frequent\323 itemsets Afterwards the mining process ends with item algorithm applies the same mining procedure to the batch Speci\336cally it 336rst constructs a new UF-tree from which 322frequent\323 itemsets          as their expected support values 2 batches Our proposed UF-streaming with expected support values of 1.6 and 1.4 in the 336rst and second batches respectively When the third batch 337ows in the algorithm 336nds 322frequent\323 itemsets     1 d e d e expSup  expSup  expSup  expSup  expSup  expSup expSup and X.W BC  007 b 007 b 007 b 005 007 b 007 b    327 327 327 327 005   327 327 327 327 005      327   327 327 327 327 327 327       005 preMinsup    005 minsup     007 b         the tree node  with their corresponding accumulated expected s upport of 1.8 1.6 1.5 0.9 and 1.4  Among them only algorithm then stores the eight mined 322frequent\323 itemsets in a UF-stream structure which consists of eight nodes representing the eight itemsets Afterwards the second batch of uncertain data stream 337ows in Our proposed UF-streaming representing the new 322frequent\323 itemset 1.6,1.4 r e p re s e nt s t he 322 fre que nt 323 itemset mined 322frequent\323 itemsets stored in the UF-stream structure are 336nally checked against the user-speci\336ed constraints Only those satisfying the constraints are returned to users To gain a better understanding of the UF-streaming L Our proposed UF-streaming is 0.9 Let the user-speci\336ed support threshold 0.9\2 As a result we get the tree branch with their corresponding expected support values of 0.9 0.9 1.4 1.4 1.8 and 2.0 can be found It then updates the existing UF-stream structure by storing these itemsets in it The resulting UF-stream structure as shown in Fig 1\(b consists of nine nodes due to the addition of the node Items 1 1 1 2 2 1 2 3 004 005 10000         327  t                                      It then inserts the contents of 0.9 0.9 0.7 0.8 0.9 0.9 0.9 0.88 2 batches and shifts the expected support of each node in the UF-stream 123 algorithm let us consider Example 1 with auxiliary information in transaction algorithm applies the UF-growth mining technique to the 336rst batch of transactions in the uncertain data stream using a lower than into the tree and results in a tree branch 0.9\:1  0.7\:1  0.7\:1  0.6\:1 into the UF-tree Since the expected support of in is the same as the expected support of in an existing branch i.e the branch for is added as a child of the node  0.9\:2  0.8\:1  0.7\:1 0.9\:1  0.9\:1  0.1\:1 0.9\:2 Consequently at the end of the tree construction process we get the UF-tree shown in Fig 1\(a capturing the important contents of the 336rst batch of uncertain data Once the UF-tree is constructed for the 336rst batch the algorithm 336rst 336nds the 322frequent\323 domain items with 0.9  0.7  0.7 that occurs once with   and ii 0.9  0.8  Note that itemsets  As a result UF-growth found 322frequent\323 itemsets with 1.4 in the second batch The node with their corresponding expected support values of 1.7 1.53 1.0 1.0 1.9 and 1.2 It then slides the window of size 265 a t C t b e t a t a t a a t a e t d e b a e e b c e c e   c w d d b w 0.9\.The algorithm constructs a UF-tree by scanning and inserting each transaction into the UF-tree It 336rst inserts the contents of 0.09  Next the algorithm extracts appropriate paths to form the  Let the window size 0,1.4 o n t h e p a t h 1.6,1.4  0,1.4 0.6 0.7 0.6 0.7 0.6 0.7 0.1 0.7 0.6 0.8 0.7 0.9 0.7 0.7 0.6 0.9 0.8 0.7 0.9 0.9 0.1 1.0 0.3 1.0 0.9 1.0 0.4 0.5 1.0 0.8 0.9 1.0 0.1 1.0 0.9 0.9 0.2 b d b d b d a b c d 1 0 in the 336rst batch and a c e a c e c e c e 11.5 1 2 3 4 5 6 7 8 9   1.17  1 d[0,2.0 c[1.35,0.9 a[1.8,0.9 e[1.17,0  c[1.5,1.8 d[0.9,2.0 e[1.4,0 e[0.98,0 b UF-stream for 322frequent\323 itemsets found in the 1st  2nd batches       d[2.0,1.0 c[0.9,1.53 a[0.9,1.7 e[0,0  c[1.8,1.9 d[2.0,1.2 e[0,0 e[0,0 c UF-stream for 322frequent\323 itemsets found in the 2nd  3rd batches Fig 1 The UF-tree and UF-stream structures for Example 1 1  1 1 Transactions 265 a c a c b e a a e d a    b c   d e a   b  c e a   b   c d b b a   b   c d 336rst 


for captures the contents of each batch of streaming transactions containing uncertain data\321one batch at a time\321in the UF-tree from which O in a batch All O captures the contents of each batch of transactions in the UF-tree from which O and its 322extensions\323 to 336nd constrained 322frequent\323 itemsets containing and against each domain item one at a time and stops as soon as it 336nds the 336rst valid item attr const attr X.attr const attr X.attr const attr because all remaining items  322frequent\323 itemsets are found All these O  The algorithm only needs to form a projected DB for each  from leaves to the root if 002p e.g attr attr attr attr CUF-streaming     1 0,1 from t he 336nds constrained FIs from uncertain data streams it checks constraints in a post-processing step As a result it wastes lots of space as it stores both valid as well as invalid itemsets in the UF-stream structure Here we propose another algorithm\321called 322frequent\323 itemsets where constraint selectivity 322frequent\323 domain items  domain items are arranged in non-descending order 1 005 005 005 005 005 values such that invalid items come before/below valid items in the UF-tree For instance if values i.e 1 1 1 1 1 2 2 1    i.e if 321which pushes the user-speci\336ed constraints inside the mining process and explores the properties of these constraints Speci\336cally when a batch of streaming transactions containing uncertain data 337ows in the algorithm inserts items in each transaction into the UF-tree in which items are arranged according to some order item valid item e C C p p m p w w p p 002 w x x x x x X C C C C x x x C x C    n 002 005 006 013 005 013 005  006 m i i i i v v j v j k k projected DB for selected k<v  By doing so the algorithm checks 212 Thismining process is repeated for the remaining selected 322frequent\323 domain items Unlike UF-streaming 1 expSup Example 2 expSup constrained 2 1 0 It then forms projected DBs for  322frequent\323 itemsets are found where  322frequent\323 valid as well as invalid itemsets from the  Afterwards the algorithm forms projected DBs for  Revisit the uncertain data stream in Example 1 With our proposed UF-streaming     0 c a n be prune d t hi s re s ul t s i n s i x node s in the structure Finally as a post-processing step the algorithm checks the 322frequent\323 itemsets stored in the FP-stream structure against the aggregate constraint  are guaranteed to be valid due to  then all supersets a c algorithm only valid itemsets are stored in the UF-stream structures See Fig 2 cf Fig 1\(b  c Some memory space is saved as each UF-stream structure consists of only four instead of eight or nine nodes and 336nd only 2.43 depending on the type of constraints Here the new transaction is merged with a child or descendant node of the root of the UF-tree only if the same  our proposed CUF-streaming algorithm does not need to form projected databases for all itemsets domain items or their extensions as CUF-streaming explores the property of constraints Thus only some itemsets are selected to check against the constraints and only some itemsets are selected to form projected DBs during the mining process The selection depends on the type of constraints T YPE I A NTI MONOTONE C ONSTRAINT Let denote an attribute of an itemset denote a constant Our proposed CUF-streaming algorithm arranges domain items in a monotonic increasing or decreasing order of of of violates structure to make room for the third batch The resulting UF-stream structure as shown in Fig 1\(c captures the expected support values for 322frequent\323 itemsets found in the second and third batches Note that nodes with zero expected support such as 2.6 2.4 and 3.7 satisfying domain items Note that the size of the UF-tree is bounded above by the number of is the window size IV UFSTREAMING  itemsets are    exists in both the transaction and the child or descendant nodes The occurrence count of a node is at least the sum of occurrence counts of all its children nodes Once the UF-tree is constructed CUF-streaming recursively mines 322frequent\323 itemsets from the tree in a depth\336rst divide-and-conquer manner The algorithm 336rst 336nds some and its extensions to 336nd constrained 322frequent\323 itemsets containing or UF-streaming is of the form is of the form  are invalid due to the antimonotonicity of 124 a b c  i x x i x x j j x Analytically UF-streaming most recent batches are stored in the UF-stream structure where Analytically UF-streaming most recent batches are stored in the UF-stream structure V C U F STREAMING E XPLORING C ONSTRAINTS WHEN M INING C ONSTRAINED F REQUENT I TEMSETS FROM U NCERTAIN D ATA S TREAMS Along this direction we propose the third algorithm\321called  because any itemsets that can be f ound in values i.e x x x      R R R 013 006 R 013 005 R  max min C HECKING C ONSTRAINTS E ARLY WHEN M INING C ONSTRAINED F REQUENT I TEMSETS FROM U NCERTAIN D ATA S TREAMS Although UF-streaming   2 3 4   c[1.35,0.9  b[1.6,1.4 c[1.5,1.8 a UF-stream for 322frequent\323 itemsets found in the 1st  2nd batches    c[0.9,1.53  b[1.4,1.0 c[1.8,1.9 b UF-stream for 322frequent\323 itemsets found in the 2nd  3rd batches Fig 2 The UF-stream structures for Example 2 then checked against the user-speci\336ed constraints and only O    items are arranged in non-ascending order UF-streaming 321which performs constraint checking as an intermediate step instead of a post-processing step Speci\336cally the algorithm 336rst uses the same UF-growth mining technique to 336nd all 322frequent\323 itemsets and it then checks the mined itemsets against userspeci\336ed constraints before storing the constrained itemsets in the UF-stream structure By doing so the UF-stream structure stores only valid itemsets See Example 2 267\267\267 


002p 002p     1         1     v<h p 006 212 006 006 212 212 212 006 006 212 212 006 It forms projected DBs for valid items i.e v<h c a   b c in the UF-tree For instance if R R R R  R R R R R R R R 006 R      p 005 005 005 2  3     4  1  1 1 also satisfy 125 min 1    max 005 005 5 batches and each batch to contain 1M transactions In addition to this dataset we also conducted the following experiments using some other datasets including UCI real-life datasets as well as FIMI datasets The observations or trends were consistent 002 p X X X X  are guaranteed to be invalid due to projected DB where where  Note that instead of checking all as in UF-streaming  CUF-streaming only needs to check O  Again CUF-streaming only needs to check O  However 322frequent\323 itemsets found in these projected DBs need to be checked against if  the algorithm only needs to check sum sum sum sum for for for for  items are arranged in non-ascending order j j j j j 2 2 e d c b a e d n n  r j is of the form  the algorithm only needs to form projected DBs for itemsets satis\336es such that valid items come before/below invalid items in the UF-tree For instance if is of the form is of the form value items are arranged in non-descending order is of the form is of the form  items are arranged in non-descending order until it 336nds the 336rst invalid item  All remaining items domain items and ii  items where  CUF-streaming also stores only valid itemsets in the UF-stream structure Unlike UF-streaming  until it 336nds the 336rst valid item 1.5 1.6 1.8 as well as their 322extensions\323 No more constraint checking is needed as any 322frequent\323 itemsets found in the projected DBs of valid items and their 322extensions\323 are guaranteed to be valid due to anti-monotonicity of in the UF-stream structure Same approach is then applied to the second batch and results in the same UF-stream structure as shown in Fig 2\(a Afterwards CUF-streaming applies the same approach to the third batch this results in the same UF-stream structure as shown in Fig 2\(b  From the 322frequent\323 itemsets against are guaranteed to be valid further constraint checking is needed for 322extensions\323 of the  from leaves to the root The algorithm then checks  322Frequent\323 itemsets found in these projected DBs are guaranteed to be valid due to the anti-monotonicity of  322Frequent\323 itemsets found in these projected DBs are guaranteed to be valid due to the monotonicity of  Unlike the procedures for other three types of constraints the algorithm forms projected DBs for 322extensions\323 of of Type III or IV having selectivity   the algorithm forms projected DBs for itemsets  are guaranteed to be invalid due to  then all supersets of values from leaves to the root if as not all of them are valid By exploring the convertible anti-monotonicity of  domain items are arranged in non-ascending order values from leaves to the root if is an itemset with non-positive is an itemset with non-negative is a Type I constraint So when the 336rst batch of transactions from uncertain data stream 337ows in our proposed CUF-streaming algorithm arranges domain items in ascending order of also violate  domain items where of of the form of  domain items are arranged in non-descending order of  domain items against of or of values By doing so the algorithm checks violates  then all 322extensions\323 of also violate of of values By doing so the algorithm checks each domain item against  All 322extensions\323 of a valid of WBC counts i.e items due to convertible monotonicity of re guaranteed to be invalid due to gainst    invalid e.g e.g e.g gainst items because some of these 322extensions\323 may be valid With i i.e if as all remaining items and UF-streaming 006  T YPE II M ONOTONE C ONSTRAINT  CUF-streaming arranges domain items in a monotonic decreasing or increasing order  T YPE III C ONVERTIBLE A NTI MONOTONE C ON STRAINT  Like Type II CUF-streaming arranges domain items in  The mined 322frequent\323 itemsets that satisfy one of the above four types of constraints are then stored in the UF-stream structure Afterwards CUF-streaming handles subsequent batches of streaming transactions of uncertain data in a similar fashion Like UF-streaming  006    1.35 CUF-streaming then stores all four constrained 322frequent\323 itemsets 006 005 006 005 attr attr attr attr  0,1 CUF s t re a m i n g c he c k s O    k v v i m h h v v i v v h h v h h m items as well as avg avg a c a c 1  n n  j j j 005 006 006 VI E XPERIMENTAL R ESULTS We used different datasets for experimental evaluation For space limitation we reported here the experimental results on a dataset generated by the program developed at IBM Almaden Research Center T hi s da t a s e t c ont a i ns 10M re c ords w i t h an average transaction length of 10 items and a domain of 1,000 items We assigned an existential probability from the range 0,1 t o each i t em i n each t r an s act i o n  W e s et t h e window size to be  005 013 013 013  For each values such that values from leaves to the root if against each domain item until it 336nds the 336rst invalid one  For each against each domain item until it 336nds the 336rst invalid one  Again projected DBs are formed only for the valid items against each item in the projected DB until it 336nds the 336rst invalid one T YPE IV C ONVERTIBLE M ONOTONE C ONSTRAINT  Again CUF-streaming arranges domain items in such that valid items come before/below invalid items in the UF-tree For instance if against each domain item in the UF-tree i.e attr X.attr const attr X.attr const attr X.attr const const attr attr X.attr const const attr attr const attr const attr because all remaining items values By doing so the algorithm checks value domain items are arranged in non-ascending order 1 r x C x x Y x C O C m m C C C C C x x x x Y x C x C x C m C C C X C X C x x x C C X C X C C C C C C x x C X m C 002 m C C C c c b a C w f  f  i v 005     CUF-streaming mines constrained 322frequent\323 itemsets more effectively as it pushes the constraint inside the mining process and explores properties of the constraint Revisit the uncertain data stream in Example 1 r i>v items While further constraint checking is unnecessary for 322extensions\323 of the Example 3 valid items come before/below invalid items valid valid invalid Y Y 


preMinsup Fig 3 Experimental results runtimes All experiments were run in a time-sharing environment in an 800 MHz machine The reported 336gures are based on the average of multiple runs Runtime includes CPU and I/Os it includes the time for both tree construction and frequent itemset mining steps We evaluated different aspects of the proposed algorithms which were implemented in C First we compared the performance of the three proposed algorithms using four different constraints one from each type of the above constraints Experimental results showed that the runtimes for both UF-streaming 100   150   200   250   10   20   30   40   50   60   70   80   90  Selectivity \(i.e., percentage of items selected CUF-streaming \(w=5 batches, each with 1M transactions Type IV constraint C4  Type II constraint C2                      Type III constraint C3                      Type I constraint C1                                 100   150   200   250   300   350   400   450   10   20   30   40   50   60   70   80   90  Selectivity \(i.e., percentage of items selected CUF-streaming \(w=50 batches, each with 1M transactions Type IV constraint C4  Type II constraint C2                      Type III constraint C3                      Type I constraint C1                                 50   55   60   65   70   75   80   85   90   0.002   0.003   0.004   0.005  preMinsup \(in percentage Runtime vs. existential probability & preMinsup Items take on an average number of existential probability values                      005 005    t t 327 327 005 items All 322extensions\323 of valid items were valid Due to the item ordering the algorithm stopped checking constraints whenever it detected the 336rst invalid items However for on the mining results For example using 0.8 C C C C C C C C C C w w C C w 0.9 preMinsup  90 of the mined constrained 322frequent\323 itemsets were truly frequent When and UF-streaming Asitexplored properties of these four constraints and pushed the constraints inside the mining process CUF-streaming required shorter runtimes than the other two algorithms As shown in Fig 3\(a the runtimes for handling all four types of constraints increased when the selectivity increased Among them a Runtime vs selectivity  a Type I constraint incurred the lowest runtime among the four types of constraints because CUF-streaming formed fewer 322extensions\323 as they consisted of only valid items Again due to the item ordering the algorithm stopped checking constraints whenever it detected the 336rst valid items Next we repeated the above experiment with a different the window size was low say 10 only a few small UF-trees were constructed and mined as the algorithm only 322extended\323 valid items and a shorter runtime 50 c Runtime vs  and the convertible monotonicity of  the monotonicity of  the convertible anti-monotonicity of 110 sec cf 160 sec in Fig 3\(a was required As another example for 5 batches when  the algorithm applied constraint checking on projected DBs for valid items as well as their 322extensions\323 because not all 322extensions\323 of valid items were valid  the algorithm 322extended\323  many bigger UF-trees were constructed and mined as the algorithm formed projected DBs for both valid as well as invalid domain items which took or having more batches in the sliding window had the bene\336ts of increasing the chance of not pruning relevant expected support information for truly frequent itemsets Moreover as shown in Fig 3\(c when increased fewer itemsets had expected support performed constraint checking as an intermediate step prior to storing the 322frequent\323 itemsets into the UF-stream structure In contrast CUF-streaming was more interesting as it runtimes depended on the type of constraints as well as the constraint selectivity Speci\336cally the algorithm explored the anti-monotonicity of a Type II constraint and a Type III constraint incurred the next two highest runtimes For  and thus shorter runtimes were required The 336gure also showed the effect of the distribution of item existential probability When items took on a few unique existential probability values the UF-tree b ecame smaller Thus times for both UF-tree construction and mining became shorter In addition we also measured the number of nodes in each UF-tree The experimental results showed that the total number of nodes in a UF-tree was no more than the total number of items with their existential probability in all transactions in the current batch of uncertain data stream Furthermore we measured the number of nodes in the UF-stream structure as well As UF-streaming   126 400 sec cf 230 sec in Fig 3\(a As all three algorithms are approximate algorithms we evaluated the effect of  95 of the mined constrained 322frequent\323 itemsets were truly frequent However lowering 5 b Runtime vs selectivity  were constant regardless of the constraint selectivity because these two algorithms did not explore property nor did they push the constraints inside the mining process Speci\336cally UF-streaming only valid preMinsup minsup preMinsup minsup preMinsup preMinsup preMinsup performed constraint checking as a postprocessing step whereas UF-streaming a Type IV constraint incurred the highest runtime because CUF-streaming 322extended\323 i.e formed projected DBs for both valid and invalid items performed constraint checking at a post-processing step the size of UF-stream was observed to be independent of the constraint selectivity In contrast as Items take on many different existential probability values  50 336xed-sized batches with each batch containing 0.1M transactions instead of using 5 336xed-sized batches with each batch containing 1M transactions With this setting each batch was smaller 0.1M vs 1M transactions Thus each batch required lower runtime e.g for constructing and mining UF-trees However the number of batches was higher 50 vs 5 batches than the previous setting This explains why the runtimes see Fig 3\(b took on a broader range than the previous experimental results For example when the selectivity of 1 2 3 4 4 2 3 2 3 1 2 4 w w 0   Runtime \(in seconds 0   Runtime \(in seconds 0   Runtime \(in seconds Items take on a few unique existential probability values                     50   50   0.001   


 ch 6 AAAI/MIT Press 2004  G  G r ahne L  V  S  L aks h m a nan and X  W ang 322E f 336 ci ent m i n i n g o f constrained correlated sets,\323 in ACM TKDD  Proc KDD 2009 Proc VLDB 1994 Proc KDD 2009 Proc IEEE ICDE 2008 Proc PAKDD 2007 Proc VLDB 2008 Proc IEEE ICDE 2000 Proc VLDB 2008 Proc IEEE ICDE 2009 Proc IEEE ICDM 2006 Proc IEEE ICDE 2002 Proc IEEE ICDE 2001 Proc IEEE ICDE 2008 preMinsup minsup Proc U  09 Proc PAKDD 2008 Proc ACM SIGMOD 2008 Data Mining and Knowledge Discovery Proc ACM SIGMOD 1993 Proc SSTD 2005 Proc ACM SIGMOD 2000 Proc ACM SIGMOD 2009 Proc ACM SIGMOD 1998 Proc ACM SIGMOD 2008 2 pp 18\32026 June 2005 12 C G ia n n e lla e t a l 322 M in in g f r e q u e n t p a tte r n s in d a ta s tr e a m s a t m u ltip le time granularities,\323 in 4 pp 337\320389 Dec 2003  C  K  S  L eung 322F r e quent i t e m s et m i ni ng w i t h cons t r ai nt s  323 i n 127 1 batch containing the entire dataset Then we compared our algorithms with UF-growth 22 b y as s i g n i n g t o each i t em i n e v er y t r an s act i o n in a dataset an existential probability of 1 i.e all items are de\336nitely present in the dataset and 005 005 Encyclopedia of Database Systems queries on uncertain streams,\323 in 34 28 34  pp 29\32037 2 R  A gr aw al et al   322M i n i n g a s s o ci at i o n r ul es bet w een s e t s of i t e ms i n large databases,\323 in  pp 207\320216 3 R  A gr aw al and R  S r i kant  322 F a s t al gor i t h ms f o r m i n i n g a s s o ci at i o n rules,\323 in  pp 487\320499 4 R  J  B ayar do J r   R  A g r a w a l  and D  G unopul os  322 C ons t r ai nt b as ed rule mining in large dense databases,\323 2\3203 pp 217\320240 July 2000 5 T  B e r n e c k e r e t a l 322 P r o b a b ilis tic f r e q u e n t ite m s e t m in in g in u n c e r ta in databases,\323 in  pp 119\320127 6 R  C h e n g e t a l 322 P r o b a b ilis tic v e r i\336 e r s  e v a lu a tin g c o n s tr a in e d n e a r e s tneighbor queries over uncertain data,\323 in  pp 47\32058 8 G  C or m ode and M  H adj i e l e f t her i ou 322F i ndi ng f r e quent i t e m s i n dat a streams,\323 in  pp 1530\3201541 9 G  C o r m o d e e t a l 322 F in d in g h ie r a r c h ic a l h e a v y h itte r s in s tr e a m in g d a ta  323  pp 400\320417  M M G a ber  A  B  Z a s l a v s k y  and S  K r i s hnas w am y  322Mi n i n g d at a streams a review,\323  pp 512\320521  J  H a n J  P e i  and Y  Y i n  322 Mi ni ng f r e quent pat t e r n s w i t hout candi dat e generation,\323 in  pp 1\32012 15 J  H u a n g e t a l 322 M a y B M S  a p r o b a b ilis tic d a ta b a s e m a n a g e m e n t s y s tem,\323 in  pp 1071\3201074  C  J i n e t a l   322 S l i di ngw i ndo w t op pp 301\320312  L  V  S  L a ks hm anan C  K  S  L e ung and R  T  N g 322E f 336 ci ent dynam i c mining of constrained frequent sets,\323  pp 9\320 18  C  K  S  L eung and B  H ao 322 Mi ni ng of f r e quent i t e m s et s f r o m s t r eam s of uncertain data,\323 in  pp 1663\3201670  C  K  S  L eung and Q  I  K han 322D S T r ee a t r e e s t r uct u r e f o r t he m i ni ng of frequent sets from data streams,\323 in  pp 928\320 933  C  K  S  L eung M A  F  Mat e o and D  A  B r a j czuk 322 A t r eebas e d approach for frequent pattern mining from uncertain data,\323 in  pp 13\320 24  J  P e i  J  H a n and L  V  S  L aks h m a nan 322Mi n i n g f r e quent i t e m s et s w i t h convertible constraints,\323 in  pp 433\320442  C  R 253 e et al 322Event queries on correlated probabilistic streams,\323 in  pp 715\320728 27 A  D  S a r m a  M  Th e o b a ld  a n d J  W id o m  322 Ex p lo itin g lin e a g e f o r con\336dence computation in uncertain and probabilistic databases,\323 in  pp 1023\3201032  K  Y i et al   322S m a l l s ynops es f o r g r oupby quer y ver i 336 cat i o n o n outsourced data streams,\323  pp 819\320832 322frequent\323 itemsets from uncertain data streams In terms of ef\336ciency the experimental results showed that UF-streaming was slightly faster because it did not perform any constraint checking whereas our three proposed algorithms performed the extra constraint checking step Among them CUF-streaming only performed constraint checking on some 322frequent\323 itemsets and the other two performed constraint checking on all 322frequent\323 itemsets However in terms of the mining results we observed that all four algorithms returned the same collection of 322frequent\323 itemsets This illustrated that our proposed algorithms could be used for mining unconstrained frequent itemsets from uncertain data streams Moreover it is important to note that while the UF-streaming is con\336ned to 336nding 322frequent\323 itemsets satisfying constraints with 100 selectivity our algorithms are capable of 336nding 322frequent\323 itemsets that satisfy constraints having lower selectivity Along this direction we set and CUF-streaming both pushed the constraint early the corresponding size of UF-stream was proportional to the selectivity of constraints Finally we evaluated the functionality and applicability of our proposed algorithms We again used four different constraints and we also set the constraint selectivity be 100 i.e all items are selected Then we compared our three proposed algorithms with UF-streaming  w hi c h w a s designed to mine 1 UF-streaming 4 article 2 Jan 2008 10 X  D a i e t a l 322 P r o b a b ilis tic s p a tia l q u e r ie s o n e x is te n tia lly u n c e r ta in data,\323 in 3 article 15 Aug 2009 29 Q  Zh a n g  F  Li a n d K  Y i 322 F in d in g f r e q u e n t ite m s in p r o b a b ilis tic data,\323 in  pp 1179\3201183 Springer 2009  C  K  S  L eung and D  A  B r a j czuk 322E f 336 ci ent a l gor i t h m s f o r m i n i n g constrained frequent patterns from uncertain data,\323 in Data Mining Next Generation Challenges and Future Directions w  UF-streaming unconstrained and CUF-streaming\321 which integrate i mining of uncertain data ii constrained mining and iii mining of data streams These algorithms effectively mine constrained frequent itemsets from uncertain data streams A CKNOWLEDGMENT This project is partially sponsored by Natural Sciences and Engineering Research Council of Canada NSERC and the University of Manitoba in the form of research grants R EFERENCES 1 C  C  A ggar w al et al   322F r e quent pat t e r n m i ni ng w i t h uncer t a i n dat a  323 i n  pp 653\320661  C  K  S  L eung R  T  N g  a nd H  Manni l a  322 O S S M  a s e gm ent a t i o n approach to optimize frequency counting,\323 in SIGMOD Record ACM TODS ACM TODS k 4   Again we observed that all four algorithms returned the same collection of frequent itemsets This illustrated that our proposed algorithms could also be used for mining unconstrained frequent itemsets from static uncertain datasets VII C ONCLUSIONS Frequent itemsets generally serve as building blocks for various patterns in many real-life applications Most of the existing algorithms 336nd unconstrained frequent itemsets from traditional static transaction databases consisting of precise data However there are situations in which ones are uncertain about the contents of transactions There are also situations in which users are only interested in some subsets of all the mined frequent itemsets Furthermore a 337ood of data can be easily produced in many situations To deal with all these situations we proposed three tree-based algorithms\321 namely UF-streaming   pp 973\320982 7 C  K  C hui  B  K ao a nd E  H ung 322Mi n i n g f r e quent i t e m s et s f r o m uncertain data,\323 in     pp 583\320592  R  T  N g et al   322E xpl or at or y m i n i n g a nd pr uni ng opt i m i zat i ons of constrained associations rules,\323 in  


              


   


                        





